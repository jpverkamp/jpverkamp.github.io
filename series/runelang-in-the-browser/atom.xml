<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Runelang in the Browser on jverkamp.com</title><link>https://blog.jverkamp.com/series/runelang-in-the-browser/</link><description>Recent content in Runelang in the Browser on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 29 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/series/runelang-in-the-browser/atom.xml" rel="self" type="application/rss+xml"/><item><title>Runelang: A Summoning Circle Generator</title><link>https://blog.jverkamp.com/2022/08/29/runelang-a-summoning-circle-generator/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/08/29/runelang-a-summoning-circle-generator/</guid><description>&lt;p&gt;Last time we had &lt;a href="https://blog.jverkamp.com/2022/08/25/runelang-a-bind-rune-generator/"&gt;Runelang: A Bind Rune Generator&lt;/a&gt;. This time, let&amp;rsquo;s make &amp;lsquo;summoning circles&amp;rsquo;. Basically, we want to make a circle with stars and other circles inscribed and around the borders with various &amp;lsquo;mystic&amp;rsquo; text in the mix. Something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate_summoning_circle&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;random chance of boder&lt;/li&gt;
&lt;li&gt;random chance of one or more inscribed stars&lt;/li&gt;
&lt;li&gt;random chance of recurring on the border (calling &lt;code&gt;generate_summoning_circle&lt;/code&gt; again)&lt;/li&gt;
&lt;li&gt;random chance of recurring in the middle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Runelang: A Bind Rune Generator</title><link>https://blog.jverkamp.com/2022/08/25/runelang-a-bind-rune-generator/</link><pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/08/25/runelang-a-bind-rune-generator/</guid><description>&lt;p&gt;Continuing with my &lt;a href="https://blog.jverkamp.com/series/runelang-in-the-browser/"&gt;Runelang in the Browser&lt;/a&gt; series, I had the idea to automatically generate runes. So basically reversing the parsing step, rather than to take what I&amp;rsquo;ve written and make it look good, to write something that Runelang can parse&amp;ndash;and still look good.&lt;/p&gt;
&lt;p&gt;In a nutshell, I want to write a series of functions that can recursively call one another to render runes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate_bind_rune&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;n&lt;/em&gt; times &lt;code&gt;generate_bind_rune_arm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;m&lt;/em&gt; times generate bars, circles, and other decrations&lt;/li&gt;
&lt;li&gt;add a fork at the end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Runelang: Evaluation</title><link>https://blog.jverkamp.com/2022/07/16/runelang-evaluation/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/07/16/runelang-evaluation/</guid><description>&lt;p&gt;As they say, life is what happens when you&amp;rsquo;re making other plans. But I&amp;rsquo;m back, so let&amp;rsquo;s talk some more about &lt;a href="https://blog.jverkamp.com/series/runelang-in-the-browser/"&gt;Runelang&lt;/a&gt;. In the interest of not dragging on months without finishing, we&amp;rsquo;re going to go ahead and push through the rest of the project. Onward!&lt;/p&gt;</description></item><item><title>Runelang: The Parser (Part 2: Expressions)</title><link>https://blog.jverkamp.com/2022/03/18/runelang-the-parser-part-2-expressions/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/03/18/runelang-the-parser-part-2-expressions/</guid><description>&lt;p&gt;&lt;a href="https://blog.jverkamp.com/2022/03/15/runelang-the-parser-part-1/"&gt;Earlier this week&lt;/a&gt;, we started parsing, getting through groups, nodes, params, and lists. A pretty good start, but it also leaves out two very powerful things (expressions and defines), one of which we absolutely do need to start actually evaluating things: expressions. Since we use them in every param, we pretty much need to know how to parse them, so let&amp;rsquo;s do it!&lt;/p&gt;</description></item><item><title>Runelang: The Parser (Part 1)</title><link>https://blog.jverkamp.com/2022/03/15/runelang-the-parser-part-1/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/03/15/runelang-the-parser-part-1/</guid><description>&lt;p&gt;I&amp;rsquo;m still here! And less sick now.&lt;/p&gt;
&lt;p&gt;Last time(s), we &lt;a href="https://blog.jverkamp.com/2022/02/23/runelang-language-specification/"&gt;described&lt;/a&gt; and &lt;a href="https://blog.jverkamp.com/2022/02/24/runelang-the-lexer/"&gt;lexed&lt;/a&gt;) Runelang! This time around, let&amp;rsquo;s take the lexed tokens and go one step further and parse them!&lt;/p&gt;
&lt;p&gt;So, how do we go about this? With a &lt;a href="https://en.wikipedia.org/wiki/recursive%20descent%20parser"&gt;recursive descent parser&lt;/a&gt;!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start with a list/stream of tokens&lt;/li&gt;
&lt;li&gt;Using the first &lt;em&gt;k&lt;/em&gt; (in a &lt;a href="https://en.wikipedia.org/wiki/LL%28k%29%20parser"&gt;LL(k) parser&lt;/a&gt;) elements of the list, identify which sort of object we are parsing (a &lt;code&gt;group&lt;/code&gt; / &lt;code&gt;identifier&lt;/code&gt; / &lt;code&gt;literal&lt;/code&gt; / &lt;code&gt;expression&lt;/code&gt; / etc)&lt;/li&gt;
&lt;li&gt;Call a parsing function for that object type (&lt;code&gt;parseGroup&lt;/code&gt; etc) that will:
&lt;ul&gt;
&lt;li&gt;Recursively parse the given object type (this may in turn call more parse functions)&lt;/li&gt;
&lt;li&gt;Advance the token stream &amp;lsquo;consuming&amp;rsquo; any tokens used in this group so the new &amp;lsquo;first&amp;rsquo; element is the next object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Runelang: The Lexer</title><link>https://blog.jverkamp.com/2022/02/24/runelang-the-lexer/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/02/24/runelang-the-lexer/</guid><description>&lt;p&gt;Let&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Lexical_analysis"&gt;LEX&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;So this is actually one of the easier parts of a programming language. In this case, we need to turn the raw text of a program into a sequence of tokens / lexemes that will be easier to parse. In this case, we want to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remove all whitespace and comments&lt;/li&gt;
&lt;li&gt;Store the row and column with the token to make debugging easier&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So let&amp;rsquo;s do it!&lt;/p&gt;</description></item><item><title>Runelang: Language Specification</title><link>https://blog.jverkamp.com/2022/02/23/runelang-language-specification/</link><pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/02/23/runelang-language-specification/</guid><description>&lt;p&gt;&lt;a href="https://blog.jverkamp.com/2021/01/26/a-dsl-for-rendering-magic-circles-and-runes/"&gt;Previously&lt;/a&gt;, I wrote a post about making a DSL in Ruby that could render magic circles/runes. It worked pretty well. I could turn things like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-ruby" data-lang="ruby"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;rune &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; scale &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;9&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; circle
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; polygon &lt;span style="color:#ae81ff"&gt;7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; star &lt;span style="color:#ae81ff"&gt;14&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; star &lt;span style="color:#ae81ff"&gt;7&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; children &lt;span style="color:#ae81ff"&gt;7&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;scale&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;&lt;span style="color:#f92672"&gt;/&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;8&lt;/span&gt;r, &lt;span style="color:#e6db74"&gt;offset&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; &lt;span style="color:#f92672"&gt;|&lt;/span&gt;i&lt;span style="color:#f92672"&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; circle
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; invert &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; text (&lt;span style="color:#ae81ff"&gt;0x2641&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; i)&lt;span style="color:#f92672"&gt;.&lt;/span&gt;chr &lt;span style="color:#66d9ef"&gt;Encoding&lt;/span&gt;&lt;span style="color:#f92672"&gt;::&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;UTF_8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; scale &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;15&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; translate &lt;span style="color:#e6db74"&gt;x&lt;/span&gt;: &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; circle; moon &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;45&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; circle
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; translate &lt;span style="color:#e6db74"&gt;x&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; circle; moon &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;55&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Into this:&lt;/p&gt;
&lt;img src="https://blog.jverkamp.com/embeds/2022/old-astrology-and-moons.svg" /&gt;
&lt;p&gt;But&amp;hellip; I decided to completely rewrite it. Now it&amp;rsquo;s an entirely separate language:&lt;/p&gt;

&lt;script defer type="module"&gt;
import { render } from '/embeds/runelang/runelang/main.js'
import logging from '/embeds/runelang/lib/logging.js'

const log = logging.get("system")

let elInput = document.querySelector('[data-input]')
let elOutput = document.querySelector('[data-output]')
let elLog = document.querySelector('[data-log]')

elInput.value = `
define offsetmoon(x, phase) {
 translate(x: x) {
 circle
 fill("black") moon(phase)
 }
}

rune {
 scale(0.9) {
 circle
 polygon(7)
 star(14, 3)
 star(7, 2)

 radial(scale: 1/8, rotate: true) [
 circle
 invert character(0x2640 + i) 
 for i in 1..7
 ]
 }

 scale(0.15) stroke(2) {
 circle
 offsetmoon(-2, 0.55)
 offsetmoon( 2, -0.55)
 }
}
`

logging.register((msg) =&gt; {
 let node = document.createElement('li')
 node.innerText = msg
 elLog.prepend(node)
})

logging.setMode('ERROR')

function doRender() {
 elLog.innerHTML = ''
 let input = elInput.value

 try {
 let svg = render(input)
 elOutput.innerHTML = svg
 log.awesome('IT WORKED!')
 } catch (exception) {
 console.log(exception)
 }
}

function debounce(f, timeout = 500) {
 let timer
 return (...args) =&gt; {
 clearTimeout(timer)
 timer = setTimeout(() =&gt; f.apply(this, args), timeout)
 }
}

document.addEventListener('keyup', debounce(doRender))
doRender()
&lt;/script&gt;

&lt;style&gt;
 textarea[data-input],
 div[data-output] {
 width: 80%;
 height: 600px;
 padding: 1em;
 }

 td {
 width: 45%;
 vertical-align: top;
 }
&lt;/style&gt;

&lt;h3&gt;Output&lt;/h3&gt;
&lt;div data-output&gt;&lt;/div&gt;

&lt;h3&gt;Source&lt;/h3&gt;
&lt;textarea data-input&gt;&lt;/textarea&gt;

&lt;h3&gt;Log (most recent messages first):&lt;/h2&gt;
&lt;ul data-log&gt;&lt;/ul&gt;</description></item></channel></rss>