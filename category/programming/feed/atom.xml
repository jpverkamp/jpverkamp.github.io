<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-01-22T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>iOS Backups in Racket: Groundwork</title><link href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork" /><id>urn:uuid:180d204b-b657-2667-bf03-1c1555d8a51d</id><updated>2015-01-22T00:00:00Z</updated><summary type="html"><![CDATA[<p>For the last little while, I've been spending my spare programming time working on a slightly larger project than I normally do: a <a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a> library for reading iOS backups.</p>
<p>Basically, I want to take the mess that is an iOS backup (not particularly designed to be easy to read by other programs) and extract some information from it, backing it up in a more easily readable format.</p>
<p>Specifically, I would like to be able to backup:</p>
<ul>
    <li>Contact information: Even thought they're mostly from Facebook, it will be useful for the other parts</li>
    <li>Messages: These are taking up a large portion of my phone's hard drive, mostly due to attachments. Back them up just in case<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span></li>
    <li>Photos: I'm already backing these up, but it would be nice to have it in the same process</li>
    <li>Application data:
        <ul>
            <li>List of applications over time</li>
            <li><a href="https://www.moves-app.com/">Moves</a>: GPS location</li>
            <li><a href="http://www.downcastapp.com/">Downcast</a>: List of current podcasts</li>
            <li><a href="http://www.sleepcycle.com/">Sleep Cycle</a>: Sleep data</li>
            <li><a href="http://www.boardgamescorer.com/">Boardgame Scorer</a>: High scores for board games</li>
        </ul>
    </li>
</ul>
]]></summary><content type="html"><![CDATA[<p>For the last little while, I've been spending my spare programming time working on a slightly larger project than I normally do: a <a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a> library for reading iOS backups.</p>
<p>Basically, I want to take the mess that is an iOS backup (not particularly designed to be easy to read by other programs) and extract some information from it, backing it up in a more easily readable format.</p>
<p>Specifically, I would like to be able to backup:</p>
<ul>
    <li>Contact information: Even thought they're mostly from Facebook, it will be useful for the other parts</li>
    <li>Messages: These are taking up a large portion of my phone's hard drive, mostly due to attachments. Back them up just in case<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span></li>
    <li>Photos: I'm already backing these up, but it would be nice to have it in the same process</li>
    <li>Application data:
        <ul>
            <li>List of applications over time</li>
            <li><a href="https://www.moves-app.com/">Moves</a>: GPS location</li>
            <li><a href="http://www.downcastapp.com/">Downcast</a>: List of current podcasts</li>
            <li><a href="http://www.sleepcycle.com/">Sleep Cycle</a>: Sleep data</li>
            <li><a href="http://www.boardgamescorer.com/">Boardgame Scorer</a>: High scores for board games</li>
        </ul>
    </li>
</ul>
<!--more-->
<p>The first thing to look at is the basic structure of the iOS backup directory:</p>
<pre class="text"><code>~/Library/Application Support/MobileSync/Backup/
    86b1...aa36/
        0003...1b9a
        0009...521c
        000b...46ab
        ...
        fff6...5152
        fff8...9f8a
        fffa...ca34
        Info.plist
        Manifest.mbdb
        Manifest.plist
        Status.plist</code></pre>
<p>Okay, that's helpful<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>. 6788 files, all but four of which named via <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> hashes. I know that there are pictures, applications, and various databases here, so there has to be a map somewhere.</p>
<p>But first, those last four files:</p>
<ul>
    <li><code>Info.plist</code> - Contains information about the backup, including the phone's name, various IDs, the phone's number, and versioning information</li>
    <li><code>Manifest.mbdb</code> - Binary file containing a listing of every file in the backup</li>
    <li><code>Manifest.plist</code> - Legacy file, useful information is mostly a list of installed applications</li>
    <li><code>Status.plist</code> - Mostly a subset of the information in <code>Info.plist</code></li>
</ul>
<p>Of those, we'll start with the first one. We want to be able to load that information into a basic structure to represent a backup:</p>
<pre class="scheme"><code>; Represents an iPhone backup on disk
(struct backup (name hash date phone-number path) #:prefab)</code></pre>
<p>Cool. First thing first, let's find the backups on disk. We want to be able to support either Windows or OSX (I use both), so try both locations:</p>
<pre class="scheme"><code>; Load all backups on disk into a list
(define list-backups
  (let* (; OS agnostic (I hope) way of finding the backup root
         [backup-root
          (for*/first ([path-parts (in-list '(("AppData" "Roaming" "Apple Computer"
                                               "MobileSync" "Backup")
                                              ("Library" "Application Support"
                                                "MobileSync" "Backup")))]
                       [path (in-value (apply build-path
                                              (cons (find-system-path 'home-dir)
                                                    path-parts)))]
                       #:when (directory-exists? path))
            path)]

         ; List all backups in that directory, along with some metadata
         [backups
          (for/list ([dir (in-list (directory-list backup-root))])
            (define info-file
              (call-with-input-file (build-path backup-root dir "Info.plist")
                read-plist/jsexpr))

            (backup (dict-ref info-file '|Device Name|)
                    (path-&gt;string dir)
                    (dict-ref info-file '|Last Backup Date|)
                    (normalize-contact (dict-ref info-file '|Phone Number|))
                    (build-path backup-root dir)))])

    (λ () backups)))</code></pre>
<p>The function is a little strange looking, mostly because of caching. Rather than scanning and loading the backup every time we want a list, scan it once on load, then return that whenever the function is called.</p>
<p>One thing missing though, we have to define the function <code>read-plist/jsexpr</code> yet. Luckily, we have the <code><a href="http://docs.racket-lang.org/search/index.html?q=xml/plist">xml/plist</a></code> library to handle the first part of this<span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>, but personally I'd rather a more straight forward format (a <code><a href="http://docs.racket-lang.org/search/index.html?q=jsexpr">jsexpr</a></code> is basically a mix of hashes, lists, and atoms):</p>
<pre class="scheme"><code>; Convert a plist into a JSON expression
(define (plist-&gt;jsexpr data)
  (match data
    [(? string?) data]
    [`(true) #t]
    [`(false) #f]
    [`(integer ,v) v]
    [`(real ,v) v]
    [`(data ,v) v] ; Should we special case these?
    [`(date ,v) v] ; Ditto
    [`(array . ,v*)
     (map plist-&gt;jsexpr v*)]
    [`(dict . ,kv*)
     (for/hash ([kv (in-list kv*)])
       (values (string-&gt;symbol (second kv)) (plist-&gt;jsexpr (third kv))))]))

; Read a plist file as a JSON expression from a file
(define (read-plist/jsexpr [in (current-input-port)])
  (plist-&gt;jsexpr (read-plist in)))</code></pre>
<p>I still haven't decided if special casing <code>data</code> and <code>date</code> elements is worthwhile.</p>
<p>The other interesting function is another utility function <code>normalize-contact</code>:</p>
<pre class="scheme"><code>; Process a phone number or email address into a common format
(define (normalize-contact value)
  (define re #px"^\\+?1? ?[\\(\\.]?(\\d\\d\\d)[\\)\\.-]? ?(\\d\\d\\d)[ \\.-]?(\\d\\d\\d\\d)$")
  (cond
    [(sql-null? value)
     #f]
    ; Standard phone numbers
    ; TODO: Figure out international numbers
    [(regexp-match re value)
     =&gt; (λ (match) (string-join (rest match) "."))]
    ; Email addresses
    [(regexp-match #px"^[^@]+@[^@]+$" value)
     value]
    ; Short phone numbers
    [(regexp-match #px"^\\d{,6}$" value)
     value]
    ; No idea...
    [else #f]))</code></pre>
<p>Phone numbers in an iPhone backup are stored all sorts of odd ways. In particular, once you start looking at the contacts, you can get three or four different formats just for normal area code + 7 phone numbers (I haven't yet decided how to support international numbers). So this can be used to at least put them all in the same format.</p>
<p>But with that, we now have the ability to list all backups on the local system:</p>
<pre class="scheme"><code>&gt; (list-backups)
'(#s(backup
     "JP’s iPhone"
     "63b5...a651"
     "2014-04-17T21:53:16Z"
     "{redacted}"
     #&lt;path:/Users/jp/Library/Application Support/MobileSync/Backup/63b5....a651&gt;))</code></pre>
<p>It's an older backup, but that's fine.</p>
<p>Next, what if we have more than one backup on the system? It would be nice to have a function that could take that list of backups and load just one (that other parts of the library can access) based on name/hash/phone number:</p>
<pre class="scheme"><code>; Store the most recently used backup for other modules
(define current-backup (make-parameter #f))

; Load a specific backup, try to guess what the identifier is
(define (read-backup identifier)
  (for/first ([backup (in-list (list-backups))]
              #:when (or (equal? identifier (backup-date backup))
                         (equal? identifier (backup-name backup))
                         (equal? identifier (backup-hash backup))
                         (equal? identifier (backup-phone-number backup))))
    backup))</code></pre>
<p>Fair enough. At the moment, you have to have an exact match, but that's fine. If we want to later, we could replace the calls to <code><a href="http://docs.racket-lang.org/search/index.html?q=equal?">equal?</a></code> with <code><a href="http://docs.racket-lang.org/search/index.html?q=regexp-match">regexp-match</a></code>.</p>
<p>So now I can find my own backup:</p>
<pre class="scheme"><code>&gt; (read-backup "86b1...aa36")
'#s(backup
    "JP’s iPhone"
    "63b5...a651"
    "2014-04-17T21:53:16Z"
    "{redacted}"
    #&lt;path:/Users/jp/Library/Application Support/MobileSync/Backup/63b5....a651&gt;)</code></pre>
<p>One more utility macro:</p>
<pre class="scheme"><code>; Parameterize code with a current backup
(define-syntax-rule (with-backup identifier body ...)
  (parameterize ([current-backup (read-backup identifier)])
    body ...))</code></pre>
<p>This will be nice, since it can let us do things like this:</p>
<pre class="scheme"><code>&gt; (define contacts
    (with-backup "86b1...aa36"
      (list-contacts)))</code></pre>
<p>Nice and clean.</p>
<p>I think that's about enough for today. The entire code for today's post (along with the entire library thus far, which is significantly further along<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span>), is available on GitHub: <a href="https://github.com/jpverkamp/ios-backup">ios-backup</a></p>]]></content></entry><entry><title>Let it snow!</title><link href="http://blog.jverkamp.com/2015/01/09/let-it-snow" /><id>urn:uuid:fa564bef-0d12-6077-4670-d0535b5acc9c</id><updated>2015-01-09T00:00:00Z</updated><summary type="html"><![CDATA[<p>♫ Oh the weather outside is frightful<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>... ♫</p>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>♫ Oh the weather outside is frightful<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>... ♫</p>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" /></a></p>
<!--more-->
<p>Today's post is inspired once again by the <a href="https://codegolf.stackexchange.com/">Code Golf StackExchange</a>: <a href="https://codegolf.stackexchange.com/questions/42506/draw-a-snowflake">Draw a snowflake</a>. Sounds simple enough, yes?</p>
<p>The basic idea is to take a similar sort of code to what I used about 10 months ago when I wrote a post on <a href="http://blog.jverkamp.com/2014/03/11/brownian-trees">Brownian trees</a>. The main difference this time is that this time we want <a href="https://en.wikipedia.org/wiki/rotational_symmetry">rotational/radial</a> and <a href="https://en.wikipedia.org/wiki/reflectional_symmetry">reflectional</a> symmetry. To do that, instead of generating points in an entire circular world, we will instead use only a slice, which we can than repeat and rotate. It turns out there's a reasonable amount of math involved in making that actually work right, but the code should still be fairly straight forward.</p>
<p>First, we need to decide what data types we're going to work with. Originally, I had a struct for both the points and the snowflakes themselves, but then I realized with have a very powerful tool at our disposal: <a href="https://en.wikipedia.org/wiki/complex_numbers">complex numbers</a>.</p>
<p>What does representing points as complex numbers buy us?</p>
<ul>
    <li>Conversion between <a href="https://en.wikipedia.org/wiki/cartesian_coordinates">cartesian coordinates</a> (<code><a href="http://docs.racket-lang.org/search/index.html?q=make-rectangular">make-rectangular</a></code>) and <a href="https://en.wikipedia.org/wiki/polar_coordinates">polar coordinates</a> with <code><a href="http://docs.racket-lang.org/search/index.html?q=make-rectangular">make-rectangular</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=make-polar">make-polar</a></code></li>
    <li>Add offsets to points</li>
    <li>Determine the distance between two points with subtration and <code><a href="http://docs.racket-lang.org/search/index.html?q=magnitude">magnitude</a></code></li>
    <li>The ability to rate points (again via <code><a href="http://docs.racket-lang.org/search/index.html?q=make-polar">make-polar</a></code>)</li>
</ul>
<p>Sounds worth doing. :)</p>
<p>So then we just need a structure for snowflakes to start with:</p>
<pre class="scheme"><code>(struct snowflake (radius arms points) #:prefab)

; Generate a new snowflake with the given number of arms
(define (make-snowflake radius arms)
  (snowflake radius arms '(0)))</code></pre>
<p><code>radius</code> and <code>arms</code> will be constants that store the structure of the snowflake, while <code>points</code> will change (sans mutation, since we didn't make it <code>#:mutable</code>) as we add more points. Originally I had a grid of points, but since we're moving going to be constantly converting between cartesean and polar coordinates and moving about in a continuous space, it didn't work so well. On the down side, the larger an image gets, the longer it takes to compare to previous points. If I wanted to optimize this, something like a <a href="https://en.wikipedia.org/wiki/quadtree">quadtree</a>, but at the moment, this works well enough.</p>
<p>Next, we want the ability to add points to a snowflake, or to check if a point is currently in it:</p>
<pre class="scheme"><code>; Rotate a point so that the angle is in the range [θ, -θ)
(define (clampθ p θmin θmax)
  (define θΔ (- θmax θmin))
  (make-polar
   (magnitude p)
   (let loop ([θ (if (= 0 p) 0 (angle p))])
     (cond
       [(&lt;  θ θmin) (loop (+ θ θΔ))]
       [(&gt;= θ θmax) (loop (- θ θΔ))]
       [else        θ]))))

; Test if a snowflake contains a point within a given Δ
; Return the index of the point if it does, #f otherwise
(define (snowflake-contains? s p Δ)
  (match-define (snowflake radius arms points) s)

  (define θ  (/ 2π arms))
  (define pα (clampθ p 0 θ))
  (define pβ (make-polar (magnitude pα) (if (= pα 0) 0 (- θ (angle pα)))))

  (for/first ([i (in-naturals)]
              [point (in-list points)]
              #:when (or (&lt; (magnitude (- pα point)) Δ)
                         (&lt; (magnitude (- pβ point)) Δ)))
    i))

; Add a new point to the snowflake
(define (snowflake-set s p)
  (match-define (snowflake radius arms points) s)
  (define θmax (/ 2π arms))
  (snowflake radius arms (cons (clampθ p 0 θmax) points)))</code></pre>
<p>Oof. That's an intense bit of code. First, the <code>clampθ</code> function. The goal here is, as mentioned earlier, we want to be able to take an arbitrary point and rotate it so that it's in a range we can specify. Basically, modular arithmatic on angles, whee!</p>
<p>Next, checking if a <code>snowflake-contains?</code> a point. This has one particularly interesting argument: <code>Δ</code>. This basically is a margin of error. That way we can check if a point is 'close enough' to any of the points currently in the snowflake, thus building the brownian tree. Next, we have <code>pα</code> and <code>pβ</code>. <code>pα</code> is taking the point and rotating it into the proper frame of reference (giving the rotational symmetry we want), while <code>pβ</code> gives us reflectional symmetry.</p>
<p>Likewise, <code>snowflake-set</code> adds a point to the snowflake. This one is much simpler, just adding the point to the snowflake. Here's where we aren't actually mutating the snowflake, but rather returning a new copy.</p>
<p>Cool<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>.</p>
<p>Now, the meat and potatoes: The function that makes a snowflake grow:</p>
<pre class="scheme"><code>; Generate a new point on the snowflake by drifting a point inwards
(define (snowflake-grow s [Δ (sqrt 2)])
  (match-define (snowflake radius arms points) s)

  (let loop ([p (make-polar radius (* (random) 2π))])
    (cond
      ; Hit an already existing point, add it and return
      [(snowflake-contains? s p Δ)
       (snowflake-set s p)]
      ; Otherwise, try to drift inwards
      [else
       (loop
        (for/fold ([p p])
                  ([step (in-list
                          (list
                           ; Drift randomly
                           (λ (p) (+ p (make-polar
                                        (* (random) Δ)
                                        (* (random) 2π))))
                           ; Drift inwards
                           (λ (p) (make-polar
                                   (- (magnitude p) (* (random) Δ))
                                   (angle p)))))])
          (step p)))])))</code></pre>
<p>I think the strangest bit in this code is the <code>for/fold</code> in the middle. Basically, it will apply a series of functions to a point in order to make it wiggle around. Why I did this was that I was experimenting with a number of other 'wiggle' functions as I was developing. In the end, I only have two--one for random motion, the other for inwards drift--but I liked the style well enough so I kept it.</p>
<p>Specifically, the first of the two functions, will generate a new random point that is up <code>Δ</code> units away in any direction and add it to our current flake. The second will keep the same angle, but move directly inwards, again by a random amount up to <code>Δ</code>. This is exactly why we wanted to use complex numbers for our points.</p>
<p>So all we have to do to make a snowflake is to call this function a bunch of times in a row:</p>
<pre class="scheme"><code>(render-snowflake
   (for/fold ([s (make-snowflake 50 6)])
             ([i (in-range 20)])
     (snowflake-grow s 4)))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-6-20steps.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-6-20steps.png" /></a></p>
<p>(We'll define <code>render-snowflake</code> in a bit.)</p>
<p>Cool! We already have some nice flakey structure. Let's take it out to it's logical conclusion and keep growing until we hit the radius:</p>
<pre class="scheme"><code>; Generate an entire snowflake
(define (generate-snowflake radius arms [Δ (sqrt 2)])
  (let loop ([s (make-snowflake radius arms)])
    (define s^ (snowflake-grow s Δ))
    (if (&gt; (magnitude (car (snowflake-points s^))) radius)
        s^
        (loop s^))))</code></pre>
<p>Basically, we keep adding points. If, at any point, the newest point added was further out from the center than our radius, we're done. Bam.</p>
<pre class="scheme"><code>&gt; (render-snowflake (generate-snowflake 50 6 4))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-6.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-6.png" /></a></p>
<p>Or we can generate a bunch of snowflakes with different numbers of arms:</p>
<pre class="scheme"><code>&gt; (for/list ([arms (in-range 3 9)])
    (render-snowflake (generate-snowflake 50 arms 4)))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-3.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-4.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-4.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-5.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-5.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-6.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-6.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-7.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-7.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-8.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-arms-8.png" /></a></p>
<p>Or we can experiment with different values for the packing radius:</p>
<pre class="scheme"><code>&gt; (for/list ([Δ (in-list (list 1 (sqrt 2) 2 3 π 4))])
    (render-snowflake (generate-snowflake 50 6 Δ)))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-1.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-1.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-root2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-root2.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-2.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-3.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-pi.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-pi.png" /></a> <a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-4.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/sample-delta-4.png" /></a></p>
<p>Okay, so how have I been rendering these things?</p>
<pre class="scheme"><code>; Render a snowflake to a bitmap
(define (render-snowflake s)
  (match-define (snowflake radius arms data) s)
  (define size (+ 1 (* radius 2)))

  (flomap-&gt;bitmap
   (build-flomap*
    1 size size
    (λ (x y)
      (define p (make-rectangular (- x radius) (- y radius)))
      (vector (if (snowflake-contains? s p 1) 1 0))))))</code></pre>
<p>Simple. That's the beauty of making that <code>snowflake-contains?</code> function as we did earlier.</p>
<p>One neat trick that we can do though, since we have all of the points ordered by how they were added to the snowflake (albeit in reverse), we can render each step along the way as a single frame:</p>
<pre class="scheme"><code>; Render a snowflake being formed
(define (render-snowflake/frames s)
  (match-define (snowflake radius arms data) s)

  (define snowflakes
    (reverse
     (for/fold ([s* (list (make-snowflake radius arms))])
               ([pt (in-list (reverse data))])
       (match-define (list* first rest) s*)
       (match-define (snowflake _ _ data^) first)
       (list* (snowflake radius arms (cons pt data^)) s*))))

  (map render-snowflake snowflakes))</code></pre>
<p>And turn that into a fun animation:</p>
<pre class="scheme"><code>(require mrlib/gif)

(write-animated-gif
 (render-snowflake/frames (generate-snowflake 50 8 4))
 5
 filename
 #:last-frame-delay 50)</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake.gif" /></a></p>
<p>I've not used the <code><a href="http://docs.racket-lang.org/search/index.html?q=mrlib/gif">mrlib/gif</a></code> library before (instead I've been using <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/universe">2htdp/universe</a></code> to generate the frames and <a href="http://www.imagemagick.org/">ImageMagick</a> to combine them), but it's really nice. Should make future animations even easier!</p>
<p>One step further, we can take that index from <code>snowflake-contains?</code> to colorize images. We just need to tweak <code>render-snowflake</code> a bit:</p>
<pre class="scheme"><code>; Render a snowflake to a bitmap
(define (render-snowflake s #:colorize? [colorize? #f])
  (match-define (snowflake radius arms data) s)
  (define size (+ 1 (* radius 2)))
  (define data-length (length data))

  (flomap-&gt;bitmap
   (build-flomap*
    (if colorize? 3 1) size size
    (λ (x y)
      (define p (make-rectangular (- x radius) (- y radius)))
      (define index (snowflake-contains? s p 1))
      (cond
        [(and colorize? index) (let ([g (- 1 (/ index data-length))])
                                 (vector g g 1))]
        [colorize?             (vector 0 0 0)]
        [index                 (vector 1)]
        [else                  (vector 0)])))))</code></pre>
<p>Trying it out:</p>
<pre class="scheme"><code>&gt; (write-animated-gif
   (render-snowflake/frames (generate-snowflake 50 8 4) #:colorize? #t)
   5
   filename
   #:last-frame-delay 50)</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake-colorized.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/09/let-it-snow/snowflake-colorized.gif" /></a></p>
<p>And there we have it. As always, the code is available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/let-it-snow.rkt">let-it-snow.rkt</a></p>
<p>♫ Let it snow, let it snow, let it snow! ♫<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>]]></content></entry><entry><title>Generating omnichromatic images</title><link href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images" /><id>urn:uuid:f0391a98-c064-56fb-c8aa-b1b2cfcb9966</id><updated>2015-01-01T00:10:00Z</updated><summary type="html"><![CDATA[<p>Inspired half by a <a href="https://codegolf.stackexchange.com/questions/22144/images-with-all-colors">post on the Code Golf StackExchange</a> and half by the corresponding website <a href="http://allrgb.com/">allrgb.com</a>, today's post tasks us with making images like this:</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" /></a></p>
<p>So what's so interesting about that picture?</p>
]]></summary><content type="html"><![CDATA[<p>Inspired half by a <a href="https://codegolf.stackexchange.com/questions/22144/images-with-all-colors">post on the Code Golf StackExchange</a> and half by the corresponding website <a href="http://allrgb.com/">allrgb.com</a>, today's post tasks us with making images like this:</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" /></a></p>
<p>So what's so interesting about that picture?</p>
<!--more-->
<p>Well, at 256x128, there are 32,768 pixels in that image. And all 32,768 are different.</p>
<p>What's really interesting about this is that there are all sorts of possible ways to do this. That's sort of the entire point behind <a href="http://allrgb.com/">allrgb.com</a>, although in that case, you are generating 4096x4096 images containing <em>all</em> RGB images (with one byte each for red, green, and blue). Perhaps by the end of the post, we can generate one of those giant images.</p>
<p>When I first started out, I had a few ideas for the images that I wanted to generate. Then a few more. Then even more. Each time I added more, I wanted to see how it would combine with each of the previous. As I added more and more, that got increasingly complicated. So instead, I decided to split all of the algorithms that I was writing into two halves:</p>
<ul>
  <li>Color producers - generate a list of unique colors in some specified order</li>
  <li>Location producers - generate a list of locations within the target image to place each color produced by a color producer</li>
</ul>
<p>Specifically, a producer is something that I can use with <code><a href="http://docs.racket-lang.org/search/index.html?q=in-producer">in-producer</a></code>. A thunk (a function of no arguments) that I can call over and over again that will return a new item with each call. In the case of color producers, I will be returning a vector of ARGB colors in the range <code>[0.0, 1.0]</code> (for use with the <code><a href="http://docs.racket-lang.org/search/index.html?q=images/flomap">images/flomap</a></code> module). In the case of location producers, the returned value will be a <code>(struct pt (x y))</code>.</p>
<p>This way, I can make a new color producer and almost immediately see how it looked with all of the location producers (and vice versa). Neat, no?</p>
<p>To do that, I made a module each for colors and locations. For each then, I defined code something like this:</p>
<pre class="scheme"><code>(provide list-rgb-producers
         get-rgb-producer
         in-rgb-producers)

; Interface to export all known rgb producers
(define rgb-producers (make-hash))

(define (list-rgb-producers) (hash-keys rgb-producers))
(define (get-rgb-producer name) (hash-ref rgb-producers name))
(define (in-rgb-producers) (in-hash rgb-producers))

(define-syntax-rule (define-rgb-producer (name count) body ...)
  (let ()
    (define (name count) body ...)
    (hash-set! rgb-producers 'name name)))</code></pre>
<p>The basic idea is that internally, I will store a list of producers which I can easily define with my custom macro (<code>define-rgb-producer</code> in this case). Then when I want to use the module, I can use one of the three exported functions:</p>
<ul>
  <li><code>list-rgb-producers</code> - get a list of names of defined producers</li>
  <li><code>get-rgb-producer</code> - get a specific producer by name (especially helpful if I want to base one off of another internally)</li>
  <li><code>in-rgb-producers</code> - a thin wrapper around <code>in-hash</code> to return both the name and function for each defined producer in turn</li>
</ul>
<p>Everything else, including all of the functions themselves I can define privately. That way, we can write our testing code using <code>in-rgb-producers</code> and have it automatically generate all new variants no matter what we add. Neat!</p>
<h2>Color producers</h2>
<p>Okay, let's get to the meat of the situation now. First, let's define a whole series of color producers. Since we need a location producer to actually render these, let's assume we have an <code>order-producer</code> that runs left to right, top to bottom. <code>reading</code> order, as it were (we'll define it in the next section).</p>
<p>First thought, let's just run directly through the RGB color space:</p>
<pre class="scheme"><code>; Move evenly through the RGB color space
(define-rgb-producer (sequential-noskip count)
  (generator ()
    (for ([i (in-range 256^3)])
      (yield (-&gt;rgb i)))))

; Convert an integer [0, 256^3) into an ARGB flvector
(define (-&gt;rgb n)
  (define (-&gt;1.0 n) (/ n 256.0))
  (vector 1.0
          (-&gt;1.0 (bitwise-and (arithmetic-shift n -16) 255))
          (-&gt;1.0 (bitwise-and (arithmetic-shift n -8) 255))
          (-&gt;1.0 (bitwise-and (arithmetic-shift n -0) 255))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_sequential-noskip_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_sequential-noskip_400x200.png" /></a></p>
<p>Nice and simple. We're using a <code><a href="http://docs.racket-lang.org/search/index.html?q=generator">generator</a></code> despite the performance problems mostly because they make the code so nice and clean. Also, especially once we get to the more complicated location generation code, the algorithmic complexity is going to dwarf the cost of a generator anyways...</p>
<p>Simple enough, but it has one major disadvantage. Because we're working in RGB, but only using 0.1% of the color space (20 thousand of the available 16 million colors), everything is blue. That's because since we're only changing the low bits, we change the blue value first (0-255). Green changes as well, but much slower, only getting up to around 80. Oops. So instead, let's skip enough colors each time so we go through the entire color space:</p>
<pre class="scheme"><code>; Move evenly through the RGB color space
(define-rgb-producer (sequential count)
  (define increment (quotient 256^3 count))
  (generator ()
    (for ([i (in-range 0 256^3 increment)])
      (yield (-&gt;rgb i)))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_sequential_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_sequential_400x200.png" /></a>.</p>
<p>Much better. This time we have a reasonable sampling of colors. Well... sort of. This time we have the opposite problem. Now instead of too much blue, we have less blue, more red and green. This time, the problem is that since we're changing the most in the low bits, we're skipping over a lot of the possible values for blue in each pixel, using all of the red values and still only some of the green. What we really want to do is iterate through each of the three channels, skipping the same amount for each:</p>
<pre class="scheme"><code>; Cascade through red, then green, then blue
(define-rgb-producer (cascade count)
  (define increment (inexact-&gt;exact (floor (/ 256 (expt count 1/3)))))
  (generator ()
    (for* ([r (in-range 0 256 increment)]
           [g (in-range 0 256 increment)]
           [b (in-range 0 256 increment)])
      (yield (-&gt;rgb (+ r (* 256 g) (* 256 256 b)))))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_cascade_400x200.png" /></a></p>
<p>One problem is that unless you have a specific power, this isn't quite going to give you an even split, but it's certainly better than the previous examples.</p>
<p>Another idea would be to make use of <a href="https://en.wikipedia.org/wiki/gray_codes">gray codes</a>, rather than directly use the indicies. Also known as a reflected binary code, the idea of a gray code is that between any two values, you change only one bit. This has two advantages. First, gray codes avoid the sudden change we have in previous images where we go from the end of one iteration to the beginning of the next. Second, gray codes essentially form a <a href="https://en.wikipedia.org/wiki/space_filling curve">space filling curve</a>. If you have a power of 2, <em>n</em> gray codes will cover the same space as <em>n</em> sequential values, just in a different order. Let's see what that means for our color generation:</p>
<pre class="scheme"><code>(define (-&gt;gray-code i)
  (bitwise-xor (arithmetic-shift i 1) i))

; Generate codes using gray codes
(define-rgb-producer (gray-code-noskip count)
  (generator ()
    (for ([i (in-range 256^3)])
      (yield (-&gt;rgb (-&gt;gray-code i))))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code-noskip_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code-noskip_400x200.png" /></a></p>
<pre class="scheme"><code>(define-rgb-producer (gray-code count)
  (define increment (quotient 256^3 count))
  (generator ()
    (for ([i (in-range 0 256^3 increment)])
      (yield (-&gt;rgb (-&gt;gray-code i))))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code_400x200.png" /></a></p>
<p>As before, if you don't skip you get change mostly in the lowest/blue channel with a slower change in the green. None at all in the red. If you skip around though, you get exactly the pattern we're looking for, smooth changes uniformly through the entire color space. Nice!</p>
<p>Last but not least, let's through all this nice theoretically color space stuff out the window. Random colors for the win!</p>
<pre class="scheme"><code>; Randomly generate colors (regenerating on duplicates)
(define-rgb-producer (randomly count)
  (define used (make-hasheq))
  (λ ()
    (for*/first ([_ (in-naturals)]
                 [new-color (in-value (random 256^3))]
                 #:when (not (hash-has-key? used new-color)))
      (hash-set! used new-color #t)
      (-&gt;rgb new-color))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_randomly_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_randomly_400x200.png" /></a></p>
<p>Optimally, I'd like to call that one <code>random</code>, but that would shadow the call to <code>random</code> made to actually choose a color. Can't very well do that, now can we?</p>
<p>Also, this one has a major performance problem, especially with larger images. Can you guess what it is?</p>
<h2>Location producers</h2>
<p>Okay, enough with the color generation. That should be enough for the moment. Let's instead move on to location producers. First, we'll start with the simple one we've been actually using all along:</p>
<pre class="scheme"><code>; Left to right, top to bottom
(define-order-producer (reading width height get-new-color get-color-at)
  (generator ()
    (for* ([y (in-range height)] [x (in-range width)])
      (yield (pt x y)))))</code></pre>
<p>Simple enough. That generates the images we've seen above:</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/reading_gray-code_400x200.png" /></a></p>
<p>This time, you may have noticed a few more parameters. Specifically, this time we care about not just how many colors to generate, but also the size of the iamge we're going to put them in. Likewise, in some of the later functions, we're going to want to determine which color we're about to place (generated from the color producers) and what neighbors we're about to place it nearby. In the next section, we'll have to show how we came to those last two functions / parameters.</p>
<p>How about next, we spiral from a central point outwards. This is similar to the <code>in-spiral</code> function I defined in the post on <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping">palette swapping</a>, only this time we'll use a <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">queue</a> rather than a generator:</p>
<pre class="scheme"><code>; Spiral from the center point outwards
(require data/queue)

(define-order-producer (spiral width height get-new-color get-color-at)
  (define q (make-queue))
  (enqueue! q (pt (quotient width 2) (quotient height 2)))

  (define (in-bounds? p)
    (match-define (pt x y) p)
    (and (&gt;= x 0) (&lt; x width)
         (&gt;= y 0) (&lt; y height)))

  (λ ()
    (let loop ()
      (define next (dequeue! q))
      (cond
        [(or (not (in-bounds? next)) (get-color-at next #f)) (loop)]
        [else
         (match-define (pt x y) next)
         (for* ([xd (in-range -1 2)] [yd (in-range -1 2)])
           (enqueue! q (pt (+ x xd) (+ y yd))))
         next]))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/spiral_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/spiral_gray-code_400x200.png" /></a></p>
<p>Not very functional code, but it certainly does work. The beauty of using a queue here is that by processing each pixel in the order it was added, we will do each layer in turn. As we do each layer, the next is added to the end of the queue. It's arguable which code is cleaner between this and <code>in-spiral</code>.</p>
<p>Neat. Okay, how about we take that code one step further. Rather than generating a single square, how about we generate a seed square randomly in the image, expanding it until we hit the edge. Once we do, generate another square, repeating over and over again with smaller and smaller seeds. Something like this:</p>
<pre class="scheme"><code>; Generate random squares each until they hit an edge or another square
(define-order-producer (square-fill width height get-new-color get-color-at)
  (define q (make-queue))
  (enqueue! q (pt (random width) (random height)))

  (define this-square (make-hash))

  (define (in-bounds? p)
    (match-define (pt x y) p)
    (and (&gt;= x 0) (&lt; x width)
         (&gt;= y 0) (&lt; y height)))

  (λ ()
    (let loop ()
      (define next (dequeue! q))
      (cond
        ; Already set, try again with this square
        [(hash-has-key? this-square next)
         (loop)]
        ; Out of bounds or already set, seed a new square
        [(or (not (in-bounds? next))
             (get-color-at next #f))

         (queue-filter! q (const #f))
         (hash-clear! this-square)

         (enqueue! q (pt (random width) (random height)))
         (loop)]
        ; Otherwise, return that point and queue up its neighbors
        [else
         (match-define (pt x y) next)
         (for* ([xd (in-range -1 2)] [yd (in-range -1 2)])
           (enqueue! q (pt (+ x xd) (+ y yd))))
         (hash-set! this-square next #t)
         next]))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/square-fill_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/square-fill_gray-code_400x200.png" /></a></p>
<p>This is actually one algorithm where the more abrupt changes of the <code>cascade</code> algorithm really look neat:</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/square-fill_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/square-fill_cascade_400x200.png" /></a></p>
<p>Next, let's take a similar idea, but instead of squares, let's go back to something I posted about all of the way in 2012: <a href="http://blog.jverkamp.com/2012/09/27/html5-bugs">random walk / bugs</a>.</p>
<p>Basically, start with a seed as before. This time though, randomly expand in one of the eight possible directions. If that doesn't work (either it's an edge or already set), try another direction until we fail at all eight. If that's the case (and we've walked ourselves into a corner), generate a new seed.</p>
<pre class="scheme"><code>; Walk randomly, starting a new seed if there are no more options
(define-order-producer (random-walk width height get-new-color get-color-at)
  (define current-point (pt (random width) (random height)))

  (define (in-bounds? p)
    (match-define (pt x y) p)
    (and (&gt;= x 0) (&lt; x width)
         (&gt;= y 0) (&lt; y height)))

  (λ ()
    (begin0
      current-point

      (let ()
        (match-define (pt x y) current-point)
        (define next-point
          (or
           ; Find a neighboring point that hasn't been set
           (for*/first ([xd (in-list (shuffle (range -1 2)))]
                        [yd (in-list (shuffle (range -1 2)))]
                        [neighbor (in-value (pt (+ x xd) (+ y yd)))]
                        #:when (and (in-bounds? neighbor)
                                    (not (= xd yd 0))
                                    (not (get-color-at neighbor #f))))
             neighbor)
           ; If that doesn't work, generate a new seed
           (let loop ()
             (define new-seed (pt (random width) (random height)))
             (if (get-color-at new-seed #f)
                 (loop)
                 new-seed))))

        (set! current-point next-point)))))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/random-walk_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/random-walk_gray-code_400x200.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/random-walk_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/random-walk_cascade_400x200.png" /></a></p>
<p>It's really neat how you can see the structure in each of the images, where fairly large initial walks fill in large regions and then as the space gets more and more full, you get more noise as walks generate only a pixel or two.</p>
<p>Okay, and now the big one. This is honestly the response to the <a href="https://codegolf.stackexchange.com/questions/22144/images-with-all-colors">StackExchange post</a> that got me the most interested in the first place, generating some really stunning images. Here's the basic algorithm:</p>
<ol>
  <li>Generate a set of border points <code>B</code>, set to some initial small set of points</li>
  <li>While <code>B</code> is not empty:
    <ol>
      <li>Generate a new color <code>c</code></li>
      <li>For each point <code>b</code> ∋ <code>B</code> calculate an error value if we were to place <code>c</code> at <code>b</code></li>
      <li>Place <code>c</code> at the <code>b</code> with the minimal error</li>
      <li>Update <code>B</code> by removing <code>b</code> and adding points adjacent to <code>b</code> that have not already been set</li>
    </ol>
  </li>
</ol>
<p>That's a bit of a mouthful, but it's relatively straight forward to turn into code:</p>
<pre class="scheme"><code>; Organically grow outwards, finding the best match among border pixels

; combine is how distances of border pixels are combined
; missing is the initial value and the value used if a point is missing
; after is called once with the final value (defaults to identity)
(define (make-grower #:combine combine
                     #:missing missing
                     #:after [after identity]
                     #:seeds [seeds #f])
  (λ (width height get-new-color get-color-at)
    (define border (make-hash))
    (if seeds
        (for-each (λ (seed) (hash-set! border seed #t)) seeds)
        (hash-set! border (pt (quotient width 2) (quotient height 2)) #t))

    (λ ()
      (define new-color (get-new-color))

      ; Loop through all border pixels to find the best match
      (define-values (_ best-point)
        (for/fold ([best-distance +inf.0] [best-point #f])
                  ([(point _) (in-hash border)])

          ; Find the minimum distance to pixels adjacent to that border
          (define new-distance
            (after
             (for*/fold ([new-distance missing])
                        ([xd (in-range -1 2)] [yd (in-range -1 2)])
               (define c (get-color-at (pt+ point (pt xd yd)) #f))
               (combine new-distance (if c (rgb-distance new-color c) missing)))))

          (if (&lt;= new-distance best-distance)
              (values new-distance point)
              (values best-distance best-point))))

      ; Update the borders without that point but with it's neighbors
      (hash-remove! border best-point)
      (match-define (pt x y) best-point)

      (for* ([xd (in-range -1 2)]
             [yd (in-range -1 2)]
             [new-border-point (in-value (pt (+ x xd) (+ y yd)))]
             #:when (and (not (= xd yd 0))
                         (&gt;= (+ x xd) 0) (&lt; (+ x xd) width)
                         (&gt;= (+ y yd) 0) (&lt; (+ y yd) height)
                         (not (get-color-at new-border-point #f))))
        (hash-set! border new-border-point #t))

      best-point)))</code></pre>
<p>I did say relatively. :) One thing to note is that we're doing something a little different here. Rather than directly defining a new ordering function, we're going to define several. That's the beauty of higher order functions is that we can make one function (like this one) and parameterize it over how exactly that error function is calculated. Specifically (as noted in the comments), we have 3 variables that determine how error is defined:</p>
<ul>
  <li><code>combine</code> - how do you combine the error of multiple already set pixels adjacent to a border pixel <code>b</code></li>
  <li><code>zero</code> - the initial value for the error, also used for neighboring pixels that are not currently set</li>
  <li><code>after</code> - a special function I needed when I wanted to average the error over the surrounding pixels</li>
</ul>
<p>Specifically, with these three functions, we can define (at the very least), the following error functions:</p>
<ul>
  <li><code>grow-minimum</code> - take the color distance to the neighboring pixel closest to the new color</li>
  <li><code>grow-minimum</code> - like <code>grow-minimum</code>, only take the worst neighbor</li>
  <li><code>grow-average</code> - take the average color of any set neighbors and use the distance to that as the error</li>
</ul>
<p>We can use the <code>make-grower</code> function to define these as such:</p>
<pre class="scheme"><code>; Choose the border pixel closest to any one of its neighbors
(define-order-producer (grow-minimum width height get-new-color get-color-at)
  ((make-grower #:combine min #:missing +inf.0)
   width height get-new-color get-color-at))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_gray-code_400x200.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_cascade_400x200.png" /></a></p>
<pre class="scheme"><code>; Choose the border pixel closest to the furthest away neighbor
(define-order-producer (grow-maximum width height get-new-color get-color-at)
  ((make-grower #:combine max #:missing -inf.0)
   width height get-new-color get-color-at))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum_gray-code_400x200.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum_cascade_400x200.png" /></a></p>
<pre class="scheme"><code>; Choose the border pixel where the difference from the average of already placed pixels is minimal
(define-order-producer (grow-average width height get-new-color get-color-at)
  ; Sneaky trick to track both sum (real) and count (imagionary)
  ((make-grower #:combine (λ (old-v new-v) (+ old-v new-v 0+1i))
                #:missing 0
                #:after (λ (v) (if (= v 0) 0 (/ (real-part v) (imag-part v)))))
   width height get-new-color get-color-at))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-average_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-average_gray-code_400x200.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-average_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-average_cascade_400x200.png" /></a></p>
<p>The oddest one is <code>grow-average</code>. Since we need to track both the sum and the count (since we don't know how many neighbors are actually set), we'll use imagionary numbers. Then we can use that <code>#:after</code> parameter to do the final division.</p>
<p>I really also like how different <code>grow-minimum</code> and <code>grow-maximum</code> are, despite how similar their definitions are. Specifically, since in the latter we take the worst case error, we get neat ridges between the expanding color sections which are only filled right at the very end. Likewise, <code>grow-average</code> has it's own distinct feel. Because of the averaging of the error, it tends to be much more muted.</p>
<p>Another interesting note is runtime. Because of how the border pixels are filled in, <code>grow-maximum</code> will have a much longer list through most of its run. Furthermore, since we have to compare every current border pixel to each new color, that results in a correspondingly longer runtime. While they would have the same runtime in <a href="https://en.wikipedia.org/wiki/Big_O notation">Big O notation</a>, the constants are very different.</p>
<p>You may be asking yourself, so what about that <code>#:seeds</code> paramater? Well, with that, you can do something like this: growing in from the edges rather than from the center:</p>
<pre class="scheme"><code>(define-order-producer (grow-maximum-corners width height get-new-color get-color-at)
  ((make-grower #:combine max #:missing -inf.0 #:seeds (corners width height))
   width height get-new-color get-color-at))</code></pre>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum-corners_gray-code_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum-corners_gray-code_400x200.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum-corners_cascade_400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-maximum-corners_cascade_400x200.png" /></a></p>
<p>And... that's that. That's all of the different algorithms I've come up with thus far. I have a few more ideas percolating in the back of my head (in particular, the idea of combining the ideas in this post with those in <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping">palette swapping</a>), but those will have to wait for another day.</p>
<h2>Putting it all together</h2>
<p>Before we go though, I think it would be interesting to show how I've been putting these images all together. Given one of each producer, how do you render that into an image?</p>
<pre class="scheme"><code>; Given a color and order producer, make an image
(define (render width height rgb-producer order-producer)
  ; Initialize the image to error pixels
  (define output (make-vector (* width height) (void)))

  ; Access a pixel, will be given to order producer
  ; If default is set, return that on unset or out of bounds
  (define (get-pixel p [default (void)])
    (match-define (pt x y) p)
    (cond
      [(and (&gt;= x 0) (&lt; x width)
            (&gt;= y 0) (&lt; y height))
       (define v (vector-ref output (+ x (* y width))))
       (cond
         [(not (void? v)) v]
         [(not (void? default)) default]
         [else (error 'get-pixel "pixel at ~a,~a undefined, no default specified" x y)])]
      [(not (void? default))
       default]
      [else
       (error 'get-pixel "invalid coordinates ~a,~a (size = ~a,~a)" x y width height)]))

  ; Set a pixel in the final image, error on out of bounds
  (define (set-pixel! p c)
    (match-define (pt x y) p)
    (cond
      [(and (&gt;= x 0) (&lt; x width)
            (&gt;= y 0) (&lt; y height))
       (vector-set! output (+ x (* y width)) c)]
      [else
       (error 'get-pixel "invalid coordinates ~a,~a (size = ~a,~a)" x y width height)]))

  (define count (* width height))

  ; Accessor for within the location producer to get the next color
  (define current-color #f)
  (define (get-current-color) current-color)

  ; Create the producers, cannot directly use for since we need to set the current color
  (define next-rgb (rgb-producer count))
  (define next-location (order-producer width height get-current-color get-pixel))

  (for ([index (in-range count)])
    (define color (next-rgb))
    (set! current-color color)
    (define location (next-location))
    (set-pixel! location color))

  ; Generate the resulting image, setting errors to magenta
  (flomap-&gt;bitmap
   (build-flomap*
    4 width height
    (λ (x y) (get-pixel (pt x y) (vector 1 1 0 1))))))</code></pre>
<p>Basically, it's very similar to how we were working with <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping">palette swapping</a>. We generate a vector to hold the colors as we're generating them, since <code>build-flomap*</code> doesn't give us a mutable image. Then we created a getter/setter for that same vector, the former of which we will be passing into the location producers above (as <code>get-color-at</code>). Finally, we loop through the colors.</p>
<p>I would optimally have rather used <code>in-rgb-producer</code> and <code>in-order-producer</code> here, but unfortunately that doesn't quite work. Since we need to know what the color generated by the former is in the latter, we have to add another instruction. So it goes.</p>
<p>And... that's it. Really this time. There's also a bit of test code for generating a bunch of test images along with all of the rest of my code available on GitHub: <a href="https://github.com/jpverkamp/small-projects/tree/master/blog/allrgb">allrgb</a>.</p>
<p>If you have any great ideas for more producers, I'd love to see them. Feel free to leave a comment / make a pull request / shoot me an email. If they're particularly neat, I'll add them here / to the repo above.</p>
<p>Oh hey, since I already generated it anyways:</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_randomly_512x512.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/grow-minimum_randomly_512x512.png" /></a></p>]]></content></entry><entry><title>Palette Swapping</title><link href="http://blog.jverkamp.com/2014/12/23/palette-swapping" /><id>urn:uuid:fdbf6642-e8d9-7544-30ed-156ee3de7f6d</id><updated>2014-12-23T00:00:00Z</updated><summary type="html"><![CDATA[<p>Today's task comes from the <a href="https://codegolf.stackexchange.com/">Code Golf StackExchange</a>. The idea behind <a href="https://en.wikipedia.org/wiki/code_golf">code golf</a> is to write a program with as few characters as possible, often rendering the code nigh on unreadable. Luckily, the same StackExchange also host popularity contests, one of which is the inspiration behind today's post:</p>
<blockquote>
You are given two true color images, the Source and the Palette. They do not necessarily have the same dimensions but it is guaranteed that their areas are the same, i.e. they have the same number of pixels.

Your task is to create an algorithm that makes the most accurate looking copy of the Source by only using the pixels in the Palette. Each pixel in the Palette must be used exactly once in a unique position in this copy. The copy must have the same dimensions as the Source.

-- <a href="https://codegolf.stackexchange.com/questions/33172/american-gothic-in-the-palette-of-mona-lisa-rearrange-the-pixels">American Gothic in the palette of Mona Lisa: Rearrange the pixels</a>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's task comes from the <a href="https://codegolf.stackexchange.com/">Code Golf StackExchange</a>. The idea behind <a href="https://en.wikipedia.org/wiki/code_golf">code golf</a> is to write a program with as few characters as possible, often rendering the code nigh on unreadable. Luckily, the same StackExchange also host popularity contests, one of which is the inspiration behind today's post:</p>
<blockquote>
You are given two true color images, the Source and the Palette. They do not necessarily have the same dimensions but it is guaranteed that their areas are the same, i.e. they have the same number of pixels.

Your task is to create an algorithm that makes the most accurate looking copy of the Source by only using the pixels in the Palette. Each pixel in the Palette must be used exactly once in a unique position in this copy. The copy must have the same dimensions as the Source.

-- <a href="https://codegolf.stackexchange.com/questions/33172/american-gothic-in-the-palette-of-mona-lisa-rearrange-the-pixels">American Gothic in the palette of Mona Lisa: Rearrange the pixels</a>
</blockquote>
<!--more-->
<p>Specifically for this post, we'll be using two source images, although for testing I had a whole pile more:</p>
<table>
    <tr>
        <td>
<a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa.png" /></a> <br />
-- <a href="https://en.wikipedia.org/wiki/Mona_Lisa">Mona Lisa</a> by <a href="https://en.wikipedia.org/wiki/Leonardo_da Vinci">Leonardo da Vinci</a>, c. 1503-1506
        </td><td>
<a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream.png" /></a> <br />
-- <a href="https://en.wikipedia.org/wiki/The_Scream">The Scream</a> by <a href="https://en.wikipedia.org/wiki/Edvard_Munch">Edvard Munch</a>, 1893
        </td>
    </tr>
</table>
<p>There are a bunch of different ways to solve this, but today we'll go through three of them:</p>
<ul>
    <li>Sort the colors in both images</li>
    <li>Swap pixels until the image is 'close enough'</li>
    <li>Fill in pixels greedily</li>
</ul>
<h2>Sort the colors in both images</h2>
<p>The first algorithm sounds crazy until you try it. In psuedocode:</p>
<ol>
    <li>Create a list of pixels from each image</li>
    <li>Sort the two lists by a given comparator</li>
    <li>For each pair of pixels in the two lists, take the color from the target image and the location from the source image</li>
</ol>
<p>And that's actually it. It turns out the code is just about as simple, with most of the length going into loading and saving the images and format juggling. First, we want a way of representing pixels which in this context are a color and a location:</p>
<pre class="scheme"><code>; A color with a location
(struct pixel (x y c) #:transparent)

; Sorting function based on grayscale value
(define (pixel&lt;?/grayscale p1 p2)
    (&lt; (apply + (flvector-&gt;list (pixel-c p1)))
       (apply + (flvector-&gt;list (pixel-c p2)))))</code></pre>
<p>We'll use <code>pixel&lt;?/grayscale</code> as a basic sorting function. It works well enough, although it could probably be tuned to more accurately model human vision.</p>
<p>Next, the pièce de résistance:</p>
<pre class="scheme"><code>; Recolor an image by sorting the pixels in both images
(define (recolor/sort original-src target-src
                      #:pixel&lt;? [pixel&lt;? pixel&lt;?/grayscale])
  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  ; Generate a list of pixels in each image
  (define (pixel-list fm)
    (for*/list ([x (in-range (flomap-width fm))]
                [y (in-range (flomap-height fm))])
      (pixel x y (flomap-ref* fm x y))))

  (define original-pixels (pixel-list original))
  (define target-pixels (pixel-list target))

  ; Sort both lists by the given sorting function
  (define sorted-original-pixels (sort original-pixels pixel&lt;?))
  (define sorted-target-pixels (sort target-pixels pixel&lt;?))

  ; Build a map from source xy to list index to target color
  (define transition-hash
    (for/fold ([h (hash)])
              ([original-pixel (in-list sorted-original-pixels)]
               [target-pixel (in-list sorted-target-pixels)])
      (hash-set h
                (list (pixel-x original-pixel)
                      (pixel-y original-pixel))
                (pixel-c target-pixel))))

  ; Build the new image from that transition matrix
  (flomap-&gt;bitmap
   (build-flomap*
    (flomap-components original)
    (flomap-width original) (flomap-height original)
    (λ (x y)
      (hash-ref transition-hash (list x y))))))</code></pre>
<p>Going through the commented blocks, we have a fairly direct match for the psuedocode. One difference is because of the structure of the <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code> function. Since it's expects a generator rather than allowing us to generate arbitrary points, it's easier to make a map first. Still, about the same.</p>
<p>And when you apply it to the source images above?</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_sort.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_sort.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_sort.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_sort.png" /></a>
        </td>
    </tr>
</table>
<p>That's actually really cool. It's really interesting how sorting by the grayscale values ends up recoloring the images while preserving small details in the grain of the background. Very neat. Even cooler, it's wicked fast. Since sorting is one of the more well understood problems in computer science, there are well known algorithms to use. In this case, our runtime is probably <span>\( \mathcal{O}(n\log{}n) \)</span> (with <em>n</em> as the number of pixels), since that is the runtime for the sort and both loading and writing the image are  <span>\( \mathcal{O}(n) \)</span>.</p>
<h2>Swap pixels until the image is 'close enough'</h2>
<p>Okay, that was straight forward. Let's see if we can do something different. This time, let's just brute force the problem. Rather than systematically dealing with the entire image at once:</p>
<ol>
    <li>Scramble the pixels of the target image</li>
    <li>Set <code>counter = 0</code></li>
    <li>While <code>counter</code> &lt; <code>threshold</code>
        <ol>
            <li>Choose two random pixels</li>
            <li>Calculate the 'error' of the image with the pixels at their current location, and the error with those two pixels swapped</li>
            <li>If the swapped error is lower, swap the pixels and set <code>counter = 0</code>; otherwise, increment <code>counter</code></li>
        </ol>
    </li>
</ol>
<p>First, let's define an error function based on the distance between two colors in RGB space (again, there are better functions we could use here):</p>
<pre class="scheme"><code>; Find the distance between two flvectors
(define (fl-distance fl1 fl2)
  (sqrt (for/sum ([a (in-vector (flvector-&gt;vector fl1))]
                  [b (in-vector (flvector-&gt;vector fl2))])
          (sqr (- a b)))))

; Simple error function based on RGB distance
(define (error/rgb-distance original-fm target-fm color-pixel location-pixel)
    (match-define (pixel x y _) location-pixel)
    (match-define (pixel _ _ c) color-pixel)
    (fl-distance (flomap-ref* original-fm x y) c))</code></pre>
<p>Using that, we can  the algorithm fairly directly into Racket:</p>
<pre class="scheme"><code>; Recolor an image by randomly swapping pixels based on improving error
(define (recolor/swap original-src target-src
                      #:threshold [threshold 100]
                      #:error-function [err error/rgb-distance])

  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  (define width (flomap-width original))
  (define height (flomap-height original))

  ; Generate a 2d vector of pixels
  (define pixels
    (list-&gt;vector
     (shuffle
      (for*/list ([y (in-range (flomap-height target))]
                  [x (in-range (flomap-width target))])
        (flomap-ref* target x y)))))

  ; Get/set a pixel in the pixel map
  (define (get x y)
    (pixel x y (vector-ref pixels (+ x (* width y)))))

  (define (set! x y c)
    (vector-set! pixels (+ x (* width y)) c))

  ; Get a random pixel (sized from the original image)
  (define (rnd) (get (random width) (random height)))

  ; Keep swapping pixels until we get a certain number of non-swaps in a row
  (let loop ([swap-count 0] [non-swap-count 0])
    (define p1 (rnd))
    (define p2 (rnd))

    (cond
      ; Haven't swapped recently, return the result
      [(&gt;= non-swap-count threshold)
       (flomap-&gt;bitmap
        (build-flomap*
         (flomap-components original)
         (flomap-width original) (flomap-height original)
         (λ (x y)
           (pixel-c (get x y)))))]
      ; Swap is better, swap and reset count
      [(&lt; (+ (err original target p1 p2) (err original target p2 p1))
          (+ (err original target p1 p1) (err original target p2 p2)))

       (set! (pixel-x p1) (pixel-y p1) (pixel-c p2))
       (set! (pixel-x p2) (pixel-y p2) (pixel-c p1))
       (loop (+ swap-count 1) 0)]
      ; Swap is worse, just count
      [else
       (loop swap-count (+ non-swap-count 1))])))</code></pre>
<p>To start with, let's go for the default threshold of 100 consecutive errors:</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-100.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-100.png" /></a>
        </td>
    </tr>
</table>
<p>It's a little grainy, mostly because you actually get a random spike of 100 error free swaps fairly easily (it turns out 'random' isn't as uniform as most people think). Let's try cranking the threshold up to a thousand instead:</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k.png" /></a>
        </td>
    </tr>
</table>
<p>That's a lot better for The Scream, but now the Mona Lisa is having some issues with the red in hear hair. It turns out there's a reasonable amount of brown, but too much red so they're both fairly close in grayscale distance. Perhaps a better error metric would work better.</p>
<p>Also, it takes a lot longer. While sorting worked in seconds and 100 took about 30 seconds, 1000 took about 5 minutes per image. Especially in The Scream recolored, the different in quality is obvious, but the cost really isn't worth it when you compare to how just sorting the pixels did.</p>
<p>Alternatively, you can try a different error function. For example, this one takes the weighted average of a 3x3 area rather than a single pixel (threshold = 1000).</p>
<pre class="scheme"><code>; Slightly more complicated error function takes original image average into account
(define (error/rgb-distance/average
         original-fm target-fm
         color-pixel location-pixel)
  (match-define (pixel x y _) location-pixel)
  (match-define (pixel _ _ c) color-pixel)
  (fl-distance (flvector-scale
                (foldl flvector+
                       (flomap-ref* original-fm x y)
                       (for*/list ([xd (in-range -1 2)] [yd (in-range -1 2)])
                         (flomap-ref* original-fm (+ x xd) (+ y yd))))
                (/ 1.0 9.0))
               c))</code></pre>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k-average.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k-average.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k-average.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k-average.png" /></a>
        </td>
    </tr>
</table>
<p>Mostly, it just made it blurry. Which makes sense, since we're comparing regions rather than a single pixel, so edges are less heavily influential than they were. So it goes.</p>
<h2>Fill in pixels greedily</h2>
<p>The third and final option was actually the first one that I came up with:</p>
<ol>
    <li>Generate a list of all colors in the target image</li>
    <li>For each pixel in the source image:
        <ol>
            <li>Find the most similar color in the target list</li>
            <li>Place that color in the result</li>
            <li>Remove it from the target list</li>
        </ol>
    </li>
</ol>
<p>As a <a href="https://en.wikipedia.org/wiki/greedy_algorithm">greedy algorithm</a>, it's theoretically fast but likely not optimal. What you end up getting is really good results for the first part of the image but increasingly bad results as the images diverge.</p>
<p>One neat trick I did here was that I could have just run from the top of the image down. But that would have lost out on a lot of the detail from the center of the image. So instead, I used the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/generator">racket/generator</a></code> library to make this neat gem:</p>
<pre class="scheme"><code>; Spiral outwards from (0,0) in squares
(define (in-spiral [radius +inf.0])
  (in-generator
    (yield (list 0 0))
    (for ([r (in-range 1 radius)])
      (yield (list (- r) (- r)))
      (yield (list (- r) r))
      (yield (list r (- r)))
      (yield (list r r))
      (for ([d (in-range (+ (- r) 1) r)])
        (yield (list (- r) d))
        (yield (list r     d))
        (yield (list d (- r)))
        (yield (list d r))))))</code></pre>
<p>That's much more Pythonic than Rackety, but it does work. Essentially, you get a square spiral moving out from the origin, first every pixel with x or y 1 different from the origin, then 2, then 3, etc. Neat.</p>
<p>Using that, we can  the psuedocode into Racket:</p>
<pre class="scheme"><code>; Recolor an image finding the best pixels from the center out
(define (recolor/fill/slow original-src target-src)
  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  (define width (flomap-width original))
  (define height (flomap-height original))

  ; Generate a list of target colors
  (define colors
    (for*/list ([y (in-range (flomap-height target))]
                [x (in-range (flomap-width target))])
      (flomap-ref* target x y)))

  ; Generate a 2d vector of pixels
  (define result
    (for*/vector ([y (in-range (flomap-height original))]
                  [x (in-range (flomap-width original))])
      #f))

  ; Get/set a pixel in the pixel map
  (define (result-get x y)
    (vector-ref result (+ x (* width y))))

  (define (result-set! x y c)
    (vector-set! result (+ x (* width y)) c))

  ; Spiral outwards from the center of the image
  (for ([pt (in-spiral (+ 2 (quotient (max width height) 2)))])
    ; Convert to image coordinates and verify that we're in the image
    (define x (+ (first pt) (quotient width 2)))
    (define y (+ (second pt) (quotient height 2)))
    (when (and (&gt;= x 0) (&lt; x width) (&gt;= y 0) (&lt; y height))
      ; Get the source color at that point
      (define target-color (flomap-ref* original x y))

      ; Choose the closest remaining color
      (define-values (_ color)
        (for/fold ([minimum-distance +inf.0] [best-color #f])
                  ([color (in-list colors)])
          (define new-distance (fl-distance target-color color))
          (if (&lt; new-distance minimum-distance)
              (values new-distance color)
              (values minimum-distance best-color))))

      ; Remove that color from the list to place, add it to the result
      (set! colors (remove color colors))
      (result-set! x y color)))

  ; Turn that into a bitmap
  (flomap-&gt;bitmap
   (build-flomap*
    (flomap-components original)
    (flomap-width original) (flomap-height original)
    result-get)))</code></pre>
<p>That's pretty straight forward. The most interesting bit is probably the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> in the middle. It's a quick way of finding the minimum value in a list where the value itself isn't what you're interested in. Another option would have been to <code>sort</code> with a custom sorting function, but that would in this case be slower (<span>\( \mathcal{O}(n) \)</span> versus <span>\( \mathcal{O}(n\log{}n) \)</span>).</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_fill.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_fill.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_fill.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_fill.png" /></a>
        </td>
    </tr>
</table>
<p>Okay, that's just weird. :) Basically, there are enough shared pixels in the two images that you can more or less reconstruct the center sections. After that though... All bets are off. You didn't get this in either of the previous solutions because in the sorting case, they ended up spread throughout similarly color regions while in swapping they just didn't move from where they started.</p>
<p>Also, there's another problem. It's slow. Since this was actually the first thing that I worked on, I did wanit to take a little bit of time to make it faster:</p>
<h2>Filling pixels: Data structures strike back</h2>
<p>The main problem with the fill solution is that for each pixel <span>\( \mathcal{O}(n) \)</span>, you're going to run through every pixel in the target image (another <span>\( \mathcal{O}(n) \)</span>), resulting in an <span>\( \mathcal{O}(n^2) \)</span> runtime. Not particularly great. Especially because we shouldn't have to scan through the entire list (or even the average of half of it) to find the closest matching pixel.</p>
<p>Instead, we should be able to do something like a <a href="https://en.wikipedia.org/wiki/binary_search">binary search</a>:</p>
<ol>
    <li>Start with a lower and upper bound of the entire list</li>
    <li>Until we find the closest color:
        <ol>
            <li>Find the midpoint of the current bounds</li>
            <li>If the target color is 'less than' that, set the upper bound to the midpoint, otherwise set the lower bound to the midpoint</li>
            <li>Repeat</li>
        </ol>
    </li>
</ol>
<p>If we could get something like that working, we would only need <span>\( \mathcal{O}(\log{}n) \)</span> per lookup, reducing the runtime to the same as the <code>recolor/sort</code> method. And... it turns out that Racket has just the sort of data strucure we need: a <a href="https://en.wikipedia.org/wiki/splay_tree">splay tree</a>. Specifically, a splay tree is a binary tree (enabling binary search), that self-adjusts (to avoid worst case badly unbalanced trees), which has the additional property of making recently accessed elements quick to access. That's helpful in this case, since we'll have blocks of similar colors, which are close in the tree. Neat!</p>
<p>In Racket, to build a splay tree, we need to set up a couple of things in the <code><a href="http://docs.racket-lang.org/search/index.html?q=data/order">data/order</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=data/splay-tree">data/splay-tree</a></code> modules:</p>
<pre class="scheme"><code>; Find the distance between two flvectors
(define (fl-distance fl1 fl2)
  (sqrt (for/sum ([a (in-vector (flvector-&gt;vector fl1))]
                  [b (in-vector (flvector-&gt;vector fl2))])
          (sqr (- a b)))))

; Test if two flvectors are equal
(define (flvector=? flv1 flv2)
  (not (for/first ([v1 (in-flvector flv1)]
                   [v2 (in-flvector flv2)]
                   #:when (not (= v1 v2)))
         #t)))

; Test if one flvector is less than another by comparing each channel in order
(define (flvector&lt;? flv1 flv2)
  (for/first ([v1 (in-flvector flv1)]
              [v2 (in-flvector flv2)]
              #:when (not (= v1 v2)))
    (&lt; v1 v2)))</code></pre>
<p>Then, when loading the colors instead of building a list, we can make the splay tree:</p>
<pre class="scheme"><code>; Generate a list of target colors
(define colors
  (make-splay-tree
   (order 'pixel-grayscale-order
          flvector?
          flvector=?
          flvector&lt;?)))

(for* ([y (in-range (flomap-height target))]
       [x (in-range (flomap-width target))])

  (define color (flomap-ref* target x y))
  (define count (+ 1 (splay-tree-ref colors color 0)))
  (splay-tree-set! colors color count))</code></pre>
<p>One thing we didn't have to do earlier was to keep track of counts for each pixel. In a list, we just duplicated the elements, for the splay tree this won't work as well.</p>
<p>Then, in the <code>recolor/fill</code> method, we tweak the color choosing function (previously the <code>for/fold</code>):</p>
<pre class="scheme"><code>...

; Get the source color at that point
(define target-color (flomap-ref* original x y))

; Choose the closest remaining color
(define iter/&gt;= (splay-tree-iterate-least/&gt;=? colors target-color))
(define iter/&lt;= (splay-tree-iterate-greatest/&lt;=? colors target-color))

(define color
  (cond
    [(and iter/&gt;= iter/&lt;=)
     (define c1 (splay-tree-iterate-key colors iter/&gt;=))
     (define c2 (splay-tree-iterate-key colors iter/&lt;=))
     (if (&lt; (fl-distance target-color c1)
            (fl-distance target-color c2))
         c1
         c2)]
    [iter/&gt;= (splay-tree-iterate-key colors iter/&gt;=)]
    [iter/&lt;= (splay-tree-iterate-key colors iter/&lt;=)]))

(define count (splay-tree-ref colors color))
(if (= count 1)
    (splay-tree-remove! colors color)
    (splay-tree-set! colors color (- count 1)))

(result-set! x y color)

...</code></pre>
<p>The method for finding the smallest element greater than / largest less than a given element that isn't actually in the tree is a little weird, but it works out in the end. That's one nice thing about how crosslinked all of the Racket documentation is, I could just keep looking until I found the functions that I needed.</p>
<p>Give this a run... And it's a <em>lot</em> faster. Rather than an hour or more to run, it takes only seconds. It's a little bit slower than the sort (since the data structure is a little more complicated), but well within the same order of runtime.</p>
<p>Yet more evidence that perhaps you should pay attention in data structures class. :)</p>
<h2>Conclusion</h2>
<p>And, that's it. That was a lot of fun to work out. I really love how the simplest algorithm is also the fastest and has arguably the best results (at least for these two images). So cool!</p>
<p>If you would like to check out the source code for today's post, you can do so here: <a href="https://github.com/jpverkamp/small-projects/tree/master/blog/palette-swap">palette-swap</a>. If you place multiple PNG images with the same number of pixels (aspect ratios don't matter) in the <code>input</code> subdirectory and run <code>test.rkt</code> it will generate a whole pile of images like you've seen here.</p>]]></content></entry><entry><title>A "one" line echo server using let in Racket</title><link href="http://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket" /><id>urn:uuid:6f76d2a6-0b14-4d60-7cba-7ede454fd445</id><updated>2014-11-13T00:00:00Z</updated><summary type="html"><![CDATA[<p>A recent post on Reddit caught my attention: <a href="https://www.reddit.com/r/Python/comments/2m6d4z/a_one_line_echo_server_using_let_in_python/">A “One” Line Echo Server Using “let” in Python</a> (<a href="http://sigusr2.net/one-line-echo-server-using-let-python.html">original article</a>). The basic idea is that you can use Python's <code>lambda</code> with default arguments as a <code>let</code>, which in turn allows you to write a simple <a href="https://en.wikipedia.org/wiki/echo_server">echo server</a> in <del>one line</del> a nicely functional style.</p>
]]></summary><content type="html"><![CDATA[<p>A recent post on Reddit caught my attention: <a href="https://www.reddit.com/r/Python/comments/2m6d4z/a_one_line_echo_server_using_let_in_python/">A “One” Line Echo Server Using “let” in Python</a> (<a href="http://sigusr2.net/one-line-echo-server-using-let-python.html">original article</a>). The basic idea is that you can use Python's <code>lambda</code> with default arguments as a <code>let</code>, which in turn allows you to write a simple <a href="https://en.wikipedia.org/wiki/echo_server">echo server</a> in <del>one line</del> a nicely functional style.</p>
<!--more-->
<p>To start with, here is their original code:</p>
<pre class="scheme"><code>import socket
import itertools

(lambda port=9000, s=socket.socket(socket.AF_INET, socket.SOCK_STREAM):
      s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) == None and
      s.bind(('', port)) == None and
      s.listen(5) == None and
      list(map(lambda c:
                  c[0].sendall(c[0].recv(1024)) and
                  c[0].close(),
               (s.accept() for _ in itertools.count(1)))))()</code></pre>
<p>It's certainly not very Pythonic, but there are a few neat tricks in there:</p>
<ul>
    <li>Using <code>lambda</code> with default arguments to define things</li>
    <li>Using <code>and</code> to sequence function calls</li>
    <li>Using list comprehension to handle the response threads</li>
</ul>
<p>It got me thinking though, what would the same sort of code look like in Racket?</p>
<p>Well, one of the draws Racket advertises (rightfully so) on its <a href="http://racket-lang.org">home page</a> is that it comes <a href="http://docs.racket-lang.org/">batteries included</a>. That means that if you're using <code><a href="http://docs.racket-lang.org/search/index.html?q=#lang racket">#lang racket</a></code>, you get a bunch of useful functions for TCP built in. Let's start with a fairly direct translation:</p>
<pre class="scheme"><code>(let ([s (tcp-listen 9000)])
  (sequence-&gt;list
   (sequence-map
    (λ (in+out) (thread (thunk (apply copy-port in+out))))
    (in-producer (thunk (call-with-values (thunk (tcp-accept s)) list))))))</code></pre>
<p>Okay, so that looks really weird. But it's a fairly straight forward translation. A few of the lines got folded into the <code><a href="http://docs.racket-lang.org/search/index.html?q=tcp-connect">tcp-connect</a></code> call and the list comprehension became a <code><a href="http://docs.racket-lang.org/search/index.html?q=in-producer">in-producer</a></code> <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence">sequence</a></code>. It's kicked off via <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence-map">sequence-map</a></code> and forced to run to termination (which will never happend) with <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence->list">sequence->list</a></code>. Unfortunately, it has the same problem that the original Python code does. Since we're constructing a list, we'll eventually run out of memory.</p>
<p>One interesting addition it does that the Python version didn't is that it both allows for multiple lines (the Python version would read one packet and hang up) and any amount of data. I've never actually used the <code><a href="http://docs.racket-lang.org/search/index.html?q=copy-port">copy-port</a></code> function before. It's really cool!</p>
<p>If we broaden our definition of "one" line a little more to allow <code><a href="http://docs.racket-lang.org/search/index.html?q=for">for</a></code> sequences (which aren't really that different under the hood), we can clean it up a bit to this:</p>
<pre class="scheme"><code>(let ([s (tcp-listen 9000)])
  (for ([(in out) (in-producer (thunk (tcp-accept s)))])
    (thread (thunk (copy-port in out)))))</code></pre>
<p>This is especially nice, since <code><a href="http://docs.racket-lang.org/search/index.html?q=in-producer">in-producer</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=for">for</a></code> work together to deal with the multiple values from <code><a href="http://docs.racket-lang.org/search/index.html?q=tcp-accept">tcp-accept</a></code>. Very clean.</p>
<p>Heck, if you want to get a little less clear about it, you can actually fold the <code>let</code> into the <code>for</code>:</p>
<pre class="scheme"><code>(for* ([s (in-value (tcp-listen 9000))]
       [(in out) (in-producer (thunk (tcp-accept s)))])
  (thread (thunk (copy-port in out))))</code></pre>
<p>This works because <code>for*</code> is actually a nested loop. So in the outer loop, it runs over the single value of the open socket. The inner loop then runs forever, accepting new incoming connections.</p>
<p>Actually, I may have to put this in my quick-scripts toolbox. There are a fair few times when writing networking clients that having a dead simple echo server could come in handy.</p>]]></content></entry><entry><title>Clockception</title><link href="http://blog.jverkamp.com/2014/11/04/clockception" /><id>urn:uuid:9a2e2d18-6c68-f33b-e456-aa1c1b531f62</id><updated>2014-11-04T09:00:00Z</updated><summary type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<!--more-->
<p>I got the basic idea for this post from <a href="http://io9.com/these-stylish-minimalistic-clocks-let-you-tell-time-wit-1652202065">this post</a> on io9. That first clock ought to look awfully familiar (although theirs looks a bit better). Let's see how we can make one of our own.</p>
<p>First, some basic structure:</p>
<pre class="scheme"><code>(struct time-data (hour minute second) #:transparent)

(define (time hour minute [second #f])
  (time-data hour minute second))

(define current-size (make-parameter 30))</code></pre>
<p>This will represent the times that we are dealing with. I specifically broke the <code>time-data</code> structure and <code>time</code> function apart, since I wanted to have optional parameters. There is an <code>#:auto</code> option for struct fields, but it doesn't quite do what I want. Finally, <code>current-size</code> will be the width of each individual analog clock.</p>
<p>Speaking of which, let's draw some basic analog clocks. I went through several different Racket drawing libraries (<code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>) before finally settling on <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>. I'm sure any of them could be used, but I just kept running into odd issues with coordinates.</p>
<pre class="scheme"><code>; Render a clock at the current-size
(define (analog-clock when)
  (match-define (time-data hour minute second) when)

  (define size (current-size))
  (define target (make-bitmap size size))
  (define dc (new bitmap-dc% [bitmap target]))

  (send dc set-pen "lightgray" 1 'solid)
  (send dc draw-ellipse 0 0 size size)
  (send dc set-pen "black" 1 'solid)

  ; Helper to draw a hand given a radius [0, 1.0] and angle
  ; Angle of 0 is upright, positive angles are clockwise
  (define (draw-hand! r θ)
    (define c (/ size 2))
    (define x (+ c (* 0.5 r size (cos θ))))
    (define y (+ c (* 0.5 r size (sin θ))))
    (send dc draw-line c c x y))

  (draw-hand! 0.8 (+ (* pi 1.5) (* 2 pi (/ minute 60))))
  (draw-hand! 0.7 (+ (* pi 1.5) (* 2 pi (/ hour 12))))

  (and second
       (begin
         (draw-hand! 0.9 (+ (* pi 1.5) (* 2 pi (/ second 60))))))

  target)</code></pre>
<p>The basic idea of <code>racket/draw</code> is that you have a sort of canvas (<code>target</code>) on which you can draw. You then issue a series of commands that either change your state (<code><a href="http://docs.racket-lang.org/search/index.html?q=set-pen">set-pen</a></code>) or draw (<code><a href="http://docs.racket-lang.org/search/index.html?q=draw-ellipse">draw-ellipse</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=draw-line">draw-line</a></code>). I did abstract a little bit the function to create the clock hands: <code>draw-hand!</code>, mostly so I wouldn't have to redo the centering offset (<code>c</code>, since <code>0,0</code> is in the top left, not the center as I'd hoped) and the <a href="https://en.wikipedia.org/wiki/trigonometry">trigonometry</a> to convert a radius and angle to x and y.</p>
<p>And that's actually all you need to make a basic clock:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 4 10)) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Straight forward enough. What's especially neat is that because radians cycle every two 2π rotations, you can put in some crazy times:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 208 -350)) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Cool. Okay, next step. Let's figure out how to animate these, so we can transition from one time to another. In this, I had two options. Either I could move as a clock moves (where the minute hand has to move an entire rotation for the hour hand to move 1/12) or independently (such that both hands move at the same speed). Because it's both less code and honestly works better in the final result, I went with the second option:</p>
<pre class="scheme"><code>; Render a sequence of frames animating a clock spinnging from one time to another
; Hands will always move clockwise but will both move at once (not as a normal clock)
(define (analog-frames α β frames)
  (match-define (time-data α-hour α-minute α-second) α)
  (match-define (time-data β-hour β-minute β-second) β)

  (let ([β-hour   (if (&gt;= β-hour α-hour)     β-hour    (+ β-hour 12))]
        [β-minute (if (&gt;= β-minute α-minute) β-minute (+ β-minute 60))]
        [β-second (and α-second β-second
                       (if (&gt;= β-second α-second) β-second (+ β-second 60)))])

    (for/list ([i (in-range frames)])
      (define frame-multiplier (/ i frames))

      (define hour (+ α-hour (* frame-multiplier (- β-hour α-hour))))
      (define minute (+ α-minute (* frame-multiplier (- β-minute α-minute))))

      (define second
        (and α-second β-second
             (+ α-second (* frame-multiplier (- β-second α-second)))))

      (analog-clock (time hour minute second)))))</code></pre>
<p>Basically, we will loop through the frames and interpolate for each frame. The <code>frame-multiplier</code> will range evenly from 0 to 1 over the course of the frames. Also, the <code>let</code> block setting <code>β-hour</code> etc is to make sure that the clocks rotate clockwise. Since the second (<code>β</code>) value will always be higher, we always rotate right.</p>
<p>Okay, next let's switch gears and make some digital clocks. Since the eventual end goal was to make clocks out of clocks, I wanted a nice blocky font, built out of only a few different pieces. That way we could animate it more easily. Luckily the Unicode <a href="https://en.wikipedia.org/wiki/box-drawing_characters">box-drawing characters</a> will do exactly what we need:</p>
<p>I went with a 3x3 character map for each letter:</p>
<pre class="scheme"><code>(define digits
  (vector "┌─┐│ │└─┘" ; 0
          "─┐  │ ─┴─" ; 1
          " ─┐┌─┘└──" ; 2
          "──┐ ─┤──┘" ; 3
          "  │└─┤  │" ; 4
          "┌─ └─┐──┘" ; 5
          "│  ├─┐└─┘" ; 6
          "──┐  │  │" ; 7
          "┌─┐├─┤└─┘" ; 8
          "┌─┐└─┤  │" ; 9
          " │     │ " ; delimiter
          " ○     ○ "))</code></pre>
<p>If you straighten them out, you have things like this for 5 for example:</p>
<pre>┌─
└─┐
──┘</pre>
<p>They're not perfect, but I think they have a certain sort of charm.</p>
<p>Putting that all together, we can loop across all of the digits in the final clock and then each character that makes them up:</p>
<pre class="scheme"><code>; Render a digital clock using ascii bar graphics
(define (digital-clock when)
  (match-define (time-data hour minute second) when)

  (string-join
   (for/list ([line-index (in-range 3)])
     (list-&gt;string
      (for*/list ([digit
                   (in-list
                    (append (list (if (&lt; hour 10) 0 (quotient hour 10))
                                  (remainder hour 10)
                                  10
                                  (if (&lt; minute 10) 0 (quotient minute 10))
                                  (remainder minute 10))
                            (if second
                                (list 10
                                      (if (&lt; second 10) 0 (quotient second 10))
                                      (remainder second 10))
                                (list))))]
                  [char-index (in-range 3)])

        (define str (vector-ref digits digit))
        (define char (string-ref str (+ char-index (* line-index 3))))

        char)))
   "\n"))</code></pre>
<p>It's a bit ugly, but the bulk of the code is to make sure that we have enough digits for numbers less than 10. I bet I could do something nice with string formatting, but it works well enough. An example:</p>
<pre class="scheme"><code>&gt; (digital-clock (time 4 10))
"┌─┐  │ │ ─┐ ┌─┐\n│ │└─┤    │ │ │\n└─┘  │ │ ─┴─└─┘"</code></pre>
<p>Oops.</p>
<pre class="scheme"><code>&gt; (display (digital-clock (time 4 10)))
┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</code></pre>
<p>Much better.</p>
<p>Okay, now we're at the point of no return. How do we turn a digital clock with that 3x3 font into smaller clocks?</p>
<p>First, we need a map of the bar characters to times:</p>
<pre class="scheme"><code>; Convert the bar images used back into clocks
(define bar-&gt;clock
  (hash #\└ (time 3 0 0)
        #\┘ (time 9 0 0)
        #\┼ (time 6 0 30)
        #\─ (time 3 45 45)
        #\┴ (time 6 45 15)
        #\├ (time 3 0 30)
        #\┤ (time 9 30 0)
        #\┬ (time 6 15 45)
        #\┌ (time 3 30 30)
        #\┐ (time 9 30 30)
        #\│ (time 12 30 30)
        #\○ #f
        #\space #f))</code></pre>
<p>These could probably use a little more tuning. But what this does allow us to make is a very simple function to make a clock out of clocks:</p>
<pre class="scheme"><code>(define timeless (make-parameter (time 12 0 0)))

; Make a clock out of clocks!
(define (clock-clock when)
  (define chars (digital-clock when))
  (define empty-frame (analog-clock (timeless)))

  (define rows
    (for/list ([line (in-list (string-split chars "\n"))])
      (for/list ([char (in-string line)])
        (cond
          [(hash-ref bar-&gt;clock char) =&gt; analog-clock]
          [else empty-frame]))))

  (apply above (map (curry apply beside) rows)))</code></pre>
<p>In use:</p>
<pre class="scheme"><code> &gt; (clock-clock (time 4 10)) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>That right there is actually one of the parts of programming I love the most. Where you write a small pile of functions, each of which does one specific piece and then when you finally get to the big overall algorithm... bam. Simple.</p>
<p>But... back to being a little more complicated. How do we do the transition from one <code>clock-clock</code> to another? It would be nice if we could use the previous function, but we really can't. A similar idea will work though:</p>
<pre class="scheme"><code>; Animate a clock of clocks turning from one time to another
(define (tick-tock α β frames)
  (define α-chars (digital-clock α))
  (define β-chars (digital-clock β))

  (define rows*
    (for/list ([α-line (in-list (string-split α-chars "\n"))]
               [β-line (in-list (string-split β-chars "\n"))])
      (for/list ([α-char (in-string α-line)]
                 [β-char (in-string β-line)])
        (analog-frames (or (hash-ref bar-&gt;clock α-char) (timeless))
                       (or (hash-ref bar-&gt;clock β-char) (timeless))
                       frames))))

  (for/list ([i (in-range frames)])

    (define rows
      (for/list ([row (string-split α-chars "\n")]
                 [row-index (in-naturals)])
        (for/list ([char-index (in-range (string-length row))])
          (list-ref (list-ref (list-ref rows* row-index) char-index) i))))

    (apply above (map (curry apply beside) rows))))</code></pre>
<p>Basically, we have two steps. First we define <code>rows*</code> by generating each of the subclocks for each of the intermediate times. Then, that last is in the wrong order (indexed by row, column, then frame, rather than frame, row, then column) so we unpack it and put it back together. This is pretty terribly inefficient, but there will only ever be 3 rows and up to 20 columns, so it's not that bad.</p>
<p>With that, we can make simple animations:</p>
<pre class="scheme"><code>&gt; ; Fix bitmaps so that big-bang / run-movie / etc can render them
&gt; (define (fix img) (rotate 0 img))
&gt; (run-movie 0.1 (tick-tock (time 7 59) (time 8 0) 56))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<p>I really wish that <code>fix</code> wasn't necessary, but for whatever reason, <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> / <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> / et al don't like <code><a href="http://docs.racket-lang.org/search/index.html?q=bitmap%">bitmap%</a></code>s. So it goes.</p>
<p>On the other hand though, <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is really cool. I've been doing things like this with <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> and the <code>stop-when</code> parameter, but this just needs a list of images and stops automatically. Another tool for my toolchest!</p>
<p>Okay, one more step. I know I just said <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is the new shiny, but let's step back to <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> for a second. Given that we have a clock made of clocks, what would it take to actually render it in real time?</p>
<pre class="scheme"><code>; Make a tick-tock real time clock
(define (tick-tock-real-time-clock #:12-hour? [12-hour? #f])
  ; Get the current time in hours/minutes/seconds
  (define (now)
    (define date (current-date))
    (time (date-hour date) (date-minute date) #f))

  ; Generate a list of frames for the next transition
  ; Note: The big bang clock is supposed to tick 28 times per second
  (define (transition-frames)
    (match-define (time-data hour minute _) (now))

    (define next-minute (remainder (+ minute 1) 60))
    (define next-hour (remainder (if (= next-minute 60) (+ hour 1) hour) (if 12-hour? 12 24)))

    (tick-tock (time hour minute)
               (time next-hour next-minute)
               56)) ; Note: The big bang clock is supposed to
                    ; tick 28 times per second

  (big-bang (list (now) (transition-frames))
    [on-tick
     (λ (state)
       (match-define (list old-time frames) state)
       (define new-time (now))
       (cond
         ; We've advanced to the new time, jump ahead!
         [(not (equal? old-time new-time))
          (list new-time (transition-frames))]
         ; Freeze if we only have one frame left
         [(null? (rest frames))
          state]
         ; Otherwise, advance one frame
         [else
          (list old-time (rest frames))]))]
    [to-draw
     (λ (state)
       (match-define (list old-time frames) state)
       (fix (first frames)))]))</code></pre>
<p>Now that is a cool function. Basically, each minute we will generate the frames that will be used by the transition. Since <code>big-bang</code> runs at 28 frames per second, the 56 frames will takes 2 seconds to animate. Each minute, the next transition will be generated and then ticked down one frame at a time until only one is left, at which point we will just wait. Neat!</p>
<p>Originally I had it rendering seconds as well, but it was just a little bit too jittery. So minutes it is! I can't really do this thing justice in a gif (it actually looks just like <code>tick-tock</code> above, just with the current time), but it's still pretty cool.</p>
<p>And... that's it. Clocks made of clocks. Who would have thought? As always, the full code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/clockception.rkt">clockception.rkt</a></p>]]></content></entry><entry><title>Tile Puzzle</title><link href="http://blog.jverkamp.com/2014/10/28/tile-puzzle" /><id>urn:uuid:073afc5c-1121-544c-5879-486d124edb3c</id><updated>2014-10-28T00:00:00Z</updated><summary type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
]]></summary><content type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
<!--more-->
<p>Okay, let's start at the beginning. How are we going to represent a puzzle? Well, let's go with the same basic idea that was described in the original post: sets of four letters (in the order north, east, south, west), one for each tile. Furthermore, the letters represent color. Originally CMYK for cyan, magenta, yellow, and black, but we'll also add RGB for red, green, and blue (it's easy enough to add colors). Next, we'll use upper case and lower case letters in order to represent the two halves of a matching image.</p>
<p>So take the unsolved image above:</p>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a></p>
<p>The first tile would be described as <code>cymK</code> for three circles and one rectangle. Continuing on, the entire puzzle would be:</p>
<pre class="scheme"><code>'("cymK" "KyCy" "ymkc" "mkYc" "MycK" "mCkY" "cmKY" "KYmC" "McMk")</code></pre>
<p>Now we'll want two helper functions:</p>
<pre class="scheme"><code>; Insert an item into the given location in a list
(define (insert-at ls item x)
  (for/list ([i (in-naturals)]
             [el (in-list ls)])
    (if (= x i) item el)))

; Return a list of all rotated versions of a string
(define (rotations str)
  (for/list ([i (in-range (string-length str))])
    (string-append (substring str i) (substring str 0 i))))</code></pre>
<p>Specifically, the first function allows us to insert a tile into a specified location in a list, while the second returns all possible rotations of our four character string. All around, things are going to be a little inefficient because we're working with lists rather than directly accessing something like a vector, but since the size of the puzzle is so small, the cost for these functions will be relatively cheap (especially compared to the crazy number of possible orderings of the tiles).</p>
<p>Okay, with that, we actually have enough of a framework to work out our solution. The basic plan of attack will be very much the same as when we worked on the <a href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens">N Queens Puzzle</a>. Place each piece in order, backtracking as soon as we see a valid solution. This way we can cut out huge swaths of the potential solution space.</p>
<pre class="scheme"><code>; Solve a puzzle by ordering pieces so that they match
(define (solve puzzle)
  ; Start with an empty solution space (all null) and a list of pieces to place
  (let loop ([solution (make-list (length puzzle) "\0\0\0\0")]
             [to-place puzzle]
             [index    0])
    (cond
      ; If we've filled in all of the pieces, we have a solution
      [(= index (length puzzle))
       solution]
      ; Otherwise, try each piece, only recurring for those that fit
      ; Return the first that solves the puzzle from here,
      ; by recursion this will be a full solution
      [else
       (for*/first ([next-item (in-list to-place)]
                    [next-item-rotated (in-list (rotations next-item))]
                    [next-puzzle (in-value (insert-at solution
                                                      next-item-rotated
                                                      index))]
                    #:when (valid? next-puzzle)
                    [recur (in-value (loop next-puzzle
                                           (remove next-item to-place)
                                           (+ index 1)))]
                    #:when recur)
         recur)])))</code></pre>
<p>Basically there are two interesting parts: the <code>let loop</code> and the <code>for*/first</code> block. The main <code>loop</code> is the primary bit of the recursion. At any particular step, we have the solution that we've built thus far. We'll start with all <code>\0</code> strings (which we'll special case in <code>valid?</code>) and then fill in puzzle pieces one at a time. <code>to-place</code> will hold the pieces we've yet to place. The <code>index</code> is used primarily to insert new pieces at the proper location.</p>
<p>Next, we have the <code>for*/first</code> loop. This is designed to clean up the search, basically by returning the first recursion that makes it through all of the lists and conditionals. Specifically, we're going to do all of the following:</p>
<ul>
  <li>Loop through all remaining pieces to place as <code>next-item</code></li>
  <li>For each piece, try each rotation in turn</li>
  <li>Generate the <code>next-puzzle</code> by inserting that piece</li>
  <li>Check that the new insertion is <code>valid?</code></li>
  <li>Recur with the newly placed piece removed</li>
  <li>If there's a valid solution, continue to the body of the loop (and thus return, since we're looking for the <code>first</code>)</li>
</ul>
<p>All that combines (with the power of recursion!) to solve the puzzle:</p>
<pre class="scheme"><code>&gt; (solve '("cymK" "KyCy" "ymkc"
           "mkYc" "MycK" "mCkY"
           "cmKY" "KYmC" "McMk"))
'("cymK" "mCkY" "ymkc"
  "McMk" "KYmC" "KyCy"
  "mkYc" "MycK" "cmKY")</code></pre>
<p>Of course that's a little hard to see what in the world is going on. Let's write a few functions using Racket's <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code> library. First, a <code><a href="http://docs.racket-lang.org/search/index.html?q=parameter">parameter</a></code> to control how large each tile will be and a pair of functions to decode the letters into colors / shapes:</p>
<pre class="scheme"><code>(define current-tile-size (make-parameter 50))

(define (char-&gt;color c)
  (case c
    [(#\R #\r) "red"]
    [(#\G #\g) "green"]
    [(#\B #\b) "blue"]
    [(#\C #\c) "cyan"]
    [(#\M #\m) "magenta"]
    [(#\Y #\y) "yellow"]
    [(#\K #\k) "black"]
    [else      "white"]))

(define (char-&gt;shape c)
  (case c
    [(#\R #\G #\B #\C #\M #\Y #\K) filled-rectangle]
    [(#\r #\g #\b #\c #\m #\y #\k) filled-ellipse]
    [(#\null)                      (λ _ (filled-rectangle 0 0))]))</code></pre>
<p>With those, we can render an individual tile:</p>
<pre class="scheme"><code>; Render a single tile given a four character specifier
; Order is top, right, bottom, left
; Colors are cyan, magenta, yellow, red, green, blue, black (k for black)
; Uppercase are square, lowercase are circular
(define (render-tile tile)
  (match-define (list top right bottom left) (string-&gt;list tile))

  ; Size of the individual images
  (define quad-size (quotient (current-tile-size) 3))

  ; Offsets for pinning, zero/half/full size adjusted for quad size
  (define zs (- (quotient quad-size 2)))
  (define hs (- (quotient (current-tile-size) 2) (quotient quad-size 2)))
  (define fs (- (current-tile-size) (quotient quad-size 2)))

  ; Helper function to render a specific shape of the specific color
  (define (shape c)
    (colorize ((char-&gt;shape c) quad-size quad-size)
              (char-&gt;color c)))

  ; Construct the image by layering each of the four sides on the base
  (let* ([pict (rectangle (current-tile-size) (current-tile-size))]
         [pict (pin-under pict hs zs (shape top))]
         [pict (pin-under pict fs hs (shape right))]
         [pict (pin-under pict hs fs (shape bottom))]
         [pict [pin-under pict zs hs (shape left)]])
    (clip pict)))</code></pre>
<p>One part that took a bit here was getting the <code>zs</code>, <code>hs</code>, and <code>fs</code> functions correct. Since coordinates are based on the top left corner of each subimage, we need to correctly offset by half of the image sizes for each of the halfway points. Also, make sure you use the <code><a href="http://docs.racket-lang.org/search/index.html?q=clip">clip</a></code> function. It will look fine with just a single tile if you do not use it, but once you start merging them... Strange things happen.</p>
<p>Demo time:</p>
<pre class="scheme"><code> &gt; (render-tile "cymK") </code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png" /></a></p>
<p>Nice!</p>
<p>Next, we can combine the <code>picts</code> into a single larger <code>pict</code>:</p>
<pre class="scheme"><code>; Render a puzzle of multiple tiles
; Puzzles are assumed to be square
(define (render puzzle)
  (define width (integer-sqrt (length puzzle)))

  (define tiles
    (for/list ([y (in-range width)])
      (for/list ([x (in-range width)])
        (render-tile (list-ref puzzle (+ x (* y width)))))))

  (define rows
    (map (λ (row) (apply (curry hc-append -1) row)) tiles))

  (apply (curry vc-append -1) rows))</code></pre>
<p>Bam:</p>
<pre class="scheme"><code>&gt; (render (solve '("cymK" "KyCy" "ymkc"
                   "mkYc" "MycK" "mCkY"
                   "cmKY" "KYmC" "McMk")))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>Neat! We can try it on larger puzzles as well:</p>
<p>...</p>
<p>Okay, that takes a really long time. Perhaps a 4x4 with more colors (more colors is actually easier to solve since there are less valid placements for each tile):</p>
<pre class="scheme"><code>&gt; (define p4x4 (random-puzzle 4 #:colors 7))
&gt; p4x4
'("yyMY" "mCKM" "Cgrr" "BMMy"
  "MrYB" "mGYK" "BRyG" "gRmc"
  "KCCm" "cyby" "mYbY" "BMcB"
  "Bmbm" "kbrr" "MkYc" "ybGY")
&gt; (render p4x4)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png" /></a></p>
<pre class="scheme"><code>&gt; (define p4x4-solution (solve p4x4))
&gt; p4x4-solution
'("rCgr" "BBMc" "YmYb" "yBMM"
  "GBRy" "mBmb" "ycyb" "mKCC"
  "rkbr" "MmCK" "YyyM" "cMkY"
  "BMrY" "cgRm" "YybG" "KmGY")
&gt; (render p4x4-solution)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png" /></a></p>
<p>Shiny. :)</p>
<p>For those interested, here's how I generated random puzzles:</p>
<pre class="scheme"><code>; Generate random puzzles
(define (random-puzzle size #:colors [colors 4])
  ; Generate n+1 intersections (including those off the edges)
  ; Each value is the top left corner of a tile with the right then down edge
  (define intersections
    (for/list ([y (in-range (+ size 1))])
      (for/list ([x (in-range (+ size 1))])
        (for/list ([which (in-list '(right down))])
          (list (string-ref "CMYKRGB" (random (min colors 7)))
                (if (= 0 (random 2)) 'normal 'inverse))))))

  (define (@ x y w invert?)
    (match-define (list char mode)
      (list-ref (list-ref (list-ref intersections y) x)
                (if (eq? w 'right) 0 1)))

    ((if (xor invert? (eq? mode 'inverse))
         char-downcase
         identity)
     char))

  ; Fill out the tiles
  (shuffle
   (for*/list ([y (in-range size)]
               [x (in-range size)])
     (string (@ x       y       'right #f)
             (@ (+ x 1) y       'down  #f)
             (@ x       (+ y 1) 'right #t)
             (@ x       y       'down  #t)))))</code></pre>
<p>And that's it. Surprisingly simple<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> to solve, a little more to render. I love problems like this. :)</p>
<p>If you really want to go off the deep end though and, go download the full source from GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/tile-puzzles.rkt">tile-puzzles.rkt</a>). Therein lies solutions for using <a href="https://en.wikipedia.org/wiki/simulated_annealing">simulated annealing</a> or <a href="https://en.wikipedia.org/wiki/genetic_algorithms">genetic algorithms</a> in an effort to solve the problem more <a href="https://en.wikipedia.org/wiki/heurisitically">heurisitically</a>, but neither is working particularly well as of yet. If you want to take one of those and finish it up, I'd love to see it.</p>]]></content></entry><entry><title>Regular Expression Fractals</title><link href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals" /><id>urn:uuid:32f94d69-d55a-a14d-ef3c-5252a500522e</id><updated>2014-10-05T00:00:00Z</updated><summary type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
<!--more-->
<p>At the end, each point in the image will have a 'path' of decisions that got you there, making a string of the numbers 1, 2, 3, and 4.</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png" /></a></p>
<p>How does that translate into code?</p>
<pre class="scheme"><code>; Generate a fractal by matching a recursive path into an image
(define (regex-fractal regex size)
  (flomap-&gt;bitmap
   (build-flomap*
    3 size size
    (λ (x y)
      (let loop ([t 0] [l 0] [s size] [path ""])
        (cond
          ; If we're at the last level, white, otherwise black
          [(&lt;= s 1)
           (cond
             [(regexp-match regex path) '#(1 1 1)]
             [else                      '#(0 0 0)])]
          ; Otherwise, divide the region into four subregions
          ; Recur into whichever our current pixel is in
          [else
           (define s/2 (quotient s 2))
           (define x-mid (+ l s/2))
           (define y-mid (+ t s/2))
           (loop
            (if (&lt; y y-mid) t y-mid)
            (if (&lt; x x-mid) l x-mid)
            s/2
            (~a path
                (match (list (&lt; y y-mid) (&lt; x x-mid))
                  ['(#t #t) 2]
                  ['(#t #f) 1]
                  ['(#f #t) 3]
                  ['(#f #f) 4])))]))))))</code></pre>
<p>That's actually pretty close to a lot of the fractal code we've been writing recently. And it generates some pretty cool images already:</p>
<pre class="scheme"><code> &gt; (regex-fractal #px"(13|31|24|42)" 256) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png" /></a></p>
<p>But we can do a little better than that. Let's parameterize a few things:</p>
<pre class="scheme"><code>(define current-size     (make-parameter 64))
(define current-coloring (make-parameter (thunk* '#(1 1 1))))
(define current-mode     (make-parameter 'short))</code></pre>
<p>Specifically, we'll pull the size out, but also add two more parameters. A mode to short circuit (so that as soon as the pattern matches, return, rather than calculating the entire depth of the image) and another to color the pixel based on a specific match. As an example coloring, consider this:</p>
<pre class="scheme"><code>; Get the maximum path length; useful for making gradients
(define (size-&gt;path-length size)
  (inexact-&gt;exact (floor (/ (log size) (log 2)))))

; Color a pixel based on how long of a match group we have
(define (color-by-length m)
  (define l (string-length (car m)))
  (define p (size-&gt;path-length (current-size)))
  (if (= l p)
      '#(1 1 1)
      (vector
       (if (&gt;= (length m) 3) (/ (string-length (list-ref m 2)) p) 0)
       (if (&gt;= (length m) 2) (/ (string-length (list-ref m 1)) p) 0)
       (if (&gt;= (length m) 4) (/ (string-length (list-ref m 3)) p) 0))))</code></pre>
<p>Now, let's take another example, one where the matching group must contain a 1. But now, color based on how much of the path is before the one:</p>
<pre class="scheme"><code>(parameterize ([current-size 256]
               [current-coloring color-by-length]
               [current-mode 'short])
  (regex-fractal #px"(.*)1"))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png" /></a></p>
<p>Very cool.</p>
<p>After that, I just collected and made up a bunch of colorings and regular expressions and generate all of the images. Check the <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">full source</a> on GitHub for details, but basically I have three colorings: a default white only, the length based coloring above, and another which matches the most common color in a match. Then I have about two dozen regular expression.</p>
<p>Then I wrote a quick loop that will generate all images in both modes (short circuiting and long), with all three colorings. It's a lot of images... Here are some of my favorites:</p>
<pre class="scheme"><code> (demo "test256" 256) </code></pre>
<p>First, a basic <a href="https://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski triangle</a> <code>1</code>:</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png" /></a></p>
<p>But if you turn on most common color, you see that each color sticks to it's own color (a pattern we'll see oft repeated):</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png" /></a></p>
<p>What's even more interesting is when you switch to 'short mode'. Since we'll stop recurring as soon as we see a 1, you get blocks rather than each individual pixel colored:</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png" /></a></p>
<p>Next, four corners. Basically, look for repeated patterns of a single digit: <code>((.)(\\2*))</code>. That should mean that we go out to the four corners, each with its own color:</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png" /></a></p>
<p>Next, split the region into left and right halves, by checking if a 1 or 2 appears first: <code>^[34]*2(.*)</code>. If it's a 2, mark it, if it's a 1, do not.</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png" /></a></p>
<p>Next, a nice jagged change on the original Sierpinski, match anything with either a 1 or a 2 (or both): <code>(12)</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png" /></a></p>
<p>Or, similarly, make two Sierpinskis by matching patterns where there's both a 1 and a 2: <code>(1.*2|2.*1)</code>:</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png" /></a></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png" /></a></p>
<p>Next, match patterns where all 1s (if any) occur before all 2s: <code>^[34]*[134]*[34]*[234]*[34]*$</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png" /></a></p>
<p>Or you can invert the Sierpinski triangle by making sure there are <em>no</em> ones at all: <code>^[^1]*$</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png" /></a></p>
<p>Or go really crazy and do some math. For example, finding all sequences with an even sum: <code>^(2|4|[13][24]*[13])*$</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png" /></a></p>
<p>Next, we have a few from the comments on the <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/">original post</a>.</p>
<p>Some nice curls: <code>[13][24][^1][^2][^3][^4]</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png" /></a></p>
<p>Patterns where you have the same pattern repeated at least three times, but with other random bits in between: <code>(.)\\1..\\1</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png" /></a>\ <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png" /></a></p>
<p>Or you can draw some nice boxes: <code>(?:13|31)(.*)</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png" /></a> <a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png" /></a></p>
<p>A nice recursive outline (reminds me of the <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>): <code>^(1[124]|2[14]|4[12]|31)*$</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png" /></a></p>
<p>Figure eights: <code>^(?:..)*(?:[13][13]|[24][24])((?:..)*)$</code></p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png" /></a></p>
<p>And finally, some nice diagonal lines, by making sure the top left/bottom right are before the top right/bottom left: <code>^[13]*[24]*$</code>:</p>
<p><a href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png" /></a></p>
<p>And there you have it. Any other awesome patterns you come up with? Share them below. I'd love to see them.</p>
<p>As always, the full source is available on GitHub if you'd like to play with it: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">regex-fractal.rkt</a></p>]]></content></entry><entry><title>Invader Fractals</title><link href="http://blog.jverkamp.com/2014/09/17/invader-fractals" /><id>urn:uuid:15d5a345-5571-4706-dc96-ad512081f006</id><updated>2014-09-17T09:00:00Z</updated><summary type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<!--more-->
<p>Specifically, here's the algorithm that we want to use to build an invader fractal:</p>
<ol>
    <li>Generate an invader</li>
    <li>Within that image:
        <ul>
            <li>For each white pixel, stop</li>
            <li>For each black pixel, recur with a smaller invader</li>
        </ul>
    </li>
    <li>Once the invader is small enough, stop recurring</li>
</ol>
<p>Sounds straight forward enough, but what does that look like in code?</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal depth)
  (let loop ([depth depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= depth 1)
                #t
                (loop (- depth 1)))
            #f)))))</code></pre>
<p>That's actually a lot more concise than I first expected. In the end, we get exactly that nice nested structure we're looking for:</p>
<pre class="scheme"><code>&gt; (make-invader-fractal 2)
'#(#(#f #f #f #f #f #f #f)
   #(#f
     #(#(#f #f #f #f #f #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #t #f #f)
       #(#f #t #t #f #f #t #f)
       #(#f #f #f #f #t #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #f #f #f))
     #f
     #(#(#f #f #f #f #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #t #t #f #f #f)
       #(#f #f #f #t #t #f #f)
       #(#f #f #t #t #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #f #f #f #f #f))
     #f
...
     #f
     #f
     #f)
   #(#f #f #f #f #f #f #f))
&gt;</code></pre>
<p>We could probably do away with representing the margins (the outermost layer is always going to be <code>#f</code>), but at the moment it makes the code easier to reason about.</p>
<p>Okay, next we need the rendering function:</p>
<pre class="scheme"><code>; Render an invader fractal as defined above
; Crop off the margin on the outmost layer
; Final size will be 5*7^{depth-1}
(define (render-invader-fractal fi)
  (define depth
    (let loop ([fi fi])
      (cond
        [(boolean? fi) 0]
        [else
         (+ 1 (for*/fold ([deepest 0]) ([col (in-vector fi)]
                                        [el (in-vector col)])
                (max (loop el) deepest)))])))

  (define size (expt 7 depth))

  (flomap-&gt;bitmap
   (flomap-crop
    (build-flomap*
     1 size size
     (λ (x y)
       (let loop ([t 0] [l 0] [s size] [fi fi])
         (cond
           [(eq? fi #t) '#(0.0)]
           [(eq? fi #f) '#(1.0)]
           [else
            ; xi and yi are the points within the current level invader
            (define xi (quotient (* 7 (- x l)) s))
            (define yi (quotient (* 7 (- y t)) s))
            (loop (+ t (* yi (/ s 7)))
                  (+ l (* xi (/ s 7)))
                  (/ s 7)
                  (vector-ref (vector-ref fi xi) yi))]))))
    (* size 5/7)
    (* size 5/7)
    1/2
    1/2)))</code></pre>
<p>Unfortunately, that first bit is a little bit hacky. Since we've split apart the functions that create and render this fractal, we don't know how large of an image to make. Still, it's quick enough to calculate. Then, we get into actually making the image. It's much the same as the code in <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. We recur down, keeping two different sets of coordinates: image coorcinates <code>x</code>, <code>y</code>, <code>t</code>, <code>l</code>, and <code>s</code> and then coordinates within the current level <code>xi</code> and <code>yi</code>. There is a lot of dividing and multiplying by that <a href="https://en.wikipedia.org/wiki/magic_number">magic number</a>, but os it goes.</p>
<p>And that's really it. There's a call to <code><a href="http://docs.racket-lang.org/search/index.html?q=flomap-crop">flomap-crop</a></code>, but that's just to cut off the outermost margin (since it will (1) always be empty and (2) the second level's margin will still include some spacing). So how does it look?</p>
<pre class="scheme"><code> &gt; (render-invader-fractal (make-invader-fractal 3)) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<p>That's about it. One more trick that I want to do though is to make these reproducable. That we can do some neat tricks with zooming in:</p>
<pre class="scheme"><code>(define-syntax-rule (with-seed seed body* ...)
  (parameterize ([current-pseudo-random-generator
                  (make-pseudo-random-generator)])
    (random-seed seed)
    body* ...))

(define (invader-fractal i depth)
  (with-seed i
    (render-invader-fractal (make-invader-fractal depth))))</code></pre>
<p>Because we reset the random seed at the beginning of the calculate and always generate the random numbers from top to bottom, we ned up with some neat effects. The top level with the same seed is always the same shape:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 8675309 depth))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png" data-toggle="lightbox"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png" /></a> <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>:)</p>
<p>Unfortunately, the lower levels aren't the same pattern, since we're generating the images using a <a href="https://en.wikipedia.org/wiki/depth_first search">depth first search</a> rather than the <a href="https://en.wikipedia.org/wiki/breadth_first search">breadth first search</a>. More specifically, we're generating the invaders in this order:</p>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png" /></a></p>
<p>In that case, the ordering is: generate the image for the given level, then the first subimage, then the first subimage of that. Generating the <em>depth first</em> as it were. What we want instead is to generate generate the top level, then all of the next level, then all of the next level, more like this:</p>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png" /></a></p>
<p>Unfortunately, that doesn't work out well in our specific code, since we're working recursively, working with a <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">stack</a> (implicitly via function calls). To do a breadth first search, we would need instead to create a explicit <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">queue</a>, which would require some fairly major refactoring.</p>
<p>There's another option though:</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal/seeded seed depth)
  (define (mod-random-seed! i)
    (random-seed (+ 1 (remainder i 2147483646))))

  (mod-random-seed! seed)
  (let loop ([d depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= d 1)
                #t
                (begin
                  (mod-random-seed! (+ (* (- depth d) 49) (* x 7) y seed))
                  (loop (- d 1))))
            #f)))))

(define (invader-fractal seed depth)
  (render-invader-fractal (make-invader-fractal/seeded seed depth)))</code></pre>
<p>With the addition of <code>mod-random-seed!</code>, we can set the seed at each level. And we've got the amusing notion of non-random random seeds. :) But since they're generated as a function of the current <code>depth</code> and <code>x</code> and <code>y</code> coordinates of the parent image, we'll always get the same images at each level:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 42 depth))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png" /></a> <a href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png" data-toggle="lightbox"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png" /></a></p>
<p>Now that's what I was looking for. :)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/invader-fractals.rkt">invader-fractals.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>
<p>Challenge: Make fractal invaders from invader fractals. Maybe later... O:)</p>]]></content></entry><entry><title>Fractal Invaders</title><link href="http://blog.jverkamp.com/2014/09/16/fractal-invaders" /><id>urn:uuid:3af088a6-d121-00ae-e2c8-a557bb1c42b3</id><updated>2014-09-16T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<!--more-->
<p>But before we get to that image, let's start with where I was Sunday. We had something that looked like this:</p>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png" /></a></p>
<p>That was my first take at a fractal invader algorithm, and in that case there really wasn't anything to do with fractals at all. The basic algorithm for that was simple:</p>
<ol>
  <li>Choose a random location and size for an invader</li>
  <li>If the new invader does not collide with any previous invader, place it</li>
  <li>Go to step 1</li>
</ol>
<p>If we failed 100 times in a row to place an invader, we made the assumption that the space was empty and bailed out. It actually worked well enough. You got to see a bunch of invaders of different sizes, all together on the map. Unfortunately though, it didn't work particularly well for filling the entire space, which is really what I was after. (If you'd like you can see the code for that on GitHub in Sunday's code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a>).</p>
<p>After that though, I took a step back. How can we actually fill the space? More specifically, how can we use recursion / fractals to efficiently fill the space? Well, what we really need is actually really similar to another previous post of mine: <a href="http://blog.jverkamp.com/2014/05/28/quadtree-image-compression">Quadtree image compression</a>.</p>
<p>Basically, here's the new algorithm:</p>
<ol>
  <li>Given a rectangular region, choose a random location and size for an invader</li>
  <li>Recursively divide the remaining space into four sections: one above, one to the right, one below, and one to the left of the new invader</li>
  <li>If any region is small enough for only a single invader, place it and stop (base case)</li>
  <li>For each other region, start again at step 1</li>
</ol>
<p>The main odd step there is step 2 above. How can we split a region into five subregions (the center being square) like that? Well, we could do something like this:</p>
<pre class="text"><code>      | R
      | i
 Top  | g
______| h
   |  | t
 L |__|____
 e |
 f | Bottom
 t |</code></pre>
<p>Making sure that you have all of the regions set up exactly right gets a little bit complicated, but if you draw a nice diagram, it should be fairly straight forward to make sure that you always generate this structure. And that's exactly what we have here:</p>
<pre class="scheme"><code>(struct rect (t l w h) #:transparent)
(struct node (bounds value-bounds value children) #:transparent)

; Create the recursive fractal structure
(define (made-fractal width height random-node)
  (let loop ([t 0] [l 0] [w width] [h height])
    (cond
      ; The next node is too small, do not place it
      [(or (&lt;= w 0) (&lt;= h 0) (&gt;= t height) (&gt;= l width))
       #f]
      ; Create a child node; recur four times as so:
      ;  T  |
      ; __  |
      ;   XX R
      ; L XX__
      ;   |
      ;   | B
      [else
       (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
       (define x (if (= w s)         0 (random (- w s))))
       (define y (if (= h s)         0 (random (- h s))))
       (node (rect t       l       w h) ; Bounds of this node
             (rect (+ t y) (+ l x) s s) ; Bounds of the value within this node
             (random-node)              ; The value of this node
             (list (loop t         l         (+ x s)   y        )
                   (loop t         (+ l x s) (- w x s) (+ y s)  )
                   (loop (+ t y s) (+ l x)   (- w x)   (- h y s))
                   (loop (+ t y)   l         x         (- h y)  )))])))</code></pre>
<p>Essentially, we want to create a nested structure made out of <code>node</code> structs. For each node, we have two bounding boxes, one for the entire recursive structure and one just for the central image (which in turn defines the four children). Then we have a value which I've already parameterized here as the <code>random-node</code> parameter and finally four children (ordered top, right, bottom, left, although it really doesn't matter).</p>
<p>What's neat about this is that the exact same code could theoretically be used for other structures. Say if we wanted 8 children for each of the orthagonal or diagonal directions. Just add more to the <code>node-children</code> list.</p>
<p>There are a few edge cases to watch out for that I did spend rather a while working out. For example, the base case deals with cases where either <code>w</code> or <code>h</code> is less than zero, but it also deals when we go off the right or bottom edge of the region. Likewise, we have to check if we only have exactly 1 square left in either width or height (which would mean we cannot generate an interesting random size) or if we only have exactly enough room for one shape.</p>
<p>After that, it's just a matter of getting the parameters right for the recursive calls. Let's try one out:</p>
<pre class="scheme"><code>&gt; (make-fractal 4 3 (const #t))
(node
 (rect 0 0 4 3)
 (rect 0 0 3 3)
 #t
 (list
  #f
  (node
   (rect 0 3 1 3)
   (rect 1 3 1 1)
   #t
   (list
    (node (rect 0 3 1 1) (rect 0 3 1 1) #t '(#f #f #f #f))
    #f
    (node (rect 2 3 1 1) (rect 2 3 1 1) #t '(#f #f #f #f))
    #f))
  #f
  #f))</code></pre>
<p>If you take each of those in order, you have the regions:</p>
<pre class="text"><code>AAAB
AAAC
AAAD</code></pre>
<p>So we generated a 3x3 region first and then filled in the rest with 1x1s. Of course that's not very nice to visualize. Let's make something a little prettier:</p>
<pre class="scheme"><code>(define (in? bounds x y)
  (match-define (rect t l w h) bounds)
  (and (&lt;= l x (+ l w -1))
       (&lt;= t y (+ t h -1))))

; Render a fractal image
(define (fractal-image
         width height
         #:random-color [random-color (thunk (vector (random) (random) (random)))])

  (define root (make-fractal width height random-color))

  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (λ (x y)
      (let loop ([node root])
        (cond
          [(in? (node-value-bounds node) x y) (node-value node)]
          [else
           (for*/first ([child (in-list (node-children node))]
                        #:when (and child (in? (node-bounds child) x y)))
             (loop child))]))))))</code></pre>
<p>That's surprisingly simple, but then again most of the work was already done in setting up the structure. The most complicated bit here is that we have two different usages of the <code>in?</code> function:</p>
<ul>
  <li><code>(in? (node-value-bounds node) x y)</code> - checks if the current point is in the current node's value box (the inner box); if that's the case, this is our base case</li>
  <li><code>(in? (node-bounds child) x y)</code> - if this is true for any of the child node's outer box; if that's true we know that our value is somewhere in that subtree</li>
</ul>
<p>That's all we need to make some pretty neat images, just changing how we generate colors:</p>
<pre class="scheme"><code>&gt; (fractal-image 200 200)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200 #:random-color (thunk (let ([g (random)]) (vector g g g))))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200
                 #:random-color (thunk
                                  (case (random 3)
                                    [(0) (vector (random) 0 0)]
                                    [(1) (vector 0 (random) 0)]
                                    [(2) (vector 0 0 (random))])))</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png" /></a></p>
<p>Which, honestly, would be a pretty neat post all by itself. But wasn't the entire point of this to made a fractal out of the <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">procedural invaders</a>?</p>
<pre class="scheme"><code>; Render a fractal image made of invaders!
(define (fractal-invaders width height #:highlights? [highlights? #f])
  (define (random-invader)
    (flomap-add-margin
     (if highlights?
         (procedural-invader/highlight (random 524288))
         (procedural-invader (random 32768)))
     1))

  (define root (make-fractal (quotient width 7)
                             (quotient height 7)
                             random-invader))

  (flomap-&gt;bitmap
   (build-flomap*
    (if highlights? 3 1) width height
    (λ (x y)
      ; Correct for coordinates within the node
      (define nx (quotient x 7))
      (define ny (quotient y 7))

      (let loop ([n root])
        (cond
          [(in? (node-value-bounds n) nx ny)
           ; Calculate coordinates within the image
           (match-define (node _ (rect t l s _) img _) n)
           (define ix (quotient (- x (* 7 l)) s))
           (define iy (quotient (- y (* 7 t)) s))
           (flomap-ref* img ix iy)]
          [else
           (or
            (for*/first ([child (in-list (node-children n))]
                         #:when (and child (in? (node-bounds child) nx ny)))
              (loop child))
            (if highlights? '#(1 1 1) '#(1)))]))))))</code></pre>
<p>Okay, this code isn't quite as nice. Mostly, that's because of a simplifying requirement that I started with: we're going to be working with a grid where each 'pixel' is a single minimal size invader. With a 1 pixel margin, that means that our minimum image size is 7x7 (thus the 7s scattered throughout the code).</p>
<p>Unfortunately, that does make our base case a little more complicated, since we're working with two different coordinate systems: image coordinates <code>x</code> and <code>y</code> and fractal coordinates <code>nx</code> and <code>ny</code>. Still, add in some offsets by 7 and a bit of padding down at the end (for images not divisible by 7) and off we go:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<p>It also works great for larger images:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png" /></a></p>
<p>It even supports highlights:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200 #:highlights? #t) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png" /></a></p>
<p>Now that's what I'm talking about. Unfortunately, the process is still somewhat random:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png" /></a></p>
<p>Sometimes the first random image is a little on the annoyingly large size. Off the top of my head, there are two ways to deal with it: either add an option parameter that controls the maximum size of a block or just keep generating images until you get what you are looking for.</p>
<p>Guess which solution I prefer? :)</p>
<pre class="scheme"><code>(define (fractal-invaders ... #:maximum-invader-size [max-size #f])
  ...
  (define root
    (make-fractal
     (quotient width 7)
     (quotient height 7)
     random-invader
     #:maximum-block-size (and max-size (/ max-size 7))))
  ...)

(define (make-fractal width height random-node #:maximum-block-size [max-size #f])
  ...
      [else
       (define s
         (let loop ()
           (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
           (cond
             [(or (not max-size) (&lt; s max-size)) s]
             [else (loop)])))
       ...])</code></pre>
<p>Simple!</p>
<pre class="scheme"><code>&gt; (fractal-invaders 400 200 #:highlights? #t #:maximum-invader-size 25)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png" /></a></p>
<p>Beautiful!</p>
<p>I wonder what other sort of images I could make with a fractal space filling algorithm like this? O:)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/fractal-invaders.rkt">fractal-invaders.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>]]></content></entry></feed>