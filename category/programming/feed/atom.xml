<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-08-13T17:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>Minimal palindromic base</title><link href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base" /><id>urn:uuid:dccae1c2-8231-ed96-21a1-54145cd10b47</id><updated>2014-08-13T17:00:00Z</updated><summary type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
<!--more-->
<p>More specifically, consider the number 15:</p>
<div>$$15_{10} = 1111_2 = 120_3 = 33_4 = 30_5 = 23_6 = 21_7 = 17_8 = 16_9$$</div>
<div>$$15_{10} = 14_{11} = 13_{12} = 12_{13} = 11_{14} = 10_{15}$$</div>
<p>In this case, <code>2</code> is our golden number, since <code>1111</code> is a palindrome. But if it wasn't, 14 is the next case, with <code>11</code>.</p>
<p>So, what do we need? Well, first we want a generic way to convert bases. We could use different characters up to base 64, but we'll eventually get beyond that. So instead, we'll use lists of digits, each of which can be any integer:</p>
<pre class="scheme"><code>; Convert a decimal number n to base b
(define (rebase n b)
  (let loop ([n n] [ls '()])
     (if (= n 0)
        ls
        (loop (quotient n b)
              (cons (remainder n b) ls)))))</code></pre>
<pre class="scheme"><code>&gt; (rebase 15 2)
'(1 1 1 1)

&gt; (rebase 15 5)
'(3 0)

&gt; (rebase 15 10)
'(1 5)

&gt; (rebase 15 14)
'(1 1)</code></pre>
<p>Looks good. Next, we'll use a macro we've often used before: <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>. It's perfect for our uses, since it will return the first value that is non-<code>#f</code>. In this case, our base:</p>
<pre class="scheme"><code>; Find the minimal base b such that n in base b is a palindrome
(define (minimal-palindromic-base n)
  (for/first ([b (in-naturals 2)]
              #:when (let ([nb (rebase n b)])
                       (equal? nb (reverse nb))))
    b))</code></pre>
<p>Bam. Let's try a few:</p>
<pre class="scheme"><code>&gt; (minimal-palindromic-base 15)
2

&gt; (minimal-palindromic-base 1234)
22

&gt; (rebase 1234 22)
'(2 12 2)

&gt; (minimal-palindromic-base 8675309)
8675308</code></pre>
<p>Huh. I think <a href="https://en.wikipedia.org/wiki/867-5309/Jenny">Jenny</a> has a secret. :)</p>
<p>That's pretty much it for the puzzle as stated, but there are still a few things that we can do. For example, we've only seen small examples. What if we want to find the number with the largest minimal palindromic base:</p>
<pre class="scheme"><code>; Find the number n which has the largest palindromic base
(define (maximal-minimal-palindromic-base n-min n-max)
  (for/fold ([b -1] [n #f]) ([i (in-range n-min (+ n-max 1))])
    (define mpb (minimal-palindromic-base i))
    (if (&gt; i b)
        (values mpb i)
        (values b   n))))</code></pre>
<p>I may or may not have just wanted an excuse to use a crazy long function name. :)</p>
<p>Give it a try:</p>
<pre class="scheme"><code>&gt; (maximal-minimal-palindromic-base 100 200)
7
200

&gt; (rebase 200 7)
'(4 0 4)</code></pre>
<p>Error, <code>maximal-minimal-palindromic-base</code> not found!</p>
<p>Okay, more seriously, what does that even look like? Let's <code><a href="http://docs.racket-lang.org/search/index.html?q=plot">plot</a></code>!</p>
<pre class="scheme"><code>(require plot)

; Plot a whole range of minimal palindromic bases
(define (plot-minimal-palindromic-bases n-min n-max)
  (plot (lines (for/list ([i (in-range n-min (+ n-max 1))])
                 (vector i (minimal-palindromic-base i)))
               #:color 6
               #:label "minimal palindromic base")))</code></pre>
<p>Basically, we're going to draw a chart relating each number to it's minimal palindromic base.</p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 100)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png" /></a></p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 1000)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png" /></a></p>
<p>Looks like like there's basically two behaviors. A background noise of really low bases (binary or trinary is often palindromic just because there aren't many digits) and a few spikes growing ever larger. Neat.</p>
<p>And that's it. Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/minimal-palindromic-base.rkt">minimal-palindromic-base.rkt</a></p>]]></content></entry><entry><title>Number words</title><link href="http://blog.jverkamp.com/2014/08/13/number-words" /><id>urn:uuid:67236730-531b-effa-30b3-b69308ea8187</id><updated>2014-08-13T14:00:00Z</updated><summary type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
<!--more-->
<p>That may look fairly straight forward. Basically, it's a <a href="https://en.wikipedia.org/wiki/parsing">parsing</a>/<a href="https://en.wikipedia.org/wiki/lexing">lexing</a> problem. You take a string as input and break it into a series of tokens (in this case, numbers 1-26); then each token is converted into a letter.</p>
<p>Unfortunately, it's a bit more complicated than that, since the grammar is ambiguous. Taking the example <code>1234</code> from above, should you parse that as <code>1 2 3 4 = ABCD</code>? Or what about <code>1 23 4 = AWD</code>? Or even <code>12 3 4 = LCD</code>? In a nutshell, we have to do all of them. So we want some sort of branching lexer that will try all possible routes.</p>
<p>So let's start with a function that meta-function that can make such a parser:</p>
<pre class="scheme"><code>; Make an optional parser
; If the regex matches, add it to each possible next parse
; If it does not, return an empty list (to be appendable)
(define (make-parser re)
  (λ (str)
    (match str
      [(regexp re (list _ n rest))
       (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
      [any
       '()])))</code></pre>
<p>Looks a bit funny, (especially since we haven't defined <code>number-&gt;words</code> yet), but basically we try to match the regular expression. If that works, make the recursive call (to <code>number-&gt;words</code>) and then append that string (as a character via <code>n->char</code>) to each recursive result. If there are no recursive results, this <code>map</code> will return an empty list. Likewise, if the regular expression doesn't match.</p>
<p>Next step, write the two parsers. We want to parse either a single digit number or a two digit number:</p>
<pre class="scheme"><code>; Create parsers for valid 1 digit and 2 digit letter numbers
(define parse-1 (make-parser #px"([1-9])(.*)"))
(define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))</code></pre>
<p>That's what makes the ambiguity the most interesting. If only <code>0</code> were a valid digit... As it is, there are four possible cases (and these two functions handle them all!):</p>
<ul>
    <li><code>str</code> starts with 1 and a digit 0-9, parse both</li>
    <li><code>str</code> starts with 2 and a digit 0-6, parse both</li>
    <li><code>str</code> starts with 2 and a digit 7-9, parse 2 digits only</li>
    <li><code>str</code> starts with 3-9, parse 1 digit only</li>
</ul>
<p>And finally, try both:</p>
<pre class="scheme"><code>; Base case, so we can stop eventually
(if (equal? str "")
    '("")
    (append (parse-1 str) (parse-2 str)))</code></pre>
<p>The base case looks a bit funny, since you might assume that if neither case matches we'll get there. That's the difference between the empty list <code>'()</code> and the list containing just an empty string <code>'("")</code>. In the latter, there's nothing to map against, ergo necessary.</p>
<p>And then all we need is the <code>n->char</code> function:</p>
<pre class="scheme"><code>; Convert a number 1-26 to a letter A-Z
(define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))</code></pre>
<p>And that's it. Put it all together:</p>
<pre class="scheme"><code>; Given 1-26 mapping to A-Z, determine all possible words represented by a number
; Correctly resolve ambiguities where 1234 -&gt; 1 2 3 4 = ABCD / 1 23 4 -&gt; AWD / 12 3 4 -&gt; LCD
(define (number-&gt;words str)
  ; Convert a number 1-26 to a letter A-Z
  (define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))

  ; Make an optional parser
  ; If the regex matches, add it to each possible next parse
  ; If it does not, return an empty list (to be appendable)
  (define (make-parser re)
    (λ (str)
      (match str
        [(regexp re (list _ n rest))
         (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
        [any
         '()])))

  ; Create parsers for valid 1 digit and 2 digit letter numbers
  (define parse-1 (make-parser #px"([1-9])(.*)"))
  (define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))

  ; Base case, so we can stop eventually
  (if (equal? str "")
      '("")
      (append (parse-1 str) (parse-2 str))))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (number-&gt;words "1234")
'("ABCD" "AWD" "LCD")

&gt; (number-&gt;words "8675309")
'("HFGECI")

&gt; (length (number-&gt;words "85121215231518124"))

1181

&gt; (number-&gt;words "85121215231518124")
'(... "HELLOWORLD" ...)</code></pre>
<p>I could claim that I just happen to know the number code for <code>HELLOWORLD</code>, but really I wrote a quick inverse function:</p>
<pre class="scheme"><code>; Convert words back to numbers
(define (words-&gt;number str)
  (define (char-&gt;n c) (number-&gt;string (- (char-&gt;integer c) 64)))
  (apply ~a (for/list ([c (in-string str)]) (char-&gt;n c))))</code></pre>
<p>Shiny!</p>
<p>Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/number-words.rkt">number-words.rkt</a></p>]]></content></entry><entry><title>Langton's ant</title><link href="http://blog.jverkamp.com/2014/08/07/langtons-ant" /><id>urn:uuid:e9c60746-187f-a46d-0c07-bb5bd223be2d</id><updated>2014-08-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<!--more-->
<p>First, let's define the problem. From Wikipedia: <a href="https://en.wikipedia.org/wiki/Langton's_ant">Langton's ant</a></p>
<blockquote>
    <p>Squares on a plane are colored variously either black or white. We arbitrarily identify one square as the "ant". The ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:</p>

    <ul>
        <li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
        <li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
    </ul>
</blockquote>
<p>That's actually pretty simple sounding, so let's just go ahead and jump into generalizing. Instead of only two states (<code>white</code> and <code>black</code>), let's generalize to an arbitrary number of states. Instead of flipping when the ant visits the state, instead advance to the next. That way, we can define ants quite simply:</p>
<ul>
    <li><code>LR</code> - an ant that turns left on state 1 to 2 and right on state 2 to 1 (the simple ant described above)</li>
    <li><code>LL</code> - an ant that always turns left; this one is boring, it just runs in circles</li>
    <li><code>LRRL</code> - a more complicated ant that turns left on either 1 to 2 or 4 to 1, but turns right on 2 to 3 or 3 to 4<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
</ul>
<p>Okay, fair enough. We also want to decide right now that we're going to support arbitrarily large grids. It would be a lot easier to define a certain region, since then we can use something like a 2-dimensional array to store the current states, but it's not actually any harder to support an unlimited grid. What we need is a way of associating a location with a state. Sounds like a job for a hash!</p>
<p>Except we need two points for a location. So we can either have nested hashes, or we can use a trick that I've used a time or two before: representings points as complex numbers. In this way, the point <code>(0, 0)</code> is the number <code>0+0i</code>; <code>(3, -7)</code> is <code>3-7i</code>. So long as we keep the numbers <code><a href="http://docs.racket-lang.org/search/index.html?q=exact">exact</a></code>, we should be able to use it as a hash key without issue.</p>
<p>Okay, so what do we need to represent the current state of a Langton's Ant simulation? We need the grid, that's true. But we also need the ant. More specifically, we need a location and current facing (since we need a direction to turn left/right from). Also, we'll need to store the current rule. We could keep this out of the structure, but since it's essentially the core of what we need to do, we'll put it in the <code><a href="http://docs.racket-lang.org/search/index.html?q=struct">struct</a></code>.</p>
<p>Something like this:</p>
<pre class="scheme"><code>(struct ant (rule location direction grid) #:transparent)
(define (make-ant rule) (ant rule 0 0+i (hash)))</code></pre>
<p>Okay, the rule is straight forward enough. Just a string of <code>L</code> or <code>R</code> characters. Location is a little stranger, but just remember that it's an exact complex number. So <code>0</code> is <code>0+0i</code> is <code>(0, 0)</code>. Direction takes some doing. Luckily though, it's going to make our math amazingly easy. Essentially, we're going to use complex multiplication. Taking from the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Rotation_(mathematics)">rotation</a>:</p>
<blockquote>
  <p>Points on the <span>\(R^2\)</span> plane can be also presented as complex numbers: the point <code>(x, y)</code> in the plane is represented by the complex number</p>

  <div>$$z = x + iy$$</div>

  <p>This can be rotated trhough an angle <span>\(\theta\)</span> by multiplying it by <span>\(e^{i\theta}\)</span>, then expanding the product using <a href="https://en.wikipedia.org/wiki/Euler's_formula">Euler's formula</a> as follows:</p>

  <p>...</p>
</blockquote>
<p>The important part is that Racket can do the complex multiplication for us. Even better, we only have to deal with two cases: left or right rotation by 90° / <span>\(\pi/2\)</span>. Expanding <span>\(e^{i\theta}\)</span>:</p>
<div>$$e^{i\pi/2} = i$$</div>
<div>$$e^{-i\pi/2} = -i$$</div>
<p>What's that? Left rotation is just multiplying by <span>\(i\)</span> and right rotation, multiplication by <span>\(-i\)</span>. Dang. That's easy. Take that, a rule to increment each state by one (modulus the number of states), and a rule to add the direction to the location (for the new location) and we have an update function.</p>
<pre class="scheme"><code>; Update an ant
(define (tick a)
  ; Unpack the previous ant, get the current cell
  (match-define (ant rule location direction grid) a)
  (define cell (hash-ref grid location 0))

  ; Rotate, multiply by e^iθ, which for 90° left or right is ±i
  (define new-direction (* direction (if (eq? #\L (string-ref rule cell)) 0+i 0-i)))

  ; Create and return the new ant
  ; Update the position via direction and move to the next state (wrapping)
  (ant rule
       (+ location new-direction)
       new-direction
       (hash-set grid location (remainder (+ cell 1) (string-length rule)))))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=match-define">match-define</a></code> is a great way to unpack the structure. <code>cell</code> holds the current state (since we need that both for the new facing and the new state). The direction is the multiplication as explained above and the new location just adds the old location and direction.</p>
<p>Nice and clean. I love it. Even better, it's completely functional. We're not actually mutating anything, even the call to <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-set">hash-set</a></code> creates a new hash rather than modifying the current one.</p>
<p>If we want to see the first few ticks of the <code>LR</code> ant:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (tick a)
(ant "LR" -1 -1 '#hash((0 . 1)))
&gt; (tick (tick a))
(ant "LR" -1-1i 0-1i '#hash((0 . 1) (-1 . 1)))
&gt; (tick (tick (tick a)))
(ant "LR" 0-1i 1 '#hash((0 . 1) (-1-1i . 1) (-1 . 1)))</code></pre>
<p>Take it from me, that's exactly what we're looking for. But it would be nice if we had a way to visualize it. Eventually, we'll want to generate actual images, but before we do that, let's do some ASCII art.</p>
<p>First, since the grid is allowed to grow unbounded, we first need to figure out how large of a grid we need to draw. Something like this:</p>
<pre class="scheme"><code>; Return the current bounds for an ant
(define (bounds a)
  (for/fold ([min-x +inf.0] [max-x -inf.0] [min-y +inf.0] [max-y -inf.0])
            ([(index cell) (in-hash (ant-grid a))])
    (values (min min-x (real-part index))
            (max max-x (real-part index))
            (min min-y (imag-part index))
            (max max-y (imag-part index)))))</code></pre>
<p>I like how <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> can be used to generate multiple values all at once, in this case both the min and max for both x and y.</p>
<p>Okay, with that, we render ASCII:</p>
<pre class="scheme"><code>; Render an ant into ASCII characters
(define (render/ascii a [charset " .:-=+*#%@"])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check the given charset
  (when (&gt; (string-length rule) (string-length charset))
    (error 'render-ascii "Charset is not longer enough, need ~a, given ~a" (string-length rule) (string-length charset)))

  ; Render an ASCII grid to current-output-port
  ; inexact-&gt;exact is necessary to avoid floating point hash errors
  (for ([y (in-range min-y (+ max-y 1))])
    (for ([x (in-range min-x (+ max-x 1))])
      (define p (inexact-&gt;exact (make-rectangular x y)))
      (display (string-ref charset (hash-ref grid p 0))))
    (newline)))</code></pre>
<p>We have a bit of error handling, which also unfortunately means that we can't deal with more than 10 characters. But it looks pretty good:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (render/ascii (tick a))
.
&gt; (render/ascii (tick (tick a)))
..
&gt; (render/ascii (tick (tick (tick a))))
.
..</code></pre>
<p>Hmm. Not very impressive. Let's write a function to do a bunch of ticks in a row.</p>
<pre class="scheme"><code>; Run multiple ticks sequentially
(define (fast-tick a n)
  (for/fold ([a a]) ([i (in-range n)])
    (tick a)))

&gt; (render/ascii (fast-tick a 10))
..
..
 ..

&gt; (render/ascii (fast-tick a 1000))
       ..    ..
      .  .    ..
     ...     .. .
  .. . ....     .
 .  ...     ..
.      ......  .
.   . ...  ..  .
.  ...   ..  . .
.   .      ......
.    .. ...   ....
.  .. ..  ...
 .   ....   ...... .
 ...  ...    .   ...
 . .. ....  .  .  .
      ..  .  .  ..
           ..</code></pre>
<p>Now, we're getting somewhere. Remember how we already built in some support for more than two character rules? Let's try a few more:</p>
<pre class="scheme"><code>&gt; (render/ascii (fast-tick (make-ant "LRL") 100))
   ..
  .  .
 .   :
.   .:
.   . .
 .    .
  .::.

&gt; (render/ascii (fast-tick (make-ant "LRRL") 100))
......
.----.
.::.
:---.
:... .
.::...</code></pre>
<p>Okay. A picture may be worth a thousand words, but these need a little work. Better yet would be an animation. To make that easier (using <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> as I often do), let's use <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code> to make some pretty pictures:</p>
<pre class="scheme"><code>; Render using htdp
(define (render/htdp a [colors '#("white" "black" "red" "blue" "green" "yellow" "magenta" "cyan" "gray" "pink")])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check that we have enough colors, then generate some
  (when (&gt; (string-length rule) (vector-length colors))
    (error 'render-ascii "Not enough colors, need ~a, given ~a" (string-length rule) (vector-length colors)))

  ; Generate the raw images
  (define images
    (for/list ([y (in-range   (- min-y 1) (+ max-y 2))])
      (for/list ([x (in-range (- min-x 1) (+ max-x 2))])
        (define p (inexact-&gt;exact (make-rectangular x y)))
        (define c (vector-ref colors (hash-ref grid p 0)))
        (define block (rectangle 10 10 "solid" c))
        (if (= p location)
            (rotate (case direction [(0+i) 0] [(1) 90] [(0-i) 180] [(-1) 270])
                    (overlay (isosceles-triangle 5 45 'outline "red")
                             (isosceles-triangle 5 45 'solid "black")
                             block))
            block))))

  ; Combine them
  (define null (empty-scene 0 0))
  (foldl above null (map (λ (row) (foldl beside null row)) images)))</code></pre>
<p>Even better, this time we have the actual ant represented as a red outlined triangle (to show facing). Let's render a few of those previous images:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 10))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png" /></a></p>
<p>Beautiful. Let's animate it:</p>
<pre class="scheme"><code>; Simulate a rule using big bang
(define (simulate rule [width 800] [height 600])
  (define background (empty-scene width height))
  (big-bang (make-ant rule)
    [on-tick tick]
    [to-draw (λ (ant) (overlay (render/2htdp ant) background))]
    [record? #t]))</code></pre>
<p>I love how what should theoretically be the most complicated part is actually so simple. Both the basic simulation itself (8 lines without comments) and the simulation loop (6 lines) are tiny. The rendering is a bit worse, but still not that bad. And you can get some <em>crazy</em> behavior with these things...</p>
<pre class="scheme"><code>&gt; (simulate "LR")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<pre class="scheme"><code>&gt; (simulate "LRRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif" /></a></p>
<p>It's interesting how this one makes such a regular grid.</p>
<pre class="scheme"><code>&gt; (simulate "LRRRLRLRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif" /></a></p>
<p>And this one is forming a nice black (state 1) border which keeps getting pushed out further and further.</p>
<p>The basic Langton's Ant (<code>LR</code>) is actually fairly famous for it's behavior:</p>
<ul>
  <li><em>simplicity</em> - &lt; ~300 steps, simple, symmetric patterns</li>
  <li><em>chaos</em> - &lt; ~10,000 steps, large irregular blocks</li>
  <li><em>order</em> - &gt; ~10,000 steps, a recurrent "highway" cycle, 104 blocks in length</li>
</ul>
<p>Examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 300))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 9000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 11000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 15000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png" /></a></p>
<p>Let it run forever, it just runs off in that one direction. It's actually really interesting:</p>
<blockquote>
  <p>Finally the ant starts building a recurrent "highway" pattern of 104 steps that repeat indefinitely. All finite initial configurations tested eventually converge to the same repetitive pattern, suggesting that the "highway" is an attractor of Langton's ant, but no one has been able to prove that this is true for all such initial configurations. It is only known that the ant's trajectory is always unbounded regardless of the initial configuration[4] – this is known as the Cohen-Kung theorem.</p>
  <p>-- <a href="https://en.wikipedia.org/wiki/Langton's_Ant">Langton's Ant</a></p>
</blockquote>
<p>And that's about it. Surprisingly simple, yet awesome emergent behavior.</p>
<p>Here are a few more fun examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "RLLRR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>That's actually an interesting aspect: repeated rules form the same patterns, just with different colors. This makes sense if you think about it, since you're getting the same pattern of <code>L</code> and <code>R</code>, just on a larger space. So:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>And that's it for today. Take a look; if you find any other awesome patterns, leave a comment! If you want to see the entire source, you can do so (as always) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/langtons-ant.rkt">langtons-ant.rkt</a></p>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 3</title><link href="http://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3" /><id>urn:uuid:9bd5dcc8-74cb-9d93-1a71-996438d2daa2</id><updated>2014-07-10T09:00:00Z</updated><summary type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
]]></summary><content type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
<!--more-->
<p>With everything we've done over the past two posts, we have everything we need to actually play the peg game:</p>
<pre class="scheme"><code>(define (play p)
  (cond
    [(= 1 (count p))         (displayln "YOU WIN!")]
    [(= 0 (length (next p))) (display "You lose. :(")]
    [else
     (render-text p)
     (displayln "Enter the peg to use and the peg to jump")
     (define from (read))
     (define over (read))
     (cond
       [(jump p from over) =&gt; play]
       [else
        (displayln "Invalid move.")
        (play p)])]))</code></pre>
<p>Let's play!</p>
<pre class="racket"><code>&gt; (play (invert (make-puzzle 1)))

        2   3
      4   5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
4 2
          1
            3
          5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
9 5
          1
        2   3
              6
    7   8       10
  11  12  13  14  15

Enter the peg to use and the peg to jump
12 8
          1
        2   3
          5   6
    7           10
  11      13  14  15

Enter the peg to use and the peg to jump
11 7
          1
        2   3
      4   5   6
                10
          13  14  15

Enter the peg to use and the peg to jump
14 13
          1
        2   3
      4   5   6
                10
      12          15

Enter the peg to use and the peg to jump
3 5
          1
        2
      4       6
        8       10
      12          15

Enter the peg to use and the peg to jump
12 8
          1
        2
      4   5   6
                10
                  15

Enter the peg to use and the peg to jump
2 4
          1

          5   6
    7           10
                  15

Enter the peg to use and the peg to jump
6 5
          1

      4
    7           10
                  15

Enter the peg to use and the peg to jump
7 4
          1
        2

                10
                  15

Enter the peg to use and the peg to jump
1 2

      4
                10
                  15

Enter the peg to use and the peg to jump
15 10
You lose. :(</code></pre>
<p>Oops.</p>
<p>Can you do any better? (Without using <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">part 1</a>?)</p>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 2</title><link href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2" /><id>urn:uuid:35e19305-69d3-fb61-a39e-a5cb4a314d43</id><updated>2014-07-09T09:00:00Z</updated><summary type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
<!--more-->
<p>Okay, first things first. Remember how we represented the puzzles as either a 15 element vector or 15 bit integer? Well that gives us a pretty solid upper bound on how many possible ways that the puzzle can end up being arrange. Specifically, <span>\(2^{15} = 32768\)</span> total states. For a computer... that's actually not that big of a number. First, let's see how many of those we can actually reach.</p>
<pre class="scheme"><code>; Count how many total states are reachable from any initial state
; By default, start with one copy of each peg missing
(define (reachable [queue (for/list ([i (in-range 15)])
                            (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [(hash-ref reached (index (first queue)) #f)
       (loop reached (rest queue))]
      ; New state, add it to the hash and all next states to the queue
      [else
       (loop (hash-set reached (index (first queue)) #t)
             (append (rest queue) (next (first queue))))])))</code></pre>
<p>Hopefully straight forward algorithm, basically we start with an (empty) index of which nodes we've visited--a hash in our case. Start with each of the fifteen opening moves in a queue. Then, keep taking one nodes off the queue. For new nodes, add that to the list of visited nodes and all its neighbors to the queue. A <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>. Give it a run:</p>
<pre class="scheme"><code>&gt; (hash-count (reachable))
13935</code></pre>
<p>So only 42.5%. Huh. A few examples of states that can't be reached:</p>
<pre class="scheme"><code>&gt; (define r (reachable))
&gt; (for/list ([i (in-range 5)])
    (let loop ()
      (define p (make-puzzle (random (expt 2 15))))
      (if (hash-ref r (index p) #f)
          (render p)
          (loop))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png" /></a></p>
<p>But that doesn't necessary tell us which starting positions are easier. For that, we need something more like this:</p>
<pre class="scheme"><code>&gt; (require plot)
&gt; (plot (discrete-histogram
         (for/list ([i (in-range 15)])
           (vector (+ i 1)
                   (hash-count (reachable (list (invert (make-puzzle (expt 2 i))))))))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png" /></a></p>
<p>Interesting. So there are three states that reach the most (4, 6, and 13), three on the next tier (1, 11, and 15), 6 on the next, and 3 that reach the least (5, 8, and 9). If you think about it, that makes a lot of sense. For each position, there are two other identical positions--rotations:</p>
<pre class="scheme"><code>; Rotate a puzzle clockwise
(define (rotate p)
  (puzzle (for/vector ([i (in-list '(11 12 7 13 8 4 14 9 5 2 15 10 6 3 1))])
            (vector-ref (puzzle-data p) (- i 1)))))

&gt; (define random-puzzle (make-puzzle (random (expt 2 15))))
&gt; (map render (list random-puzzle
                    (rotate random-puzzle)
                    (rotate (rotate random-puzzle))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png" /></a></p>
<p>Further than that, there are also reflections:</p>
<pre class="scheme"><code>; Reflect a puzzle left to right
(define (reflect p)
  (puzzle (for/vector ([i (in-list '(1 3 2 6 5 4 10 9 8 7 15 14 13 12 11))])
            (vector-ref (puzzle-data p) (- i 1)))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png" /></a></p>
<p>This is what I meant last time, when I said that there were only four initial states (1, 2, 4, and 5). All of the rest are reflections and/or rotations of one of those 4.</p>
<p>Finally, if you combine these two functions, it should be possible to get a real idea of how many truly unique states there are. Since each puzzle has a numeric form and each puzzle has up to six unique states (three rotations, each with two reflections), we can consistently find the one of those six with the lowest value. Something like this:</p>
<pre class="scheme"><code>; Minimize a puzzle by finding the reflection/rotation with the minimal vector
(define (minify p)
  (define r1 (rotate p))
  (define r2 (rotate r1))
  (first (sort (list p r1 r2 (reflect p) (reflect r1) (reflect r2))
               (λ (p1 p2)
                 (&lt; (index p1) (index p2))))))

&gt; (map index (list random-puzzle
                   (reflect random-puzzle)
                   (rotate random-puzzle)
                   (reflect (rotate random-puzzle))
                   (rotate (rotate random-puzzle))
                   (reflect (rotate (rotate random-puzzle)))))
'(26794 21322 10025 7474 12412 12679)
&gt; (index (minify random-puzzle))
7474
&gt; (render (minify random-puzzle))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png" /></a></p>
<p>So how many states do we get if we take only the minimum form? Both overall and reachable?</p>
<pre class="scheme"><code>&gt; (set-count
   (for/set ([i (in-range (expt 2 15))])
     (index (minify (make-puzzle i)))))
5728

; Modification of reachable states, only minified
; By default, start with one copy of each peg missing
(define (reachable-min [queue (for/list ([i (in-range 15)])
                                (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [else
       (define p (minify (first queue)))
       (define i (index p))
       (cond
         [(hash-ref reached i #f)
          (loop reached (rest queue))]
         [else
          (loop (hash-set reached i #t)
                (append (rest queue) (next p)))])])))

&gt; (hash-count (reachable-min))
2383</code></pre>
<p>Still about the same (technically slightly lower, it's only 41.6%). That's a good sign. We're all of the way down to 2,383 states from the original potential 32,768. A lot more manageable.</p>
<p>Next, let's shift to moves rather than states. Given two states, they are connected with a move if you could make a single jump to get from one to the other. So now rather than a set, we have a graph. Something like this:</p>
<pre class="scheme"><code>; Find a map of all possible moves from a given puzzle
(define (all-moves p)
  (define moves (make-hash))
  (let loop ([p p])
    (let ([p (minify p)])
      (define i (index (minify p)))
      (when (not (hash-has-key? moves i))
        (define next-ps (next p))
        (hash-set! moves i (list-&gt;set (map index (map minify next-ps))))
        (map loop next-ps))))
  moves)</code></pre>
<p>From there, we can recursively build up a count for each state how many times we win (end up with only a single peg) and how many times we lose.</p>
<pre class="scheme"><code>; Count the number of winning and losing states from a given puzzle
(define (score p)
  (define moves (all-moves p))
  (define-values (wins losses)
    (let loop ([i (index (minify p))])
      (define nxt (hash-ref moves i (set)))
      (cond
        [(set-empty? nxt)
         (if (= 1 (count (make-puzzle i)))
             (values 1 0)
             (values 0 1))]
        [else
         (for/fold ([wins 0] [losses 0]) ([n (in-set nxt)])
           (define-values (r-wins r-losses) (loop n))
           (values (+ wins   r-wins)
                   (+ losses r-losses)))])))
  (* 1.0 (/ wins (+ wins losses))))</code></pre>
<p>That way we can tell how 'hard' each puzzle is, assuming that you always rotate/reflect to avoid potential duplicate state:</p>
<pre class="scheme"><code>&gt; (for/list ([i (in-list '(1 2 3 5))])
    (list i (score (invert (make-puzzle i)))))

'((1 0.05239514926876435)
  (2 0.05138285262741999)
  (3 0.08392304995059131)
  (5 0.08392304995059131))</code></pre>
<p>So there you have it. If you're playing optimally, it's slightly easier to do so starting with a corner or the second. The center or center of each edge are slightly harder.</p>
<p>And that's all we have for today. Originally, I meant to use the graph library I've used a number of times before to visualize the solution space (there's a function that will do that on GitHub), but the graphs honestly aren't that helpful. There nodes are too nested and there are just too many to helpfully visualize. So it goes. Still, I think we found a few interesting things.</p>
<p>As always, the code is available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Cracker Barrel Peg Game</title><link href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game" /><id>urn:uuid:d9fc95b6-10c0-7679-ae85-b61ec0a2f271</id><updated>2014-07-05T09:00:00Z</updated><summary type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
]]></summary><content type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
<!--more-->
<p>Let's start with a bit of ground work:</p>
<pre class="scheme"><code>; Puzzles are represented as a 15 element vector (#t for pegs)
; but can be entered as a 15 bit integer (1 for pegs)
(struct puzzle (data) #:transparent)
(define (make-puzzle v)
  (cond
    [(and (integer? v) (&lt;= 0 v 32767))
     (puzzle (list-&gt;vector
              (map (curry eq? #\1)
                   (reverse (string-&gt;list (~a (number-&gt;string v 2)
                                              #:width 15
                                              #:align 'right
                                              #:pad-string "0"))))))]
    [(and (vector? v) (= 15 (vector-length v)))
     (puzzle v)]
    [(and (list? v) (length v 15))
     (puzzle (list-&gt;vector v))]))</code></pre>
<p>It's a bit heavier than it needs to be (in order to support multiple datatypes), but that saved me all sorts of time in testing. It's a lot easier to enter a puzzle like this:</p>
<pre class="scheme"><code>(make-puzzle #b111110010000000)</code></pre>
<p>Rather than:</p>
<pre class="scheme"><code>(make-puzzle '#(#f #f #f #f #f #f #f #t #f #f #t #t #t #t #t))</code></pre>
<p>(Note that the ordering is opposite. The highest bit is the last peg, while the first vector is the first peg. This is so that puzzle 1 is peg 1 and so on.)</p>
<p>Anyways.</p>
<p>Next, we need to be able to visualize what we're working with. You can always see the sequence of pegs, but without putting them in their proper triangular shape, it's a bit hard to tell what exactly is going on. So first, let's render a puzzle as text:</p>
<pre class="scheme"><code>; Render a puzzle to text
(define (render-text puzzle)
  (for ([row (in-range 1 6)])
    (display (~a "" #:width (* 2 (- 6 row))))
    (for ([col (in-range 1 (+ 1 row))])
      (define i (+ (* 1/2 row (- row 1)) col))
      (display (~a (if (vector-ref (puzzle-data puzzle) (- i 1)) i "") #:width 4)))
    (newline)))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code> is rather handy for formatting like this, making sure that each peg (at least the ones still visible) is exactly four characters wide. The formula in the line defining <code>i</code> should look familiar: it's the sum of the first i integers. Neat.</p>
<pre class="scheme"><code>&gt; (render-text (make-puzzle (random (expt 2 15))))

        2
          5   6
    7   8   9   10
      12  13      15</code></pre>
<p>That's all well and good, but it's the 21st century. We should be able to make pretty pictures as well:</p>
<pre class="scheme"><code>; Render a puzzle to a bitmap
(define (render puzzle)
  (define (bit-set? i) (vector-ref (puzzle-data puzzle) (- i 1)))

  (define imgs
    (for/list ([row (in-range 1 6)])
      (for/list ([col (in-range 1 (+ 1 row))])
        (define i (+ (* 1/2 row (- row 1)) col))
        (define color (if (bit-set? i) "black" "gray"))
        (htdp:overlay (htdp:text (~a i) 12 color)
                      (htdp:circle 10 "outline" color)
                      (htdp:circle 12 "solid" "white")))))

  (define rows (map (λ (row) (if (= 1 (length row))
                                 (first row)
                                 (apply htdp:beside row)))
                    imgs))

  (apply htdp:above rows))</code></pre>
<p>That's a bit more complicated. The basic idea is straight forward enough. First, for each peg we're going to overlay the number as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code> on an outlined <code><a href="http://docs.racket-lang.org/search/index.html?q=circle">circle</a></code>. The second, white circle is in order to get a bit of spacing. We'll render each of these into nested lists, each of increasing length. Then we shove each row together with <code><a href="http://docs.racket-lang.org/search/index.html?q=beside">beside</a></code>, then the rows together with <code><a href="http://docs.racket-lang.org/search/index.html?q=above">above</a></code>. All that to make a picture something like this:</p>
<pre class="scheme"><code>&gt; (render (make-puzzle (random (expt 2 15))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png" /></a></p>
<p>Looks good! (And it's nice being able to see the locations where there currently isn't a peg as well).</p>
<p>Okay, so now that we have some framework set up, how are we going to attack this problem?</p>
<p>Well, the first thing we need is the ability to make a move. In this case, given two neighboring pegs, jump one over the other:</p>
<pre class="scheme"><code>; Given a peg to move from and the peg to move over, return the new puzzle state
(define (jump p ifrom iover)
  (define from-list '(1  1  2  2  3  3  4  4  4  5  5  6  6  7  8  11 12 13))
  (define over-list '(2  3  4  5  5  6  5  7  8  8  9  9  10 8  9  12 13 14))
  (define to-list   '(4  6  7  9  8  10 6  11 13 12 14 13 15 9  10 13 14 15))

  (for/first ([from (in-list (append from-list to-list))]
              [over (in-list (append over-list over-list))]
              [to   (in-list (append to-list from-list))]
              #:when (and (= from ifrom)
                          (= over iover)
                          (vector-ref (puzzle-data p) (- from 1))
                          (vector-ref (puzzle-data p) (- over 1))
                          (not (vector-ref (puzzle-data p) (- to 1)))))
    (let ([new-data (vector-copy (puzzle-data p))])
      (vector-set! new-data (- from 1) #f)
      (vector-set! new-data (- over 1) #f)
      (vector-set! new-data (- to   1) #t)
      (puzzle new-data))))</code></pre>
<p>That's a bit of an ugly function. Unfortunately, I'm not entirely sure how it could be made better. Still, it works. By virtue of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>, we'll either get the new puzzle or <code>#f</code> if it's not a valid move.</p>
<p>Next, we take this function and map it over a puzzle in order to generate all possible next states. Something like this:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      [over (in-range 1 16)])
            (jump p from over))))</code></pre>
<p>This one though, you should see a fairly easy way to optimize. Right now, no matter how many pegs there are in a puzzle, we're going to try every neighboring pair. <code>jump</code> can deal with the weird cases, but we shouldn't have to:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- from 1))
                      [over (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- over 1)))
            (jump p from over))))</code></pre>
<p>That way, the further we get down the puzzle, the fewer cases we will check while still not duplicating <em>too</em> much of the code between the two.</p>
<p>Believe it or not... That's it. That's all we need:</p>
<pre class="scheme"><code>; Solve a puzzle using backtracking
(define (solve p)
  (cond
    [(= 1 (count p))
     (list p)]
    [else
     (let ([n (ormap solve (next p))])
       (and n (cons p n)))]))</code></pre>
<p><code>count</code> returns the number of pegs left on the current board:</p>
<pre class="scheme"><code>; Count how many pegs are left in a puzzle
(define (count p)
  (vector-length (vector-filter identity (puzzle-data p))))</code></pre>
<p>That's it. Give it any peg puzzle and it will solve it. Quickly too. On my machine, it might as well be instantaneous. So how does it work?</p>
<p>Two cases: Either we're done or we're not. If we're done, return the end state. Otherwise, we need to find a state we can move forward from. With <code>ormap</code>, we're going to try each in turn, returning the first thing that isn't <code>#f</code>. Since we're mapping <code>solve</code> (recurring) and almost making progress (<code>next</code> always has at least one less peg), we can rely on the recursion to do it's job. In this case, we'll either find a solution one step down (return that one) or not (check the next one).</p>
<p>Don't believe me? Let's check it out:</p>
<pre class="scheme"><code>&gt; (map render (solve (make-puzzle #b111111111111110)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png" /></a></p>
<p>Flip the board over and it looks like we're genius. :) Sweet.</p>
<p>That's all for today. I am working on a part two though. As a preview: If you take rotations and reflections into account, there are only four possible starting pegs (1, 2, 4, and 5). But it turns out that not all four are created equal--some are (relatively) easy to solve. Some are not.</p>
<p>If you'd like to check out the full source code (and possibly a preview for next time), you can do so on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Factor trees</title><link href="http://blog.jverkamp.com/2014/06/17/factor-trees" /><id>urn:uuid:1797c7a3-6e74-dfbc-5e52-3c2d7b9eaa14</id><updated>2014-06-17T14:00:00Z</updated><summary type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
]]></summary><content type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
<!--more-->
<p>The basic idea is straight forward enough. Each positive integer of note<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> is in one of two classes: either it is <a href="https://en.wikipedia.org/wiki/prime">Prime number</a> or a <a href="https://en.wikipedia.org/wiki/composite">Composite number</a>. For the composite numbers, there are at least two numbers <em>m</em> and <em>n</em> such that neither <em>m</em> nor <em>n</em> is 1 and <em>mn</em> equals that number. For example, 6 is composite because <em>2 * 3 = 6</em>, yet 5 is not, since the only numbers that divide it are 1 and itself. Since 5 is not composite, it only makes sense that it is prime.</p>
<p>But then, what if you have a bigger number, such as 24. You can break that into <em>4 * 6</em>. But neither of those is prime, so you can further break it into <em>(2 * 2) * (2 * 3)</em>. Finally, each of those is prime. All together, that makes up what is called a <a href="https://en.wikipedia.org/wiki/factor_tree">factor tree</a>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png" /></a></p>
<p>That's the challenge this week. Generate that tree.</p>
<p>Well, that's more than enough description. Let's get to it.</p>
<p>Basically, there's a quick (albeit not perfectly efficient) way to find factors: <a href="https://en.wikipedia.org/wiki/trial_division">trial division</a>. Basically, you loop through all of the numbers from 2 to the square root of the number (any larger and you'll find factors you've already found), trying to divide by each in turn. That though, generates this image rather than the previous:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png" /></a></p>
<p>Not quite as nice and balanced. Easily fixed though. Rather than looping from 2 up, loop from the square root down. You'll find the same factors, but you'll find the largest (and thus the most likely split) first.</p>
<p>Code:</p>
<pre class="scheme"><code>; Return a tree of the factors of n
(define (factor-tree n)
  (or
   ; Try to find the first pair of factors
   ; Start from sqrt(n) and work down to get the largest factors first
   (for/first ([i (in-range (integer-sqrt n) 1 -1)]
               #:when (zero? (remainder n i)))
     ; Factor, create a tree with that node and it's further factors
     (list n
           (factor-tree i)
           (factor-tree (quotient n i))))
   ; If for/first returns #f there are no other factors, n is prime
   n))</code></pre>
<p>The comments should be straight forward enough to explain the rest of the structure. <code>for/first</code> will return the first factor that we've found (if any) or <code>#f</code> if not (which then falls through to the next case).</p>
<p>That gives us this structure:</p>
<pre class="scheme"><code>&gt; (factor-tree 24)
'(24 (4 2 2) (6 2 3))</code></pre>
<p>It's perhaps a bit odd to read, but look at the first of each triple. 24 has factors 4 and 6. 4 has factors 2 and 2, 6 has 2 and 3. A bit larger example (formatted to make it a bit easier to read):</p>
<pre class="scheme"><code>&gt; (factor-tree 1767150)
'(1767150 (1309 17
                (77 7 11))
          (1350 (30 5 (6 2 3))
                (45 5 (9 3 3))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png" /></a></p>
<p>Speaking of which, how am I getting those nice images?</p>
<p>Well, to some extent, I'm cheating. I took the code that I'd written a while ago for the <a href="https://github.com/iu-c211/c211-libs/blob/master/c211-libs/tree.rkt">c211-lib/tree</a> library, designed to render trees. All I needed to do was rewrite the <code>match</code> to match against <code>list</code> instead of <code>tree</code>:</p>
<pre class="scheme"><code>; Render a tree structure
; Tree : (U (List Integer Tree Tree) Integer)
(define (render-factor-tree tr)
  (match tr
    ; Recursive tree, unpack the value and render subtrees
    [(list factor left right)
     (define v (text (~a factor)))
     (define l (render-factor-tree left))
     (define r (render-factor-tree right))
     ; Pin-line connects the nodes, append sets the trees side by side
     ; cb/ct-find tells the pins how to connect to the nodes (center bottom/top)
     (pin-line (pin-line (vc-append 10 v (ht-append 10 l r))
                         v cb-find
                         l ct-find)
               v cb-find
               r ct-find)]
    ; Values are directly rendered
    [prime
     (text (~a prime))]))</code></pre>
<p>The interesting parts are the functions <code>text</code> which turns text into an image, <code>pin-line</code> which draws lines between two images, and <code>vc-append</code> / <code>ht-append</code> to combine them vertically centered or horizontal aligned to the top. All together, it lets us render all sorts of nice trees:</p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 828441))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 863029))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 1048576))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png" /></a></p>
<p>And that's about it. Quick enough (even if the rendering probably took a bit more than five minutes when I first wrote it). As always, you can see the entire code for this (and most of my other small projects) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/factor-tree.rkt">factor-tree.rkt</a></p>]]></content></entry><entry><title>Call stack bracket matcher</title><link href="http://blog.jverkamp.com/2014/06/11/call-stack-bracket-matcher" /><id>urn:uuid:85b873db-f3b6-d39f-6194-e0122474be7b</id><updated>2014-06-11T14:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://programmingpraxis.com/2014/06/10/balanced-delimiters-2/">Five minute post</a> from Programming Praxis:</p>
<blockquote>
Write a function to return true/false after looking at a string. Examples of strings that pass:

<code>{}, [], (), a(b)c, abc[d], a(b)c{d[e]}</code>

Examples of strings that don’t pass:

<code>{], (], a(b]c, abc[d}, a(b)c{d[e}]</code>
</blockquote>
]]></summary><content type="html"><![CDATA[<p><a href="http://programmingpraxis.com/2014/06/10/balanced-delimiters-2/">Five minute post</a> from Programming Praxis:</p>
<blockquote>
Write a function to return true/false after looking at a string. Examples of strings that pass:

<code>{}, [], (), a(b)c, abc[d], a(b)c{d[e]}</code>

Examples of strings that don’t pass:

<code>{], (], a(b]c, abc[d}, a(b)c{d[e}]</code>
</blockquote>
<!--more-->
<p>The basic idea you have to deal with here is that you need a stack of which brackets you're matching. It's easy enough if there's only one pair, but what if you have two nested pairs:</p>
<p><code>a(b[c]d)e</code></p>
<p>Then, once you hit the opening <code>(</code>, you have to look for a <code>)</code>, but once you see the <code>[</code>, you need to see a <code>]</code> <em>first</em>, while still looking for the <code>)</code> after. Sounds like a stack for me.</p>
<p>It would be perfectly acceptable to keep a stack around as a variable and loop over the string. Heck, that's what I did in <a href="https://github.com/jpverkamp/wombat-ide/blob/master/ide/src/wombat/gui/text/BracketMatcher.java">Wombat's bracket matcher</a>. But since we're working with Scheme, let's do something a little more recursive:</p>
<pre class="scheme"><code>(define (match-brackets [matching #f])
  (define pairs '((#\( . #\)) (#\{ . #\}) (#\[ . #\])))
  (define c (read-char))
  (cond
    [(eof-object? c)            (not (not matching))]
    [(assoc c pairs)            =&gt; (λ (pair) (and (match-brackets (cdr pair))
                                                  (match-brackets matching)))]
    [(eq? c matching)           #t]
    [(member c (map cdr pairs)) #f]
    [else                       (match-brackets matching)]))</code></pre>
<p>'But what?' you might say, where is the stack? How do we remember the first bracket we're matching when we get to the second? Well that's the beauty of the stack. Easy time we see a bracket (the second case of the <code>cond</code>), we recur with the new matching character. That call will short circuit if it sees the matching bracket (the third case), a mismatched bracket (the fourth), or an early end of string (the first, only returning valid if we're in the outermost part of the loop where <code>matching</code> is <code>#f</code>).</p>
<p>And that's pretty much it. One last trick is that we also get implicit position within the string, because of the state maintained by <code>read-char</code>, so we don't even have to explicitly recur down the string. Just calling <code>match-brackets</code> will do it for us, and sequential calls (as in the second case) work as they need to.</p>
<p>Shiny!</p>
<p>Source: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/match-brackets.rkt">match-brackets.rkt</a></p>]]></content></entry><entry><title>What the (be)funge‽</title><link href="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd" /><id>urn:uuid:d4667b97-6b9a-fb0c-7c44-559a97b1f81c</id><updated>2014-06-10T14:00:00Z</updated><summary type="html"><![CDATA[<p>Here's a fun little bit of code for you:</p>
<pre class="bash"><code>55*4*v    _   v
v   &lt;&gt;:1-:^
    |:&lt;$      &lt;    ,*48 &lt;
    @"@"&gt;0"zzif"&gt;:#,_$      v
&gt;:3%!|    &gt;0"zzub"&gt;:#,_$^
     &gt;:5%!|
v "buzz"0&lt;&gt;:.           ^
         |!%5:           &lt;
&gt;:#,_   $&gt;              ^</code></pre>
<p>Gibberish you say? No! <a href="https://en.wikipedia.org/wiki/Befuge">Befunge</a>!</p>
]]></summary><content type="html"><![CDATA[<p>Here's a fun little bit of code for you:</p>
<pre class="bash"><code>55*4*v    _   v
v   &lt;&gt;:1-:^
    |:&lt;$      &lt;    ,*48 &lt;
    @"@"&gt;0"zzif"&gt;:#,_$      v
&gt;:3%!|    &gt;0"zzub"&gt;:#,_$^
     &gt;:5%!|
v "buzz"0&lt;&gt;:.           ^
         |!%5:           &lt;
&gt;:#,_   $&gt;              ^</code></pre>
<p>Gibberish you say? No! <a href="https://en.wikipedia.org/wiki/Befuge">Befunge</a>!</p>
<!--more-->
<p>More specifically:</p>
<blockquote>Befunge is a stack-based, reflective, esoteric programming language. It differs from conventional languages in that programs are arranged on a two-dimensional grid. "Arrow" instructions direct the control flow to the left, right, up or down, and loops are constructed by sending the control flow in a cycle. It has been described as "a cross between Forth and Lemmings."</blockquote>
<p>-- <a href="https://en.wikipedia.org/wiki/Wikipedia">Befunge</a></p>
<p>There's not much of a write up this time, since pretty much the entire code is the state machine that actually drives the language. We'll go ahead and assume that we have a whole suite of helper functions (see <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/befunge.rkt">GitHub</a> for details):</p>
<ul>
        <li><code>wrapped-vector-ref</code> - <code>vector-ref </code>where indexes out of bounds wrap</li>
        <li><code>wrapped-vector-set!</code> - likewise for <code>vector-set!</code></li>
        <li><code>grid-ref</code> - ref for a vector of vectors, using wrapping</li>
        <li><code>grid-set!</code> - set! for a vector of vectors</li>
        <li><code>read-befunge</code> - read a befunge program from input</li>
        <li><code>write-befunge</code> - write a befunge grid out for debugging</li>
</ul>
<p>Next, we have the state of the machine. I'll store it in a parameter, so we can access it from a number of helper functions (up in a bit):</p>
<h3>State functions</h3>
<pre class="scheme"><code>; Befunge state
(struct state (x y facing stack grid running) #:transparent #:mutable)
(define current-state (make-parameter #f))</code></pre>
<p>Next, said helpers to manipulate the stack, move the pointer, and get the current character. All of them are safe to use even if there is no current state, they just won't do anything.</p>
<pre class="scheme"><code>; Stack maniuplation. Pop 0 on an empty stack
(define (pop!)
  (when (current-state)
    (define stack (state-stack (current-state)))
    (if (null? stack)
        0
        (begin0
          (car stack)
          (set-state-stack! (current-state) (cdr stack))))))

(define (push! v)
  (when (current-state)
    (set-state-stack! (current-state) (cons v (state-stack (current-state))))))

; Move in the current direction
(define (move!)
  (when (current-state)
    (case (state-facing (current-state))
      [(right) (set-state-x! (current-state) (+ (state-x (current-state)) 1))]
      [(left)  (set-state-x! (current-state) (- (state-x (current-state)) 1))]
      [(down)  (set-state-y! (current-state) (+ (state-y (current-state)) 1))]
      [(up)    (set-state-y! (current-state) (- (state-y (current-state)) 1))])))

; Get the current character from the state
(define (grid-@"@")
  (if (current-state)
      (grid-ref (state-grid (current-state))
                (state-x (current-state))
                (state-y (current-state)))
      #\space))</code></pre>
<h3>Stepper</h3>
<p>Now it's just a literal translation of the instructions into state transitions. I'll have one function to advance the state to make it easier to make a debugging rendering function:</p>
<pre class="scheme"><code>; Advance the befunge program to the next step
(define (step!)
  (when (and (current-state) (state-running (current-state)))
    ; Decode the next instruction
    (define cmd (grid-@"@"))
    (case cmd
      ; Push this number on the stack
      [(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (push! (string-&gt;number (string cmd)))]
      ; Addition: Pop a and b, then push a+b
      ; Subtraction: Pop a and b, then push b-a
      ; Multiplication: Pop a and b, then push a*b
      ; Integer division: Pop a and b, then push b/a, rounded down. If a is zero, ask the user what result they want.[dubious – discuss]
      ; Modulo: Pop a and b, then push the remainder of the integer division of b/a. If a is zero, ask the user what result they want.[dubious – discuss]
      ; Greater than: Pop a and b, then push 1 if b&gt;a, otherwise zero.
      [(#\+ #\- #\* #\/ #\% #\`)
       (define a (pop!))
       (define b (pop!))
       (define op (cdr (assoc cmd `((#\+ . ,+)
                                    (#\- . ,-)
                                    (#\* . ,*)
                                    (#\/ . ,quotient)
                                    (#\% . ,remainder)
                                    (#\` . ,(λ (b a) (if (&gt; b a) 1 0)))))))
       (push! (op b a))]
      ; Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
      [(#\!)
       (push! (if (zero? (pop!)) 1 0))]
      ; Change direction
      [(#\&gt; #\&lt; #\^ #\v)
       (set-state-facing! (current-state) (cdr (assoc cmd `((#\&gt; . right)
                                                            (#\&lt; . left)
                                                            (#\^ . up)
                                                            (#\v . down)))))]
      ; Start moving in a random cardinal direction
      [(#\?)
       (set-state-facing! (current-state) (list-ref `(right left up down) (random 4)))]
      ; Pop a value; move right if value=0, left otherwise
      [(#\_)
       (set-state-facing! (current-state) (if (zero? (pop!)) 'right 'left))]
      ; Pop a value; move down if value=0, up otherwise
      [(#\|)
       (set-state-facing! (current-state) (if (zero? (pop!)) 'down 'up))]
      ; Start string mode: push each character's ASCII value all the way up to the next "
      ; Note: uses one fuel
      [(#\quote) ; (should be a quote character but that breaks syntax highlighting)
       (let loop ()
         (move!)
         (define c (grid-@"@"))
         (when (not (equal? c #\quote)) ; ditto
           (push! (char-&gt;integer c))
           (loop)))]
      ; Duplicate value on top of the stack
      [(#\:)
       (define v (pop!))
       (push! v)
       (push! v)]
      ; Swap two values on top of the stack
      [(#\\)
       (define a (pop!))
       (define b (pop!))
       (push! a)
       (push! b)]
      ; Pop value from the stack and discard it
      [(#\$)
       (pop!)]
      ; Pop value and output as an integer
      [(#\.)
       (display (pop!))
       (display " ")]
      ; Pop value and output as ASCII character
      [(#\,)
       (display (integer-&gt;char (pop!)))]
      ; Trampoline: Skip next cell
      [(#\#)
       (move!)]
      ; A "put" call (a way to store a value for later use).
      ; Pop y, x and v, then change the character at the position (x,y)
      ; in the program to the character with ASCII value v
      [(#\p)
       (define y (pop!))
       (define x (pop!))
       (define v (pop!))
       (grid-set! (state-grid (current-state))
                  x y
                  (with-handlers ([exn? (λ _ v)])
                    (integer-&gt;char v)))]
      ; A "get" call (a way to retrieve data in storage).
      ; Pop y and x, then push ASCII value of the character at that position in the program
      [(#\g)
       (define y (pop!))
       (define x (pop!))
       (define v (grid-@"@"))
       (push! (if (number? v) v (char-&gt;integer v)))]
      ; Ask user for a number and push it
      [(#\&)
       (display "Enter a number: ")
       (push! (read))]
      ; Ask user for a character and push its ASCII value
      [(#\~)
       (display "Enter a character: ")
       (push! (read-char))
       (newline)]
      ; End program
      [(#\@"@")
       (set-state-running! (current-state) #f)])

    (move!)))</code></pre>
<p>There are a few interesting cases:</p>
<ul>
        <li><code>#\"</code> - nested loop to read the rest of a string (counts as one 'step')</li>
        <li><code>#\#</code> - one <code>move!</code> is called here, the next at the end of the function</li>
        <li><code>#\p</code> - we're extending support out to the full <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> character set, but not every integer represents a code point, so for those store the number instead</li>
        <li><code>#\@</code> - trust that the caller will actually check the <code>state-running</code> parameter</li>
</ul>
<h3>Main loop</h3>
<p>Around that, we need a loop that just keeps calling <code>step!</code> until <code>state-running</code> is false. Something like this:</p>
<pre class="scheme"><code>; Run a befunge program
(define (run-befunge [input   (current-input-port)]
                     #:debug  [debug #f]
                     #:fuel   [fuel +inf.0])
  ; Load the grid
  (define grid
    (cond
      [(input-port? input) (read-befunge input)]
      [(string? input) (call-with-input-string input read-befunge)]
      [(vector? input) input]))

  ; Set up initial state (x y facing stack grid running)
  (parameterize ([current-state (state 0 0 'right '() grid #t)])
    (let loop ([step 0])
      (when (and (state-running (current-state))
                 (&lt; step fuel))
        (when debug
          (write-befunge (state-grid (current-state)))
          (printf "~a x ~a, ~a\nstack: ~a\n\n"
                  (state-x (current-state))
                  (state-y (current-state))
                  (state-facing (current-state))
                  (state-stack (current-state))))

        (step!)
        (loop (+ step 1))))))</code></pre>
<p>I went ahead and stuck in a debug view (which will print out the grid, cursor, and stack on each step) and a limited fuel on the case that we don't want to accidently run a program for forever.</p>
<h3>Examples</h3>
<p>And that's all we need. Let's test it with a few sample programs:</p>
<h4>Hello World (Wikipedia)</h4>
<pre class="scheme"><code>&gt; (run-befunge)
&gt;              v ; hello world
v  ,,,,,"Hello"&lt; ; source: wikipedia
&gt;48*,          v
v,,,,,,"World!"&lt;
&gt;25*,@"@"

Hello World!</code></pre>
<h4>Hello World (Wikipedia)</h4>
<pre class="scheme"><code>&gt; (run-befunge)
&gt;25*"!dlrow ,olleH":v  ; hello world v2
                 v:,_@"@" ; source: wikipedia
                 &gt;  ^

Hello, world!</code></pre>
<h4>Fizz Buzz (RosettaCode)</h4>
<pre class="scheme"><code>&gt; (run-befunge)
55*4*v    _   v            ; fizz buzz
v   &lt;&gt;:1-:^                ; source: rosettacode
    |:&lt;$      &lt;    ,*48 &lt;
    @"@"&gt;0"zzif"&gt;:#,_$      v
&gt;:3%!|    &gt;0"zzub"&gt;:#,_$^
     &gt;:5%!|
v "buzz"0&lt;&gt;:.           ^
         |!%5:           &lt;
&gt;:#,_   $&gt;              ^

1  2  fizz 4  buzz fizz 7  8  fizz buzz 11  fizz 13  14  fizzbuzz 16  17  fizz 19  buzz fizz 22  23  fizz buzz 26  fizz 28  29  fizzbuzz 31  32  fizz 34  buzz fizz 37  38  fizz buzz 41  fizz 43  44  fizzbuzz 46  47  fizz 49  buzz fizz 52  53  fizz buzz 56  fizz 58  59  fizzbuzz 61  62  fizz 64  buzz fizz 67  68  fizz buzz 71  fizz 73  74  fizzbuzz 76  77  fizz 79  buzz fizz 82  83  fizz buzz 86  fizz 88  89  fizzbuzz 91  92  fizz 94  buzz fizz 97  98  fizz buzz</code></pre>
<h4>Random digit generator (Wikipedia)</h4>
<pre class="scheme"><code>&gt; (run-befunge #:fuel 1000)
v&gt;&gt;&gt;&gt;. ; random digit generator
 12345 ; source: wikipedia
 ^?^
&gt; ? ?^
 v?v
v6789&gt;

4 3 5 7 1 8 5 1 7 3 3 2 6 3 5 8 5 1 4 9 9 2 6 4 5</code></pre>
<p>Looks pretty good from here!</p>
<h3>Pretty pretty pictures</h3>
<p>One last trick, let's do much the same that we did a <a href="http://blog.jverkamp.com/2014/05/28/quadtree-image-compression">bit ago</a> and make a rendering function:</p>
<h4>Hello World (Wikipedia)</h4>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/hello-world.gif"><img src="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/hello-world.gif" /></a></p>
<h4>Random digit generator (Wikipedia)</h4>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/random.gif"><img src="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/random.gif" /></a></p>
<h4>Fizz Buzz (RosettaCode)</h4>
<p>(Limited to 10 in interest of time)</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/fizz-buzz.gif"><img src="http://blog.jverkamp.com/2014/06/10/what-the-befunge%e2%80%bd/fizz-buzz.gif" /></a></p>
<p>And that's it. Check out the full source on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/befunge.rkt">befunge.rkt</a></p>]]></content></entry><entry><title>Braille unicode pixelation</title><link href="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation" /><id>urn:uuid:b9f389dc-885f-d219-9803-66fd678b9a6a</id><updated>2014-05-30T14:00:00Z</updated><summary type="html"><![CDATA[<p>What would you do if you were on a machine that had no higher level graphics, but you still wanted to display images?</p>
]]></summary><content type="html"><![CDATA[<p>What would you do if you were on a machine that had no higher level graphics, but you still wanted to display images?</p>
<!--more-->
<p>One option is <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII art</a>:</p>
<pre> _____________
< Hello world >
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</pre>
<p><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>Another is using 'denser' characters (such as @/&amp;) for darker points and less dense characters (' or even a space) for lighter ones, such as the case with <a href="http://aa-project.sourceforge.net/aalib/">AALib</a>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/AAlib-zebra1.png"><img src="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/AAlib-zebra1.png" /></a><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span></p>
<p>But what if we want to get really exotic? Here's a <del>crazy</del> neat idea based on <a href="https://github.com/asciimoo/drawille/">a Python library</a> that came up on <a href="http://www.reddit.com/r/programming/comments/263opn/drawille_pixel_graphics_in_a_terminal_using/">/r/programming</a> a bit back: <a href="https://en.wikipedia.org/wiki/Braille_pixel graphics">Braille</a>.</p>
<p>Basically, we have a set of Unicode codepoints that are assigned to Braille (0x2800-0x28FF), known as <a href="https://en.wikipedia.org/wiki/Braille_Patterns">Braille Patterns</a>. With the extended set, there exists a character for every possible combination of up to 8 dots in a 2x4 grid. There's one main oddity, in that the dots aren't ordered in a purely row major or column major order. Instead, they're more like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/braille-dot-numbering.png"><img src="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/braille-dot-numbering.png" /></a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>
<p>The reason for this is mostly historical. Originally, Braille characters had 6 dots. The additional two lowest dots were added later, and thus don't fit with the original numbering.</p>
<p>In any case, the above ordering gives us a way to encode a Braille character as a bitstring:</p>
<pre>○● 14
●● 25
○○ 36
●○ 78
=
○●○●●○●○
12345678
=
01011010
=>
90 / #x5a
=>
#x285a</pre>
<pre class="scheme"><code>&gt; (integer-&gt;char #x285a)
#\⡚</code></pre>
<p>So now we have a game plan: take the pixels of an image and treat each group of 2x4 pixels as a block. For each block, encode as binary using the Braille ordering. Convert that number to a Unicode code point and get the character. Loop over all of the blocks in the image and we should be good.</p>
<p>Something like this:</p>
<pre class="scheme"><code>; Convert a flomap into a dot matrix string, using Braille for the pixels
(define (flomap-&gt;braille fm #:threshold [threshold 0.75])
  ; Braille characters are two dots wide and four tall
  (define-values (width height) (flomap-size fm))
  (define b-width  (ceiling (/ width 2)))
  (define b-height (ceiling (/ height 4)))

  ; Return if the grayscale (simple average) at a point is greater than a threshold
  ; flomap-ref* is already 'safe' in that out of bounds pixels are always 0
  (define (bit x y)
    (define c (flomap-ref* fm x y))
    (define g (/ (flvector-sum c) (flvector-length c)))
    (&gt; g threshold))

  ; Load each line directly to a string, join with newlines
  (string-join
   (for/list ([b-y (in-range b-height)])
     (list-&gt;string
      (for/list ([b-x (in-range b-width)])
        (integer-&gt;char
         ; The Braille unicode range is #x2800 - #x28FF, where each dot is one of 8 bits
         (+ #x2800
            ; Because Braille was originally only 6 dots, the order of bits is:
            ; 1 4
            ; 2 5
            ; 3 6
            ; 7 8
            (for/sum ([xΔ  (in-list '(0 0 0 1  1  1  0   1))]
                      [yΔ  (in-list '(0 1 2 0  1  2  3   3))]
                      [mul (in-list '(1 2 4 8 16 32 64 128))])
              (* mul (if (bit (+ (* 2 b-x) xΔ) (+ (* 4 b-y) yΔ)) 1 0))))))))
   "\n"))</code></pre>
<p>That crazy line / <code>for/sum</code> right at the end does most of the work, actually doing the binary conversion. Basically, the <code>bit</code> function gets a thresholded pixel out of the image (using the fact that <code>flomap-ref*</code> actually does bounds checking for us, return 0 for out of bounds pixels). We use that and some bit shifting (the <code>mul</code> variable) to get an offset than add it to the #x2800 constant.</p>
<p>Other than that, we have some boilerplate to form a string. But that's all we need:</p>
<pre class="scheme"><code>&gt; (display (flomap-&gt;braille (read-flomap "kitten.jpg") #:threshold 0.8))</code></pre>
<pre>⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠉⠉⠉⠉⠉⠉⠁⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠘⠻⢾⡀⠀⣠⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠛⠛⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠙⢿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠈⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣾⣦⣦⢀⡀⢀⢠⡀⢀⣀⢠⣴⣄⣀⣤⢀⢰⣟⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿</pre>
<p>(Unfortunately, you do have to do some amount of hand tuning for the threshold...)</p>
<p>Or how about those entirely too cute mascots for a animated franchise:</p>
<pre class="scheme"><code>&gt; (display (flomap-&gt;braille (read-flomap "minion.jpg") #:threshold 0.6))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/minion.txt.png"><img src="http://blog.jverkamp.com/2014/05/30/braille-unicode-pixelation/minion.txt.png" /></a></p>
<p>And that's all there is to it. It's wicked fast too (honestly, the actual printing is the slowest part by far). It might be interesting to actually hook this up as a video driver or the like and see if you could actually play a game.</p>
<p>Still, that's good for a day. As always, the code is on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/braille-images.rkt">braille-images.rkt</a>. Enjoy!</p>]]></content></entry></feed>