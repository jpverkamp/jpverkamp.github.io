<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-08-23T18:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>Ludum Dare 30: 24 hours</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours" /><id>urn:uuid:37f85de8-ca29-d5a8-2c0f-d57f53b84283</id><updated>2014-08-23T18:00:00Z</updated><summary type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
]]></summary><content type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
<!--more-->
<p>Well, it turns out that the solution wasn't that bad. Rather than having a bunch of threads running around, I've just put the entire thing into lockstep. Now, we go through the entire sequence (sand falls, swaps happen, rendering happens, move tiles) once ever frame, in that order. It's a bit more expensive when it comes to performance, but really not that much, since technically JavaScript doesn't do more than one thing at a time anyways.</p>
<p>In exchange though, the game is playing great:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png" /></a></p>
<p>Another thing that I did was to do some styling, converting the game from a big mess of an HTML page into a nice layered style that all fits within the 600x400 game area that I've set aside (I doubt I'll make that changeable, although it shouldn't be hard). Specifically:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png" /></a></p>
<p>If you click options, these fade in (jQuery transitions are awesome for this):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png" /></a></p>
<p>If you click play, all of the button and options fading out, taking you into the game:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png" /></a></p>
<p>At the end of the game (the timer is in the bottom right, set to a static 1 minute at the moment), you get the new scoring screen. I think I worked about 2 hours on this, which sounds crazy, but I think the effect is pretty awesome:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png" /></a></p>
<p>You can't see it in the screenshot there, but it will go through each player one by one, scoring the region from bottom to top, counting up each kind of sand individually. That should make scoring modes much easier if/when I add more options. I can just do things like discount (or even count negative) your own sand, or only count it.</p>
<p>And finally, once it's done counting:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png" /></a></p>
<p>I'd like to have some sort of background motion going on both here and during the opening menu. Something like having the tiles bounce around using some sort of AI. Speaking of which, here is a tentative feature list that I'd like to see in the next 24 hours (in no particular order):</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Pending the first, AI players playing in the background, periodically resetting before the game has started and between games</li>
  <li>Music and/or sound effects; of course with options to turn those on and off</li>
  <li>Some sort of high score menu, probably not live (although I certainly could)</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<p>I think that's about it. If you have any ideas, I'd love to hear them. There's not much (well, any) code this time, since nothing major has changed (other than refactoring). It's pretty much all tweaks. If you'd like to see the entire source (warning: ugly, bit getting a little better), it's still right here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Demo time!</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Hints of a game</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game" /><id>urn:uuid:7e16e7ce-b97f-2d28-ba95-ea26c1b8a027</id><updated>2014-08-23T12:00:00Z</updated><summary type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
]]></summary><content type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png" /></a></p>
<p>(I'll include a demo at the bottom of the post)</p>
<p>Basically, I went with allowing each box to be controlled individually by the keyboard. There will be some problems with having that many people on the keyboard at once, but we'll deal with that later (if we can).</p>
<p>One additional thing I wanted (and mostly figured out) is somewhat 'loose' controls. Basically, rather than explicitly dealing with moving only when a key is down, we'll accelerate when the key is down, preserving velocity even after  keys are raised. There will be some small amount of friction as well, to make sure that eventually pieces will slow down.</p>
<p>It's actually not too hard to implement a system like this:</p>
<p>First, load in the keybindings from the interface you can see in the screenshot above:</p>
<pre class="javascript"><code>// Load key bindings
var loadKeyBindings = function() {
  keys = {};

  console.log('Loading key bindings...');

  $('#controls table').each(function(i, eli) {
    var player = parseInt($(eli).attr('data-player'));

    console.log('loading controls for player ' + player);

    $(eli).find('input').each(function(j, elj) {
      var command = $(elj).attr('name');
      var key = $(elj).val();

      keys[key] = [player, command, false];
    });
  });
};</code></pre>
<p>This will put everything into the <code>key</code> array, indexed by key name and storing the player it refers to, the direction you are going (one of <code>left</code>, <code>right</code>, <code>up</code>, or <code>down</code>), and if that key is currently active (pressed down). If I can, I may add additional key bindings (such as rotation or powerups), otherwise, that's pretty good for the moment.</p>
<p>Next, we'll add a function to tell when keys are active:</p>
<pre class="javascript"><code>var onkey = function(event) {
  switch (event.keyCode) {
    case  37: key = 'LEFT'; break;
    case  38: key = 'UP'; break;
    case  39: key = 'RIGHT'; break;
    case  40: key = 'DOWN'; break;
    case  97: key = 'NUM1'; break;
    case  98: key = 'NUM2'; break;
    case  99: key = 'NUM3'; break;
    case 100: key = 'NUM4'; break;
    case 101: key = 'NUM5'; break;
    case 102: key = 'NUM6'; break;
    case 103: key = 'NUM7'; break;
    case 104: key = 'NUM8'; break;
    case 105: key = 'NUM9'; break;
    default: key = String.fromCharCode(event.keyCode).toUpperCase();
  }

  if (key in keys) {
    if (event.type == 'keydown') {
      keys[key][2] = true;
    } else if (event.type == 'keyup') {
      keys[key][2] = false;
    }
  }
};</code></pre>
<p>Longer than I wanted, but it correctly deals with both the numpad and arrow keys, which is kind of necessary if you want to support 4 human players all at the same time. Perhaps I'll implement AIs, but until I do, we're going to have to allow for a bunch of players...</p>
<p>Okay, so what do we do with all of this information? Well, just like before, we have a <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function(event) {
  $.each(keys, function(i, el) {
    var player = el[0];
    var command = el[1];
    var active = el[2];

    $game = $('#tiles');
    $tile = $('#tiles *[data-player="' + player + '"]');

    // Update velocity
    ...

    // Use friction to slow each box down over time
    ...

    // Cap velocity so we don't go too fast
    ...

    // Update the current position based on velocity
    ...

    // Bounce off the edges of the screen
    ...

    // Finally, update the position
    $tile.css({'top': top, 'left': left});
  });

  if (running) {
    setTimeout(tick, 1000/30);
  }
};</code></pre>
<p>Oof. That's a heck of a function. Luckily, the individual parts aren't <em>that</em> bad. First, we want to update the velocity. This is where the <code>active</code> parameter (the third in each key definition) comes into play:</p>
<pre class="javascript"><code>// Update velocity
if (active) {
  if (command == 'up') {
    vel[player][1] -= PER_TICK_ACCELERATION;
  } else if (command == 'down') {
    vel[player][1] += PER_TICK_ACCELERATION;
  } else if (command == 'left') {
    vel[player][0] -= PER_TICK_ACCELERATION;
  } else if (command == 'right') {
    vel[player][0] += PER_TICK_ACCELERATION;
  }
}</code></pre>
<p>That's simple enough. As before, we have to decide that <code>up</code> and <code>down</code> are inverted (they almost always are when it comes to computers), but once you've decided that's easy enough.</p>
<p>Now, outside of that black, the next thing we'll do is apply friction. This way the boxes will slow down over time, forcing players both to pay attention and to let them bounce around like madmen.</p>
<pre class="javascript"><code>// Use friction to slow each box down over time
// If we're close enough to zero that friction will accelerate us, just stop
if (Math.abs(vel[player][0]) &lt; PER_TICK_FRICTION) {
  vel[player][0] = 0;
} else {
  vel[player][0] += (vel[player][0] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

if (Math.abs(vel[player][1]) &lt; PER_TICK_FRICTION) {
  vel[player][1] = 0;
} else {
  vel[player][1] += (vel[player][1] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

// Cap velcity so we don't go too fast
vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));</code></pre>
<p>Also at the end there, we make sure we don't keep accelerating indefinitely. That both helps keep the game a little easier to play and prevents edge cases (such as moving further in one tick than we're allowed).</p>
<p>Next, we can finally update the position:</p>
<pre class="javascript"><code>// Update the current position based on velocity
var left = $tile[0].offsetLeft + vel[player][0];
var top = $tile[0].offsetTop + vel[player][1];

// Bounce off the edges of the screen
if (left &lt; 0) {
  left = 0;
  vel[player][0] = Math.abs(vel[player][0]);
} else if (left &gt; $game.width() - $tile.width()) {
  left = $game.width() - $tile.width();
  vel[player][0] = -1 * Math.abs(vel[player][0]);
}

if (top &lt; 0) {
  top = 0;
  vel[player][1] = Math.abs(vel[player][1]);
} else if (top &gt; $game.height() - $tile.height()) {
  top =  $game.height() - $tile.height();
  vel[player][1] = -1 * Math.abs(vel[player][1]);
}</code></pre>
<p>Once again, we want to clip the positions. This time though, we're actually going to use the velocities we have rather than zeroing them out. Instead: bounce! It's nice, because it makes the game feel more 'realistic' (for some definitions of the word).</p>
<p>And that's about it. With that, we can have the boxes moving around and interacting as they did last night. We're actually starting to get a game going here. One other tweak is the control code:</p>
<pre class="javascript"><code>var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec &gt; 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}</code></pre>
<p>Technically, it's not a gameloop, since everything is done asynchronously via <code>setTimeout</code> (and make <strong>absolutely sure</strong> that you don't use <code>setInterval</code>...), but it's close enough. What this does give us though is a strict time before the game ends. Otherwise, the boxes will eventually fill up, and where's the fun in that? (Although that might be an interesting alternative end condition).</p>
<p>After that, all I have to figure out is scoring. And I have another 6 hours until the one day mark. If I can make it by then, I'll feel pretty good--and can use all of the rest of the time for polish. I'm thinking some simple music, sound effects, a title screen (initial letters in sand?). Of course, I still have to figure out the scoring algorithm..</p>
<p>Same as yesterday, the entire source (warning: still ugly) if available on GitHub: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<hr />
<p>Demo:</p>
<style>
#controls table {
  border: 1px solid black;
  display: inline-block;
  margin: 1em;
  padding: 0.5em;
  border-radius: 0.5em;

}

#controls table td {
  padding: 0.1em;
}

#controls table td:first-child {
  text-align: right;
}

#controls table input {
  width: 50px;
  text-align: center;
}

#tiles {
  position: relative;
  width: 600px;
  height: 400px;
  background: black;
  border: 1px solid black;
}

#tiles canvas {
  position: absolute;
  border: 1px solid black;
}

#tiles canvas[data-player="0"] { border: 1px solid blue; }
#tiles canvas[data-player="1"] { border: 1px solid red; }
#tiles canvas[data-player="2"] { border: 1px solid green; }
#tiles canvas[data-player="3"] { border: 1px solid hotPink; }

#tiles #countdown {
  color: white;
}
</style>
<script>
function Tiles() {
  var running = false;
  var allData = {};
  var ordering = [];

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  // Make a 2D array initialized all to a given valu
  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  // Update the given grid
  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  // Animate a given frame
  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;
      var imageData = frame_ctx.createImageData(width, height);

      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // Bail out if we haven't loaded the data yet
              if (!(frameIndex in allData && otherIndex in allData)) {
                return;
              }

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                    a = 0;
                  } else if (data[x][y] == 1) {
                    b = 255;
                  } else if (data[x][y] == 2) {
                    r = 255;
                  } else if (data[x][y] == 3) {
                    g = 255;
                  } else if (data[x][y] == 4) {
                    r = 246;
                    g = 96;
                    b = 171;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (running) {
              setTimeout(tick, 1000/60);
          }
      }
      tick();
  };

  this.run = function() {
    running = true;
    $('canvas').each(animate);
  };

  this.stop = function() {
    running = false;
  };
};

function Controls() {
  var keys = {};
  var running = false;
  var PER_TICK_ACCELERATION = 0.1;
  var PER_TICK_FRICTION = 0.01;
  var VELOCITY_CAP = 10;

  var vel = {};

  // Load key bindings
  var loadKeyBindings = function() {
    keys = {};

    console.log('Loading key bindings...');

    $('#controls table').each(function(i, eli) {
      var player = parseInt($(eli).attr('data-player'));

      console.log('loading controls for player ' + player);

      $(eli).find('input').each(function(j, elj) {
        var command = $(elj).attr('name');
        var key = $(elj).val();

        keys[key] = [player, command, false];
      });
    });
  };

  var onkey = function(event) {
    switch (event.keyCode) {
      case  37: key = 'LEFT'; break;
      case  38: key = 'UP'; break;
      case  39: key = 'RIGHT'; break;
      case  40: key = 'DOWN'; break;
      case  97: key = 'NUM1'; break;
      case  98: key = 'NUM2'; break;
      case  99: key = 'NUM3'; break;
      case 100: key = 'NUM4'; break;
      case 101: key = 'NUM5'; break;
      case 102: key = 'NUM6'; break;
      case 103: key = 'NUM7'; break;
      case 104: key = 'NUM8'; break;
      case 105: key = 'NUM9'; break;
      default: key = String.fromCharCode(event.keyCode).toUpperCase();
    }

    if (key in keys) {
      if (event.type == 'keydown') {
        keys[key][2] = true;
      } else if (event.type == 'keyup') {
        keys[key][2] = false;
      }
    }
  };

  var tick = function(event) {
    $.each(keys, function(i, el) {
      var player = el[0];
      var command = el[1];
      var active = el[2];

      $game = $('#tiles');
      $tile = $('#tiles *[data-player="' + player + '"]');

      // Update velocity
      if (active) {
        if (command == 'up') {
          vel[player][1] -= PER_TICK_ACCELERATION;
        } else if (command == 'down') {
          vel[player][1] += PER_TICK_ACCELERATION;
        } else if (command == 'left') {
          vel[player][0] -= PER_TICK_ACCELERATION;
        } else if (command == 'right') {
          vel[player][0] += PER_TICK_ACCELERATION;
        }
      }

      // Use friction to slow each box down over time
      // If we're close enough to zero that friction will accelerate us, just stop
      if (Math.abs(vel[player][0]) < PER_TICK_FRICTION) {
        vel[player][0] = 0;
      } else {
        vel[player][0] += (vel[player][0] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      if (Math.abs(vel[player][1]) < PER_TICK_FRICTION) {
        vel[player][1] = 0;
      } else {
        vel[player][1] += (vel[player][1] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      // Cap velocity so we don't go too fast
      vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
      vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));

      // Update the current position based on velocity
      var left = $tile[0].offsetLeft + vel[player][0];
      var top = $tile[0].offsetTop + vel[player][1];

      // Bounce off the edges of the screen
      if (left < 0) {
        left = 0;
        vel[player][0] = Math.abs(vel[player][0]);
      } else if (left > $game.width() - $tile.width()) {
        left = $game.width() - $tile.width();
        vel[player][0] = -1 * Math.abs(vel[player][0]);
      }

      if (top < 0) {
        top = 0;
        vel[player][1] = Math.abs(vel[player][1]);
      } else if (top > $game.height() - $tile.height()) {
        top =  $game.height() - $tile.height();
        vel[player][1] = -1 * Math.abs(vel[player][1]);
      }

      // Finally, update the position
      $tile.css({'top': top, 'left': left});
    });

    if (running) {
      setTimeout(tick, 1000/30);
    }
  };

  this.run = function() {
    // Reload keybindings in case they've changed
    loadKeyBindings();

    // Initialize velocities to zero
    $game = $('#tiles');
    $('#tiles canvas').each(function(i, eli) {
      vel[i] = [0, 0];
      $(eli).css({
        top: Math.random() * ($game.height() - $(eli).height()),
        left: Math.random() * ($game.width() - $(eli).width())
      });
    });

    // Add keybindings, we can use the same function since it can check type
    $(document).unbind('keydown').bind('keydown', onkey);
    $(document).unbind('keyup').bind('keyup', onkey);

    running = true;
    tick();
  }

  this.stop = function() {
    running = false;

    $(document).unbind('keydown');
    $(document).unbind('keyup');
  }
};

var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec > 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}
</script>
<div class="table" id="controls">
  <table data-player="0">
    <tr><td colspan="2">Player 1 - Blue</tr>
    <tr><td>Up</td><td><input name="up" value="W"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="A"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="D"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="S"></input></td></tr>
  </table>

  <table data-player="1">
    <tr><td colspan="2">Player 2 - Red</tr>
    <tr><td>Up</td><td><input name="up" value="I"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="J"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="L"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="K"></input></td></tr>
  </table>

  <table data-player="2">
    <tr><td colspan="2">Player 3 - Green</tr>
    <tr><td>Up</td><td><input name="up" value="UP"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="LEFT"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="RIGHT"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="DOWN"></input></td></tr>
  </table>

  <table data-player="3">
    <tr><td colspan="2">Player 4 - Pink</tr>
    <tr><td>Up</td><td><input name="up" value="NUM8"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="NUM4"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="NUM6"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="NUM2"></input></td></tr>
  </table>
</div>
<div>
  [ <a href="javascript:run()">Run!</a> ]
  [ <a href="javascript:stop()">Stop!</a> ]
</div>
<div width="600" height="400">
  <div id="tiles">
    <p id="countdown"></p>
    <canvas data-player="0" width="100" height="100"></canvas>
    <canvas data-player="1" width="100" height="100"></canvas>
    <canvas data-player="2" width="100" height="100"></canvas>
    <canvas data-player="3" width="100" height="100"></canvas>
  </div>
</div>
<hr />
<p>I'm sure there are bugs... And I'm working on it right at the moment. If you have any questions or comments though, feel free to drop me a line below.</p>]]></content></entry><entry><title>Ludum Dare 30: Sandbox Battle</title><link href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle" /><id>urn:uuid:60fce17b-2d64-c87b-a259-90aa26aa5803</id><updated>2014-08-22T23:00:00Z</updated><summary type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
]]></summary><content type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
<!--more-->
<p>The theme this time is <a href="http://www.ludumdare.com/compo/2014/08/16/ludum-dare-30-theme-voting-begins/">Connected Worlds</a>. I like that a lot more than many of the previous themes, so let's see what ideas we can come up with.</p>
<p>Taking about an hour at the start of the compo to both work out and think, I ended up basically going in two directions:</p>
<ul>
  <li>A <a href="https://en.wikipedia.org/wiki/falling_sand">falling sand</a> style game, only with discrete 'bubbles' with different particles / physics</li>
  <li>A <a href="https://en.wikipedia.org/wiki/Platform_game#Puzzle_platformers">puzzle platformer</a> based around portals that split you into two realities you play at the same time</li>
</ul>
<p>Of the two, the second has the advantages of 1) actually sounding like a game (that's always been my problem with falling sand style simulations) and 2) being much easier to code. I've worked on falling sand style games before (<a href="http://blog.jverkamp.com/category/programming/by-project/games/sandbox">Sandbox</a>) and they take a lot of tuning to get reasonable performance. Certainly worth doing... but not the best idea for a 48 hour time window.</p>
<p>So of course I'm going with option A. :)</p>
<p>About 6 hours in, and so far this is what I have:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png" /></a></p>
<hr />
<p>Real-life demo! (Click run, then try dragging the boxes around)</p>
<canvas id="frame1" width="100" height="100"></canvas>
<canvas id="frame2" width="100" height="100"></canvas>
<canvas id="frame3" width="100" height="100"></canvas>
<p><button id="runGame" type="button">Run!</button></p>
<style>
canvas { border: 1px solid black; }
</style>
<script>
$(function() {
  var maxFrames = 10000;

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  var ordering = [];
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  var allData = {};

  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;

      var imageData = frame_ctx.createImageData(width, height);

      var count = 0;
      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              /*
              // We only want to run this once, so only for the frame on top
              // If we see the frame first, we're golden (break out of the loop)
              // If we see the other first, we're in the wrong order (stop processing)
              for (var i = 0; i < ordering.length; i++) {
                  if (ordering[i] == frameIndex) break;
                  if (ordering[i] == otherIndex) return;
              }
              */

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                      a = 0;
                  } else if (data[x][y] == 1) {
                      b = 255;
                  } else if (data[x][y] == 2) {
                      r = 255;
                  } else if (data[x][y] == 3) {
                      g = 255;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (count < maxFrames) {
              count += 1;
              setTimeout(tick, 0);
          } else {
              end = new Date().getTime();
              console.log(
                  maxFrames + ' frames in ' +
                  (end - start) + ' ms = ' +
                  (maxFrames / ((end - start) / 1000)) + ' fps'
              );
          }
      }
      tick();
  }

  $('#runGame').click(function() {
    console.log('starting...');
    $('canvas').each(animate);
  });
});
</script>
<p>You can click and drag the blocks around and the sand will from from box to box. At first, I was trying to figure out goals where you could--for example--use water in one box to put out fire in another. But right at the end, I had an even better idea (hopefully not just the long day talking): SANDBOX BATTLE! Basically, some sort of multiplayer / AI madness, where you are trying to steal the other box's sand before they can steal yours... I'm going to have to think about that...</p>
<p>Anyways, here are some of the interesting bits (in JavaScript for once!):</p>
<p>First, the core of the whole thing, the update function:</p>
<pre class="javascript"><code>var update = function(data, buffer, width, height) {
    // Clear the buffer
    for (var x = 0; x &lt; width; x++) {
        for (var y = 0; y &lt; height; y++) {
            buffer[x][y] = 0;
        }
    }

    // Update the buffer with falling cells
    var r = 0, xt = 0, yt = 0;
    for (var y = height - 1; y &gt;= 0; y--) {
        for (var x = 0; x &lt; width; x++) {
            // Skip empty cells
            if (data[x][y] == 0) continue;
            xt = x;
            yt = y;

            // Determine which way it's going to fall
            r = Math.random();
            if (r &lt; 0.5) { // Straight down
                if (y &gt; 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
            } else if (r &lt; 0.7) { // Down left
                if (x &gt; 0 && y &gt; 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
            } else if (r &lt; 0.9) { // Down right
                if (x &lt; width - 1 && y &gt; 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
            } else if (r &lt; 0.95) { // Straight left
                if (x &gt; 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
            } else { // Straight right
                if (x &lt; width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
            }

            if (data[xt][yt] != 0) { xt = x; yt = y; }

            // Update the buffer
            buffer[xt][yt] = data[x][y];
        }
    }
}</code></pre>
<p>The basic idea is two have two data arrays: <code>data</code> and <code>buffer</code>. We will trust the rest of the code to swap them the other way and spend all of the effort in this function creating buffer as the next frame. Specifically, we're going to loop through all of the tiles from bottom to top (because sand falls) then left to right. For each particle (non-<code>0</code> space), there are five possibilities:</p>
<ul>
  <li>50% chance of trying to move directly down</li>
  <li>20% chance of trying to move down and left, 20% down and right</li>
  <li>5% chance each of moving directly left or right</li>
</ul>
<p>Sounds pretty good. It's the same sort of code I've written rather a lot of times... This time around, we're not going to do any optimizations. We'll deal with that later if we have time.</p>
<p>Next, we have to deal with the <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function() {
    // Debug: Add a pixel
    data[width / 2][height - 1] = frameIndex + 1;

    // Update from data to buffer; swap the arrays for the next iteration
    update(data, buffer, width, height);
    temp = data;
    data = buffer;
    buffer = temp;

    // Detect overlapping buffers, if so swap randomly
    ...

    // Render to the image data
    ...
}</code></pre>
<p>So we start with pixels dumping in from the ceiling and we update the world. We have space for two more functions: copying between worlds (pretty much the core idea of the game :)) and rendering. Let's look at the latter first.</p>
<p>In order to render quickly, I'm going to use the <code>canvas</code> element's context's <code>createImageData</code> and <code>putImageData</code> to write data directly into the image. That will be a lot faster than setting pixels individually, especially since we're going to be changing rather a lot of pixels at the indiviual level. So... rendering:</p>
<pre class="javascript"><code>// Render to the image data
for (var y = 0; y &lt; height; y++) {
    for (var x = 0; x &lt; width; x++) {
        i = x + (height - y) * width;

        r = g = b = 0;
        a = 255;

        if (data[x][y] == 0) {
            a = 0;
        } else if (data[x][y] == 1) {
            b = 255;
        } else if (data[x][y] == 2) {
            r = 255;
        } else if (data[x][y] == 3) {
            g = 255;
        }

        imageData.data[i * 4 + 0] = r;
        imageData.data[i * 4 + 1] = g;
        imageData.data[i * 4 + 2] = b;
        imageData.data[i * 4 + 3] = a;

    }
}

// Copy back to the GUI
frame_ctx.putImageData(imageData, 0, 0);</code></pre>
<p>We've previously set up <code>imageData</code> using <code>createImageData</code> (we only have to do this once and then can reuse that same memory) and the <code>frame_ctx</code> as the context object of the canvas.</p>
<p>One interesting part that I changed right before this writeup was the transparency of empty cells. That way the page will shine through. I'm not entirely sure that's what I want, but it's an interesting effect, so I'll leave it for the time being.</p>
<p>And then last but not least, the combination function. This one is honestly kind of weird:</p>
<pre class="javascript"><code>// Detect overlapping buffers, if so swap randomly
$('canvas').each(function(otherIndex, other) {
    // If we're comparing to ourself, we'll always overlap, skip
    if (frame == other) return;

    // If the two canvases don't overlap, don't look at them
    var frameBounds = frame.getBoundingClientRect();
    var otherBounds = other.getBoundingClientRect();
    if (frameBounds.right &lt; otherBounds.left ||
        frameBounds.left &gt; otherBounds.right ||
        frameBounds.bottom &lt; otherBounds.top ||
        frameBounds.top &gt; otherBounds.bottom) {
        return;
    }

    // We only want this once, so give priority to whichever frame is 'lower' on the screen
    if (frameBounds.top &lt; otherBounds.top) return;

    // TODO: Find the actual offset rather than looping over an entire image
    var otherX, otherY, temp;
    for (var frameY = 0; frameY &lt; height; frameY++) {
        for (var frameX = 0; frameX &lt; width; frameX++) {
            otherX = frameBounds.left - otherBounds.left + frameX;
            otherY = otherBounds.top - frameBounds.top + frameY;

            if (0 &lt;= otherX && otherX &lt; width && 0 &lt;= otherY && otherY &lt; height) {
                if (allData[frameIndex][frameX][frameY] == 0 ) {
                    temp = allData[frameIndex][frameX][frameY];
                    allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                    allData[otherIndex][otherX][otherY] = temp;
                }
            }
        }
    }
});</code></pre>
<p>Theoretically the comments should be enough, but if not, the basic idea is to first find if we have two overlapping regions (the <code>frameIndex</code> and <code>otherIndex</code> will make more sense if you look at the full code). If you have one, then loop over the shared region and copy pixels to the lower of the two boxes. I'm going to have to figure out a better rule for that. I tried using z-index, but that didn't work much better... Essentially, we need to be able to move particles from one box to another, but we need to be careful to neither lose nor duplicate particles. There are a number of weird edges cases (as I'm sure you've found if you played with the simulation).</p>
<p>And, that's it. I have until 5pm Pacific on Sunday. I'm actually feeling pretty good about this. The best plan is to have a playable game after 24 hours and to spend the second day on polish. I'm not sure if I'll quite hit that... but maybe!</p>
<p>If you'd like to see the entire source (warning: ugly) and potentially spoilers, check it out here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>]]></content></entry><entry><title>Minimal palindromic base</title><link href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base" /><id>urn:uuid:dccae1c2-8231-ed96-21a1-54145cd10b47</id><updated>2014-08-13T17:00:00Z</updated><summary type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
<!--more-->
<p>More specifically, consider the number 15:</p>
<div>$$15_{10} = 1111_2 = 120_3 = 33_4 = 30_5 = 23_6 = 21_7 = 17_8 = 16_9$$</div>
<div>$$15_{10} = 14_{11} = 13_{12} = 12_{13} = 11_{14} = 10_{15}$$</div>
<p>In this case, <code>2</code> is our golden number, since <code>1111</code> is a palindrome. But if it wasn't, 14 is the next case, with <code>11</code>.</p>
<p>So, what do we need? Well, first we want a generic way to convert bases. We could use different characters up to base 64, but we'll eventually get beyond that. So instead, we'll use lists of digits, each of which can be any integer:</p>
<pre class="scheme"><code>; Convert a decimal number n to base b
(define (rebase n b)
  (let loop ([n n] [ls '()])
     (if (= n 0)
        ls
        (loop (quotient n b)
              (cons (remainder n b) ls)))))</code></pre>
<pre class="scheme"><code>&gt; (rebase 15 2)
'(1 1 1 1)

&gt; (rebase 15 5)
'(3 0)

&gt; (rebase 15 10)
'(1 5)

&gt; (rebase 15 14)
'(1 1)</code></pre>
<p>Looks good. Next, we'll use a macro we've often used before: <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>. It's perfect for our uses, since it will return the first value that is non-<code>#f</code>. In this case, our base:</p>
<pre class="scheme"><code>; Find the minimal base b such that n in base b is a palindrome
(define (minimal-palindromic-base n)
  (for/first ([b (in-naturals 2)]
              #:when (let ([nb (rebase n b)])
                       (equal? nb (reverse nb))))
    b))</code></pre>
<p>Bam. Let's try a few:</p>
<pre class="scheme"><code>&gt; (minimal-palindromic-base 15)
2

&gt; (minimal-palindromic-base 1234)
22

&gt; (rebase 1234 22)
'(2 12 2)

&gt; (minimal-palindromic-base 8675309)
8675308</code></pre>
<p>Huh. I think <a href="https://en.wikipedia.org/wiki/867-5309/Jenny">Jenny</a> has a secret. :)</p>
<p>That's pretty much it for the puzzle as stated, but there are still a few things that we can do. For example, we've only seen small examples. What if we want to find the number with the largest minimal palindromic base:</p>
<pre class="scheme"><code>; Find the number n which has the largest palindromic base
(define (maximal-minimal-palindromic-base n-min n-max)
  (for/fold ([b -1] [n #f]) ([i (in-range n-min (+ n-max 1))])
    (define mpb (minimal-palindromic-base i))
    (if (&gt; i b)
        (values mpb i)
        (values b   n))))</code></pre>
<p>I may or may not have just wanted an excuse to use a crazy long function name. :)</p>
<p>Give it a try:</p>
<pre class="scheme"><code>&gt; (maximal-minimal-palindromic-base 100 200)
7
200

&gt; (rebase 200 7)
'(4 0 4)</code></pre>
<p>Error, <code>maximal-minimal-palindromic-base</code> not found!</p>
<p>Okay, more seriously, what does that even look like? Let's <code><a href="http://docs.racket-lang.org/search/index.html?q=plot">plot</a></code>!</p>
<pre class="scheme"><code>(require plot)

; Plot a whole range of minimal palindromic bases
(define (plot-minimal-palindromic-bases n-min n-max)
  (plot (lines (for/list ([i (in-range n-min (+ n-max 1))])
                 (vector i (minimal-palindromic-base i)))
               #:color 6
               #:label "minimal palindromic base")))</code></pre>
<p>Basically, we're going to draw a chart relating each number to it's minimal palindromic base.</p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 100)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png" /></a></p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 1000)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png" /></a></p>
<p>Looks like like there's basically two behaviors. A background noise of really low bases (binary or trinary is often palindromic just because there aren't many digits) and a few spikes growing ever larger. Neat.</p>
<p>And that's it. Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/minimal-palindromic-base.rkt">minimal-palindromic-base.rkt</a></p>]]></content></entry><entry><title>Number words</title><link href="http://blog.jverkamp.com/2014/08/13/number-words" /><id>urn:uuid:67236730-531b-effa-30b3-b69308ea8187</id><updated>2014-08-13T14:00:00Z</updated><summary type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
<!--more-->
<p>That may look fairly straight forward. Basically, it's a <a href="https://en.wikipedia.org/wiki/parsing">parsing</a>/<a href="https://en.wikipedia.org/wiki/lexing">lexing</a> problem. You take a string as input and break it into a series of tokens (in this case, numbers 1-26); then each token is converted into a letter.</p>
<p>Unfortunately, it's a bit more complicated than that, since the grammar is ambiguous. Taking the example <code>1234</code> from above, should you parse that as <code>1 2 3 4 = ABCD</code>? Or what about <code>1 23 4 = AWD</code>? Or even <code>12 3 4 = LCD</code>? In a nutshell, we have to do all of them. So we want some sort of branching lexer that will try all possible routes.</p>
<p>So let's start with a function that meta-function that can make such a parser:</p>
<pre class="scheme"><code>; Make an optional parser
; If the regex matches, add it to each possible next parse
; If it does not, return an empty list (to be appendable)
(define (make-parser re)
  (λ (str)
    (match str
      [(regexp re (list _ n rest))
       (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
      [any
       '()])))</code></pre>
<p>Looks a bit funny, (especially since we haven't defined <code>number-&gt;words</code> yet), but basically we try to match the regular expression. If that works, make the recursive call (to <code>number-&gt;words</code>) and then append that string (as a character via <code>n->char</code>) to each recursive result. If there are no recursive results, this <code>map</code> will return an empty list. Likewise, if the regular expression doesn't match.</p>
<p>Next step, write the two parsers. We want to parse either a single digit number or a two digit number:</p>
<pre class="scheme"><code>; Create parsers for valid 1 digit and 2 digit letter numbers
(define parse-1 (make-parser #px"([1-9])(.*)"))
(define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))</code></pre>
<p>That's what makes the ambiguity the most interesting. If only <code>0</code> were a valid digit... As it is, there are four possible cases (and these two functions handle them all!):</p>
<ul>
    <li><code>str</code> starts with 1 and a digit 0-9, parse both</li>
    <li><code>str</code> starts with 2 and a digit 0-6, parse both</li>
    <li><code>str</code> starts with 2 and a digit 7-9, parse 2 digits only</li>
    <li><code>str</code> starts with 3-9, parse 1 digit only</li>
</ul>
<p>And finally, try both:</p>
<pre class="scheme"><code>; Base case, so we can stop eventually
(if (equal? str "")
    '("")
    (append (parse-1 str) (parse-2 str)))</code></pre>
<p>The base case looks a bit funny, since you might assume that if neither case matches we'll get there. That's the difference between the empty list <code>'()</code> and the list containing just an empty string <code>'("")</code>. In the latter, there's nothing to map against, ergo necessary.</p>
<p>And then all we need is the <code>n->char</code> function:</p>
<pre class="scheme"><code>; Convert a number 1-26 to a letter A-Z
(define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))</code></pre>
<p>And that's it. Put it all together:</p>
<pre class="scheme"><code>; Given 1-26 mapping to A-Z, determine all possible words represented by a number
; Correctly resolve ambiguities where 1234 -&gt; 1 2 3 4 = ABCD / 1 23 4 -&gt; AWD / 12 3 4 -&gt; LCD
(define (number-&gt;words str)
  ; Convert a number 1-26 to a letter A-Z
  (define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))

  ; Make an optional parser
  ; If the regex matches, add it to each possible next parse
  ; If it does not, return an empty list (to be appendable)
  (define (make-parser re)
    (λ (str)
      (match str
        [(regexp re (list _ n rest))
         (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
        [any
         '()])))

  ; Create parsers for valid 1 digit and 2 digit letter numbers
  (define parse-1 (make-parser #px"([1-9])(.*)"))
  (define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))

  ; Base case, so we can stop eventually
  (if (equal? str "")
      '("")
      (append (parse-1 str) (parse-2 str))))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (number-&gt;words "1234")
'("ABCD" "AWD" "LCD")

&gt; (number-&gt;words "8675309")
'("HFGECI")

&gt; (length (number-&gt;words "85121215231518124"))

1181

&gt; (number-&gt;words "85121215231518124")
'(... "HELLOWORLD" ...)</code></pre>
<p>I could claim that I just happen to know the number code for <code>HELLOWORLD</code>, but really I wrote a quick inverse function:</p>
<pre class="scheme"><code>; Convert words back to numbers
(define (words-&gt;number str)
  (define (char-&gt;n c) (number-&gt;string (- (char-&gt;integer c) 64)))
  (apply ~a (for/list ([c (in-string str)]) (char-&gt;n c))))</code></pre>
<p>Shiny!</p>
<p>Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/number-words.rkt">number-words.rkt</a></p>]]></content></entry><entry><title>Langton's ant</title><link href="http://blog.jverkamp.com/2014/08/07/langtons-ant" /><id>urn:uuid:e9c60746-187f-a46d-0c07-bb5bd223be2d</id><updated>2014-08-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<!--more-->
<p>First, let's define the problem. From Wikipedia: <a href="https://en.wikipedia.org/wiki/Langton's_ant">Langton's ant</a></p>
<blockquote>
    <p>Squares on a plane are colored variously either black or white. We arbitrarily identify one square as the "ant". The ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:</p>

    <ul>
        <li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
        <li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
    </ul>
</blockquote>
<p>That's actually pretty simple sounding, so let's just go ahead and jump into generalizing. Instead of only two states (<code>white</code> and <code>black</code>), let's generalize to an arbitrary number of states. Instead of flipping when the ant visits the state, instead advance to the next. That way, we can define ants quite simply:</p>
<ul>
    <li><code>LR</code> - an ant that turns left on state 1 to 2 and right on state 2 to 1 (the simple ant described above)</li>
    <li><code>LL</code> - an ant that always turns left; this one is boring, it just runs in circles</li>
    <li><code>LRRL</code> - a more complicated ant that turns left on either 1 to 2 or 4 to 1, but turns right on 2 to 3 or 3 to 4<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
</ul>
<p>Okay, fair enough. We also want to decide right now that we're going to support arbitrarily large grids. It would be a lot easier to define a certain region, since then we can use something like a 2-dimensional array to store the current states, but it's not actually any harder to support an unlimited grid. What we need is a way of associating a location with a state. Sounds like a job for a hash!</p>
<p>Except we need two points for a location. So we can either have nested hashes, or we can use a trick that I've used a time or two before: representings points as complex numbers. In this way, the point <code>(0, 0)</code> is the number <code>0+0i</code>; <code>(3, -7)</code> is <code>3-7i</code>. So long as we keep the numbers <code><a href="http://docs.racket-lang.org/search/index.html?q=exact">exact</a></code>, we should be able to use it as a hash key without issue.</p>
<p>Okay, so what do we need to represent the current state of a Langton's Ant simulation? We need the grid, that's true. But we also need the ant. More specifically, we need a location and current facing (since we need a direction to turn left/right from). Also, we'll need to store the current rule. We could keep this out of the structure, but since it's essentially the core of what we need to do, we'll put it in the <code><a href="http://docs.racket-lang.org/search/index.html?q=struct">struct</a></code>.</p>
<p>Something like this:</p>
<pre class="scheme"><code>(struct ant (rule location direction grid) #:transparent)
(define (make-ant rule) (ant rule 0 0+i (hash)))</code></pre>
<p>Okay, the rule is straight forward enough. Just a string of <code>L</code> or <code>R</code> characters. Location is a little stranger, but just remember that it's an exact complex number. So <code>0</code> is <code>0+0i</code> is <code>(0, 0)</code>. Direction takes some doing. Luckily though, it's going to make our math amazingly easy. Essentially, we're going to use complex multiplication. Taking from the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Rotation_(mathematics)">rotation</a>:</p>
<blockquote>
  <p>Points on the <span>\(R^2\)</span> plane can be also presented as complex numbers: the point <code>(x, y)</code> in the plane is represented by the complex number</p>

  <div>$$z = x + iy$$</div>

  <p>This can be rotated trhough an angle <span>\(\theta\)</span> by multiplying it by <span>\(e^{i\theta}\)</span>, then expanding the product using <a href="https://en.wikipedia.org/wiki/Euler's_formula">Euler's formula</a> as follows:</p>

  <p>...</p>
</blockquote>
<p>The important part is that Racket can do the complex multiplication for us. Even better, we only have to deal with two cases: left or right rotation by 90° / <span>\(\pi/2\)</span>. Expanding <span>\(e^{i\theta}\)</span>:</p>
<div>$$e^{i\pi/2} = i$$</div>
<div>$$e^{-i\pi/2} = -i$$</div>
<p>What's that? Left rotation is just multiplying by <span>\(i\)</span> and right rotation, multiplication by <span>\(-i\)</span>. Dang. That's easy. Take that, a rule to increment each state by one (modulus the number of states), and a rule to add the direction to the location (for the new location) and we have an update function.</p>
<pre class="scheme"><code>; Update an ant
(define (tick a)
  ; Unpack the previous ant, get the current cell
  (match-define (ant rule location direction grid) a)
  (define cell (hash-ref grid location 0))

  ; Rotate, multiply by e^iθ, which for 90° left or right is ±i
  (define new-direction (* direction (if (eq? #\L (string-ref rule cell)) 0+i 0-i)))

  ; Create and return the new ant
  ; Update the position via direction and move to the next state (wrapping)
  (ant rule
       (+ location new-direction)
       new-direction
       (hash-set grid location (remainder (+ cell 1) (string-length rule)))))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=match-define">match-define</a></code> is a great way to unpack the structure. <code>cell</code> holds the current state (since we need that both for the new facing and the new state). The direction is the multiplication as explained above and the new location just adds the old location and direction.</p>
<p>Nice and clean. I love it. Even better, it's completely functional. We're not actually mutating anything, even the call to <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-set">hash-set</a></code> creates a new hash rather than modifying the current one.</p>
<p>If we want to see the first few ticks of the <code>LR</code> ant:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (tick a)
(ant "LR" -1 -1 '#hash((0 . 1)))
&gt; (tick (tick a))
(ant "LR" -1-1i 0-1i '#hash((0 . 1) (-1 . 1)))
&gt; (tick (tick (tick a)))
(ant "LR" 0-1i 1 '#hash((0 . 1) (-1-1i . 1) (-1 . 1)))</code></pre>
<p>Take it from me, that's exactly what we're looking for. But it would be nice if we had a way to visualize it. Eventually, we'll want to generate actual images, but before we do that, let's do some ASCII art.</p>
<p>First, since the grid is allowed to grow unbounded, we first need to figure out how large of a grid we need to draw. Something like this:</p>
<pre class="scheme"><code>; Return the current bounds for an ant
(define (bounds a)
  (for/fold ([min-x +inf.0] [max-x -inf.0] [min-y +inf.0] [max-y -inf.0])
            ([(index cell) (in-hash (ant-grid a))])
    (values (min min-x (real-part index))
            (max max-x (real-part index))
            (min min-y (imag-part index))
            (max max-y (imag-part index)))))</code></pre>
<p>I like how <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> can be used to generate multiple values all at once, in this case both the min and max for both x and y.</p>
<p>Okay, with that, we render ASCII:</p>
<pre class="scheme"><code>; Render an ant into ASCII characters
(define (render/ascii a [charset " .:-=+*#%@"])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check the given charset
  (when (&gt; (string-length rule) (string-length charset))
    (error 'render-ascii "Charset is not longer enough, need ~a, given ~a" (string-length rule) (string-length charset)))

  ; Render an ASCII grid to current-output-port
  ; inexact-&gt;exact is necessary to avoid floating point hash errors
  (for ([y (in-range min-y (+ max-y 1))])
    (for ([x (in-range min-x (+ max-x 1))])
      (define p (inexact-&gt;exact (make-rectangular x y)))
      (display (string-ref charset (hash-ref grid p 0))))
    (newline)))</code></pre>
<p>We have a bit of error handling, which also unfortunately means that we can't deal with more than 10 characters. But it looks pretty good:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (render/ascii (tick a))
.
&gt; (render/ascii (tick (tick a)))
..
&gt; (render/ascii (tick (tick (tick a))))
.
..</code></pre>
<p>Hmm. Not very impressive. Let's write a function to do a bunch of ticks in a row.</p>
<pre class="scheme"><code>; Run multiple ticks sequentially
(define (fast-tick a n)
  (for/fold ([a a]) ([i (in-range n)])
    (tick a)))

&gt; (render/ascii (fast-tick a 10))
..
..
 ..

&gt; (render/ascii (fast-tick a 1000))
       ..    ..
      .  .    ..
     ...     .. .
  .. . ....     .
 .  ...     ..
.      ......  .
.   . ...  ..  .
.  ...   ..  . .
.   .      ......
.    .. ...   ....
.  .. ..  ...
 .   ....   ...... .
 ...  ...    .   ...
 . .. ....  .  .  .
      ..  .  .  ..
           ..</code></pre>
<p>Now, we're getting somewhere. Remember how we already built in some support for more than two character rules? Let's try a few more:</p>
<pre class="scheme"><code>&gt; (render/ascii (fast-tick (make-ant "LRL") 100))
   ..
  .  .
 .   :
.   .:
.   . .
 .    .
  .::.

&gt; (render/ascii (fast-tick (make-ant "LRRL") 100))
......
.----.
.::.
:---.
:... .
.::...</code></pre>
<p>Okay. A picture may be worth a thousand words, but these need a little work. Better yet would be an animation. To make that easier (using <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> as I often do), let's use <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code> to make some pretty pictures:</p>
<pre class="scheme"><code>; Render using htdp
(define (render/htdp a [colors '#("white" "black" "red" "blue" "green" "yellow" "magenta" "cyan" "gray" "pink")])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check that we have enough colors, then generate some
  (when (&gt; (string-length rule) (vector-length colors))
    (error 'render-ascii "Not enough colors, need ~a, given ~a" (string-length rule) (vector-length colors)))

  ; Generate the raw images
  (define images
    (for/list ([y (in-range   (- min-y 1) (+ max-y 2))])
      (for/list ([x (in-range (- min-x 1) (+ max-x 2))])
        (define p (inexact-&gt;exact (make-rectangular x y)))
        (define c (vector-ref colors (hash-ref grid p 0)))
        (define block (rectangle 10 10 "solid" c))
        (if (= p location)
            (rotate (case direction [(0+i) 0] [(1) 90] [(0-i) 180] [(-1) 270])
                    (overlay (isosceles-triangle 5 45 'outline "red")
                             (isosceles-triangle 5 45 'solid "black")
                             block))
            block))))

  ; Combine them
  (define null (empty-scene 0 0))
  (foldl above null (map (λ (row) (foldl beside null row)) images)))</code></pre>
<p>Even better, this time we have the actual ant represented as a red outlined triangle (to show facing). Let's render a few of those previous images:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 10))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png" /></a></p>
<p>Beautiful. Let's animate it:</p>
<pre class="scheme"><code>; Simulate a rule using big bang
(define (simulate rule [width 800] [height 600])
  (define background (empty-scene width height))
  (big-bang (make-ant rule)
    [on-tick tick]
    [to-draw (λ (ant) (overlay (render/2htdp ant) background))]
    [record? #t]))</code></pre>
<p>I love how what should theoretically be the most complicated part is actually so simple. Both the basic simulation itself (8 lines without comments) and the simulation loop (6 lines) are tiny. The rendering is a bit worse, but still not that bad. And you can get some <em>crazy</em> behavior with these things...</p>
<pre class="scheme"><code>&gt; (simulate "LR")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<pre class="scheme"><code>&gt; (simulate "LRRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif" /></a></p>
<p>It's interesting how this one makes such a regular grid.</p>
<pre class="scheme"><code>&gt; (simulate "LRRRLRLRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif" /></a></p>
<p>And this one is forming a nice black (state 1) border which keeps getting pushed out further and further.</p>
<p>The basic Langton's Ant (<code>LR</code>) is actually fairly famous for it's behavior:</p>
<ul>
  <li><em>simplicity</em> - &lt; ~300 steps, simple, symmetric patterns</li>
  <li><em>chaos</em> - &lt; ~10,000 steps, large irregular blocks</li>
  <li><em>order</em> - &gt; ~10,000 steps, a recurrent "highway" cycle, 104 blocks in length</li>
</ul>
<p>Examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 300))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 9000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 11000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 15000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png" /></a></p>
<p>Let it run forever, it just runs off in that one direction. It's actually really interesting:</p>
<blockquote>
  <p>Finally the ant starts building a recurrent "highway" pattern of 104 steps that repeat indefinitely. All finite initial configurations tested eventually converge to the same repetitive pattern, suggesting that the "highway" is an attractor of Langton's ant, but no one has been able to prove that this is true for all such initial configurations. It is only known that the ant's trajectory is always unbounded regardless of the initial configuration[4] – this is known as the Cohen-Kung theorem.</p>
  <p>-- <a href="https://en.wikipedia.org/wiki/Langton's_Ant">Langton's Ant</a></p>
</blockquote>
<p>And that's about it. Surprisingly simple, yet awesome emergent behavior.</p>
<p>Here are a few more fun examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "RLLRR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>That's actually an interesting aspect: repeated rules form the same patterns, just with different colors. This makes sense if you think about it, since you're getting the same pattern of <code>L</code> and <code>R</code>, just on a larger space. So:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>And that's it for today. Take a look; if you find any other awesome patterns, leave a comment! If you want to see the entire source, you can do so (as always) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/langtons-ant.rkt">langtons-ant.rkt</a></p>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 3</title><link href="http://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3" /><id>urn:uuid:9bd5dcc8-74cb-9d93-1a71-996438d2daa2</id><updated>2014-07-10T09:00:00Z</updated><summary type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
]]></summary><content type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
<!--more-->
<p>With everything we've done over the past two posts, we have everything we need to actually play the peg game:</p>
<pre class="scheme"><code>(define (play p)
  (cond
    [(= 1 (count p))         (displayln "YOU WIN!")]
    [(= 0 (length (next p))) (display "You lose. :(")]
    [else
     (render-text p)
     (displayln "Enter the peg to use and the peg to jump")
     (define from (read))
     (define over (read))
     (cond
       [(jump p from over) =&gt; play]
       [else
        (displayln "Invalid move.")
        (play p)])]))</code></pre>
<p>Let's play!</p>
<pre class="racket"><code>&gt; (play (invert (make-puzzle 1)))

        2   3
      4   5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
4 2
          1
            3
          5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
9 5
          1
        2   3
              6
    7   8       10
  11  12  13  14  15

Enter the peg to use and the peg to jump
12 8
          1
        2   3
          5   6
    7           10
  11      13  14  15

Enter the peg to use and the peg to jump
11 7
          1
        2   3
      4   5   6
                10
          13  14  15

Enter the peg to use and the peg to jump
14 13
          1
        2   3
      4   5   6
                10
      12          15

Enter the peg to use and the peg to jump
3 5
          1
        2
      4       6
        8       10
      12          15

Enter the peg to use and the peg to jump
12 8
          1
        2
      4   5   6
                10
                  15

Enter the peg to use and the peg to jump
2 4
          1

          5   6
    7           10
                  15

Enter the peg to use and the peg to jump
6 5
          1

      4
    7           10
                  15

Enter the peg to use and the peg to jump
7 4
          1
        2

                10
                  15

Enter the peg to use and the peg to jump
1 2

      4
                10
                  15

Enter the peg to use and the peg to jump
15 10
You lose. :(</code></pre>
<p>Oops.</p>
<p>Can you do any better? (Without using <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">part 1</a>?)</p>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 2</title><link href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2" /><id>urn:uuid:35e19305-69d3-fb61-a39e-a5cb4a314d43</id><updated>2014-07-09T09:00:00Z</updated><summary type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
<!--more-->
<p>Okay, first things first. Remember how we represented the puzzles as either a 15 element vector or 15 bit integer? Well that gives us a pretty solid upper bound on how many possible ways that the puzzle can end up being arrange. Specifically, <span>\(2^{15} = 32768\)</span> total states. For a computer... that's actually not that big of a number. First, let's see how many of those we can actually reach.</p>
<pre class="scheme"><code>; Count how many total states are reachable from any initial state
; By default, start with one copy of each peg missing
(define (reachable [queue (for/list ([i (in-range 15)])
                            (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [(hash-ref reached (index (first queue)) #f)
       (loop reached (rest queue))]
      ; New state, add it to the hash and all next states to the queue
      [else
       (loop (hash-set reached (index (first queue)) #t)
             (append (rest queue) (next (first queue))))])))</code></pre>
<p>Hopefully straight forward algorithm, basically we start with an (empty) index of which nodes we've visited--a hash in our case. Start with each of the fifteen opening moves in a queue. Then, keep taking one nodes off the queue. For new nodes, add that to the list of visited nodes and all its neighbors to the queue. A <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>. Give it a run:</p>
<pre class="scheme"><code>&gt; (hash-count (reachable))
13935</code></pre>
<p>So only 42.5%. Huh. A few examples of states that can't be reached:</p>
<pre class="scheme"><code>&gt; (define r (reachable))
&gt; (for/list ([i (in-range 5)])
    (let loop ()
      (define p (make-puzzle (random (expt 2 15))))
      (if (hash-ref r (index p) #f)
          (render p)
          (loop))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png" /></a></p>
<p>But that doesn't necessary tell us which starting positions are easier. For that, we need something more like this:</p>
<pre class="scheme"><code>&gt; (require plot)
&gt; (plot (discrete-histogram
         (for/list ([i (in-range 15)])
           (vector (+ i 1)
                   (hash-count (reachable (list (invert (make-puzzle (expt 2 i))))))))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png" /></a></p>
<p>Interesting. So there are three states that reach the most (4, 6, and 13), three on the next tier (1, 11, and 15), 6 on the next, and 3 that reach the least (5, 8, and 9). If you think about it, that makes a lot of sense. For each position, there are two other identical positions--rotations:</p>
<pre class="scheme"><code>; Rotate a puzzle clockwise
(define (rotate p)
  (puzzle (for/vector ([i (in-list '(11 12 7 13 8 4 14 9 5 2 15 10 6 3 1))])
            (vector-ref (puzzle-data p) (- i 1)))))

&gt; (define random-puzzle (make-puzzle (random (expt 2 15))))
&gt; (map render (list random-puzzle
                    (rotate random-puzzle)
                    (rotate (rotate random-puzzle))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png" /></a></p>
<p>Further than that, there are also reflections:</p>
<pre class="scheme"><code>; Reflect a puzzle left to right
(define (reflect p)
  (puzzle (for/vector ([i (in-list '(1 3 2 6 5 4 10 9 8 7 15 14 13 12 11))])
            (vector-ref (puzzle-data p) (- i 1)))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png" /></a></p>
<p>This is what I meant last time, when I said that there were only four initial states (1, 2, 4, and 5). All of the rest are reflections and/or rotations of one of those 4.</p>
<p>Finally, if you combine these two functions, it should be possible to get a real idea of how many truly unique states there are. Since each puzzle has a numeric form and each puzzle has up to six unique states (three rotations, each with two reflections), we can consistently find the one of those six with the lowest value. Something like this:</p>
<pre class="scheme"><code>; Minimize a puzzle by finding the reflection/rotation with the minimal vector
(define (minify p)
  (define r1 (rotate p))
  (define r2 (rotate r1))
  (first (sort (list p r1 r2 (reflect p) (reflect r1) (reflect r2))
               (λ (p1 p2)
                 (&lt; (index p1) (index p2))))))

&gt; (map index (list random-puzzle
                   (reflect random-puzzle)
                   (rotate random-puzzle)
                   (reflect (rotate random-puzzle))
                   (rotate (rotate random-puzzle))
                   (reflect (rotate (rotate random-puzzle)))))
'(26794 21322 10025 7474 12412 12679)
&gt; (index (minify random-puzzle))
7474
&gt; (render (minify random-puzzle))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png" /></a></p>
<p>So how many states do we get if we take only the minimum form? Both overall and reachable?</p>
<pre class="scheme"><code>&gt; (set-count
   (for/set ([i (in-range (expt 2 15))])
     (index (minify (make-puzzle i)))))
5728

; Modification of reachable states, only minified
; By default, start with one copy of each peg missing
(define (reachable-min [queue (for/list ([i (in-range 15)])
                                (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [else
       (define p (minify (first queue)))
       (define i (index p))
       (cond
         [(hash-ref reached i #f)
          (loop reached (rest queue))]
         [else
          (loop (hash-set reached i #t)
                (append (rest queue) (next p)))])])))

&gt; (hash-count (reachable-min))
2383</code></pre>
<p>Still about the same (technically slightly lower, it's only 41.6%). That's a good sign. We're all of the way down to 2,383 states from the original potential 32,768. A lot more manageable.</p>
<p>Next, let's shift to moves rather than states. Given two states, they are connected with a move if you could make a single jump to get from one to the other. So now rather than a set, we have a graph. Something like this:</p>
<pre class="scheme"><code>; Find a map of all possible moves from a given puzzle
(define (all-moves p)
  (define moves (make-hash))
  (let loop ([p p])
    (let ([p (minify p)])
      (define i (index (minify p)))
      (when (not (hash-has-key? moves i))
        (define next-ps (next p))
        (hash-set! moves i (list-&gt;set (map index (map minify next-ps))))
        (map loop next-ps))))
  moves)</code></pre>
<p>From there, we can recursively build up a count for each state how many times we win (end up with only a single peg) and how many times we lose.</p>
<pre class="scheme"><code>; Count the number of winning and losing states from a given puzzle
(define (score p)
  (define moves (all-moves p))
  (define-values (wins losses)
    (let loop ([i (index (minify p))])
      (define nxt (hash-ref moves i (set)))
      (cond
        [(set-empty? nxt)
         (if (= 1 (count (make-puzzle i)))
             (values 1 0)
             (values 0 1))]
        [else
         (for/fold ([wins 0] [losses 0]) ([n (in-set nxt)])
           (define-values (r-wins r-losses) (loop n))
           (values (+ wins   r-wins)
                   (+ losses r-losses)))])))
  (* 1.0 (/ wins (+ wins losses))))</code></pre>
<p>That way we can tell how 'hard' each puzzle is, assuming that you always rotate/reflect to avoid potential duplicate state:</p>
<pre class="scheme"><code>&gt; (for/list ([i (in-list '(1 2 3 5))])
    (list i (score (invert (make-puzzle i)))))

'((1 0.05239514926876435)
  (2 0.05138285262741999)
  (3 0.08392304995059131)
  (5 0.08392304995059131))</code></pre>
<p>So there you have it. If you're playing optimally, it's slightly easier to do so starting with a corner or the second. The center or center of each edge are slightly harder.</p>
<p>And that's all we have for today. Originally, I meant to use the graph library I've used a number of times before to visualize the solution space (there's a function that will do that on GitHub), but the graphs honestly aren't that helpful. There nodes are too nested and there are just too many to helpfully visualize. So it goes. Still, I think we found a few interesting things.</p>
<p>As always, the code is available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Cracker Barrel Peg Game</title><link href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game" /><id>urn:uuid:d9fc95b6-10c0-7679-ae85-b61ec0a2f271</id><updated>2014-07-05T09:00:00Z</updated><summary type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
]]></summary><content type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
<!--more-->
<p>Let's start with a bit of ground work:</p>
<pre class="scheme"><code>; Puzzles are represented as a 15 element vector (#t for pegs)
; but can be entered as a 15 bit integer (1 for pegs)
(struct puzzle (data) #:transparent)
(define (make-puzzle v)
  (cond
    [(and (integer? v) (&lt;= 0 v 32767))
     (puzzle (list-&gt;vector
              (map (curry eq? #\1)
                   (reverse (string-&gt;list (~a (number-&gt;string v 2)
                                              #:width 15
                                              #:align 'right
                                              #:pad-string "0"))))))]
    [(and (vector? v) (= 15 (vector-length v)))
     (puzzle v)]
    [(and (list? v) (length v 15))
     (puzzle (list-&gt;vector v))]))</code></pre>
<p>It's a bit heavier than it needs to be (in order to support multiple datatypes), but that saved me all sorts of time in testing. It's a lot easier to enter a puzzle like this:</p>
<pre class="scheme"><code>(make-puzzle #b111110010000000)</code></pre>
<p>Rather than:</p>
<pre class="scheme"><code>(make-puzzle '#(#f #f #f #f #f #f #f #t #f #f #t #t #t #t #t))</code></pre>
<p>(Note that the ordering is opposite. The highest bit is the last peg, while the first vector is the first peg. This is so that puzzle 1 is peg 1 and so on.)</p>
<p>Anyways.</p>
<p>Next, we need to be able to visualize what we're working with. You can always see the sequence of pegs, but without putting them in their proper triangular shape, it's a bit hard to tell what exactly is going on. So first, let's render a puzzle as text:</p>
<pre class="scheme"><code>; Render a puzzle to text
(define (render-text puzzle)
  (for ([row (in-range 1 6)])
    (display (~a "" #:width (* 2 (- 6 row))))
    (for ([col (in-range 1 (+ 1 row))])
      (define i (+ (* 1/2 row (- row 1)) col))
      (display (~a (if (vector-ref (puzzle-data puzzle) (- i 1)) i "") #:width 4)))
    (newline)))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code> is rather handy for formatting like this, making sure that each peg (at least the ones still visible) is exactly four characters wide. The formula in the line defining <code>i</code> should look familiar: it's the sum of the first i integers. Neat.</p>
<pre class="scheme"><code>&gt; (render-text (make-puzzle (random (expt 2 15))))

        2
          5   6
    7   8   9   10
      12  13      15</code></pre>
<p>That's all well and good, but it's the 21st century. We should be able to make pretty pictures as well:</p>
<pre class="scheme"><code>; Render a puzzle to a bitmap
(define (render puzzle)
  (define (bit-set? i) (vector-ref (puzzle-data puzzle) (- i 1)))

  (define imgs
    (for/list ([row (in-range 1 6)])
      (for/list ([col (in-range 1 (+ 1 row))])
        (define i (+ (* 1/2 row (- row 1)) col))
        (define color (if (bit-set? i) "black" "gray"))
        (htdp:overlay (htdp:text (~a i) 12 color)
                      (htdp:circle 10 "outline" color)
                      (htdp:circle 12 "solid" "white")))))

  (define rows (map (λ (row) (if (= 1 (length row))
                                 (first row)
                                 (apply htdp:beside row)))
                    imgs))

  (apply htdp:above rows))</code></pre>
<p>That's a bit more complicated. The basic idea is straight forward enough. First, for each peg we're going to overlay the number as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code> on an outlined <code><a href="http://docs.racket-lang.org/search/index.html?q=circle">circle</a></code>. The second, white circle is in order to get a bit of spacing. We'll render each of these into nested lists, each of increasing length. Then we shove each row together with <code><a href="http://docs.racket-lang.org/search/index.html?q=beside">beside</a></code>, then the rows together with <code><a href="http://docs.racket-lang.org/search/index.html?q=above">above</a></code>. All that to make a picture something like this:</p>
<pre class="scheme"><code>&gt; (render (make-puzzle (random (expt 2 15))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png" /></a></p>
<p>Looks good! (And it's nice being able to see the locations where there currently isn't a peg as well).</p>
<p>Okay, so now that we have some framework set up, how are we going to attack this problem?</p>
<p>Well, the first thing we need is the ability to make a move. In this case, given two neighboring pegs, jump one over the other:</p>
<pre class="scheme"><code>; Given a peg to move from and the peg to move over, return the new puzzle state
(define (jump p ifrom iover)
  (define from-list '(1  1  2  2  3  3  4  4  4  5  5  6  6  7  8  11 12 13))
  (define over-list '(2  3  4  5  5  6  5  7  8  8  9  9  10 8  9  12 13 14))
  (define to-list   '(4  6  7  9  8  10 6  11 13 12 14 13 15 9  10 13 14 15))

  (for/first ([from (in-list (append from-list to-list))]
              [over (in-list (append over-list over-list))]
              [to   (in-list (append to-list from-list))]
              #:when (and (= from ifrom)
                          (= over iover)
                          (vector-ref (puzzle-data p) (- from 1))
                          (vector-ref (puzzle-data p) (- over 1))
                          (not (vector-ref (puzzle-data p) (- to 1)))))
    (let ([new-data (vector-copy (puzzle-data p))])
      (vector-set! new-data (- from 1) #f)
      (vector-set! new-data (- over 1) #f)
      (vector-set! new-data (- to   1) #t)
      (puzzle new-data))))</code></pre>
<p>That's a bit of an ugly function. Unfortunately, I'm not entirely sure how it could be made better. Still, it works. By virtue of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>, we'll either get the new puzzle or <code>#f</code> if it's not a valid move.</p>
<p>Next, we take this function and map it over a puzzle in order to generate all possible next states. Something like this:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      [over (in-range 1 16)])
            (jump p from over))))</code></pre>
<p>This one though, you should see a fairly easy way to optimize. Right now, no matter how many pegs there are in a puzzle, we're going to try every neighboring pair. <code>jump</code> can deal with the weird cases, but we shouldn't have to:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- from 1))
                      [over (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- over 1)))
            (jump p from over))))</code></pre>
<p>That way, the further we get down the puzzle, the fewer cases we will check while still not duplicating <em>too</em> much of the code between the two.</p>
<p>Believe it or not... That's it. That's all we need:</p>
<pre class="scheme"><code>; Solve a puzzle using backtracking
(define (solve p)
  (cond
    [(= 1 (count p))
     (list p)]
    [else
     (let ([n (ormap solve (next p))])
       (and n (cons p n)))]))</code></pre>
<p><code>count</code> returns the number of pegs left on the current board:</p>
<pre class="scheme"><code>; Count how many pegs are left in a puzzle
(define (count p)
  (vector-length (vector-filter identity (puzzle-data p))))</code></pre>
<p>That's it. Give it any peg puzzle and it will solve it. Quickly too. On my machine, it might as well be instantaneous. So how does it work?</p>
<p>Two cases: Either we're done or we're not. If we're done, return the end state. Otherwise, we need to find a state we can move forward from. With <code>ormap</code>, we're going to try each in turn, returning the first thing that isn't <code>#f</code>. Since we're mapping <code>solve</code> (recurring) and almost making progress (<code>next</code> always has at least one less peg), we can rely on the recursion to do it's job. In this case, we'll either find a solution one step down (return that one) or not (check the next one).</p>
<p>Don't believe me? Let's check it out:</p>
<pre class="scheme"><code>&gt; (map render (solve (make-puzzle #b111111111111110)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png" /></a></p>
<p>Flip the board over and it looks like we're genius. :) Sweet.</p>
<p>That's all for today. I am working on a part two though. As a preview: If you take rotations and reflections into account, there are only four possible starting pegs (1, 2, 4, and 5). But it turns out that not all four are created equal--some are (relatively) easy to solve. Some are not.</p>
<p>If you'd like to check out the full source code (and possibly a preview for next time), you can do so on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Factor trees</title><link href="http://blog.jverkamp.com/2014/06/17/factor-trees" /><id>urn:uuid:1797c7a3-6e74-dfbc-5e52-3c2d7b9eaa14</id><updated>2014-06-17T14:00:00Z</updated><summary type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
]]></summary><content type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
<!--more-->
<p>The basic idea is straight forward enough. Each positive integer of note<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> is in one of two classes: either it is <a href="https://en.wikipedia.org/wiki/prime">Prime number</a> or a <a href="https://en.wikipedia.org/wiki/composite">Composite number</a>. For the composite numbers, there are at least two numbers <em>m</em> and <em>n</em> such that neither <em>m</em> nor <em>n</em> is 1 and <em>mn</em> equals that number. For example, 6 is composite because <em>2 * 3 = 6</em>, yet 5 is not, since the only numbers that divide it are 1 and itself. Since 5 is not composite, it only makes sense that it is prime.</p>
<p>But then, what if you have a bigger number, such as 24. You can break that into <em>4 * 6</em>. But neither of those is prime, so you can further break it into <em>(2 * 2) * (2 * 3)</em>. Finally, each of those is prime. All together, that makes up what is called a <a href="https://en.wikipedia.org/wiki/factor_tree">factor tree</a>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png" /></a></p>
<p>That's the challenge this week. Generate that tree.</p>
<p>Well, that's more than enough description. Let's get to it.</p>
<p>Basically, there's a quick (albeit not perfectly efficient) way to find factors: <a href="https://en.wikipedia.org/wiki/trial_division">trial division</a>. Basically, you loop through all of the numbers from 2 to the square root of the number (any larger and you'll find factors you've already found), trying to divide by each in turn. That though, generates this image rather than the previous:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png" /></a></p>
<p>Not quite as nice and balanced. Easily fixed though. Rather than looping from 2 up, loop from the square root down. You'll find the same factors, but you'll find the largest (and thus the most likely split) first.</p>
<p>Code:</p>
<pre class="scheme"><code>; Return a tree of the factors of n
(define (factor-tree n)
  (or
   ; Try to find the first pair of factors
   ; Start from sqrt(n) and work down to get the largest factors first
   (for/first ([i (in-range (integer-sqrt n) 1 -1)]
               #:when (zero? (remainder n i)))
     ; Factor, create a tree with that node and it's further factors
     (list n
           (factor-tree i)
           (factor-tree (quotient n i))))
   ; If for/first returns #f there are no other factors, n is prime
   n))</code></pre>
<p>The comments should be straight forward enough to explain the rest of the structure. <code>for/first</code> will return the first factor that we've found (if any) or <code>#f</code> if not (which then falls through to the next case).</p>
<p>That gives us this structure:</p>
<pre class="scheme"><code>&gt; (factor-tree 24)
'(24 (4 2 2) (6 2 3))</code></pre>
<p>It's perhaps a bit odd to read, but look at the first of each triple. 24 has factors 4 and 6. 4 has factors 2 and 2, 6 has 2 and 3. A bit larger example (formatted to make it a bit easier to read):</p>
<pre class="scheme"><code>&gt; (factor-tree 1767150)
'(1767150 (1309 17
                (77 7 11))
          (1350 (30 5 (6 2 3))
                (45 5 (9 3 3))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png" /></a></p>
<p>Speaking of which, how am I getting those nice images?</p>
<p>Well, to some extent, I'm cheating. I took the code that I'd written a while ago for the <a href="https://github.com/iu-c211/c211-libs/blob/master/c211-libs/tree.rkt">c211-lib/tree</a> library, designed to render trees. All I needed to do was rewrite the <code>match</code> to match against <code>list</code> instead of <code>tree</code>:</p>
<pre class="scheme"><code>; Render a tree structure
; Tree : (U (List Integer Tree Tree) Integer)
(define (render-factor-tree tr)
  (match tr
    ; Recursive tree, unpack the value and render subtrees
    [(list factor left right)
     (define v (text (~a factor)))
     (define l (render-factor-tree left))
     (define r (render-factor-tree right))
     ; Pin-line connects the nodes, append sets the trees side by side
     ; cb/ct-find tells the pins how to connect to the nodes (center bottom/top)
     (pin-line (pin-line (vc-append 10 v (ht-append 10 l r))
                         v cb-find
                         l ct-find)
               v cb-find
               r ct-find)]
    ; Values are directly rendered
    [prime
     (text (~a prime))]))</code></pre>
<p>The interesting parts are the functions <code>text</code> which turns text into an image, <code>pin-line</code> which draws lines between two images, and <code>vc-append</code> / <code>ht-append</code> to combine them vertically centered or horizontal aligned to the top. All together, it lets us render all sorts of nice trees:</p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 828441))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 863029))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 1048576))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png" /></a></p>
<p>And that's about it. Quick enough (even if the rendering probably took a bit more than five minutes when I first wrote it). As always, you can see the entire code for this (and most of my other small projects) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/factor-tree.rkt">factor-tree.rkt</a></p>]]></content></entry></feed>