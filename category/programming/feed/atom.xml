<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-08-24T18:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>Sandbox Battle!</title><link href="http://blog.jverkamp.com/2014/08/24/sandbox-battle" /><id>urn:uuid:645b48c8-e1d6-e804-d919-58df438ef692</id><updated>2014-08-24T18:00:00Z</updated><summary type="html"><![CDATA[<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/sandbox-battle.embed.htm"></iframe></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
<h2>Created for <a href="http://www.ludumdare.com/compo/ludum-dare-30/">Ludum Dare 30</a></h2>
<h3><a href="http://www.ludumdare.com/compo/ludum-dare-30/?action=preview&uid=19702">Entry</a></h3>
<h3><a href="https://github.com/jpverkamp/sandbox-battle">Source code</a></h3>
<h4>Note: Runs best in <a href="https://www.google.com/chrome/browser/">Chrome</a>.</h4>
<h3>Instructions</h3>
<ul>
  <li>You have 60 seconds to collect as much sand as you can</li>
  <li>Each player's sand falls to the bottom of their tile</li>
  <li>Colliding with other players will steal their sand</li>
  <li>Choose options for keyboard controls and to enable multiplayer</li>
</ul>
<h3>Comments</h3>
<ul>
  <li>Libraries used: <a href="https://jquery.com/">jQuery</a>, <a href="http://getbootstrap.com/">Boostrap</a></li>
  <li>Graphics generated in Photoshop CS6</li>
</li>]]></summary><content type="html"><![CDATA[<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/sandbox-battle.embed.htm"></iframe></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
<h2>Created for <a href="http://www.ludumdare.com/compo/ludum-dare-30/">Ludum Dare 30</a></h2>
<h3><a href="http://www.ludumdare.com/compo/ludum-dare-30/?action=preview&uid=19702">Entry</a></h3>
<h3><a href="https://github.com/jpverkamp/sandbox-battle">Source code</a></h3>
<h4>Note: Runs best in <a href="https://www.google.com/chrome/browser/">Chrome</a>.</h4>
<h3>Instructions</h3>
<ul>
  <li>You have 60 seconds to collect as much sand as you can</li>
  <li>Each player's sand falls to the bottom of their tile</li>
  <li>Colliding with other players will steal their sand</li>
  <li>Choose options for keyboard controls and to enable multiplayer</li>
</ul>
<h3>Comments</h3>
<ul>
  <li>Libraries used: <a href="https://jquery.com/">jQuery</a>, <a href="http://getbootstrap.com/">Boostrap</a></li>
  <li>Graphics generated in Photoshop CS6</li>
</li>]]></content></entry><entry><title>Ludum Dare 30: Demo mode</title><link href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode" /><id>urn:uuid:eaf9e838-2040-375f-db84-612ac3daf122</id><updated>2014-08-24T12:00:00Z</updated><summary type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
]]></summary><content type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png" /></a></p>
<p>As soon as you start, you'll go right back to the normal mode. Between rounds, there's no demo, since it's still showing the last round's game.</p>
<p>Unfortunately, it doesn't stop, so if you just let it sit for a while, strange things may happen:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png" /></a></p>
<p>Also, instructions (technically, these were in last night, but I don't think I mentioned them):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png" /></a></p>
<p>Up to date code (as always): <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Programmer art and simple AI</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai" /><id>urn:uuid:f2360aa3-c003-b836-c4a8-ea379a7ef8de</id><updated>2014-08-23T23:00:00Z</updated><summary type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
]]></summary><content type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<!--more-->
<p>More specifically, here's how you can change the AIs:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png" /></a></p>
<p>Those are the three AIs currently implemented. I've tied them into the same framework as the player movement. It's a bit hacky and could be in its own file, but for a 48 hour game, it works well enough.</p>
<p>The first, the <code>Wiggle</code>, is straight forward:</p>
<pre class="javascript"><code>// Randomly wiggle about, changing directions no slower than every second
case 'wiggle':
  ai['nextWiggle'] = ai['nextWiggle'] || new Date().getTime() + 1000 * Math.random();
  ai['xAccel'] = ai['xAccel'] || 0;
  ai['yAccel'] = ai['yAccel'] || 0;

  if (new Date().getTime() &gt; ai['nextWiggle']) {
    ai['xAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;
    ai['yAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;

    ai['nextWiggle'] = new Date().getTime() + 1000 * Math.random();
  }

  vel[player][0] += ai['xAccel'];
  vel[player][1] += ai['yAccel'];

  break;</code></pre>
<p>The other two (<code>Chicken</code> and <code>Shark</code>) are actually really similar. Enough so that they share almost all of their code. The only difference is that the former runs from the closest neighbor while the latter chases it. It's a bit of math, but it runs great:</p>
<pre class="javascript"><code>case 'chicken': // Run away from the nearest other tile
case 'shark':   // Run towards the nearest other tile
  $me = $('#tiles *[data-player="' + player + '"]');
  var myCenterX = $me.offset().left + $me.width() / 2;
  var myCenterY = $me.offset().top + $me.height() / 2;

  // Find the closest target
  var otherCenterX, otherCenterY, distance;
  var minimumDistance = +Infinity, $target;
  $('#tiles *[data-player]').each(function(otherPlayer, other) {
    $other = $(other);

    var otherCenterX = $other.offset().left + $other.width() / 2;
    var otherCenterY = $other.offset().top + $other.height() / 2;

    distance = (
      (myCenterX - otherCenterX) * (myCenterX - otherCenterX) +
      (myCenterY - otherCenterY) * (myCenterY - otherCenterY)
    );

    if (distance &gt; 0 && distance &lt; minimumDistance) {
      minimumDistance = distance;
      $target = $other;
    }
  });

  // Calculate the direction to that target
  var targetCenterX = $target.offset().left + $target.width() / 2;
  var targetCenterY = $target.offset().top + $target.height() / 2;

  // Get the length and normalized direciton
  var length = Math.sqrt(
    (targetCenterX - myCenterX) * (targetCenterX - myCenterX) +
    (targetCenterY - myCenterY) * (targetCenterY - myCenterY)
  );

  var directionX = (targetCenterX - myCenterX) / length;
  var directionY = (targetCenterY - myCenterY) / length;

  // If we're the chicken, invert that and run away rather than towards
  // Sharks also move away, once they've come in for the kill
  if (ai['type'] == 'chicken' || distance &lt; 25) {
    directionX *= -1;
    directionY *= -1;
  }

  // Apply a force in that direction
  // Sharks and chickens accelerate more slowly or they'll stay right on the player
  vel[player][0] += directionX * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);
  vel[player][1] += directionY * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);

  break;</code></pre>
<p>Shiny.</p>
<p>Up to date code: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: 24 hours</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours" /><id>urn:uuid:37f85de8-ca29-d5a8-2c0f-d57f53b84283</id><updated>2014-08-23T18:00:00Z</updated><summary type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
]]></summary><content type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
<!--more-->
<p>Well, it turns out that the solution wasn't that bad. Rather than having a bunch of threads running around, I've just put the entire thing into lockstep. Now, we go through the entire sequence (sand falls, swaps happen, rendering happens, move tiles) once ever frame, in that order. It's a bit more expensive when it comes to performance, but really not that much, since technically JavaScript doesn't do more than one thing at a time anyways.</p>
<p>In exchange though, the game is playing great:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png" /></a></p>
<p>Another thing that I did was to do some styling, converting the game from a big mess of an HTML page into a nice layered style that all fits within the 600x400 game area that I've set aside (I doubt I'll make that changeable, although it shouldn't be hard). Specifically:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png" /></a></p>
<p>If you click options, these fade in (jQuery transitions are awesome for this):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png" /></a></p>
<p>If you click play, all of the button and options fading out, taking you into the game:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png" /></a></p>
<p>At the end of the game (the timer is in the bottom right, set to a static 1 minute at the moment), you get the new scoring screen. I think I worked about 2 hours on this, which sounds crazy, but I think the effect is pretty awesome:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png" /></a></p>
<p>You can't see it in the screenshot there, but it will go through each player one by one, scoring the region from bottom to top, counting up each kind of sand individually. That should make scoring modes much easier if/when I add more options. I can just do things like discount (or even count negative) your own sand, or only count it.</p>
<p>And finally, once it's done counting:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png" /></a></p>
<p>I'd like to have some sort of background motion going on both here and during the opening menu. Something like having the tiles bounce around using some sort of AI. Speaking of which, here is a tentative feature list that I'd like to see in the next 24 hours (in no particular order):</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Pending the first, AI players playing in the background, periodically resetting before the game has started and between games</li>
  <li>Music and/or sound effects; of course with options to turn those on and off</li>
  <li>Some sort of high score menu, probably not live (although I certainly could)</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<p>I think that's about it. If you have any ideas, I'd love to hear them. There's not much (well, any) code this time, since nothing major has changed (other than refactoring). It's pretty much all tweaks. If you'd like to see the entire source (warning: ugly, bit getting a little better), it's still right here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Demo time!</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Hints of a game</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game" /><id>urn:uuid:7e16e7ce-b97f-2d28-ba95-ea26c1b8a027</id><updated>2014-08-23T12:00:00Z</updated><summary type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
]]></summary><content type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png" /></a></p>
<p>(I'll include a demo at the bottom of the post)</p>
<p>Basically, I went with allowing each box to be controlled individually by the keyboard. There will be some problems with having that many people on the keyboard at once, but we'll deal with that later (if we can).</p>
<p>One additional thing I wanted (and mostly figured out) is somewhat 'loose' controls. Basically, rather than explicitly dealing with moving only when a key is down, we'll accelerate when the key is down, preserving velocity even after  keys are raised. There will be some small amount of friction as well, to make sure that eventually pieces will slow down.</p>
<p>It's actually not too hard to implement a system like this:</p>
<p>First, load in the keybindings from the interface you can see in the screenshot above:</p>
<pre class="javascript"><code>// Load key bindings
var loadKeyBindings = function() {
  keys = {};

  console.log('Loading key bindings...');

  $('#controls table').each(function(i, eli) {
    var player = parseInt($(eli).attr('data-player'));

    console.log('loading controls for player ' + player);

    $(eli).find('input').each(function(j, elj) {
      var command = $(elj).attr('name');
      var key = $(elj).val();

      keys[key] = [player, command, false];
    });
  });
};</code></pre>
<p>This will put everything into the <code>key</code> array, indexed by key name and storing the player it refers to, the direction you are going (one of <code>left</code>, <code>right</code>, <code>up</code>, or <code>down</code>), and if that key is currently active (pressed down). If I can, I may add additional key bindings (such as rotation or powerups), otherwise, that's pretty good for the moment.</p>
<p>Next, we'll add a function to tell when keys are active:</p>
<pre class="javascript"><code>var onkey = function(event) {
  switch (event.keyCode) {
    case  37: key = 'LEFT'; break;
    case  38: key = 'UP'; break;
    case  39: key = 'RIGHT'; break;
    case  40: key = 'DOWN'; break;
    case  97: key = 'NUM1'; break;
    case  98: key = 'NUM2'; break;
    case  99: key = 'NUM3'; break;
    case 100: key = 'NUM4'; break;
    case 101: key = 'NUM5'; break;
    case 102: key = 'NUM6'; break;
    case 103: key = 'NUM7'; break;
    case 104: key = 'NUM8'; break;
    case 105: key = 'NUM9'; break;
    default: key = String.fromCharCode(event.keyCode).toUpperCase();
  }

  if (key in keys) {
    if (event.type == 'keydown') {
      keys[key][2] = true;
    } else if (event.type == 'keyup') {
      keys[key][2] = false;
    }
  }
};</code></pre>
<p>Longer than I wanted, but it correctly deals with both the numpad and arrow keys, which is kind of necessary if you want to support 4 human players all at the same time. Perhaps I'll implement AIs, but until I do, we're going to have to allow for a bunch of players...</p>
<p>Okay, so what do we do with all of this information? Well, just like before, we have a <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function(event) {
  $.each(keys, function(i, el) {
    var player = el[0];
    var command = el[1];
    var active = el[2];

    $game = $('#tiles');
    $tile = $('#tiles *[data-player="' + player + '"]');

    // Update velocity
    ...

    // Use friction to slow each box down over time
    ...

    // Cap velocity so we don't go too fast
    ...

    // Update the current position based on velocity
    ...

    // Bounce off the edges of the screen
    ...

    // Finally, update the position
    $tile.css({'top': top, 'left': left});
  });

  if (running) {
    setTimeout(tick, 1000/30);
  }
};</code></pre>
<p>Oof. That's a heck of a function. Luckily, the individual parts aren't <em>that</em> bad. First, we want to update the velocity. This is where the <code>active</code> parameter (the third in each key definition) comes into play:</p>
<pre class="javascript"><code>// Update velocity
if (active) {
  if (command == 'up') {
    vel[player][1] -= PER_TICK_ACCELERATION;
  } else if (command == 'down') {
    vel[player][1] += PER_TICK_ACCELERATION;
  } else if (command == 'left') {
    vel[player][0] -= PER_TICK_ACCELERATION;
  } else if (command == 'right') {
    vel[player][0] += PER_TICK_ACCELERATION;
  }
}</code></pre>
<p>That's simple enough. As before, we have to decide that <code>up</code> and <code>down</code> are inverted (they almost always are when it comes to computers), but once you've decided that's easy enough.</p>
<p>Now, outside of that black, the next thing we'll do is apply friction. This way the boxes will slow down over time, forcing players both to pay attention and to let them bounce around like madmen.</p>
<pre class="javascript"><code>// Use friction to slow each box down over time
// If we're close enough to zero that friction will accelerate us, just stop
if (Math.abs(vel[player][0]) &lt; PER_TICK_FRICTION) {
  vel[player][0] = 0;
} else {
  vel[player][0] += (vel[player][0] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

if (Math.abs(vel[player][1]) &lt; PER_TICK_FRICTION) {
  vel[player][1] = 0;
} else {
  vel[player][1] += (vel[player][1] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

// Cap velcity so we don't go too fast
vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));</code></pre>
<p>Also at the end there, we make sure we don't keep accelerating indefinitely. That both helps keep the game a little easier to play and prevents edge cases (such as moving further in one tick than we're allowed).</p>
<p>Next, we can finally update the position:</p>
<pre class="javascript"><code>// Update the current position based on velocity
var left = $tile[0].offsetLeft + vel[player][0];
var top = $tile[0].offsetTop + vel[player][1];

// Bounce off the edges of the screen
if (left &lt; 0) {
  left = 0;
  vel[player][0] = Math.abs(vel[player][0]);
} else if (left &gt; $game.width() - $tile.width()) {
  left = $game.width() - $tile.width();
  vel[player][0] = -1 * Math.abs(vel[player][0]);
}

if (top &lt; 0) {
  top = 0;
  vel[player][1] = Math.abs(vel[player][1]);
} else if (top &gt; $game.height() - $tile.height()) {
  top =  $game.height() - $tile.height();
  vel[player][1] = -1 * Math.abs(vel[player][1]);
}</code></pre>
<p>Once again, we want to clip the positions. This time though, we're actually going to use the velocities we have rather than zeroing them out. Instead: bounce! It's nice, because it makes the game feel more 'realistic' (for some definitions of the word).</p>
<p>And that's about it. With that, we can have the boxes moving around and interacting as they did last night. We're actually starting to get a game going here. One other tweak is the control code:</p>
<pre class="javascript"><code>var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec &gt; 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}</code></pre>
<p>Technically, it's not a gameloop, since everything is done asynchronously via <code>setTimeout</code> (and make <strong>absolutely sure</strong> that you don't use <code>setInterval</code>...), but it's close enough. What this does give us though is a strict time before the game ends. Otherwise, the boxes will eventually fill up, and where's the fun in that? (Although that might be an interesting alternative end condition).</p>
<p>After that, all I have to figure out is scoring. And I have another 6 hours until the one day mark. If I can make it by then, I'll feel pretty good--and can use all of the rest of the time for polish. I'm thinking some simple music, sound effects, a title screen (initial letters in sand?). Of course, I still have to figure out the scoring algorithm..</p>
<p>Same as yesterday, the entire source (warning: still ugly) if available on GitHub: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<hr />
<p>Demo:</p>
<style>
#controls table {
  border: 1px solid black;
  display: inline-block;
  margin: 1em;
  padding: 0.5em;
  border-radius: 0.5em;

}

#controls table td {
  padding: 0.1em;
}

#controls table td:first-child {
  text-align: right;
}

#controls table input {
  width: 50px;
  text-align: center;
}

#tiles {
  position: relative;
  width: 600px;
  height: 400px;
  background: black;
  border: 1px solid black;
}

#tiles canvas {
  position: absolute;
  border: 1px solid black;
}

#tiles canvas[data-player="0"] { border: 1px solid blue; }
#tiles canvas[data-player="1"] { border: 1px solid red; }
#tiles canvas[data-player="2"] { border: 1px solid green; }
#tiles canvas[data-player="3"] { border: 1px solid hotPink; }

#tiles #countdown {
  color: white;
}
</style>
<script>
function Tiles() {
  var running = false;
  var allData = {};
  var ordering = [];

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  // Make a 2D array initialized all to a given valu
  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  // Update the given grid
  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  // Animate a given frame
  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;
      var imageData = frame_ctx.createImageData(width, height);

      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // Bail out if we haven't loaded the data yet
              if (!(frameIndex in allData && otherIndex in allData)) {
                return;
              }

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                    a = 0;
                  } else if (data[x][y] == 1) {
                    b = 255;
                  } else if (data[x][y] == 2) {
                    r = 255;
                  } else if (data[x][y] == 3) {
                    g = 255;
                  } else if (data[x][y] == 4) {
                    r = 246;
                    g = 96;
                    b = 171;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (running) {
              setTimeout(tick, 1000/60);
          }
      }
      tick();
  };

  this.run = function() {
    running = true;
    $('canvas').each(animate);
  };

  this.stop = function() {
    running = false;
  };
};

function Controls() {
  var keys = {};
  var running = false;
  var PER_TICK_ACCELERATION = 0.1;
  var PER_TICK_FRICTION = 0.01;
  var VELOCITY_CAP = 10;

  var vel = {};

  // Load key bindings
  var loadKeyBindings = function() {
    keys = {};

    console.log('Loading key bindings...');

    $('#controls table').each(function(i, eli) {
      var player = parseInt($(eli).attr('data-player'));

      console.log('loading controls for player ' + player);

      $(eli).find('input').each(function(j, elj) {
        var command = $(elj).attr('name');
        var key = $(elj).val();

        keys[key] = [player, command, false];
      });
    });
  };

  var onkey = function(event) {
    switch (event.keyCode) {
      case  37: key = 'LEFT'; break;
      case  38: key = 'UP'; break;
      case  39: key = 'RIGHT'; break;
      case  40: key = 'DOWN'; break;
      case  97: key = 'NUM1'; break;
      case  98: key = 'NUM2'; break;
      case  99: key = 'NUM3'; break;
      case 100: key = 'NUM4'; break;
      case 101: key = 'NUM5'; break;
      case 102: key = 'NUM6'; break;
      case 103: key = 'NUM7'; break;
      case 104: key = 'NUM8'; break;
      case 105: key = 'NUM9'; break;
      default: key = String.fromCharCode(event.keyCode).toUpperCase();
    }

    if (key in keys) {
      if (event.type == 'keydown') {
        keys[key][2] = true;
      } else if (event.type == 'keyup') {
        keys[key][2] = false;
      }
    }
  };

  var tick = function(event) {
    $.each(keys, function(i, el) {
      var player = el[0];
      var command = el[1];
      var active = el[2];

      $game = $('#tiles');
      $tile = $('#tiles *[data-player="' + player + '"]');

      // Update velocity
      if (active) {
        if (command == 'up') {
          vel[player][1] -= PER_TICK_ACCELERATION;
        } else if (command == 'down') {
          vel[player][1] += PER_TICK_ACCELERATION;
        } else if (command == 'left') {
          vel[player][0] -= PER_TICK_ACCELERATION;
        } else if (command == 'right') {
          vel[player][0] += PER_TICK_ACCELERATION;
        }
      }

      // Use friction to slow each box down over time
      // If we're close enough to zero that friction will accelerate us, just stop
      if (Math.abs(vel[player][0]) < PER_TICK_FRICTION) {
        vel[player][0] = 0;
      } else {
        vel[player][0] += (vel[player][0] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      if (Math.abs(vel[player][1]) < PER_TICK_FRICTION) {
        vel[player][1] = 0;
      } else {
        vel[player][1] += (vel[player][1] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      // Cap velocity so we don't go too fast
      vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
      vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));

      // Update the current position based on velocity
      var left = $tile[0].offsetLeft + vel[player][0];
      var top = $tile[0].offsetTop + vel[player][1];

      // Bounce off the edges of the screen
      if (left < 0) {
        left = 0;
        vel[player][0] = Math.abs(vel[player][0]);
      } else if (left > $game.width() - $tile.width()) {
        left = $game.width() - $tile.width();
        vel[player][0] = -1 * Math.abs(vel[player][0]);
      }

      if (top < 0) {
        top = 0;
        vel[player][1] = Math.abs(vel[player][1]);
      } else if (top > $game.height() - $tile.height()) {
        top =  $game.height() - $tile.height();
        vel[player][1] = -1 * Math.abs(vel[player][1]);
      }

      // Finally, update the position
      $tile.css({'top': top, 'left': left});
    });

    if (running) {
      setTimeout(tick, 1000/30);
    }
  };

  this.run = function() {
    // Reload keybindings in case they've changed
    loadKeyBindings();

    // Initialize velocities to zero
    $game = $('#tiles');
    $('#tiles canvas').each(function(i, eli) {
      vel[i] = [0, 0];
      $(eli).css({
        top: Math.random() * ($game.height() - $(eli).height()),
        left: Math.random() * ($game.width() - $(eli).width())
      });
    });

    // Add keybindings, we can use the same function since it can check type
    $(document).unbind('keydown').bind('keydown', onkey);
    $(document).unbind('keyup').bind('keyup', onkey);

    running = true;
    tick();
  }

  this.stop = function() {
    running = false;

    $(document).unbind('keydown');
    $(document).unbind('keyup');
  }
};

var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec > 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}
</script>
<div class="table" id="controls">
  <table data-player="0">
    <tr><td colspan="2">Player 1 - Blue</tr>
    <tr><td>Up</td><td><input name="up" value="W"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="A"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="D"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="S"></input></td></tr>
  </table>

  <table data-player="1">
    <tr><td colspan="2">Player 2 - Red</tr>
    <tr><td>Up</td><td><input name="up" value="I"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="J"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="L"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="K"></input></td></tr>
  </table>

  <table data-player="2">
    <tr><td colspan="2">Player 3 - Green</tr>
    <tr><td>Up</td><td><input name="up" value="UP"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="LEFT"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="RIGHT"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="DOWN"></input></td></tr>
  </table>

  <table data-player="3">
    <tr><td colspan="2">Player 4 - Pink</tr>
    <tr><td>Up</td><td><input name="up" value="NUM8"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="NUM4"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="NUM6"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="NUM2"></input></td></tr>
  </table>
</div>
<div>
  [ <a href="javascript:run()">Run!</a> ]
  [ <a href="javascript:stop()">Stop!</a> ]
</div>
<div width="600" height="400">
  <div id="tiles">
    <p id="countdown"></p>
    <canvas data-player="0" width="100" height="100"></canvas>
    <canvas data-player="1" width="100" height="100"></canvas>
    <canvas data-player="2" width="100" height="100"></canvas>
    <canvas data-player="3" width="100" height="100"></canvas>
  </div>
</div>
<hr />
<p>I'm sure there are bugs... And I'm working on it right at the moment. If you have any questions or comments though, feel free to drop me a line below.</p>]]></content></entry><entry><title>Ludum Dare 30: Sandbox Battle</title><link href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle" /><id>urn:uuid:60fce17b-2d64-c87b-a259-90aa26aa5803</id><updated>2014-08-22T23:00:00Z</updated><summary type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
]]></summary><content type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
<!--more-->
<p>The theme this time is <a href="http://www.ludumdare.com/compo/2014/08/16/ludum-dare-30-theme-voting-begins/">Connected Worlds</a>. I like that a lot more than many of the previous themes, so let's see what ideas we can come up with.</p>
<p>Taking about an hour at the start of the compo to both work out and think, I ended up basically going in two directions:</p>
<ul>
  <li>A <a href="https://en.wikipedia.org/wiki/falling_sand">falling sand</a> style game, only with discrete 'bubbles' with different particles / physics</li>
  <li>A <a href="https://en.wikipedia.org/wiki/Platform_game#Puzzle_platformers">puzzle platformer</a> based around portals that split you into two realities you play at the same time</li>
</ul>
<p>Of the two, the second has the advantages of 1) actually sounding like a game (that's always been my problem with falling sand style simulations) and 2) being much easier to code. I've worked on falling sand style games before (<a href="http://blog.jverkamp.com/category/programming/by-project/games/sandbox">Sandbox</a>) and they take a lot of tuning to get reasonable performance. Certainly worth doing... but not the best idea for a 48 hour time window.</p>
<p>So of course I'm going with option A. :)</p>
<p>About 6 hours in, and so far this is what I have:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png" /></a></p>
<hr />
<p>Real-life demo! (Click run, then try dragging the boxes around)</p>
<canvas id="frame1" width="100" height="100"></canvas>
<canvas id="frame2" width="100" height="100"></canvas>
<canvas id="frame3" width="100" height="100"></canvas>
<p><button id="runGame" type="button">Run!</button></p>
<style>
canvas { border: 1px solid black; }
</style>
<script>
$(function() {
  var maxFrames = 10000;

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  var ordering = [];
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  var allData = {};

  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;

      var imageData = frame_ctx.createImageData(width, height);

      var count = 0;
      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              /*
              // We only want to run this once, so only for the frame on top
              // If we see the frame first, we're golden (break out of the loop)
              // If we see the other first, we're in the wrong order (stop processing)
              for (var i = 0; i < ordering.length; i++) {
                  if (ordering[i] == frameIndex) break;
                  if (ordering[i] == otherIndex) return;
              }
              */

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                      a = 0;
                  } else if (data[x][y] == 1) {
                      b = 255;
                  } else if (data[x][y] == 2) {
                      r = 255;
                  } else if (data[x][y] == 3) {
                      g = 255;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (count < maxFrames) {
              count += 1;
              setTimeout(tick, 0);
          } else {
              end = new Date().getTime();
              console.log(
                  maxFrames + ' frames in ' +
                  (end - start) + ' ms = ' +
                  (maxFrames / ((end - start) / 1000)) + ' fps'
              );
          }
      }
      tick();
  }

  $('#runGame').click(function() {
    console.log('starting...');
    $('canvas').each(animate);
  });
});
</script>
<p>You can click and drag the blocks around and the sand will from from box to box. At first, I was trying to figure out goals where you could--for example--use water in one box to put out fire in another. But right at the end, I had an even better idea (hopefully not just the long day talking): SANDBOX BATTLE! Basically, some sort of multiplayer / AI madness, where you are trying to steal the other box's sand before they can steal yours... I'm going to have to think about that...</p>
<p>Anyways, here are some of the interesting bits (in JavaScript for once!):</p>
<p>First, the core of the whole thing, the update function:</p>
<pre class="javascript"><code>var update = function(data, buffer, width, height) {
    // Clear the buffer
    for (var x = 0; x &lt; width; x++) {
        for (var y = 0; y &lt; height; y++) {
            buffer[x][y] = 0;
        }
    }

    // Update the buffer with falling cells
    var r = 0, xt = 0, yt = 0;
    for (var y = height - 1; y &gt;= 0; y--) {
        for (var x = 0; x &lt; width; x++) {
            // Skip empty cells
            if (data[x][y] == 0) continue;
            xt = x;
            yt = y;

            // Determine which way it's going to fall
            r = Math.random();
            if (r &lt; 0.5) { // Straight down
                if (y &gt; 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
            } else if (r &lt; 0.7) { // Down left
                if (x &gt; 0 && y &gt; 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
            } else if (r &lt; 0.9) { // Down right
                if (x &lt; width - 1 && y &gt; 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
            } else if (r &lt; 0.95) { // Straight left
                if (x &gt; 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
            } else { // Straight right
                if (x &lt; width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
            }

            if (data[xt][yt] != 0) { xt = x; yt = y; }

            // Update the buffer
            buffer[xt][yt] = data[x][y];
        }
    }
}</code></pre>
<p>The basic idea is two have two data arrays: <code>data</code> and <code>buffer</code>. We will trust the rest of the code to swap them the other way and spend all of the effort in this function creating buffer as the next frame. Specifically, we're going to loop through all of the tiles from bottom to top (because sand falls) then left to right. For each particle (non-<code>0</code> space), there are five possibilities:</p>
<ul>
  <li>50% chance of trying to move directly down</li>
  <li>20% chance of trying to move down and left, 20% down and right</li>
  <li>5% chance each of moving directly left or right</li>
</ul>
<p>Sounds pretty good. It's the same sort of code I've written rather a lot of times... This time around, we're not going to do any optimizations. We'll deal with that later if we have time.</p>
<p>Next, we have to deal with the <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function() {
    // Debug: Add a pixel
    data[width / 2][height - 1] = frameIndex + 1;

    // Update from data to buffer; swap the arrays for the next iteration
    update(data, buffer, width, height);
    temp = data;
    data = buffer;
    buffer = temp;

    // Detect overlapping buffers, if so swap randomly
    ...

    // Render to the image data
    ...
}</code></pre>
<p>So we start with pixels dumping in from the ceiling and we update the world. We have space for two more functions: copying between worlds (pretty much the core idea of the game :)) and rendering. Let's look at the latter first.</p>
<p>In order to render quickly, I'm going to use the <code>canvas</code> element's context's <code>createImageData</code> and <code>putImageData</code> to write data directly into the image. That will be a lot faster than setting pixels individually, especially since we're going to be changing rather a lot of pixels at the indiviual level. So... rendering:</p>
<pre class="javascript"><code>// Render to the image data
for (var y = 0; y &lt; height; y++) {
    for (var x = 0; x &lt; width; x++) {
        i = x + (height - y) * width;

        r = g = b = 0;
        a = 255;

        if (data[x][y] == 0) {
            a = 0;
        } else if (data[x][y] == 1) {
            b = 255;
        } else if (data[x][y] == 2) {
            r = 255;
        } else if (data[x][y] == 3) {
            g = 255;
        }

        imageData.data[i * 4 + 0] = r;
        imageData.data[i * 4 + 1] = g;
        imageData.data[i * 4 + 2] = b;
        imageData.data[i * 4 + 3] = a;

    }
}

// Copy back to the GUI
frame_ctx.putImageData(imageData, 0, 0);</code></pre>
<p>We've previously set up <code>imageData</code> using <code>createImageData</code> (we only have to do this once and then can reuse that same memory) and the <code>frame_ctx</code> as the context object of the canvas.</p>
<p>One interesting part that I changed right before this writeup was the transparency of empty cells. That way the page will shine through. I'm not entirely sure that's what I want, but it's an interesting effect, so I'll leave it for the time being.</p>
<p>And then last but not least, the combination function. This one is honestly kind of weird:</p>
<pre class="javascript"><code>// Detect overlapping buffers, if so swap randomly
$('canvas').each(function(otherIndex, other) {
    // If we're comparing to ourself, we'll always overlap, skip
    if (frame == other) return;

    // If the two canvases don't overlap, don't look at them
    var frameBounds = frame.getBoundingClientRect();
    var otherBounds = other.getBoundingClientRect();
    if (frameBounds.right &lt; otherBounds.left ||
        frameBounds.left &gt; otherBounds.right ||
        frameBounds.bottom &lt; otherBounds.top ||
        frameBounds.top &gt; otherBounds.bottom) {
        return;
    }

    // We only want this once, so give priority to whichever frame is 'lower' on the screen
    if (frameBounds.top &lt; otherBounds.top) return;

    // TODO: Find the actual offset rather than looping over an entire image
    var otherX, otherY, temp;
    for (var frameY = 0; frameY &lt; height; frameY++) {
        for (var frameX = 0; frameX &lt; width; frameX++) {
            otherX = frameBounds.left - otherBounds.left + frameX;
            otherY = otherBounds.top - frameBounds.top + frameY;

            if (0 &lt;= otherX && otherX &lt; width && 0 &lt;= otherY && otherY &lt; height) {
                if (allData[frameIndex][frameX][frameY] == 0 ) {
                    temp = allData[frameIndex][frameX][frameY];
                    allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                    allData[otherIndex][otherX][otherY] = temp;
                }
            }
        }
    }
});</code></pre>
<p>Theoretically the comments should be enough, but if not, the basic idea is to first find if we have two overlapping regions (the <code>frameIndex</code> and <code>otherIndex</code> will make more sense if you look at the full code). If you have one, then loop over the shared region and copy pixels to the lower of the two boxes. I'm going to have to figure out a better rule for that. I tried using z-index, but that didn't work much better... Essentially, we need to be able to move particles from one box to another, but we need to be careful to neither lose nor duplicate particles. There are a number of weird edges cases (as I'm sure you've found if you played with the simulation).</p>
<p>And, that's it. I have until 5pm Pacific on Sunday. I'm actually feeling pretty good about this. The best plan is to have a playable game after 24 hours and to spend the second day on polish. I'm not sure if I'll quite hit that... but maybe!</p>
<p>If you'd like to see the entire source (warning: ugly) and potentially spoilers, check it out here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>]]></content></entry><entry><title>Chess Puzzles 1: Get moving!</title><link href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving" /><id>urn:uuid:c9a01028-c833-db3c-8a7b-1118c75bc69f</id><updated>2014-08-21T20:00:00Z</updated><summary type="html"><![CDATA[<p>Here's something I haven't done much<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>: chess puzzles! I'm still not sure entirely what I think about the game in general. There is certainly quite a lot of strategy, which I like, but to really get good at chess, there's also some amount of memorizing openings and closings. That's something I'm a little less thrilled with.</p>
<p>Still, it's the perfect sort of came to work out programming exercises with. It's a game of <a href="https://en.wikipedia.org/wiki/perfect_information">perfect information</a>, so you don't have to deal with what a player knows and doesn't. The pieces have well defined, regular moves<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> There's a fairly intense branching factor, but not insurmountable--<a href="https://en.wikipedia.org/wiki/Deep_Blue (chess computer)">Deep Blue</a> proved that.</p>
<p>Anyways, enough chatter. Let's play some chess!</p>
]]></summary><content type="html"><![CDATA[<p>Here's something I haven't done much<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>: chess puzzles! I'm still not sure entirely what I think about the game in general. There is certainly quite a lot of strategy, which I like, but to really get good at chess, there's also some amount of memorizing openings and closings. That's something I'm a little less thrilled with.</p>
<p>Still, it's the perfect sort of came to work out programming exercises with. It's a game of <a href="https://en.wikipedia.org/wiki/perfect_information">perfect information</a>, so you don't have to deal with what a player knows and doesn't. The pieces have well defined, regular moves<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> There's a fairly intense branching factor, but not insurmountable--<a href="https://en.wikipedia.org/wiki/Deep_Blue (chess computer)">Deep Blue</a> proved that.</p>
<p>Anyways, enough chatter. Let's play some chess!</p>
<!--more-->
<p>Okay, first things first, we're going to have to lay some ground work. Despite how straight forward chess pieces are, it will still take a bit of effort to turn that into something that a computer can deal with. So first, let's work out a way of defining chess piece movement.</p>
<p>Here, I'm going a little ambitious. I want to be able to support arbitrary <a href="https://en.wikipedia.org/wiki/fairy_chess pieces">fairy chess pieces</a>. In addition to the more standard pieces, we have  strictly more powerful pieces like the Princess (Knight + Bishop) or the Empress (Knight + Rook). Or we have alternatives, like the Camel (like the Knight, only 3:1 instead of 2:1). Or the Nightrider, which moves like the Knight, but keeps on going. I want to be able to support all of these...</p>
<p>Okay, first things first. A basic struct for points and another to use for a <code>move-sequence</code>:</p>
<pre class="scheme"><code>; Points, with associated methods; can also be used as offsets
(struct pt (x y) #:transparent)

; Move sequences for a piece; used for special flags (eg initial, capturing)
(struct move-sequence (tag moves) #:transparent)</code></pre>
<p>The tags are mostly used for Pawns or the like, since they move one way when capturing and another when not. The rest is going to be a list of moves. So for something like the Rook, we'll have something like this:</p>
<pre class="scheme"><code>(list
 (move-sequence (set) (list (pt 0 1) (pt 0 2) (pt 0 3) (pt 0 4) (pt 0 5) (pt 0 6) (pt 0 7) (pt 0 8)))
 (move-sequence (set) (list (pt -1 0) (pt -2 0) (pt -3 0) (pt -4 0) (pt -5 0) (pt -6 0) (pt -7 0) (pt -8 0)))
 (move-sequence (set) (list (pt 1 0) (pt 2 0) (pt 3 0) (pt 4 0) (pt 5 0) (pt 6 0) (pt 7 0) (pt 8 0)))
 (move-sequence (set) (list (pt 0 -1) (pt 0 -2) (pt 0 -3) (pt 0 -4) (pt 0 -5) (pt 0 -6) (pt 0 -7) (pt 0 -8))))</code></pre>
<p>When we get around to it, the idea is we can run down any of these lists until we run into something. If we run into an enemy piece, we'll allow the move; if not, we won't. Similarly, the Pawn:</p>
<pre class="scheme"><code>(list
 (move-sequence (set 'initial-only 'non-capture) (list (pt 0 2)))
 (move-sequence (set 'non-capture) (list (pt 0 1)))
 (move-sequence (set 'capture-only) (list (pt -1 1)))
 (move-sequence (set 'capture-only) (list (pt 1 1))))</code></pre>
<p>On the other hand though, these are kind of a pain to type in by hand. Let's make some helper functions. First, basic movement:</p>
<pre class="scheme"><code>; A sequence of moves along a specific direction
; Distance is either not specified (exactly 1)
;   a number (exactly that number), n (unlimited)
;   or a range (min/max inclusive)
; Direction is either from the list '(* + &gt; &lt; &lt;&gt; = &gt;= &lt;= X X&gt; X&lt;)
;   or a list of possible single offsets
(define move
  (case-lambda
    [(direction)
     (move 1 1 direction)]
    [(distance direction)
     (if (eq? distance 'n)
         (move 1        +inf.0   direction)
         (move distance distance direction))]
    [(minimum-distance maximum-distance direction)
     (for/list ([offset (in-list (offsets-by-direction direction))])
       (move-sequence
        (set)
        (for*/list ([distance (in-range minimum-distance (+ maximum-distance 1))]
                    [p (in-value (pt* distance offset))])
                    #:break (or (&gt; (abs (pt-x p)) (current-board-size))
                                (&gt; (abs (pt-y p)) (current-board-size)))
          p)))]))</code></pre>
<p>Basically, we have three different ways of specifying moves:</p>
<ul>
    <li><code>(move direction)</code> - moves one square in a given direction (like a pawn)</li>
    <li><code>(move distance direction)</code> - moves either exactly a specific number of tiles or an unlimited number (if <code>distance</code> is <code>n</code>)</li>
    <li><code>(move minimum-distance maximum-distance direction)</code> - a range of movement, so you can move between the minimum and maximum inclusive but no more or less</li>
</ul>
<p>But what does direction mean? If it's specified as a point, that's straight forward enough, but still, we want to be able to specify these things more simply. Let's take a page out of <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Parlett.27s_movement_notation">Parlett's movement notation</a>. Specifically the direction specifications:</p>
<ul>
        <li><code>*</code> – orthogonally or diagonally (all eight possible directions)</li>
    <li><code>+</code> – orthogonally (four possible directions)</li>
    <li><code>&gt;</code> – orthogonally forwards</li>
    <li><code>&lt;</code> – orthogonally backwards</li>
    <li><code>&lt;&gt;</code> – orthogonally forwards and backwards</li>
    <li><code>=</code> – orthogonally sideways (used here instead of Parlett's divide symbol.)</li>
    <li><code>&gt;=</code> – orthogonally forwards or sideways</li>
    <li><code>&lt;=</code> – orthogonally backwards or sideways</li>
    <li><code>X</code> – diagonally (four possible directions)</li>
    <li><code>X&gt;</code> – diagonally forwards</li>
    <li><code>X&lt;</code> – diagonally backwards</li>
</ul>
<p>Turn it into code:</p>
<pre class="scheme"><code>; Return a sequence of all possible offsets for a given direction
; Order specified front to back, left to right
(define (offsets-by-direction direction)
  `(,@(if (member direction '(*                  X X&gt;   )) (list (pt -1  1)) '())
    ,@(if (member direction '(* + &gt;   &lt;&gt;   &gt;=           )) (list (pt  0  1)) '())
    ,@(if (member direction '(*                  X X&gt;   )) (list (pt  1  1)) '())
    ,@(if (member direction '(* +        = &gt;= &lt;=        )) (list (pt -1  0)) '())
    ,@(if (member direction '(* +        = &gt;= &lt;=        )) (list (pt  1  0)) '())
    ,@(if (member direction '(*                  X    X&lt;)) (list (pt -1 -1)) '())
    ,@(if (member direction '(* +   &lt; &lt;&gt;      &lt;=        )) (list (pt  0 -1)) '())
    ,@(if (member direction '(*                  X    X&lt;)) (list (pt  1 -1)) '())
    ,@(if (pt? direction)   (list direction) '())
    ,@(if (list? direction) direction        '())))</code></pre>
<p>We're going to set it out now: <code>pt</code> is specified as <code>x, y</code>, not <code>row, column</code>. That's something that will bite you if you don't pay attention, so make sure to be consistent.</p>
<p>That's enough to define most of the pieces we want.</p>
<pre class="scheme"><code>(define King   (move  1 '*))
(define Queen  (move 'n '*))
(define Rook   (move 'n '+))
(define Bishop (move 'n 'X))</code></pre>
<p>Two are still left: the Knight and the Pawn. For the Knight, we need to specify something that will let us jump in arbitrary directions:</p>
<pre class="scheme"><code>; Make a leaper from a given offset
(define (leaper xΔ yΔ)
  (set-&gt;list
   (list-&gt;set
    `(,(pt    xΔ     yΔ )
      ,(pt (- xΔ)    yΔ )
      ,(pt    xΔ  (- yΔ))
      ,(pt (- xΔ) (- yΔ))
      ,(pt    yΔ     xΔ )
      ,(pt (- yΔ)    xΔ )
      ,(pt    yΔ  (- xΔ))
      ,(pt (- yΔ) (- xΔ))))))</code></pre>
<p>The <code>list-&gt;set</code> and set-&gt;list` calls are to avoid duplicates. Otherwise, it's every combination of leaps in a given ratio. So if you want to define a Knight:</p>
<pre class="scheme"><code>(define Knight (move 1 (leaper 1 2)))</code></pre>
<p>If you want to define the Nightrider though, it's just as simple:</p>
<pre class="scheme"><code>(define Nightrider (move 'n (leaper 1 2)))</code></pre>
<p>And... that leaves us the Pawn. It's funny how perhaps the simplest of the pieces is the most complicated to define. But if you think about it, the behavior is also the longest to describe. You can move two spaces on the first move, one space any other move, but only capture diagonally. Something like this:</p>
<pre class="scheme"><code>(define Pawn
  (alternatives
   (on-non-capture (on-initial (move 2 '&gt;)))
   (on-non-capture             (move 1 '&gt;))
   (on-capture                 (move 1 'X&gt;))))</code></pre>
<p>What's that? We don't have <code>on-non-capture</code> / <code>on-capture</code> functions defined? Well, all we have to do is set the <code>tag</code> field we defined earlier. Something like this:</p>
<pre class="scheme"><code>; Set special flags for move lists
(define (set-flag flag movelist*)
  (for/list ([movelist (in-list movelist*)])
    (match-define (move-sequence flags moves) movelist)
    (move-sequence (set-add flags flag) moves)))

(define (on-initial     movelist*) (set-flag 'initial-only movelist*))
(define (on-capture     movelist*) (set-flag 'capture-only movelist*))
(define (on-non-capture movelist*) (set-flag 'non-capture  movelist*))
(define (as-locust      movelist*) (set-flag 'locust       movelist*))</code></pre>
<p>Locusts are something we'll get to eventually. Those are pieces that move like checkers: they capture by jumping. Other than that, we just need the <code>alternatives</code>:</p>
<pre class="scheme"><code>; Merge multiple move lists by allowing any of them
(define (alternatives . list*)
  (apply append list*))</code></pre>
<p>Feels like cheating. And there we have the pawn:</p>
<pre class="scheme"><code>&gt; Pawn
(list
 (move-sequence (set 'initial-only 'non-capture) (list (pt 0 2)))
 (move-sequence (set 'non-capture) (list (pt 0 1)))
 (move-sequence (set 'capture-only) (list (pt -1 1)))
 (move-sequence (set 'capture-only) (list (pt 1 1))))</code></pre>
<p>Sweet.</p>
<p>Okay, what about other kinds of pieces. Say... the Aanca. That's a piece that moves one square orthogonally than diagonally outwards. It's a bit complicated by the fact that we don't want to double back with the diagonals and we need one more function. A sequencer:</p>
<pre class="scheme"><code>; Merge multiple move lists by doing one and then the next, each relative to the previous endpoint
(define (and-then first* rest*)
  (for*/list ([first (in-list first*)]
              [rest  (in-list rest*)])
    (match-define (move-sequence first-flags first-moves) first)
    (match-define (move-sequence rest-flags  rest-moves)  rest)
    (define offset (last first-moves))
    (move-sequence
     (set-union first-flags rest-flags)
     (append first-moves (map (λ (each) (pt+ offset each)) rest-moves)))))</code></pre>
<p>Now we can have the Aanca:</p>
<pre class="scheme"><code>; Move one square like a rook, followed by any number of spaces diagonally outwards
(define Aanca
  (alternatives
   (and-then (move 1 '&gt;) (move 'n 'X&gt;))
   (and-then (move 1 (pt 1 0))  (alternatives (move 'n (pt  1 -1))
                                              (move 'n (pt  1  1))))
   (and-then (move 1 '&lt;) (move 'n 'X&lt;))
   (and-then (move 1 (pt -1 0)) (alternatives (move 'n (pt -1 -1))
                                              (move 'n (pt -1  1))))))</code></pre>
<p>And that's it. We can define a whole pile of the other <a href="https://en.wikipedia.org/wiki/Fairy_chess pieces">Fairy chess pieces</a>:</p>
<pre class="scheme"><code>(define Adjutant     (move  1 '&lt;&gt;))
(define Advisor      (move  1 'X))
(define Alfil        (move  1 (leaper 2 2)))
(define Afilrider    (move 'n (leaper 2 2)))
(define Alibaba      (alternatives (move 'n (leaper 2 2)) (move 'n (leaper 0 2))))
(define Amazon       (alternatives (move 1 (leaper 1 2)) (move 'n '*)))
(define Antelope     (move  1 (leaper 3 4)))
(define Archbishop   (alternatives (move 'n 'X) (move 1 (leaper 1 2))))
(define ArrowPawn    (alternatives (on-non-capture (move 1 '+))
                                   (on-capture (move 1 'X))))
(define Backslider   (move  1 '&lt;))
(define Banshee      (alternatives (move 'n 'X) (move 'n (leaper 1 2))))
(define Bede         (alternatives (move 'n 'X) (move 'n (leaper 0 2))))
(define BerolinaPawn (alternatives (on-non-capture (on-initial (move 2 'X&gt;)))
                                   (on-non-capture (move 1 'X&gt;))
                                   (on-capture (move 1 '&gt;))))
...</code></pre>
<p>(Feel free to submit a <a href="https://github.com/jpverkamp/chess-puzzles/pulls">pull request</a> if you want to add more. :))</p>
<p>Oof. That's a lot of code. I think that's about enough for today.</p>
<p>You can see the full code on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles">jpverkamp/chess-puzzles</a>. Warning though: I'm a bit further ahead code-wise than blog-wise. That way lies spoilers...</p>
<p>Speaking of which:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/chessboard.png"><img src="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/chessboard.png" /></a></p>
<p>:)</p>]]></content></entry><entry><title>Minimal palindromic base</title><link href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base" /><id>urn:uuid:dccae1c2-8231-ed96-21a1-54145cd10b47</id><updated>2014-08-13T17:00:00Z</updated><summary type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
<!--more-->
<p>More specifically, consider the number 15:</p>
<div>$$15_{10} = 1111_2 = 120_3 = 33_4 = 30_5 = 23_6 = 21_7 = 17_8 = 16_9$$</div>
<div>$$15_{10} = 14_{11} = 13_{12} = 12_{13} = 11_{14} = 10_{15}$$</div>
<p>In this case, <code>2</code> is our golden number, since <code>1111</code> is a palindrome. But if it wasn't, 14 is the next case, with <code>11</code>.</p>
<p>So, what do we need? Well, first we want a generic way to convert bases. We could use different characters up to base 64, but we'll eventually get beyond that. So instead, we'll use lists of digits, each of which can be any integer:</p>
<pre class="scheme"><code>; Convert a decimal number n to base b
(define (rebase n b)
  (let loop ([n n] [ls '()])
     (if (= n 0)
        ls
        (loop (quotient n b)
              (cons (remainder n b) ls)))))</code></pre>
<pre class="scheme"><code>&gt; (rebase 15 2)
'(1 1 1 1)

&gt; (rebase 15 5)
'(3 0)

&gt; (rebase 15 10)
'(1 5)

&gt; (rebase 15 14)
'(1 1)</code></pre>
<p>Looks good. Next, we'll use a macro we've often used before: <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>. It's perfect for our uses, since it will return the first value that is non-<code>#f</code>. In this case, our base:</p>
<pre class="scheme"><code>; Find the minimal base b such that n in base b is a palindrome
(define (minimal-palindromic-base n)
  (for/first ([b (in-naturals 2)]
              #:when (let ([nb (rebase n b)])
                       (equal? nb (reverse nb))))
    b))</code></pre>
<p>Bam. Let's try a few:</p>
<pre class="scheme"><code>&gt; (minimal-palindromic-base 15)
2

&gt; (minimal-palindromic-base 1234)
22

&gt; (rebase 1234 22)
'(2 12 2)

&gt; (minimal-palindromic-base 8675309)
8675308</code></pre>
<p>Huh. I think <a href="https://en.wikipedia.org/wiki/867-5309/Jenny">Jenny</a> has a secret. :)</p>
<p>That's pretty much it for the puzzle as stated, but there are still a few things that we can do. For example, we've only seen small examples. What if we want to find the number with the largest minimal palindromic base:</p>
<pre class="scheme"><code>; Find the number n which has the largest palindromic base
(define (maximal-minimal-palindromic-base n-min n-max)
  (for/fold ([b -1] [n #f]) ([i (in-range n-min (+ n-max 1))])
    (define mpb (minimal-palindromic-base i))
    (if (&gt; i b)
        (values mpb i)
        (values b   n))))</code></pre>
<p>I may or may not have just wanted an excuse to use a crazy long function name. :)</p>
<p>Give it a try:</p>
<pre class="scheme"><code>&gt; (maximal-minimal-palindromic-base 100 200)
7
200

&gt; (rebase 200 7)
'(4 0 4)</code></pre>
<p>Error, <code>maximal-minimal-palindromic-base</code> not found!</p>
<p>Okay, more seriously, what does that even look like? Let's <code><a href="http://docs.racket-lang.org/search/index.html?q=plot">plot</a></code>!</p>
<pre class="scheme"><code>(require plot)

; Plot a whole range of minimal palindromic bases
(define (plot-minimal-palindromic-bases n-min n-max)
  (plot (lines (for/list ([i (in-range n-min (+ n-max 1))])
                 (vector i (minimal-palindromic-base i)))
               #:color 6
               #:label "minimal palindromic base")))</code></pre>
<p>Basically, we're going to draw a chart relating each number to it's minimal palindromic base.</p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 100)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png" /></a></p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 1000)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png" /></a></p>
<p>Looks like like there's basically two behaviors. A background noise of really low bases (binary or trinary is often palindromic just because there aren't many digits) and a few spikes growing ever larger. Neat.</p>
<p>And that's it. Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/minimal-palindromic-base.rkt">minimal-palindromic-base.rkt</a></p>]]></content></entry><entry><title>Number words</title><link href="http://blog.jverkamp.com/2014/08/13/number-words" /><id>urn:uuid:67236730-531b-effa-30b3-b69308ea8187</id><updated>2014-08-13T14:00:00Z</updated><summary type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
<!--more-->
<p>That may look fairly straight forward. Basically, it's a <a href="https://en.wikipedia.org/wiki/parsing">parsing</a>/<a href="https://en.wikipedia.org/wiki/lexing">lexing</a> problem. You take a string as input and break it into a series of tokens (in this case, numbers 1-26); then each token is converted into a letter.</p>
<p>Unfortunately, it's a bit more complicated than that, since the grammar is ambiguous. Taking the example <code>1234</code> from above, should you parse that as <code>1 2 3 4 = ABCD</code>? Or what about <code>1 23 4 = AWD</code>? Or even <code>12 3 4 = LCD</code>? In a nutshell, we have to do all of them. So we want some sort of branching lexer that will try all possible routes.</p>
<p>So let's start with a function that meta-function that can make such a parser:</p>
<pre class="scheme"><code>; Make an optional parser
; If the regex matches, add it to each possible next parse
; If it does not, return an empty list (to be appendable)
(define (make-parser re)
  (λ (str)
    (match str
      [(regexp re (list _ n rest))
       (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
      [any
       '()])))</code></pre>
<p>Looks a bit funny, (especially since we haven't defined <code>number-&gt;words</code> yet), but basically we try to match the regular expression. If that works, make the recursive call (to <code>number-&gt;words</code>) and then append that string (as a character via <code>n->char</code>) to each recursive result. If there are no recursive results, this <code>map</code> will return an empty list. Likewise, if the regular expression doesn't match.</p>
<p>Next step, write the two parsers. We want to parse either a single digit number or a two digit number:</p>
<pre class="scheme"><code>; Create parsers for valid 1 digit and 2 digit letter numbers
(define parse-1 (make-parser #px"([1-9])(.*)"))
(define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))</code></pre>
<p>That's what makes the ambiguity the most interesting. If only <code>0</code> were a valid digit... As it is, there are four possible cases (and these two functions handle them all!):</p>
<ul>
    <li><code>str</code> starts with 1 and a digit 0-9, parse both</li>
    <li><code>str</code> starts with 2 and a digit 0-6, parse both</li>
    <li><code>str</code> starts with 2 and a digit 7-9, parse 2 digits only</li>
    <li><code>str</code> starts with 3-9, parse 1 digit only</li>
</ul>
<p>And finally, try both:</p>
<pre class="scheme"><code>; Base case, so we can stop eventually
(if (equal? str "")
    '("")
    (append (parse-1 str) (parse-2 str)))</code></pre>
<p>The base case looks a bit funny, since you might assume that if neither case matches we'll get there. That's the difference between the empty list <code>'()</code> and the list containing just an empty string <code>'("")</code>. In the latter, there's nothing to map against, ergo necessary.</p>
<p>And then all we need is the <code>n->char</code> function:</p>
<pre class="scheme"><code>; Convert a number 1-26 to a letter A-Z
(define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))</code></pre>
<p>And that's it. Put it all together:</p>
<pre class="scheme"><code>; Given 1-26 mapping to A-Z, determine all possible words represented by a number
; Correctly resolve ambiguities where 1234 -&gt; 1 2 3 4 = ABCD / 1 23 4 -&gt; AWD / 12 3 4 -&gt; LCD
(define (number-&gt;words str)
  ; Convert a number 1-26 to a letter A-Z
  (define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))

  ; Make an optional parser
  ; If the regex matches, add it to each possible next parse
  ; If it does not, return an empty list (to be appendable)
  (define (make-parser re)
    (λ (str)
      (match str
        [(regexp re (list _ n rest))
         (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
        [any
         '()])))

  ; Create parsers for valid 1 digit and 2 digit letter numbers
  (define parse-1 (make-parser #px"([1-9])(.*)"))
  (define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))

  ; Base case, so we can stop eventually
  (if (equal? str "")
      '("")
      (append (parse-1 str) (parse-2 str))))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (number-&gt;words "1234")
'("ABCD" "AWD" "LCD")

&gt; (number-&gt;words "8675309")
'("HFGECI")

&gt; (length (number-&gt;words "85121215231518124"))

1181

&gt; (number-&gt;words "85121215231518124")
'(... "HELLOWORLD" ...)</code></pre>
<p>I could claim that I just happen to know the number code for <code>HELLOWORLD</code>, but really I wrote a quick inverse function:</p>
<pre class="scheme"><code>; Convert words back to numbers
(define (words-&gt;number str)
  (define (char-&gt;n c) (number-&gt;string (- (char-&gt;integer c) 64)))
  (apply ~a (for/list ([c (in-string str)]) (char-&gt;n c))))</code></pre>
<p>Shiny!</p>
<p>Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/number-words.rkt">number-words.rkt</a></p>]]></content></entry><entry><title>Langton's ant</title><link href="http://blog.jverkamp.com/2014/08/07/langtons-ant" /><id>urn:uuid:e9c60746-187f-a46d-0c07-bb5bd223be2d</id><updated>2014-08-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<!--more-->
<p>First, let's define the problem. From Wikipedia: <a href="https://en.wikipedia.org/wiki/Langton's_ant">Langton's ant</a></p>
<blockquote>
    <p>Squares on a plane are colored variously either black or white. We arbitrarily identify one square as the "ant". The ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:</p>

    <ul>
        <li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
        <li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
    </ul>
</blockquote>
<p>That's actually pretty simple sounding, so let's just go ahead and jump into generalizing. Instead of only two states (<code>white</code> and <code>black</code>), let's generalize to an arbitrary number of states. Instead of flipping when the ant visits the state, instead advance to the next. That way, we can define ants quite simply:</p>
<ul>
    <li><code>LR</code> - an ant that turns left on state 1 to 2 and right on state 2 to 1 (the simple ant described above)</li>
    <li><code>LL</code> - an ant that always turns left; this one is boring, it just runs in circles</li>
    <li><code>LRRL</code> - a more complicated ant that turns left on either 1 to 2 or 4 to 1, but turns right on 2 to 3 or 3 to 4<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
</ul>
<p>Okay, fair enough. We also want to decide right now that we're going to support arbitrarily large grids. It would be a lot easier to define a certain region, since then we can use something like a 2-dimensional array to store the current states, but it's not actually any harder to support an unlimited grid. What we need is a way of associating a location with a state. Sounds like a job for a hash!</p>
<p>Except we need two points for a location. So we can either have nested hashes, or we can use a trick that I've used a time or two before: representings points as complex numbers. In this way, the point <code>(0, 0)</code> is the number <code>0+0i</code>; <code>(3, -7)</code> is <code>3-7i</code>. So long as we keep the numbers <code><a href="http://docs.racket-lang.org/search/index.html?q=exact">exact</a></code>, we should be able to use it as a hash key without issue.</p>
<p>Okay, so what do we need to represent the current state of a Langton's Ant simulation? We need the grid, that's true. But we also need the ant. More specifically, we need a location and current facing (since we need a direction to turn left/right from). Also, we'll need to store the current rule. We could keep this out of the structure, but since it's essentially the core of what we need to do, we'll put it in the <code><a href="http://docs.racket-lang.org/search/index.html?q=struct">struct</a></code>.</p>
<p>Something like this:</p>
<pre class="scheme"><code>(struct ant (rule location direction grid) #:transparent)
(define (make-ant rule) (ant rule 0 0+i (hash)))</code></pre>
<p>Okay, the rule is straight forward enough. Just a string of <code>L</code> or <code>R</code> characters. Location is a little stranger, but just remember that it's an exact complex number. So <code>0</code> is <code>0+0i</code> is <code>(0, 0)</code>. Direction takes some doing. Luckily though, it's going to make our math amazingly easy. Essentially, we're going to use complex multiplication. Taking from the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Rotation_(mathematics)">rotation</a>:</p>
<blockquote>
  <p>Points on the <span>\(R^2\)</span> plane can be also presented as complex numbers: the point <code>(x, y)</code> in the plane is represented by the complex number</p>

  <div>$$z = x + iy$$</div>

  <p>This can be rotated trhough an angle <span>\(\theta\)</span> by multiplying it by <span>\(e^{i\theta}\)</span>, then expanding the product using <a href="https://en.wikipedia.org/wiki/Euler's_formula">Euler's formula</a> as follows:</p>

  <p>...</p>
</blockquote>
<p>The important part is that Racket can do the complex multiplication for us. Even better, we only have to deal with two cases: left or right rotation by 90° / <span>\(\pi/2\)</span>. Expanding <span>\(e^{i\theta}\)</span>:</p>
<div>$$e^{i\pi/2} = i$$</div>
<div>$$e^{-i\pi/2} = -i$$</div>
<p>What's that? Left rotation is just multiplying by <span>\(i\)</span> and right rotation, multiplication by <span>\(-i\)</span>. Dang. That's easy. Take that, a rule to increment each state by one (modulus the number of states), and a rule to add the direction to the location (for the new location) and we have an update function.</p>
<pre class="scheme"><code>; Update an ant
(define (tick a)
  ; Unpack the previous ant, get the current cell
  (match-define (ant rule location direction grid) a)
  (define cell (hash-ref grid location 0))

  ; Rotate, multiply by e^iθ, which for 90° left or right is ±i
  (define new-direction (* direction (if (eq? #\L (string-ref rule cell)) 0+i 0-i)))

  ; Create and return the new ant
  ; Update the position via direction and move to the next state (wrapping)
  (ant rule
       (+ location new-direction)
       new-direction
       (hash-set grid location (remainder (+ cell 1) (string-length rule)))))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=match-define">match-define</a></code> is a great way to unpack the structure. <code>cell</code> holds the current state (since we need that both for the new facing and the new state). The direction is the multiplication as explained above and the new location just adds the old location and direction.</p>
<p>Nice and clean. I love it. Even better, it's completely functional. We're not actually mutating anything, even the call to <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-set">hash-set</a></code> creates a new hash rather than modifying the current one.</p>
<p>If we want to see the first few ticks of the <code>LR</code> ant:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (tick a)
(ant "LR" -1 -1 '#hash((0 . 1)))
&gt; (tick (tick a))
(ant "LR" -1-1i 0-1i '#hash((0 . 1) (-1 . 1)))
&gt; (tick (tick (tick a)))
(ant "LR" 0-1i 1 '#hash((0 . 1) (-1-1i . 1) (-1 . 1)))</code></pre>
<p>Take it from me, that's exactly what we're looking for. But it would be nice if we had a way to visualize it. Eventually, we'll want to generate actual images, but before we do that, let's do some ASCII art.</p>
<p>First, since the grid is allowed to grow unbounded, we first need to figure out how large of a grid we need to draw. Something like this:</p>
<pre class="scheme"><code>; Return the current bounds for an ant
(define (bounds a)
  (for/fold ([min-x +inf.0] [max-x -inf.0] [min-y +inf.0] [max-y -inf.0])
            ([(index cell) (in-hash (ant-grid a))])
    (values (min min-x (real-part index))
            (max max-x (real-part index))
            (min min-y (imag-part index))
            (max max-y (imag-part index)))))</code></pre>
<p>I like how <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> can be used to generate multiple values all at once, in this case both the min and max for both x and y.</p>
<p>Okay, with that, we render ASCII:</p>
<pre class="scheme"><code>; Render an ant into ASCII characters
(define (render/ascii a [charset " .:-=+*#%@"])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check the given charset
  (when (&gt; (string-length rule) (string-length charset))
    (error 'render-ascii "Charset is not longer enough, need ~a, given ~a" (string-length rule) (string-length charset)))

  ; Render an ASCII grid to current-output-port
  ; inexact-&gt;exact is necessary to avoid floating point hash errors
  (for ([y (in-range min-y (+ max-y 1))])
    (for ([x (in-range min-x (+ max-x 1))])
      (define p (inexact-&gt;exact (make-rectangular x y)))
      (display (string-ref charset (hash-ref grid p 0))))
    (newline)))</code></pre>
<p>We have a bit of error handling, which also unfortunately means that we can't deal with more than 10 characters. But it looks pretty good:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (render/ascii (tick a))
.
&gt; (render/ascii (tick (tick a)))
..
&gt; (render/ascii (tick (tick (tick a))))
.
..</code></pre>
<p>Hmm. Not very impressive. Let's write a function to do a bunch of ticks in a row.</p>
<pre class="scheme"><code>; Run multiple ticks sequentially
(define (fast-tick a n)
  (for/fold ([a a]) ([i (in-range n)])
    (tick a)))

&gt; (render/ascii (fast-tick a 10))
..
..
 ..

&gt; (render/ascii (fast-tick a 1000))
       ..    ..
      .  .    ..
     ...     .. .
  .. . ....     .
 .  ...     ..
.      ......  .
.   . ...  ..  .
.  ...   ..  . .
.   .      ......
.    .. ...   ....
.  .. ..  ...
 .   ....   ...... .
 ...  ...    .   ...
 . .. ....  .  .  .
      ..  .  .  ..
           ..</code></pre>
<p>Now, we're getting somewhere. Remember how we already built in some support for more than two character rules? Let's try a few more:</p>
<pre class="scheme"><code>&gt; (render/ascii (fast-tick (make-ant "LRL") 100))
   ..
  .  .
 .   :
.   .:
.   . .
 .    .
  .::.

&gt; (render/ascii (fast-tick (make-ant "LRRL") 100))
......
.----.
.::.
:---.
:... .
.::...</code></pre>
<p>Okay. A picture may be worth a thousand words, but these need a little work. Better yet would be an animation. To make that easier (using <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> as I often do), let's use <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code> to make some pretty pictures:</p>
<pre class="scheme"><code>; Render using htdp
(define (render/htdp a [colors '#("white" "black" "red" "blue" "green" "yellow" "magenta" "cyan" "gray" "pink")])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check that we have enough colors, then generate some
  (when (&gt; (string-length rule) (vector-length colors))
    (error 'render-ascii "Not enough colors, need ~a, given ~a" (string-length rule) (vector-length colors)))

  ; Generate the raw images
  (define images
    (for/list ([y (in-range   (- min-y 1) (+ max-y 2))])
      (for/list ([x (in-range (- min-x 1) (+ max-x 2))])
        (define p (inexact-&gt;exact (make-rectangular x y)))
        (define c (vector-ref colors (hash-ref grid p 0)))
        (define block (rectangle 10 10 "solid" c))
        (if (= p location)
            (rotate (case direction [(0+i) 0] [(1) 90] [(0-i) 180] [(-1) 270])
                    (overlay (isosceles-triangle 5 45 'outline "red")
                             (isosceles-triangle 5 45 'solid "black")
                             block))
            block))))

  ; Combine them
  (define null (empty-scene 0 0))
  (foldl above null (map (λ (row) (foldl beside null row)) images)))</code></pre>
<p>Even better, this time we have the actual ant represented as a red outlined triangle (to show facing). Let's render a few of those previous images:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 10))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png" /></a></p>
<p>Beautiful. Let's animate it:</p>
<pre class="scheme"><code>; Simulate a rule using big bang
(define (simulate rule [width 800] [height 600])
  (define background (empty-scene width height))
  (big-bang (make-ant rule)
    [on-tick tick]
    [to-draw (λ (ant) (overlay (render/2htdp ant) background))]
    [record? #t]))</code></pre>
<p>I love how what should theoretically be the most complicated part is actually so simple. Both the basic simulation itself (8 lines without comments) and the simulation loop (6 lines) are tiny. The rendering is a bit worse, but still not that bad. And you can get some <em>crazy</em> behavior with these things...</p>
<pre class="scheme"><code>&gt; (simulate "LR")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<pre class="scheme"><code>&gt; (simulate "LRRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif" /></a></p>
<p>It's interesting how this one makes such a regular grid.</p>
<pre class="scheme"><code>&gt; (simulate "LRRRLRLRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif" /></a></p>
<p>And this one is forming a nice black (state 1) border which keeps getting pushed out further and further.</p>
<p>The basic Langton's Ant (<code>LR</code>) is actually fairly famous for it's behavior:</p>
<ul>
  <li><em>simplicity</em> - &lt; ~300 steps, simple, symmetric patterns</li>
  <li><em>chaos</em> - &lt; ~10,000 steps, large irregular blocks</li>
  <li><em>order</em> - &gt; ~10,000 steps, a recurrent "highway" cycle, 104 blocks in length</li>
</ul>
<p>Examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 300))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 9000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 11000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 15000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png" /></a></p>
<p>Let it run forever, it just runs off in that one direction. It's actually really interesting:</p>
<blockquote>
  <p>Finally the ant starts building a recurrent "highway" pattern of 104 steps that repeat indefinitely. All finite initial configurations tested eventually converge to the same repetitive pattern, suggesting that the "highway" is an attractor of Langton's ant, but no one has been able to prove that this is true for all such initial configurations. It is only known that the ant's trajectory is always unbounded regardless of the initial configuration[4] – this is known as the Cohen-Kung theorem.</p>
  <p>-- <a href="https://en.wikipedia.org/wiki/Langton's_Ant">Langton's Ant</a></p>
</blockquote>
<p>And that's about it. Surprisingly simple, yet awesome emergent behavior.</p>
<p>Here are a few more fun examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "RLLRR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>That's actually an interesting aspect: repeated rules form the same patterns, just with different colors. This makes sense if you think about it, since you're getting the same pattern of <code>L</code> and <code>R</code>, just on a larger space. So:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>And that's it for today. Take a look; if you find any other awesome patterns, leave a comment! If you want to see the entire source, you can do so (as always) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/langtons-ant.rkt">langtons-ant.rkt</a></p>]]></content></entry></feed>