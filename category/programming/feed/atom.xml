<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-11-13T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>A "one" line echo server using let in Racket</title><link href="http://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket" /><id>urn:uuid:6f76d2a6-0b14-4d60-7cba-7ede454fd445</id><updated>2014-11-13T00:00:00Z</updated><summary type="html"><![CDATA[<p>A recent post on Reddit caught my attention: <a href="https://www.reddit.com/r/Python/comments/2m6d4z/a_one_line_echo_server_using_let_in_python/">A “One” Line Echo Server Using “let” in Python</a> (<a href="http://sigusr2.net/one-line-echo-server-using-let-python.html">original article</a>). The basic idea is that you can use Python's <code>lambda</code> with default arguments as a <code>let</code>, which in turn allows you to write a simple <a href="https://en.wikipedia.org/wiki/echo_server">echo server</a> in <del>one line</del> a nicely functional style.</p>
]]></summary><content type="html"><![CDATA[<p>A recent post on Reddit caught my attention: <a href="https://www.reddit.com/r/Python/comments/2m6d4z/a_one_line_echo_server_using_let_in_python/">A “One” Line Echo Server Using “let” in Python</a> (<a href="http://sigusr2.net/one-line-echo-server-using-let-python.html">original article</a>). The basic idea is that you can use Python's <code>lambda</code> with default arguments as a <code>let</code>, which in turn allows you to write a simple <a href="https://en.wikipedia.org/wiki/echo_server">echo server</a> in <del>one line</del> a nicely functional style.</p>
<!--more-->
<p>To start with, here is their original code:</p>
<pre class="scheme"><code>import socket
import itertools

(lambda port=9000, s=socket.socket(socket.AF_INET, socket.SOCK_STREAM):
      s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) == None and
      s.bind(('', port)) == None and
      s.listen(5) == None and
      list(map(lambda c:
                  c[0].sendall(c[0].recv(1024)) and
                  c[0].close(),
               (s.accept() for _ in itertools.count(1)))))()</code></pre>
<p>It's certainly not very Pythonic, but there are a few neat tricks in there:</p>
<ul>
    <li>Using <code>lambda</code> with default arguments to define things</li>
    <li>Using <code>and</code> to sequence function calls</li>
    <li>Using list comprehension to handle the response threads</li>
</ul>
<p>It got me thinking though, what would the same sort of code look like in Racket?</p>
<p>Well, one of the draws Racket advertises (rightfully so) on its <a href="http://racket-lang.org">home page</a> is that it comes <a href="http://docs.racket-lang.org/">batteries included</a>. That means that if you're using <code><a href="http://docs.racket-lang.org/search/index.html?q=#lang racket">#lang racket</a></code>, you get a bunch of useful functions for TCP built in. Let's start with a fairly direct translation:</p>
<pre class="scheme"><code>(let ([s (tcp-listen 9000)])
  (sequence-&gt;list
   (sequence-map
    (λ (in+out) (thread (thunk (apply copy-port in+out))))
    (in-producer (thunk (call-with-values (thunk (tcp-accept s)) list))))))</code></pre>
<p>Okay, so that looks really weird. But it's a fairly straight forward translation. A few of the lines got folded into the <code><a href="http://docs.racket-lang.org/search/index.html?q=tcp-connect">tcp-connect</a></code> call and the list comprehension became a <code><a href="http://docs.racket-lang.org/search/index.html?q=in-producer">in-producer</a></code> <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence">sequence</a></code>. It's kicked off via <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence-map">sequence-map</a></code> and forced to run to termination (which will never happend) with <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence->list">sequence->list</a></code>. Unfortunately, it has the same problem that the original Python code does. Since we're constructing a list, we'll eventually run out of memory.</p>
<p>One interesting addition it does that the Python version didn't is that it both allows for multiple lines (the Python version would read one packet and hang up) and any amount of data. I've never actually used the <code><a href="http://docs.racket-lang.org/search/index.html?q=copy-port">copy-port</a></code> function before. It's really cool!</p>
<p>If we broaden our definition of "one" line a little more to allow <code><a href="http://docs.racket-lang.org/search/index.html?q=for">for</a></code> sequences (which aren't really that different under the hood), we can clean it up a bit to this:</p>
<pre class="scheme"><code>(let ([s (tcp-listen 9000)])
  (for ([(in out) (in-producer (thunk (tcp-accept s)))])
    (thread (thunk (copy-port in out)))))</code></pre>
<p>This is especially nice, since <code><a href="http://docs.racket-lang.org/search/index.html?q=in-producer">in-producer</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=for">for</a></code> work together to deal with the multiple values from <code><a href="http://docs.racket-lang.org/search/index.html?q=tcp-accept">tcp-accept</a></code>. Very clean.</p>
<p>Actually, I may have to put this in my quick-scripts toolbox. There are a fair few times when writing networking clients that having a dead simple echo server could come in handy.</p>]]></content></entry><entry><title>Clockception</title><link href="http://blog.jverkamp.com/2014/11/04/clockception" /><id>urn:uuid:9a2e2d18-6c68-f33b-e456-aa1c1b531f62</id><updated>2014-11-04T09:00:00Z</updated><summary type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<!--more-->
<p>I got the basic idea for this post from <a href="http://io9.com/these-stylish-minimalistic-clocks-let-you-tell-time-wit-1652202065">this post</a> on io9. That first clock ought to look awfully familiar (although theirs looks a bit better). Let's see how we can make one of our own.</p>
<p>First, some basic structure:</p>
<pre class="scheme"><code>(struct time-data (hour minute second) #:transparent)

(define (time hour minute [second #f])
  (time-data hour minute second))

(define current-size (make-parameter 30))</code></pre>
<p>This will represent the times that we are dealing with. I specifically broke the <code>time-data</code> structure and <code>time</code> function apart, since I wanted to have optional parameters. There is an <code>#:auto</code> option for struct fields, but it doesn't quite do what I want. Finally, <code>current-size</code> will be the width of each individual analog clock.</p>
<p>Speaking of which, let's draw some basic analog clocks. I went through several different Racket drawing libraries (<code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>) before finally settling on <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>. I'm sure any of them could be used, but I just kept running into odd issues with coordinates.</p>
<pre class="scheme"><code>; Render a clock at the current-size
(define (analog-clock when)
  (match-define (time-data hour minute second) when)

  (define size (current-size))
  (define target (make-bitmap size size))
  (define dc (new bitmap-dc% [bitmap target]))

  (send dc set-pen "lightgray" 1 'solid)
  (send dc draw-ellipse 0 0 size size)
  (send dc set-pen "black" 1 'solid)

  ; Helper to draw a hand given a radius [0, 1.0] and angle
  ; Angle of 0 is upright, positive angles are clockwise
  (define (draw-hand! r θ)
    (define c (/ size 2))
    (define x (+ c (* 0.5 r size (cos θ))))
    (define y (+ c (* 0.5 r size (sin θ))))
    (send dc draw-line c c x y))

  (draw-hand! 0.8 (+ (* pi 1.5) (* 2 pi (/ minute 60))))
  (draw-hand! 0.7 (+ (* pi 1.5) (* 2 pi (/ hour 12))))

  (and second
       (begin
         (draw-hand! 0.9 (+ (* pi 1.5) (* 2 pi (/ second 60))))))

  target)</code></pre>
<p>The basic idea of <code>racket/draw</code> is that you have a sort of canvas (<code>target</code>) on which you can draw. You then issue a series of commands that either change your state (<code><a href="http://docs.racket-lang.org/search/index.html?q=set-pen">set-pen</a></code>) or draw (<code><a href="http://docs.racket-lang.org/search/index.html?q=draw-ellipse">draw-ellipse</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=draw-line">draw-line</a></code>). I did abstract a little bit the function to create the clock hands: <code>draw-hand!</code>, mostly so I wouldn't have to redo the centering offset (<code>c</code>, since <code>0,0</code> is in the top left, not the center as I'd hoped) and the <a href="https://en.wikipedia.org/wiki/trigonometry">trigonometry</a> to convert a radius and angle to x and y.</p>
<p>And that's actually all you need to make a basic clock:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 4 10)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Straight forward enough. What's especially neat is that because radians cycle every two 2π rotations, you can put in some crazy times:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 208 -350)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Cool. Okay, next step. Let's figure out how to animate these, so we can transition from one time to another. In this, I had two options. Either I could move as a clock moves (where the minute hand has to move an entire rotation for the hour hand to move 1/12) or independently (such that both hands move at the same speed). Because it's both less code and honestly works better in the final result, I went with the second option:</p>
<pre class="scheme"><code>; Render a sequence of frames animating a clock spinnging from one time to another
; Hands will always move clockwise but will both move at once (not as a normal clock)
(define (analog-frames α β frames)
  (match-define (time-data α-hour α-minute α-second) α)
  (match-define (time-data β-hour β-minute β-second) β)

  (let ([β-hour   (if (&gt;= β-hour α-hour)     β-hour    (+ β-hour 12))]
        [β-minute (if (&gt;= β-minute α-minute) β-minute (+ β-minute 60))]
        [β-second (and α-second β-second
                       (if (&gt;= β-second α-second) β-second (+ β-second 60)))])

    (for/list ([i (in-range frames)])
      (define frame-multiplier (/ i frames))

      (define hour (+ α-hour (* frame-multiplier (- β-hour α-hour))))
      (define minute (+ α-minute (* frame-multiplier (- β-minute α-minute))))

      (define second
        (and α-second β-second
             (+ α-second (* frame-multiplier (- β-second α-second)))))

      (analog-clock (time hour minute second)))))</code></pre>
<p>Basically, we will loop through the frames and interpolate for each frame. The <code>frame-multiplier</code> will range evenly from 0 to 1 over the course of the frames. Also, the <code>let</code> block setting <code>β-hour</code> etc is to make sure that the clocks rotate clockwise. Since the second (<code>β</code>) value will always be higher, we always rotate right.</p>
<p>Okay, next let's switch gears and make some digital clocks. Since the eventual end goal was to make clocks out of clocks, I wanted a nice blocky font, built out of only a few different pieces. That way we could animate it more easily. Luckily the Unicode <a href="https://en.wikipedia.org/wiki/box-drawing_characters">box-drawing characters</a> will do exactly what we need:</p>
<p>I went with a 3x3 character map for each letter:</p>
<pre class="scheme"><code>(define digits
  (vector "┌─┐│ │└─┘" ; 0
          "─┐  │ ─┴─" ; 1
          " ─┐┌─┘└──" ; 2
          "──┐ ─┤──┘" ; 3
          "  │└─┤  │" ; 4
          "┌─ └─┐──┘" ; 5
          "│  ├─┐└─┘" ; 6
          "──┐  │  │" ; 7
          "┌─┐├─┤└─┘" ; 8
          "┌─┐└─┤  │" ; 9
          " │     │ " ; delimiter
          " ○     ○ "))</code></pre>
<p>If you straighten them out, you have things like this for 5 for example:</p>
<pre>┌─
└─┐
──┘</pre>
<p>They're not perfect, but I think they have a certain sort of charm.</p>
<p>Putting that all together, we can loop across all of the digits in the final clock and then each character that makes them up:</p>
<pre class="scheme"><code>; Render a digital clock using ascii bar graphics
(define (digital-clock when)
  (match-define (time-data hour minute second) when)

  (string-join
   (for/list ([line-index (in-range 3)])
     (list-&gt;string
      (for*/list ([digit
                   (in-list
                    (append (list (if (&lt; hour 10) 0 (quotient hour 10))
                                  (remainder hour 10)
                                  10
                                  (if (&lt; minute 10) 0 (quotient minute 10))
                                  (remainder minute 10))
                            (if second
                                (list 10
                                      (if (&lt; second 10) 0 (quotient second 10))
                                      (remainder second 10))
                                (list))))]
                  [char-index (in-range 3)])

        (define str (vector-ref digits digit))
        (define char (string-ref str (+ char-index (* line-index 3))))

        char)))
   "\n"))</code></pre>
<p>It's a bit ugly, but the bulk of the code is to make sure that we have enough digits for numbers less than 10. I bet I could do something nice with string formatting, but it works well enough. An example:</p>
<pre class="scheme"><code>&gt; (digital-clock (time 4 10))
"┌─┐  │ │ ─┐ ┌─┐\n│ │└─┤    │ │ │\n└─┘  │ │ ─┴─└─┘"</code></pre>
<p>Oops.</p>
<pre class="scheme"><code>&gt; (display (digital-clock (time 4 10)))
┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</code></pre>
<p>Much better.</p>
<p>Okay, now we're at the point of no return. How do we turn a digital clock with that 3x3 font into smaller clocks?</p>
<p>First, we need a map of the bar characters to times:</p>
<pre class="scheme"><code>; Convert the bar images used back into clocks
(define bar-&gt;clock
  (hash #\└ (time 3 0 0)
        #\┘ (time 9 0 0)
        #\┼ (time 6 0 30)
        #\─ (time 3 45 45)
        #\┴ (time 6 45 15)
        #\├ (time 3 0 30)
        #\┤ (time 9 30 0)
        #\┬ (time 6 15 45)
        #\┌ (time 3 30 30)
        #\┐ (time 9 30 30)
        #\│ (time 12 30 30)
        #\○ #f
        #\space #f))</code></pre>
<p>These could probably use a little more tuning. But what this does allow us to make is a very simple function to make a clock out of clocks:</p>
<pre class="scheme"><code>(define timeless (make-parameter (time 12 0 0)))

; Make a clock out of clocks!
(define (clock-clock when)
  (define chars (digital-clock when))
  (define empty-frame (analog-clock (timeless)))

  (define rows
    (for/list ([line (in-list (string-split chars "\n"))])
      (for/list ([char (in-string line)])
        (cond
          [(hash-ref bar-&gt;clock char) =&gt; analog-clock]
          [else empty-frame]))))

  (apply above (map (curry apply beside) rows)))</code></pre>
<p>In use:</p>
<pre class="scheme"><code> &gt; (clock-clock (time 4 10)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>That right there is actually one of the parts of programming I love the most. Where you write a small pile of functions, each of which does one specific piece and then when you finally get to the big overall algorithm... bam. Simple.</p>
<p>But... back to being a little more complicated. How do we do the transition from one <code>clock-clock</code> to another? It would be nice if we could use the previous function, but we really can't. A similar idea will work though:</p>
<pre class="scheme"><code>; Animate a clock of clocks turning from one time to another
(define (tick-tock α β frames)
  (define α-chars (digital-clock α))
  (define β-chars (digital-clock β))

  (define rows*
    (for/list ([α-line (in-list (string-split α-chars "\n"))]
               [β-line (in-list (string-split β-chars "\n"))])
      (for/list ([α-char (in-string α-line)]
                 [β-char (in-string β-line)])
        (analog-frames (or (hash-ref bar-&gt;clock α-char) (timeless))
                       (or (hash-ref bar-&gt;clock β-char) (timeless))
                       frames))))

  (for/list ([i (in-range frames)])

    (define rows
      (for/list ([row (string-split α-chars "\n")]
                 [row-index (in-naturals)])
        (for/list ([char-index (in-range (string-length row))])
          (list-ref (list-ref (list-ref rows* row-index) char-index) i))))

    (apply above (map (curry apply beside) rows))))</code></pre>
<p>Basically, we have two steps. First we define <code>rows*</code> by generating each of the subclocks for each of the intermediate times. Then, that last is in the wrong order (indexed by row, column, then frame, rather than frame, row, then column) so we unpack it and put it back together. This is pretty terribly inefficient, but there will only ever be 3 rows and up to 20 columns, so it's not that bad.</p>
<p>With that, we can make simple animations:</p>
<pre class="scheme"><code>&gt; ; Fix bitmaps so that big-bang / run-movie / etc can render them
&gt; (define (fix img) (rotate 0 img))
&gt; (run-movie 0.1 (tick-tock (time 7 59) (time 8 0) 56))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<p>I really wish that <code>fix</code> wasn't necessary, but for whatever reason, <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> / <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> / et al don't like <code><a href="http://docs.racket-lang.org/search/index.html?q=bitmap%">bitmap%</a></code>s. So it goes.</p>
<p>On the other hand though, <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is really cool. I've been doing things like this with <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> and the <code>stop-when</code> parameter, but this just needs a list of images and stops automatically. Another tool for my toolchest!</p>
<p>Okay, one more step. I know I just said <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is the new shiny, but let's step back to <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> for a second. Given that we have a clock made of clocks, what would it take to actually render it in real time?</p>
<pre class="scheme"><code>; Make a tick-tock real time clock
(define (tick-tock-real-time-clock #:12-hour? [12-hour? #f])
  ; Get the current time in hours/minutes/seconds
  (define (now)
    (define date (current-date))
    (time (date-hour date) (date-minute date) #f))

  ; Generate a list of frames for the next transition
  ; Note: The big bang clock is supposed to tick 28 times per second
  (define (transition-frames)
    (match-define (time-data hour minute _) (now))

    (define next-minute (remainder (+ minute 1) 60))
    (define next-hour (remainder (if (= next-minute 60) (+ hour 1) hour) (if 12-hour? 12 24)))

    (tick-tock (time hour minute)
               (time next-hour next-minute)
               56)) ; Note: The big bang clock is supposed to
                    ; tick 28 times per second

  (big-bang (list (now) (transition-frames))
    [on-tick
     (λ (state)
       (match-define (list old-time frames) state)
       (define new-time (now))
       (cond
         ; We've advanced to the new time, jump ahead!
         [(not (equal? old-time new-time))
          (list new-time (transition-frames))]
         ; Freeze if we only have one frame left
         [(null? (rest frames))
          state]
         ; Otherwise, advance one frame
         [else
          (list old-time (rest frames))]))]
    [to-draw
     (λ (state)
       (match-define (list old-time frames) state)
       (fix (first frames)))]))</code></pre>
<p>Now that is a cool function. Basically, each minute we will generate the frames that will be used by the transition. Since <code>big-bang</code> runs at 28 frames per second, the 56 frames will takes 2 seconds to animate. Each minute, the next transition will be generated and then ticked down one frame at a time until only one is left, at which point we will just wait. Neat!</p>
<p>Originally I had it rendering seconds as well, but it was just a little bit too jittery. So minutes it is! I can't really do this thing justice in a gif (it actually looks just like <code>tick-tock</code> above, just with the current time), but it's still pretty cool.</p>
<p>And... that's it. Clocks made of clocks. Who would have thought? As always, the full code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/clockception.rkt">clockception.rkt</a></p>]]></content></entry><entry><title>Tile Puzzle</title><link href="http://blog.jverkamp.com/2014/10/28/tile-puzzle" /><id>urn:uuid:073afc5c-1121-544c-5879-486d124edb3c</id><updated>2014-10-28T00:00:00Z</updated><summary type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
]]></summary><content type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
<!--more-->
<p>Okay, let's start at the beginning. How are we going to represent a puzzle? Well, let's go with the same basic idea that was described in the original post: sets of four letters (in the order north, east, south, west), one for each tile. Furthermore, the letters represent color. Originally CMYK for cyan, magenta, yellow, and black, but we'll also add RGB for red, green, and blue (it's easy enough to add colors). Next, we'll use upper case and lower case letters in order to represent the two halves of a matching image.</p>
<p>So take the unsolved image above:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a></p>
<p>The first tile would be described as <code>cymK</code> for three circles and one rectangle. Continuing on, the entire puzzle would be:</p>
<pre class="scheme"><code>'("cymK" "KyCy" "ymkc" "mkYc" "MycK" "mCkY" "cmKY" "KYmC" "McMk")</code></pre>
<p>Now we'll want two helper functions:</p>
<pre class="scheme"><code>; Insert an item into the given location in a list
(define (insert-at ls item x)
  (for/list ([i (in-naturals)]
             [el (in-list ls)])
    (if (= x i) item el)))

; Return a list of all rotated versions of a string
(define (rotations str)
  (for/list ([i (in-range (string-length str))])
    (string-append (substring str i) (substring str 0 i))))</code></pre>
<p>Specifically, the first function allows us to insert a tile into a specified location in a list, while the second returns all possible rotations of our four character string. All around, things are going to be a little inefficient because we're working with lists rather than directly accessing something like a vector, but since the size of the puzzle is so small, the cost for these functions will be relatively cheap (especially compared to the crazy number of possible orderings of the tiles).</p>
<p>Okay, with that, we actually have enough of a framework to work out our solution. The basic plan of attack will be very much the same as when we worked on the <a href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens">N Queens Puzzle</a>. Place each piece in order, backtracking as soon as we see a valid solution. This way we can cut out huge swaths of the potential solution space.</p>
<pre class="scheme"><code>; Solve a puzzle by ordering pieces so that they match
(define (solve puzzle)
  ; Start with an empty solution space (all null) and a list of pieces to place
  (let loop ([solution (make-list (length puzzle) "\0\0\0\0")]
             [to-place puzzle]
             [index    0])
    (cond
      ; If we've filled in all of the pieces, we have a solution
      [(= index (length puzzle))
       solution]
      ; Otherwise, try each piece, only recurring for those that fit
      ; Return the first that solves the puzzle from here,
      ; by recursion this will be a full solution
      [else
       (for*/first ([next-item (in-list to-place)]
                    [next-item-rotated (in-list (rotations next-item))]
                    [next-puzzle (in-value (insert-at solution
                                                      next-item-rotated
                                                      index))]
                    #:when (valid? next-puzzle)
                    [recur (in-value (loop next-puzzle
                                           (remove next-item to-place)
                                           (+ index 1)))]
                    #:when recur)
         recur)])))</code></pre>
<p>Basically there are two interesting parts: the <code>let loop</code> and the <code>for*/first</code> block. The main <code>loop</code> is the primary bit of the recursion. At any particular step, we have the solution that we've built thus far. We'll start with all <code>\0</code> strings (which we'll special case in <code>valid?</code>) and then fill in puzzle pieces one at a time. <code>to-place</code> will hold the pieces we've yet to place. The <code>index</code> is used primarily to insert new pieces at the proper location.</p>
<p>Next, we have the <code>for*/first</code> loop. This is designed to clean up the search, basically by returning the first recursion that makes it through all of the lists and conditionals. Specifically, we're going to do all of the following:</p>
<ul>
  <li>Loop through all remaining pieces to place as <code>next-item</code></li>
  <li>For each piece, try each rotation in turn</li>
  <li>Generate the <code>next-puzzle</code> by inserting that piece</li>
  <li>Check that the new insertion is <code>valid?</code></li>
  <li>Recur with the newly placed piece removed</li>
  <li>If there's a valid solution, continue to the body of the loop (and thus return, since we're looking for the <code>first</code>)</li>
</ul>
<p>All that combines (with the power of recursion!) to solve the puzzle:</p>
<pre class="scheme"><code>&gt; (solve '("cymK" "KyCy" "ymkc"
           "mkYc" "MycK" "mCkY"
           "cmKY" "KYmC" "McMk"))
'("cymK" "mCkY" "ymkc"
  "McMk" "KYmC" "KyCy"
  "mkYc" "MycK" "cmKY")</code></pre>
<p>Of course that's a little hard to see what in the world is going on. Let's write a few functions using Racket's <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code> library. First, a <code><a href="http://docs.racket-lang.org/search/index.html?q=parameter">parameter</a></code> to control how large each tile will be and a pair of functions to decode the letters into colors / shapes:</p>
<pre class="scheme"><code>(define current-tile-size (make-parameter 50))

(define (char-&gt;color c)
  (case c
    [(#\R #\r) "red"]
    [(#\G #\g) "green"]
    [(#\B #\b) "blue"]
    [(#\C #\c) "cyan"]
    [(#\M #\m) "magenta"]
    [(#\Y #\y) "yellow"]
    [(#\K #\k) "black"]
    [else      "white"]))

(define (char-&gt;shape c)
  (case c
    [(#\R #\G #\B #\C #\M #\Y #\K) filled-rectangle]
    [(#\r #\g #\b #\c #\m #\y #\k) filled-ellipse]
    [(#\null)                      (λ _ (filled-rectangle 0 0))]))</code></pre>
<p>With those, we can render an individual tile:</p>
<pre class="scheme"><code>; Render a single tile given a four character specifier
; Order is top, right, bottom, left
; Colors are cyan, magenta, yellow, red, green, blue, black (k for black)
; Uppercase are square, lowercase are circular
(define (render-tile tile)
  (match-define (list top right bottom left) (string-&gt;list tile))

  ; Size of the individual images
  (define quad-size (quotient (current-tile-size) 3))

  ; Offsets for pinning, zero/half/full size adjusted for quad size
  (define zs (- (quotient quad-size 2)))
  (define hs (- (quotient (current-tile-size) 2) (quotient quad-size 2)))
  (define fs (- (current-tile-size) (quotient quad-size 2)))

  ; Helper function to render a specific shape of the specific color
  (define (shape c)
    (colorize ((char-&gt;shape c) quad-size quad-size)
              (char-&gt;color c)))

  ; Construct the image by layering each of the four sides on the base
  (let* ([pict (rectangle (current-tile-size) (current-tile-size))]
         [pict (pin-under pict hs zs (shape top))]
         [pict (pin-under pict fs hs (shape right))]
         [pict (pin-under pict hs fs (shape bottom))]
         [pict [pin-under pict zs hs (shape left)]])
    (clip pict)))</code></pre>
<p>One part that took a bit here was getting the <code>zs</code>, <code>hs</code>, and <code>fs</code> functions correct. Since coordinates are based on the top left corner of each subimage, we need to correctly offset by half of the image sizes for each of the halfway points. Also, make sure you use the <code><a href="http://docs.racket-lang.org/search/index.html?q=clip">clip</a></code> function. It will look fine with just a single tile if you do not use it, but once you start merging them... Strange things happen.</p>
<p>Demo time:</p>
<pre class="scheme"><code> &gt; (render-tile "cymK") </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png" /></a></p>
<p>Nice!</p>
<p>Next, we can combine the <code>picts</code> into a single larger <code>pict</code>:</p>
<pre class="scheme"><code>; Render a puzzle of multiple tiles
; Puzzles are assumed to be square
(define (render puzzle)
  (define width (integer-sqrt (length puzzle)))

  (define tiles
    (for/list ([y (in-range width)])
      (for/list ([x (in-range width)])
        (render-tile (list-ref puzzle (+ x (* y width)))))))

  (define rows
    (map (λ (row) (apply (curry hc-append -1) row)) tiles))

  (apply (curry vc-append -1) rows))</code></pre>
<p>Bam:</p>
<pre class="scheme"><code>&gt; (render (solve '("cymK" "KyCy" "ymkc"
                   "mkYc" "MycK" "mCkY"
                   "cmKY" "KYmC" "McMk")))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>Neat! We can try it on larger puzzles as well:</p>
<p>...</p>
<p>Okay, that takes a really long time. Perhaps a 4x4 with more colors (more colors is actually easier to solve since there are less valid placements for each tile):</p>
<pre class="scheme"><code>&gt; (define p4x4 (random-puzzle 4 #:colors 7))
&gt; p4x4
'("yyMY" "mCKM" "Cgrr" "BMMy"
  "MrYB" "mGYK" "BRyG" "gRmc"
  "KCCm" "cyby" "mYbY" "BMcB"
  "Bmbm" "kbrr" "MkYc" "ybGY")
&gt; (render p4x4)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png" /></a></p>
<pre class="scheme"><code>&gt; (define p4x4-solution (solve p4x4))
&gt; p4x4-solution
'("rCgr" "BBMc" "YmYb" "yBMM"
  "GBRy" "mBmb" "ycyb" "mKCC"
  "rkbr" "MmCK" "YyyM" "cMkY"
  "BMrY" "cgRm" "YybG" "KmGY")
&gt; (render p4x4-solution)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png" /></a></p>
<p>Shiny. :)</p>
<p>For those interested, here's how I generated random puzzles:</p>
<pre class="scheme"><code>; Generate random puzzles
(define (random-puzzle size #:colors [colors 4])
  ; Generate n+1 intersections (including those off the edges)
  ; Each value is the top left corner of a tile with the right then down edge
  (define intersections
    (for/list ([y (in-range (+ size 1))])
      (for/list ([x (in-range (+ size 1))])
        (for/list ([which (in-list '(right down))])
          (list (string-ref "CMYKRGB" (random (min colors 7)))
                (if (= 0 (random 2)) 'normal 'inverse))))))

  (define (@ x y w invert?)
    (match-define (list char mode)
      (list-ref (list-ref (list-ref intersections y) x)
                (if (eq? w 'right) 0 1)))

    ((if (xor invert? (eq? mode 'inverse))
         char-downcase
         identity)
     char))

  ; Fill out the tiles
  (shuffle
   (for*/list ([y (in-range size)]
               [x (in-range size)])
     (string (@ x       y       'right #f)
             (@ (+ x 1) y       'down  #f)
             (@ x       (+ y 1) 'right #t)
             (@ x       y       'down  #t)))))</code></pre>
<p>And that's it. Surprisingly simple<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> to solve, a little more to render. I love problems like this. :)</p>
<p>If you really want to go off the deep end though and, go download the full source from GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/tile-puzzles.rkt">tile-puzzles.rkt</a>). Therein lies solutions for using <a href="https://en.wikipedia.org/wiki/simulated_annealing">simulated annealing</a> or <a href="https://en.wikipedia.org/wiki/genetic_algorithms">genetic algorithms</a> in an effort to solve the problem more <a href="https://en.wikipedia.org/wiki/heurisitically">heurisitically</a>, but neither is working particularly well as of yet. If you want to take one of those and finish it up, I'd love to see it.</p>]]></content></entry><entry><title>Regular Expression Fractals</title><link href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals" /><id>urn:uuid:32f94d69-d55a-a14d-ef3c-5252a500522e</id><updated>2014-10-05T00:00:00Z</updated><summary type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
<!--more-->
<p>At the end, each point in the image will have a 'path' of decisions that got you there, making a string of the numbers 1, 2, 3, and 4.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png" /></a></p>
<p>How does that translate into code?</p>
<pre class="scheme"><code>; Generate a fractal by matching a recursive path into an image
(define (regex-fractal regex size)
  (flomap-&gt;bitmap
   (build-flomap*
    3 size size
    (λ (x y)
      (let loop ([t 0] [l 0] [s size] [path ""])
        (cond
          ; If we're at the last level, white, otherwise black
          [(&lt;= s 1)
           (cond
             [(regexp-match regex path) '#(1 1 1)]
             [else                      '#(0 0 0)])]
          ; Otherwise, divide the region into four subregions
          ; Recur into whichever our current pixel is in
          [else
           (define s/2 (quotient s 2))
           (define x-mid (+ l s/2))
           (define y-mid (+ t s/2))
           (loop
            (if (&lt; y y-mid) t y-mid)
            (if (&lt; x x-mid) l x-mid)
            s/2
            (~a path
                (match (list (&lt; y y-mid) (&lt; x x-mid))
                  ['(#t #t) 2]
                  ['(#t #f) 1]
                  ['(#f #t) 3]
                  ['(#f #f) 4])))]))))))</code></pre>
<p>That's actually pretty close to a lot of the fractal code we've been writing recently. And it generates some pretty cool images already:</p>
<pre class="scheme"><code> &gt; (regex-fractal #px"(13|31|24|42)" 256) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png" /></a></p>
<p>But we can do a little better than that. Let's parameterize a few things:</p>
<pre class="scheme"><code>(define current-size     (make-parameter 64))
(define current-coloring (make-parameter (thunk* '#(1 1 1))))
(define current-mode     (make-parameter 'short))</code></pre>
<p>Specifically, we'll pull the size out, but also add two more parameters. A mode to short circuit (so that as soon as the pattern matches, return, rather than calculating the entire depth of the image) and another to color the pixel based on a specific match. As an example coloring, consider this:</p>
<pre class="scheme"><code>; Get the maximum path length; useful for making gradients
(define (size-&gt;path-length size)
  (inexact-&gt;exact (floor (/ (log size) (log 2)))))

; Color a pixel based on how long of a match group we have
(define (color-by-length m)
  (define l (string-length (car m)))
  (define p (size-&gt;path-length (current-size)))
  (if (= l p)
      '#(1 1 1)
      (vector
       (if (&gt;= (length m) 3) (/ (string-length (list-ref m 2)) p) 0)
       (if (&gt;= (length m) 2) (/ (string-length (list-ref m 1)) p) 0)
       (if (&gt;= (length m) 4) (/ (string-length (list-ref m 3)) p) 0))))</code></pre>
<p>Now, let's take another example, one where the matching group must contain a 1. But now, color based on how much of the path is before the one:</p>
<pre class="scheme"><code>(parameterize ([current-size 256]
               [current-coloring color-by-length]
               [current-mode 'short])
  (regex-fractal #px"(.*)1"))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png" /></a></p>
<p>Very cool.</p>
<p>After that, I just collected and made up a bunch of colorings and regular expressions and generate all of the images. Check the <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">full source</a> on GitHub for details, but basically I have three colorings: a default white only, the length based coloring above, and another which matches the most common color in a match. Then I have about two dozen regular expression.</p>
<p>Then I wrote a quick loop that will generate all images in both modes (short circuiting and long), with all three colorings. It's a lot of images... Here are some of my favorites:</p>
<pre class="scheme"><code> (demo "test256" 256) </code></pre>
<p>First, a basic <a href="https://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski triangle</a> <code>1</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png" /></a></p>
<p>But if you turn on most common color, you see that each color sticks to it's own color (a pattern we'll see oft repeated):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png" /></a></p>
<p>What's even more interesting is when you switch to 'short mode'. Since we'll stop recurring as soon as we see a 1, you get blocks rather than each individual pixel colored:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png" /></a></p>
<p>Next, four corners. Basically, look for repeated patterns of a single digit: <code>((.)(\\2*))</code>. That should mean that we go out to the four corners, each with its own color:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png" /></a></p>
<p>Next, split the region into left and right halves, by checking if a 1 or 2 appears first: <code>^[34]*2(.*)</code>. If it's a 2, mark it, if it's a 1, do not.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png" /></a></p>
<p>Next, a nice jagged change on the original Sierpinski, match anything with either a 1 or a 2 (or both): <code>(12)</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png" /></a></p>
<p>Or, similarly, make two Sierpinskis by matching patterns where there's both a 1 and a 2: <code>(1.*2|2.*1)</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png" /></a></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png" /></a></p>
<p>Next, match patterns where all 1s (if any) occur before all 2s: <code>^[34]*[134]*[34]*[234]*[34]*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png" /></a></p>
<p>Or you can invert the Sierpinski triangle by making sure there are <em>no</em> ones at all: <code>^[^1]*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png" /></a></p>
<p>Or go really crazy and do some math. For example, finding all sequences with an even sum: <code>^(2|4|[13][24]*[13])*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png" /></a></p>
<p>Next, we have a few from the comments on the <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/">original post</a>.</p>
<p>Some nice curls: <code>[13][24][^1][^2][^3][^4]</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png" /></a></p>
<p>Patterns where you have the same pattern repeated at least three times, but with other random bits in between: <code>(.)\\1..\\1</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png" /></a>\ <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png" /></a></p>
<p>Or you can draw some nice boxes: <code>(?:13|31)(.*)</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png" /></a></p>
<p>A nice recursive outline (reminds me of the <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>): <code>^(1[124]|2[14]|4[12]|31)*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png" /></a></p>
<p>Figure eights: <code>^(?:..)*(?:[13][13]|[24][24])((?:..)*)$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png" /></a></p>
<p>And finally, some nice diagonal lines, by making sure the top left/bottom right are before the top right/bottom left: <code>^[13]*[24]*$</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png" /></a></p>
<p>And there you have it. Any other awesome patterns you come up with? Share them below. I'd love to see them.</p>
<p>As always, the full source is available on GitHub if you'd like to play with it: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">regex-fractal.rkt</a></p>]]></content></entry><entry><title>Invader Fractals</title><link href="http://blog.jverkamp.com/2014/09/17/invader-fractals" /><id>urn:uuid:15d5a345-5571-4706-dc96-ad512081f006</id><updated>2014-09-17T09:00:00Z</updated><summary type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<!--more-->
<p>Specifically, here's the algorithm that we want to use to build an invader fractal:</p>
<ol>
    <li>Generate an invader</li>
    <li>Within that image:
        <ul>
            <li>For each white pixel, stop</li>
            <li>For each black pixel, recur with a smaller invader</li>
        </ul>
    </li>
    <li>Once the invader is small enough, stop recurring</li>
</ol>
<p>Sounds straight forward enough, but what does that look like in code?</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal depth)
  (let loop ([depth depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= depth 1)
                #t
                (loop (- depth 1)))
            #f)))))</code></pre>
<p>That's actually a lot more concise than I first expected. In the end, we get exactly that nice nested structure we're looking for:</p>
<pre class="scheme"><code>&gt; (make-invader-fractal 2)
'#(#(#f #f #f #f #f #f #f)
   #(#f
     #(#(#f #f #f #f #f #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #t #f #f)
       #(#f #t #t #f #f #t #f)
       #(#f #f #f #f #t #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #f #f #f))
     #f
     #(#(#f #f #f #f #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #t #t #f #f #f)
       #(#f #f #f #t #t #f #f)
       #(#f #f #t #t #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #f #f #f #f #f))
     #f
...
     #f
     #f
     #f)
   #(#f #f #f #f #f #f #f))
&gt;</code></pre>
<p>We could probably do away with representing the margins (the outermost layer is always going to be <code>#f</code>), but at the moment it makes the code easier to reason about.</p>
<p>Okay, next we need the rendering function:</p>
<pre class="scheme"><code>; Render an invader fractal as defined above
; Crop off the margin on the outmost layer
; Final size will be 5*7^{depth-1}
(define (render-invader-fractal fi)
  (define depth
    (let loop ([fi fi])
      (cond
        [(boolean? fi) 0]
        [else
         (+ 1 (for*/fold ([deepest 0]) ([col (in-vector fi)]
                                        [el (in-vector col)])
                (max (loop el) deepest)))])))

  (define size (expt 7 depth))

  (flomap-&gt;bitmap
   (flomap-crop
    (build-flomap*
     1 size size
     (λ (x y)
       (let loop ([t 0] [l 0] [s size] [fi fi])
         (cond
           [(eq? fi #t) '#(0.0)]
           [(eq? fi #f) '#(1.0)]
           [else
            ; xi and yi are the points within the current level invader
            (define xi (quotient (* 7 (- x l)) s))
            (define yi (quotient (* 7 (- y t)) s))
            (loop (+ t (* yi (/ s 7)))
                  (+ l (* xi (/ s 7)))
                  (/ s 7)
                  (vector-ref (vector-ref fi xi) yi))]))))
    (* size 5/7)
    (* size 5/7)
    1/2
    1/2)))</code></pre>
<p>Unfortunately, that first bit is a little bit hacky. Since we've split apart the functions that create and render this fractal, we don't know how large of an image to make. Still, it's quick enough to calculate. Then, we get into actually making the image. It's much the same as the code in <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. We recur down, keeping two different sets of coordinates: image coorcinates <code>x</code>, <code>y</code>, <code>t</code>, <code>l</code>, and <code>s</code> and then coordinates within the current level <code>xi</code> and <code>yi</code>. There is a lot of dividing and multiplying by that <a href="https://en.wikipedia.org/wiki/magic_number">magic number</a>, but os it goes.</p>
<p>And that's really it. There's a call to <code><a href="http://docs.racket-lang.org/search/index.html?q=flomap-crop">flomap-crop</a></code>, but that's just to cut off the outermost margin (since it will (1) always be empty and (2) the second level's margin will still include some spacing). So how does it look?</p>
<pre class="scheme"><code> &gt; (render-invader-fractal (make-invader-fractal 3)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<p>That's about it. One more trick that I want to do though is to make these reproducable. That we can do some neat tricks with zooming in:</p>
<pre class="scheme"><code>(define-syntax-rule (with-seed seed body* ...)
  (parameterize ([current-pseudo-random-generator
                  (make-pseudo-random-generator)])
    (random-seed seed)
    body* ...))

(define (invader-fractal i depth)
  (with-seed i
    (render-invader-fractal (make-invader-fractal depth))))</code></pre>
<p>Because we reset the random seed at the beginning of the calculate and always generate the random numbers from top to bottom, we ned up with some neat effects. The top level with the same seed is always the same shape:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 8675309 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png" /></a> <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>:)</p>
<p>Unfortunately, the lower levels aren't the same pattern, since we're generating the images using a <a href="https://en.wikipedia.org/wiki/depth_first search">depth first search</a> rather than the <a href="https://en.wikipedia.org/wiki/breadth_first search">breadth first search</a>. More specifically, we're generating the invaders in this order:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png" /></a></p>
<p>In that case, the ordering is: generate the image for the given level, then the first subimage, then the first subimage of that. Generating the <em>depth first</em> as it were. What we want instead is to generate generate the top level, then all of the next level, then all of the next level, more like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png" /></a></p>
<p>Unfortunately, that doesn't work out well in our specific code, since we're working recursively, working with a <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">stack</a> (implicitly via function calls). To do a breadth first search, we would need instead to create a explicit <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">queue</a>, which would require some fairly major refactoring.</p>
<p>There's another option though:</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal/seeded seed depth)
  (define (mod-random-seed! i)
    (random-seed (+ 1 (remainder i 2147483646))))

  (mod-random-seed! seed)
  (let loop ([d depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= d 1)
                #t
                (begin
                  (mod-random-seed! (+ (* (- depth d) 49) (* x 7) y seed))
                  (loop (- d 1))))
            #f)))))

(define (invader-fractal seed depth)
  (render-invader-fractal (make-invader-fractal/seeded seed depth)))</code></pre>
<p>With the addition of <code>mod-random-seed!</code>, we can set the seed at each level. And we've got the amusing notion of non-random random seeds. :) But since they're generated as a function of the current <code>depth</code> and <code>x</code> and <code>y</code> coordinates of the parent image, we'll always get the same images at each level:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 42 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png" /></a></p>
<p>Now that's what I was looking for. :)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/invader-fractals.rkt">invader-fractals.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>
<p>Challenge: Make fractal invaders from invader fractals. Maybe later... O:)</p>]]></content></entry><entry><title>Fractal Invaders</title><link href="http://blog.jverkamp.com/2014/09/16/fractal-invaders" /><id>urn:uuid:3af088a6-d121-00ae-e2c8-a557bb1c42b3</id><updated>2014-09-16T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<!--more-->
<p>But before we get to that image, let's start with where I was Sunday. We had something that looked like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png" /></a></p>
<p>That was my first take at a fractal invader algorithm, and in that case there really wasn't anything to do with fractals at all. The basic algorithm for that was simple:</p>
<ol>
  <li>Choose a random location and size for an invader</li>
  <li>If the new invader does not collide with any previous invader, place it</li>
  <li>Go to step 1</li>
</ol>
<p>If we failed 100 times in a row to place an invader, we made the assumption that the space was empty and bailed out. It actually worked well enough. You got to see a bunch of invaders of different sizes, all together on the map. Unfortunately though, it didn't work particularly well for filling the entire space, which is really what I was after. (If you'd like you can see the code for that on GitHub in Sunday's code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a>).</p>
<p>After that though, I took a step back. How can we actually fill the space? More specifically, how can we use recursion / fractals to efficiently fill the space? Well, what we really need is actually really similar to another previous post of mine: <a href="http://blog.jverkamp.com/2014/05/28/quadtree-image-compression">Quadtree image compression</a>.</p>
<p>Basically, here's the new algorithm:</p>
<ol>
  <li>Given a rectangular region, choose a random location and size for an invader</li>
  <li>Recursively divide the remaining space into four sections: one above, one to the right, one below, and one to the left of the new invader</li>
  <li>If any region is small enough for only a single invader, place it and stop (base case)</li>
  <li>For each other region, start again at step 1</li>
</ol>
<p>The main odd step there is step 2 above. How can we split a region into five subregions (the center being square) like that? Well, we could do something like this:</p>
<pre class="text"><code>      | R
      | i
 Top  | g
______| h
   |  | t
 L |__|____
 e |
 f | Bottom
 t |</code></pre>
<p>Making sure that you have all of the regions set up exactly right gets a little bit complicated, but if you draw a nice diagram, it should be fairly straight forward to make sure that you always generate this structure. And that's exactly what we have here:</p>
<pre class="scheme"><code>(struct rect (t l w h) #:transparent)
(struct node (bounds value-bounds value children) #:transparent)

; Create the recursive fractal structure
(define (made-fractal width height random-node)
  (let loop ([t 0] [l 0] [w width] [h height])
    (cond
      ; The next node is too small, do not place it
      [(or (&lt;= w 0) (&lt;= h 0) (&gt;= t height) (&gt;= l width))
       #f]
      ; Create a child node; recur four times as so:
      ;  T  |
      ; __  |
      ;   XX R
      ; L XX__
      ;   |
      ;   | B
      [else
       (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
       (define x (if (= w s)         0 (random (- w s))))
       (define y (if (= h s)         0 (random (- h s))))
       (node (rect t       l       w h) ; Bounds of this node
             (rect (+ t y) (+ l x) s s) ; Bounds of the value within this node
             (random-node)              ; The value of this node
             (list (loop t         l         (+ x s)   y        )
                   (loop t         (+ l x s) (- w x s) (+ y s)  )
                   (loop (+ t y s) (+ l x)   (- w x)   (- h y s))
                   (loop (+ t y)   l         x         (- h y)  )))])))</code></pre>
<p>Essentially, we want to create a nested structure made out of <code>node</code> structs. For each node, we have two bounding boxes, one for the entire recursive structure and one just for the central image (which in turn defines the four children). Then we have a value which I've already parameterized here as the <code>random-node</code> parameter and finally four children (ordered top, right, bottom, left, although it really doesn't matter).</p>
<p>What's neat about this is that the exact same code could theoretically be used for other structures. Say if we wanted 8 children for each of the orthagonal or diagonal directions. Just add more to the <code>node-children</code> list.</p>
<p>There are a few edge cases to watch out for that I did spend rather a while working out. For example, the base case deals with cases where either <code>w</code> or <code>h</code> is less than zero, but it also deals when we go off the right or bottom edge of the region. Likewise, we have to check if we only have exactly 1 square left in either width or height (which would mean we cannot generate an interesting random size) or if we only have exactly enough room for one shape.</p>
<p>After that, it's just a matter of getting the parameters right for the recursive calls. Let's try one out:</p>
<pre class="scheme"><code>&gt; (make-fractal 4 3 (const #t))
(node
 (rect 0 0 4 3)
 (rect 0 0 3 3)
 #t
 (list
  #f
  (node
   (rect 0 3 1 3)
   (rect 1 3 1 1)
   #t
   (list
    (node (rect 0 3 1 1) (rect 0 3 1 1) #t '(#f #f #f #f))
    #f
    (node (rect 2 3 1 1) (rect 2 3 1 1) #t '(#f #f #f #f))
    #f))
  #f
  #f))</code></pre>
<p>If you take each of those in order, you have the regions:</p>
<pre class="text"><code>AAAB
AAAC
AAAD</code></pre>
<p>So we generated a 3x3 region first and then filled in the rest with 1x1s. Of course that's not very nice to visualize. Let's make something a little prettier:</p>
<pre class="scheme"><code>(define (in? bounds x y)
  (match-define (rect t l w h) bounds)
  (and (&lt;= l x (+ l w -1))
       (&lt;= t y (+ t h -1))))

; Render a fractal image
(define (fractal-image
         width height
         #:random-color [random-color (thunk (vector (random) (random) (random)))])

  (define root (make-fractal width height random-color))

  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (λ (x y)
      (let loop ([node root])
        (cond
          [(in? (node-value-bounds node) x y) (node-value node)]
          [else
           (for*/first ([child (in-list (node-children node))]
                        #:when (and child (in? (node-bounds child) x y)))
             (loop child))]))))))</code></pre>
<p>That's surprisingly simple, but then again most of the work was already done in setting up the structure. The most complicated bit here is that we have two different usages of the <code>in?</code> function:</p>
<ul>
  <li><code>(in? (node-value-bounds node) x y)</code> - checks if the current point is in the current node's value box (the inner box); if that's the case, this is our base case</li>
  <li><code>(in? (node-bounds child) x y)</code> - if this is true for any of the child node's outer box; if that's true we know that our value is somewhere in that subtree</li>
</ul>
<p>That's all we need to make some pretty neat images, just changing how we generate colors:</p>
<pre class="scheme"><code>&gt; (fractal-image 200 200)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200 #:random-color (thunk (let ([g (random)]) (vector g g g))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200
                 #:random-color (thunk
                                  (case (random 3)
                                    [(0) (vector (random) 0 0)]
                                    [(1) (vector 0 (random) 0)]
                                    [(2) (vector 0 0 (random))])))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png" /></a></p>
<p>Which, honestly, would be a pretty neat post all by itself. But wasn't the entire point of this to made a fractal out of the <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">procedural invaders</a>?</p>
<pre class="scheme"><code>; Render a fractal image made of invaders!
(define (fractal-invaders width height #:highlights? [highlights? #f])
  (define (random-invader)
    (flomap-add-margin
     (if highlights?
         (procedural-invader/highlight (random 524288))
         (procedural-invader (random 32768)))
     1))

  (define root (make-fractal (quotient width 7)
                             (quotient height 7)
                             random-invader))

  (flomap-&gt;bitmap
   (build-flomap*
    (if highlights? 3 1) width height
    (λ (x y)
      ; Correct for coordinates within the node
      (define nx (quotient x 7))
      (define ny (quotient y 7))

      (let loop ([n root])
        (cond
          [(in? (node-value-bounds n) nx ny)
           ; Calculate coordinates within the image
           (match-define (node _ (rect t l s _) img _) n)
           (define ix (quotient (- x (* 7 l)) s))
           (define iy (quotient (- y (* 7 t)) s))
           (flomap-ref* img ix iy)]
          [else
           (or
            (for*/first ([child (in-list (node-children n))]
                         #:when (and child (in? (node-bounds child) nx ny)))
              (loop child))
            (if highlights? '#(1 1 1) '#(1)))]))))))</code></pre>
<p>Okay, this code isn't quite as nice. Mostly, that's because of a simplifying requirement that I started with: we're going to be working with a grid where each 'pixel' is a single minimal size invader. With a 1 pixel margin, that means that our minimum image size is 7x7 (thus the 7s scattered throughout the code).</p>
<p>Unfortunately, that does make our base case a little more complicated, since we're working with two different coordinate systems: image coordinates <code>x</code> and <code>y</code> and fractal coordinates <code>nx</code> and <code>ny</code>. Still, add in some offsets by 7 and a bit of padding down at the end (for images not divisible by 7) and off we go:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<p>It also works great for larger images:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png" /></a></p>
<p>It even supports highlights:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png" /></a></p>
<p>Now that's what I'm talking about. Unfortunately, the process is still somewhat random:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png" /></a></p>
<p>Sometimes the first random image is a little on the annoyingly large size. Off the top of my head, there are two ways to deal with it: either add an option parameter that controls the maximum size of a block or just keep generating images until you get what you are looking for.</p>
<p>Guess which solution I prefer? :)</p>
<pre class="scheme"><code>(define (fractal-invaders ... #:maximum-invader-size [max-size #f])
  ...
  (define root
    (make-fractal
     (quotient width 7)
     (quotient height 7)
     random-invader
     #:maximum-block-size (and max-size (/ max-size 7))))
  ...)

(define (make-fractal width height random-node #:maximum-block-size [max-size #f])
  ...
      [else
       (define s
         (let loop ()
           (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
           (cond
             [(or (not max-size) (&lt; s max-size)) s]
             [else (loop)])))
       ...])</code></pre>
<p>Simple!</p>
<pre class="scheme"><code>&gt; (fractal-invaders 400 200 #:highlights? #t #:maximum-invader-size 25)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png" /></a></p>
<p>Beautiful!</p>
<p>I wonder what other sort of images I could make with a fractal space filling algorithm like this? O:)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/fractal-invaders.rkt">fractal-invaders.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>]]></content></entry><entry><title>Look and Say</title><link href="http://blog.jverkamp.com/2014/09/15/look-and-say" /><id>urn:uuid:eac2659f-3660-3f5e-9ba1-540308c23093</id><updated>2014-09-15T00:00:00Z</updated><summary type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
<!--more-->
<p>Originally, my interest in this came from a video on the excellent YouTube video series <a href="https://www.youtube.com/user/numberphile">Numberphile</a>:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/ea7lJkEhytA" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>Yes, that is <a href="https://en.wikipedia.org/wiki/John_Conway">John Conway</a> of <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. It's well worth the watch.</p>
<p>Then this morning, /r/dailyprogrammer has a post: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ggy30/9152014_challenge180_easy_looknsay/">Challenge #180 [Easy] Look'n'Say</a>. Seems like it's about time. :)</p>
<p>So how do we do it? Well, essentially we're going to want a function that can recur down a list of, collecting groups of like numbers. So in the sequence <code>111221</code>, we want to collect that into <code>111 22 1</code>. Then we know how long each sequence is, <code>31 22 11</code>, which is the next number in the sequence. How's that look in code?</p>
<pre class="scheme"><code>; Create a look and see list by combining repeated values into count+number
; For example: 111221 becomes 3 1s, 2 2s, 1 1 =&gt; 312211
(define (look-and-say ls)
  (apply
   append
   (let count ([ls (rest ls)] [i 1] [v (first ls)])
     (cond
       [(null? ls)
        (list (list i v))]
       [(equal? (first ls) v)
        (count (rest ls) (+ i 1) v)]
       [else
        (list* (list i v) (count (rest ls) 1 (first ls)))]))))</code></pre>
<p>The counting function will recur down the list, collecting the current count (<code>i</code>) and value (<code>v</code>) as we go. Within that recursion, there are three cases. In the first case (<code>(null? ls)</code>), we've reached the end. This makes sure that we output the last sequence. In the second (<code>(equal? (first ls) v)</code>), we have a matching number, so increment the current sequence. In the last (<code>else</code>), the number do not match. Output the current count and start a new sequence.</p>
<p>Let's try it out:</p>
<pre class="scheme"><code>&gt; (look-and-say '(1))
'(1 1)
&gt; (look-and-say '(1 1))
'(2 1)
&gt; (look-and-say '(2 1))
'(1 2 1 1)
&gt; (look-and-say '(1 2 1 1))
'(1 1 1 2 2 1)</code></pre>
<p>Looks good. It's annoying to have to keep calling it like that though. What I'd really like to see is a Racket <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence">sequence</a></code>. Luckily, this is exactly the sort of thing we can make with <code><a href="http://docs.racket-lang.org/search/index.html?q=make-do-sequence">make-do-sequence</a></code>:</p>
<pre class="scheme"><code>; Make an infinite sequence that generates look-and-see lists
; Use the current look-and-say list itself as both the key and value
(define (in-look-and-say [ls '(1)])
  (make-do-sequence
   (thunk
    (values
     identity       ; Current
     look-and-say   ; Next
     ls             ; Initial
     (const #t)     ; Continue from this key/value/pair
     (const #t)
     (const #t)))))</code></pre>
<p>We're going to use the sequence itself as the 'count', which makes the first few arguments easy enough. Basically, we use <code>identity</code> to return the current value, and <code>look-and-say</code> (the function we just defined above) as the <code>next</code> function. The last three are easy as well. Since we want an infinite sequence: just always return <code>#t</code>. Done.</p>
<p>Given this, we can generate as long a seqence as we want:</p>
<pre class="scheme"><code>; Take the first chunk off of a sequence
(define (look-and-say* ls i)
  (for/list ([ls (in-look-and-say ls)]
             [_  (in-range i)])
    ls))</code></pre>
<p>Nice. :)</p>
<p>Or we can plot some interesting information about them, say the length:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say length '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png" /></a></p>
<p>Or the maximum value:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say (curry apply max) '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png" /></a></p>
<p>It's interesting how it never gets beyond 3 up to 50 steps along the sequence. Unfortunately</p>
<p>Last thing last, pretty pictures!</p>
<pre class="scheme"><code>; Render a look and say sequence to a bitmap, stretching rows to the entire width
; Note: Values are clamped to between 0.0 and 1.0 before conversion. *rolls eyes*
(define (render-look-and-say ls bound)
  ; Precalculate the image data; figuring out what dimenions will we need from that
  (define ls* (look-and-say* ls bound))
  (define height (length ls*))
  (define width (length (last ls*)))

  ; Precalculated list of colors that are defined to be more visually distinct
  (define colors
    '#(#(1.00 0.70 0.00) #(0.50 0.24 0.46) #(1.00 0.41 0.00) #(0.65 0.74 0.84) #(0.75 0.00 0.12)
       #(0.80 0.63 0.38) #(0.50 0.44 0.40) #(0.00 0.49 0.20) #(0.96 0.46 0.55) #(0.00 0.32 0.54)
       #(1.00 0.48 0.36) #(0.32 0.21 0.48) #(1.00 0.55 0.00) #(0.70 0.16 0.32) #(0.95 0.78 0.00)
       #(0.50 0.09 0.05) #(0.57 0.66 0.00) #(0.35 0.20 0.08) #(0.94 0.23 0.07) #(0.14 0.17 0.09)))

  ; Generate the image, three channels are RGB
  ; Note: 4 channels is ARGB, not RGBA *rolls eyes again*
  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (λ (x y)
      ; Pull out the correct row for the data, normalize entries to 'stretch' over the entire row
      (define row (list-ref ls* y))
      (define row-width (length row))
      (define index (quotient (* x row-width) width))
      (displayln `(,x ,y ,index ,(list-ref row index) ,row))

      (vector-ref colors (list-ref row index))))))</code></pre>
<p>That will encode each iteration into a line of the resulting image and each different value into its own color. Something like this:</p>
<pre class="scheme"><code> &gt; (scale-to 200 200 (render-look-and-say '(1) 20)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png" /></a></p>
<p>Neat how there's a nice line right down the center. Although that makes sense, given that there are always an even number of values. On thing that I want to check out is those divisions that the video was talking about where two parts of a sequence can diverge and never interact again. Those would be fairly straight forward to find even, just 'tag' each part of the sequence with where it came from. Perhaps another day.</p>
<p>As always, code on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/look-and-say.rkt">look-and-say.rkt</a></p>
<p>As a side note, here's a neat trick:</p>
<pre class="scheme"><code>; Create a look and say sequence with regular expressions instead of lists
(define (look-and-say/regex str)
  (regexp-replace*
   #px"(.)(\\1*)"
   str
   (λ (match block repeat) (~a (string-length match) block))))</code></pre>
<p>Regular expressions for the win! Of course, it's an order of magnitude slower than the list version, but it's still neat.</p>]]></content></entry><entry><title>Procedural Invaders</title><link href="http://blog.jverkamp.com/2014/09/14/procedural-invaders" /><id>urn:uuid:41ac4ba4-e097-9023-3504-488ff41b9a68</id><updated>2014-09-14T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<!--more-->
<p>Despite the fact that it's scaled up, on the lowest level we actually have a 5x5 grid of pixels. In addition, it's mirrored to make it symmetrical, so (counting the non-mirrored center row), we actually only have 15 pixels:</p>
<pre class="text"><code>+----+----+----+----+----+
|  1 |  6 | 11 |  6 |  1 |
+----+----+----+----+----+
|  2 |  7 | 12 |  7 |  2 |
+----+----+----+----+----+
|  3 |  8 | 13 |  8 |  3 |
+----+----+----+----+----+
|  4 |  9 | 14 |  9 |  4 |
+----+----+----+----+----+
|  5 | 10 | 15 | 10 |  5 |
+----+----+----+----+----+</code></pre>
<p>Represent those 15 pixels as a 15 bit number. For example, the above image, we have bits 2, 4, 6, 7, 8, 10, 13, and 15 set, so we have the number:</p>
<pre class="scheme"><code>&gt; #b010101110100101
11173</code></pre>
<p>Given that there are over 32 thousand 15 bit numbers (<span>\(2^{15}=32768\)</span>), that's a lot of invaders. So how do we generate them?</p>
<pre class="scheme"><code>; Create a symmetric 5x5 image similar to a space invader with this bit pattern
; 0 5 10 5 0
; 1 6 11 6 1
; 2 7 12 7 2
; 3 8 13 8 3
; 4 9 14 9 4
(define (procedural-invader i)
  (define bits
    (for/vector ([c (in-string (~a (number-&gt;string i 2) #:width 15 #:pad-string "0" #:align 'right))])
      (eq? c #\1)))

  (build-flomap*
   1 5 5
   (λ (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (vector-ref bits i) '#(1.0) '#(0.0)))))</code></pre>
<p>There are really two parts here. First we covert the given integer into a vector of <code>#t</code> / <code>#f</code>. There are certainly far faster ways to do this (<code>bitwise-and</code> with the correct bit for example), but given that the size is set and small, this is good enough for the time being.</p>
<p>After that, we take those bits and use <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code> to create a 5x5 image where <code>#t</code> is white and <code>#f</code> is black. Shiny. Now unfortunately Dr. Racket will not display flomaps directly inline, but if we convert them to bitmaps it will:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (procedural-invader 11173))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png" /></a></p>
<p>Oof. Tiny. Let's make it bigger:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png" /></a></p>
<p>Well that's not what I was looking for. The problem is that flomaps by default are designed for interpolated values. So that if you have a black pixel right next to a white pixel, you can actually ask for the 'pixel' halfway between the two, getting a gray value. But in this case, that's not what we want. We want sharp (<a href="https://en.wikipedia.org/wiki/nearest_neighbor">nearest neighbor</a>) scaling:</p>
<pre class="scheme"><code>; Resize a flomap using nearest-neighbors to preserve sharp edges
(define (flomap-resize/nn img new-width [new-height new-width])
  (match-define (flomap _ components old-width old-height) img)

  (build-flomap*
   components new-width new-height
   (λ (new-x new-y)
     (flomap-ref* img
                  (floor (* old-width (/ new-x new-width)))
                  (floor (* old-height (/ new-y new-height)))))))</code></pre>
<p>Same as before, we are creating a new image. But this time, we covert the old coordinate system to the new and throw away any of the decimal part, getting an exact answer. That way we never interpolate:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize/nn (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<p>Nice and sharp. That's exactly what we were looking for.</p>
<p>For the base of the problem, that's pretty much it. But we're not quite done. What if we want to make a nice display mode so that we can see a bunch of them at once?</p>
<pre class="scheme"><code>; Generate a demo shee\t of procedural invaders
(define (demo [rows 5] [cols rows] #:image-size [image-size 20] #:margins [margins 5])
  (define images
    (for/list ([row (in-range rows)])
      (for/list ([col (in-range cols)])
        (define r (random 32768))
        (define img (procedural-invader r))
        (flomap-&gt;bitmap (flomap-add-margin (flomap-resize/nn img image-size) margins)))))

  (cond
    [(and (= rows 1) (= cols 1))
     (caar images)]
    [(= rows 1)
     (car (map (curry apply beside) images))]
    [(= cols 1)
     (apply above (map car images))]
    [else
     (apply above (map (curry apply beside) images))]))</code></pre>
<p>That way we can make nice mixed sheets of the things:</p>
<pre class="scheme"><code> &gt; (demo) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png" /></a></p>
<p>Pop quiz: Find two identical invaders. What is the likelihood of that happening? Well using the same math as in <a href="http://blog.jverkamp.com/2012/10/01/the-birthday-paradox">The Birthday Paradox</a>, the chance of no duplicates is:</p>
<div>$$ B(n, x) = 1 - \prod_{i=1}^{(n-1)}(1-\frac{i}{x}) $$</div>
<p>Where <span>\(n\)</span> is the number of generated invaders and <span>\(x = 15^{2} = 32768\)</span> is the total number of possible invaders.</p>
<p>Specifically, for the 5x5 case:</p>
<div>$$B(25, 32768)
= 1 - \prod_{i=1}^{(25-1)}(1-\frac{i}{32768})
\approx 9.1\%$$</div>
<p>And for the 80x40 case:</p>
<div>$$B(3200, 32768)
= 1 - \prod_{i=1}^{(3200-1)}(1-\frac{i}{32768})
\approx 100\%$$</div>
<p>So it's (almost certainly) there... you just have to find it. :)</p>
<p>Okay, what else can we do with these things? Well, at the moment, they're a little bit bland. Let's add a few bits to the generation and spice them up a bit with highlights. Specifically, let's choose one of the 15 bits to be red instead of black or white. In order to do that (choose 1 of 15), we need 4 bits (with one left over). SOmething like this should work:</p>
<pre class="scheme"><code>; Create a procedural invader as above, but highlight the point specified by four highest bits
(define (procedural-invader/highlight i)
  (define highlight (bitwise-and i #b1111))
  (define img-w/o-highlight (procedural-invader (arithmetic-shift i -4)))

  (build-flomap*
   3 5 5
   (λ (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (= highlight i)
         '#(1.0 0.0 0.0)
         (make-vector 3 (flomap-ref img-w/o-highlight 0 x y))))))</code></pre>
<p>Basically, we pull off the lowest four bits with a <a href="https://en.wikipedia.org/wiki/bitmask">bitmask</a> for the highlight then shift all the rest down and pass off to the original <code>procedural-invader</code> function. Then we build a new image from that, mostly copying but taking a single pixel and making it red. Adding an argument so that our <code>demo</code> function can handle highlighting:</p>
<pre class="scheme"><code> &gt; (demo #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png" /></a></p>
<p>Ooh. That's starting to look like a game. Perhaps I'll revist these for the next <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>...</p>
<p>What else can we do with these? Well, take the <a href="http://www.complexification.net/gallery/machines/invaderfractal/">post I was inspired by</a>. In that case, they fill up a space with procedural invaders of different sizes. That would be neat to check out. I've started implementing something...</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png" /></a></p>
<p>But it's not quite right yet. Perhaps next time...</p>
<p>If you'd like to check out the entire code for today's post, as always, it's available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a></p>]]></content></entry><entry><title>Chess Puzzles: Knight's Tour</title><link href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour" /><id>urn:uuid:7b068d00-2bb7-61fb-e0d8-045306814067</id><updated>2014-09-04T20:00:00Z</updated><summary type="html"><![CDATA[<p>Onwards and upwards! For today's chess puzzle, let's take a first crack at the <a href="https://en.wikipedia.org/wiki/Knight's_Tour">Knight's Tour</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Onwards and upwards! For today's chess puzzle, let's take a first crack at the <a href="https://en.wikipedia.org/wiki/Knight's_Tour">Knight's Tour</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
<!--more-->
<p>As with <a href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens">N Queens</a>, the problem is simply stated:</p>
<blockquote>A knight's tour is a sequence of moves of a knight on a chessboard such that the knight visits every square only once.</blockquote>
<p>And once again, we can get a solution working relatively well using <a href="https://en.wikipedia.org/wiki/backtracking">backtracking</a>:</p>
<pre class="scheme"><code>(define-piece Knight (move 1 (leaper 1 2)))
(define-piece Visited '())

; Solve a knights tour on a given board
(define (knights-tour width [height width])
  ; Create a new empty board
  (define b (make-board width height #:pieces (list Knight Visited)))

  ; A board is completed if there are no empty squares
  ; All squares are either the Knight or Visited
  (define (completed? b)
    (not (for*/first ([x (in-range width)]
                      [y (in-range height)]
                      #:when (not (board-ref b (pt x y))))
           #t)))

  ; Move the knight from the given point to each possible next point in turn
  ; Return a list of valid moves to finish the tour if such a list exists, #f otherwise
  (define (move-knight b p)
    (cond
      ; Done, we have a tour and there are no more valid moves necessary
      [(completed? b) '()]
      ; Otherwise, try all possible moves from this point
      ; Since all pieces are the same color, moves from is only empty tiles
      [else
       (for*/first ([next (in-list (moves-from b p))]
                    [recur (in-value (let* ([b (board-move b p next)]
                                            [b (board-set b p '(Black Visited))])
                                       (move-knight b next)))]
                    #:when recur)
         (cons p recur))]))

  ; Try each possible initial location until we find one that works
  (for*/first ([x (in-range width)]
               [y (in-range height)]
               [solution (in-value
                           (move-knight
                             (board-set b (pt x y) '(Black Knight))
                             (pt x y)))]
               #:when solution)
    solution))</code></pre>
<p>Basically, there are three interesting pieces here: <code>completed?</code>, <code>move-knight</code>, and the <code>for*/first</code> initial loop.</p>
<p>First, how can a tour be <code>completed?</code> If all of the locations on the board are filled. We get around this with the psuedo-piece: <code>Visited</code>. It fills up the board as we continue to move our knight around. Technically, I could have just filled the board with knights, but I like how visited lets us visualize things.</p>
<p>Next, <code>move-knight</code>. This is the core of the algorithm. As it states, we are building up a list of moves recursively. So the base case (when the board is completed) return the empty list <code>'()</code>. Otherwise, we're going to use <code><a href="http://docs.racket-lang.org/search/index.html?q=for*/first">for*/first</a></code> to find the first move which recursively solves the problem (or <code>#f</code> if none does). The use of <code><a href="http://docs.racket-lang.org/search/index.html?q=in-value">in-value</a></code> is a trick I picked up <a href="https://groups.google.com/forum/#!topic/racket-users/p2S6F3FAiU0">from the mailing list</a> for using an 'expensive' value in a <code>#:when</code> clause and body without having to recalculate it.</p>
<p>Finally, we loop across all of the starting states. It doesn't matter in the case of closed tours (where the start and end points match and thus any point can be a start point), but on some boards not every starting location is valid.</p>
<p>So now we can solve a tour:</p>
<pre class="scheme"><code>&gt; (knights-tour 5)
(list
 (pt 0 0) (pt 1 2) (pt 0 4) (pt 2 3) (pt 3 1)
 (pt 1 0) (pt 0 2) (pt 1 4) (pt 2 2) (pt 4 3)
 (pt 2 4) (pt 0 3) (pt 1 1) (pt 3 0) (pt 4 2)
 (pt 3 4) (pt 1 3) (pt 0 1) (pt 2 0) (pt 4 1)
 (pt 3 3) (pt 2 1) (pt 4 0) (pt 3 2))</code></pre>
<p>Whee! Okay, what does that actually look like? Let's animate it!</p>
<pre class="scheme"><code>(current-glyphs (hash 'Knight "♞"
                      'Visited "♘"))

; Render a knights tour into an animation
(define (knights-tour/animate-solution width [height width])
  (define tour (knights-tour width height)

  ; Create an initial board
  (define board (make-board width height #:pieces (list Knight Visited)))

  ; Prerender the board once so we know how large of a scene to create
  (define r (render board #:player-colors (const "black")))
  (define render-width (send r get-width))
  (define render-height (send r get-height))

  ; Animate the tour, rendering each frame once
  (big-bang tour
    [on-tick cdr]
    [to-draw (λ (tour)
               (place-image
                (render (if (null? tour)
                            board
                            (board-set board (car tour) '(Black Knight))))
                (/ render-width 2)
                (/ render-height 2)
                (empty-scene render-width render-height)))]
    [stop-when null?]
    [record? #t]))</code></pre>
<pre class="scheme"><code> &gt; (knights-tour/animate-solution 5) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
<p>Shiny.</p>
<p>Okay, so that's all well and good for normal boards. What if instead you want a board with holes in it / a non-regular board?</p>
<p>Simple! We'll just add a third type of piece <code>Invalid</code> and pre-populate the board with those:</p>
<pre class="scheme"><code>(current-glyphs (hash 'Knight "♞"
                      'Invalid "✗"
                      'Visited "♘"))

(define-piece Knight (move 1 (leaper 1 2)))
(define-piece Invalid '())
(define-piece Visited '())

; Solve a knights tour on a given board (optionally with some pieces removed)
(define (knights-tour width [height width] #:removed [removed '()])
  ; Create a new board (potentially removing some pieces)
  (define b
    (for/fold ([b (make-board width height
                    #:pieces (list Knight Invalid Visited))])
              ([p (in-list removed)])
      (board-set b p '(Black Invalid))))

  ...)</code></pre>
<p>All the rest of the code stays the same. Pretty nice eh? Let's try an example:</p>
<pre class="scheme"><code>&gt; (knights-tour/animate-solution 4
    #:removed (list (pt 1 0) (pt 0 2) (pt 0 3) (pt 2 3) (pt 3 3)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-solution.gif" /></a></p>
<p>Hmm, that's all well and code showing off the final tour. But what if we want to see the search in progress? Let's put in a <code><a href="http://docs.racket-lang.org/search/index.html?q=generator">generator</a></code> again so we can animate this. This time around though, I'm actually going to fold the generator code into the main method rather than duplicating a bunch of code.</p>
<pre class="scheme"><code>(define (knights-tour width [height width] #:generator? [generator? #f])
  (define g
    (generator ()
      ...

      (define (move-knight b p)
        (when generator?
          (yield b p))

        ...)))

  (if generator? g (g)))</code></pre>
<p>In this case, we create the <code>generator</code> no matter what. But we only call <code>yield</code> if we actually specify it to the function. This way we can see each step of our simultion as we go. If we don't want the generator, we immediately call it as we're returning, forcing it to return a value: the implicit <code>yield</code> at the end of the function.</p>
<p>So with this, we have enough that we can animate the search space:</p>
<pre class="scheme"><code>; Render the search for a knights tour into an animation
(define (knights-tour/animate-search width [height width] #:removed [removed '()])
  ; Create an initial board including the missing tiles
  (define board
    (for/fold ([b (make-board width height #:pieces (list Knight Invalid Visited))])
              ([p (in-list removed)])
      (board-set b p '(Black Invalid))))

  ; Prerender the board once so we know how large of a scene to create
  (define r (render board #:player-colors (const "black")))
  (define render-width (send r get-width))
  (define render-height (send r get-height))

  ; Set the last board, which will be updated on each yield
  (define last-board board)
  (define last-point (pt 0 0))
  (define g (knights-tour width height #:removed removed #:generator? #t))

  ; Animate the tour, rendering each frame once
  ; Stop when the generator returns 1 value
  (big-bang #t
    [on-tick
     (λ (running?)
       (and running?
            (with-handlers ([exn? (const #f)])
              (define-values (board point) (g))
              (set! last-board board)
              (set! last-point point)
              #t)))]
    [to-draw
     (λ (_)
       (place-image
        (render last-board)
        (/ render-width 2)
        (/ render-height 2)
        (empty-scene render-width render-height)))]
    [stop-when (negate identity)]
    [record? #t]))</code></pre>
<p>And in action:</p>
<pre class="scheme"><code>&gt; (knights-tour/animate-search 4
     #:removed (list (pt 1 0) (pt 0 2) (pt 0 3) (pt 2 3) (pt 3 3)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-search.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-search.gif" /></a></p>
<p>Sweet!</p>
<p>That's about all for today. If you were following along though, you might have noticed one very important omission...</p>
<p>It doesn't work on 8x8 boards.</p>
<p>Well, that's not strictly speaking true. It will work. If you wait long enough, you will eventually get a solution, but it's going to be a <em>very</em> long wait. So looks like we'll need a follow looking for a better solution<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span></p>
<p>That's for another time though. If you'd like to see the entire code, you can do so in the <a href="https://github.com/jpverkamp/chess-puzzles">chess-puzzles</a> repo on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles/blob/master/puzzles/knights-tour.rkt">knights-tour.rkt</a>. Check it out!</p>]]></content></entry><entry><title>Chess Puzzles: N Queens</title><link href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens" /><id>urn:uuid:ca36a36d-8baa-c760-8b5a-2162fcfa5a9c</id><updated>2014-09-03T20:00:00Z</updated><summary type="html"><![CDATA[<p>After two weeks, it seems only right that we actually get around to a real chess puzzle. First on the list: <a href="https://en.wikipedia.org/wiki/Eight_queens puzzle">the eight queens puzzle</a>.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Specifically, how do you place n queens on an n by n chess board such that no pair of queens can attack one another?</p>
]]></summary><content type="html"><![CDATA[<p>After two weeks, it seems only right that we actually get around to a real chess puzzle. First on the list: <a href="https://en.wikipedia.org/wiki/Eight_queens puzzle">the eight queens puzzle</a>.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Specifically, how do you place n queens on an n by n chess board such that no pair of queens can attack one another?</p>
<!--more-->
<p>Those of you paying attention may think this problem looks <a href="http://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code">awfully familiar</a>. Turns out I've already done this one. But not with my new <a href="http://blog.jverkamp.com/category/programming/by-topic/chess">chess library</a>! So let's do it again:</p>
<p>Basically, the idea is simple. Start in the first row and column, placing a queen:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-1.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-1.png" /></a></p>
<p>Next, move down to the second row, first column:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-2.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-3.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-4.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-4.png" /></a></p>
<p>We cannot place a queen there since it can attack the first. Try the second column ... Still doesn't work, since it can attack diagonally. Try the third... Bam. Placed. Head down to the third row and start over in the first column.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-5.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-5.png" /></a></p>
<p>Keep on keeping on. Eventually though, you'll run into a row when you can't place a queen. What do you do then?</p>
<p><a href="https://en.wikipedia.org/wiki/Backtracking">Backtrack!</a></p>
<p>Specifically, go back one row and remove that queen. Start over from one column to the right of where it was. If there's no where else to place that queen, back up another column, over and over until you finally find where you can place one.</p>
<p>Sounds crazy, keeping track of all that state (how many queens we've removed and which), but this is where the magic of recursion comes in. We can actually use the call stack to handle all of this backtracking for us!</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(define (queens n)
  ; Create a new nxn board
  (current-board-size n)
  (define-piece Queen (move 'n '*))
  (define b (make-board n #:pieces (hash 'Queen Queen)))

  ; Try to place a queen in each row
  (let place-queen ([board b] [x 0] [y 0])
    (cond
      ; Done with all of the rows, we have a valid configuration
      [(&gt;= y n) board]
      ; Done with the current row, if we haven't placed a queen yet, bail out
      [(&gt;= x n) #f]
      ; Otherwise, try to place the queen at this location
      ; Use the row as the player ID so they can all attack one another
      [else
       (define new-board (board-set board (pt x y) `(,y Queen)))
       (cond
         ; We attack a current queen, try the next square on the old board
         [(for/first ([target-pt (moves-from new-board (pt x y))]
                      #:when (board-ref new-board target-pt))
            #t)
          (place-queen board (+ x 1) y)]
         ; We do not attack anything (yet), try this solution
         ; If that fails, fall through (or short circuits)
         [else
          (or (place-queen new-board 0 (+ y 1))
              (place-queen board     (+ x 1) y))])])))</code></pre>
<p>The interesting parts of the solution are at the beginning (when we set up the intial board using our new library) and the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code> section. That's what's checking out attacks. In this case, <code>for/first</code> will return <code>#t</code> if any <code>#:when</code> is true, <code>#f</code> if none of them are. This works with our framework (as the code mentions) because we're setting each queen to a different player so they can all attack one another.</p>
<pre class="scheme"><code> &gt; (render (queens 8)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Nice!</p>
<p>Even bigger?</p>
<pre class="scheme"><code> &gt; (render (queens 13)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/13-queens.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/13-queens.png" /></a></p>
<pre class="scheme"><code> &gt; (render (queens 25) #:tile-size 12) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/25-queens.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/25-queens.png" /></a></p>
<p>(That one took a little while.)</p>
<p>Okay, so that's all well and good. But what if we don't want just one solution. What if we want all of them? Well, it turns out, that's actually not that much harder. We just need to slightly tweak how we recur. Instead of a board or <code>#f</code>, we need to return a list of possible solutions. That way we can <code>append</code> instead of <code>or</code>:</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(define (queens n #:all? [generate-all? #f])
  ...

      ; Done with all of the rows, we have a valid configuration
      [(&gt;= y n) (if generate-all? (list board) board)]
      ; Done with the current row, if we haven't placed a queen yet, bail out
      [(&gt;= x n) (if generate-all? (list)       #f)]

      ...

         ; We do not attack anything (yet), try this solution
         ; If that fails, fall through (or short circuits)
         ; If we're generating all solutions, do both
         ; (we cannot do ((if generate-all? append or) ...) because or is a macro
         [generate-all?
          (append (place-queen new-board 0 (+ y 1))
                  (place-queen board     (+ x 1) y))]

         ...)</code></pre>
<p>That way, we could get all of the 6x6 solutions in one go:</p>
<pre class="scheme"><code>&gt; (map (λ (b) (render b #:player-colors (const "black")))
       (queens 6 #:all? #t))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-1.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-2.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-3.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-4.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-4.png" /></a></p>
<p>Or determine how many queens that there are for each puzzle size:</p>
<pre class="scheme"><code>&gt; (for/list ([n (in-range 1 11)])
    (list n (length (queens n #:all? #t))))
'((1 1) (2 0) (3 0) (4 2) (5 10) (6 4) (7 40) (8 92) (9 352) (10 724))</code></pre>
<p>That matches up perfectly with sequence <a href="https://oeis.org/A000170">A000170</a> on <a href="https://en.wikipedia.org/wiki/OEIS">OEIS</a>, which must mean we're doing something right. Shiny!</p>
<p>One final trick, what if we want to animate these things? Well, for that we're going to use the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/generator">racket/generator</a></code> module. I've used it before, and although the performance isn't <em>great</em>, it's certainly the easiest way to get what we want. Really, we only need two changes:</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(require racket/generator)
(define (queens-generator n #:all? [generate-all? #f])
  (generator ()
    ...

    ; Try to place a queen in each row
    (let place-queen ([board b] [x 0] [y 0])
      (yield board x y)
      (cond
        ...</code></pre>
<p>That way, if we create a generator and keep calling it, it will return each board state including the backtracking. It's a little more complicated to turn it into a nice animation, once again using the excellent <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> function:</p>
<pre class="scheme"><code>; Use the queens generator to render an n-queens problem
(require 2htdp/image 2htdp/universe)
(define (queens-animate n #:all? [generate-all? #f])
  (define g (queens-generator n #:all? generate-all?))

  (define-values (last-board last-x last-y) (g))
  (define done? #f)

  (define r (render last-board #:player-colors (const "black")))
  (define w (send r get-width))
  (define h (send r get-height))

  (big-bang (void)
    [stop-when (λ (_) done?)]
    [on-tick
     (λ (_)
       (with-handlers ([exn? (thunk* (set! done? #t))])
         (define-values (board x y) (g))
         (set! last-board board)
         (set! last-x x)
         (set! last-y y)))]
    [to-draw
     (λ (_)
       (place-image
        (render last-board
                #:player-colors (const "black")
                #:highlights (hash (pt last-x last-y) "green"))
        (/ w 2)
        (/ h 2)
        (empty-scene w h)))]
    [record? #t]))</code></pre>
<p>The <code><a href="http://docs.racket-lang.org/search/index.html?q=with-handlers">with-handlers</a></code> is a little ugly, but it's designed to deal with the fact that we don't return multiple values on the last call, since generators by default return the last (return) value of a function at the end. But if we wanted to make that return x and y as well, things might just get ugly, seeing as how we'd have to change all of the recursive calls. No thank you.</p>
<p>It's certainly pretty to watch though:</p>
<pre class="scheme"><code> &gt; (queens-animate 4) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens.gif"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens.gif" /></a></p>
<p>You can see the backtracking anytime the green box jumps back and suddenly one or more of the previously place queens vanishes. It would be even neater if it could show the branching solutions, but that's a challenge for another day.</p>
<p>And that's it. A bit more in detail than <a href="http://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code">last time</a>, but I think it was a lot of fun. The code is available in my <a href="https://github.com/jpverkamp/chess-puzzles">chess-puzzles</a> repo on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles/blob/master/puzzles/queens.rkt">queens.rkt</a>. Check it out!</p>]]></content></entry></feed>