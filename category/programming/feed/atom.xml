<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2016-12-06T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:e246205b-1f33-c07a-2aa5-10021f3fe725</id><entry><title>Command line unicode search</title><link href="//blog.jverkamp.com/2016/12/06/command-line-unicode-search" /><id>urn:uuid:2a36cc6a-f2a3-47cd-be7a-0eb5d72d0e62</id><updated>2016-12-06T00:00:00Z</updated><summary type="html"><![CDATA[<p>Similar to Monday's post about <a href="//blog.jverkamp.com/2016/12/04/command-line-emoji-search">command line emoji search</a>, I often find myself wanting to look up Unicode characters. I have a custom search engine / bookmark set up in Chrome / Firefox (<code>uni %s</code> maps to <code>http://unicode-search.net/unicode-namesearch.pl?term=%s&.submit=Submit&subs=1</code>). That actually works great, but given how relatively much of my day I spend on the command line, I thought it would be interesting to do something there:</p>
<pre class="bash"><code>$ uni delta
⍋	apl functional symbol delta stile
⍙	apl functional symbol delta underbar
⍍	apl functional symbol quad delta
≜	delta equal to
Δ	greek capital letter delta
δ	greek small letter delta
ẟ	latin small letter delta
ƍ	latin small letter turned delta
𝚫	mathematical bold capital delta
𝜟	mathematical bold italic capital delta
𝜹	mathematical bold italic small delta
𝛅	mathematical bold small delta
𝛥	mathematical italic capital delta
𝛿	mathematical italic small delta
𝝙	mathematical sans-serif bold capital delta
𝞓	mathematical sans-serif bold italic capital delta
𝞭	mathematical sans-serif bold italic small delta
𝝳	mathematical sans-serif bold small delta
ᵟ	modifier letter small delta</code></pre>
]]></summary><content type="html"><![CDATA[<p>Similar to Monday's post about <a href="//blog.jverkamp.com/2016/12/04/command-line-emoji-search">command line emoji search</a>, I often find myself wanting to look up Unicode characters. I have a custom search engine / bookmark set up in Chrome / Firefox (<code>uni %s</code> maps to <code>http://unicode-search.net/unicode-namesearch.pl?term=%s&.submit=Submit&subs=1</code>). That actually works great, but given how relatively much of my day I spend on the command line, I thought it would be interesting to do something there:</p>
<pre class="bash"><code>$ uni delta
⍋	apl functional symbol delta stile
⍙	apl functional symbol delta underbar
⍍	apl functional symbol quad delta
≜	delta equal to
Δ	greek capital letter delta
δ	greek small letter delta
ẟ	latin small letter delta
ƍ	latin small letter turned delta
𝚫	mathematical bold capital delta
𝜟	mathematical bold italic capital delta
𝜹	mathematical bold italic small delta
𝛅	mathematical bold small delta
𝛥	mathematical italic capital delta
𝛿	mathematical italic small delta
𝝙	mathematical sans-serif bold capital delta
𝞓	mathematical sans-serif bold italic capital delta
𝞭	mathematical sans-serif bold italic small delta
𝝳	mathematical sans-serif bold small delta
ᵟ	modifier letter small delta</code></pre>
<!--more-->
<p>The basic idea is to take Python's <code>unicodedata</code> module and use that to get the names of characters, then to find those that best match user input. Of course one problem with that is that as of version 8 of the Unicode specification there are up to 263,994 characters defined in 262 different blocks. That's a bit much.</p>
<p>So instead, I'm going to select a handpicked list of blocks that I think might be vaguely interesting (see <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/uni#L284">here</a>) as a default and add the ability to select any other block as a command line switch:</p>
<pre class="bash"><code>$ uni --block currency euro
€	euro sign
₠	euro-currency sign</code></pre>
<p>So, how do I do it? First, let's assume I have a list of unicode blocks defined as such (available from the Unicode Consortium: <a href="ftp://ftp.unicode.org/Public/8.0.0/ucd/Blocks.txt">Blocks.txt</a>):</p>
<pre class="text"><code>0000..007F; Basic Latin
0080..00FF; Latin-1 Supplement
0100..017F; Latin Extended-A
0180..024F; Latin Extended-B
0250..02AF; IPA Extensions
...</code></pre>
<p>First, we'll want to either determine which block(s) we'll be looking at:</p>
<pre class="python"><code># Determine which unicode blocks we'll be searching through
blocks = []

if args.block:
    for line in all_blocks.split('\n'):
        if fuzz.token_set_ratio(args.block, line.split('; ')[-1]) &gt; 100 * args.block_threshold:
            blocks.append(line)
else:
    blocks = default_blocks.split('\n')

if not blocks:
    sys.stderr.write('No blocks found\n')
    sys.exit(-1)</code></pre>
<p><code>args</code> contains the parsed command line parameters, I'll get to that later. <code>fuzz</code> is from the <a href="https://github.com/seatgeek/fuzzywuzzy">fuzzywuzzy</a> Python library for fuzzy string matching. Basically, if the <code>--block</code> parameter was specified, we'll search for any that match closely enough, otherwise we'll use the default blocks.</p>
<p>Next, we'll look through and build a list of all possible matching characters within those blocks. Given the formats above, we can get the lower and upper bounds with <code>int</code>, specifying base 16 and then use <code>unicodedata</code> to get the character name. Again, we'll apply a fuzzy match to the character names.</p>
<pre class="python"><code># Search through all of those blocks, whee
results = []

for block in blocks:
    bounds, name = block.split('; ')
    lower_bound, upper_bound = bounds.split('..')

    lower_bound = int(lower_bound, 16)
    upper_bound = int(upper_bound, 16)

    for codepoint in range(lower_bound, upper_bound + 1):
        try:
            character = chr(codepoint)
            name = unicodedata.name(character, None).lower()
            score = fuzz.token_set_ratio(args.name, name)

            if score &gt; 100 * args.name_threshold:
                results.append((score, name, character))
        except:
            pass

if not results:
    sys.stderr.write('No characters found\n')
    sys.exit(-1)</code></pre>
<p>And after that, we have a few tweaks for output. We can print all of the results (default) or just a limited number and we can print just the character or also the name:</p>
<pre class="python"><code># Only print out the requested number of results
for count, (score, name, character) in enumerate(sorted(results)):
    if args.count and count &gt;= args.count:
        break

    if args.quiet:
        print(character)
    else:
        print(character, name, sep = '\t')</code></pre>
<p>I guess now would be a good time to go back to how we got the <code>args</code> object in the first place:</p>
<pre class="python"><code>parser = argparse.ArgumentParser('Search unicode characters')
parser.add_argument('name', nargs = '+', help = ...)
parser.add_argument('--block', '-b', help = ...)
parser.add_argument('--block-threshold', default = 0.9, help = ...)
parser.add_argument('--name-threshold', default = 0.9, help = ...)
parser.add_argument('--count', default = 0, type = int, help = ...)
parser.add_argument('--quiet', '-q', default = False, action = 'store_true', help = ...)
args = parser.parse_args()</code></pre>
<p><code>argparse</code> is a most excellent library. It allows you to declaratively specify what your command line parameters will be and then will parse it into an object with one field for each variable (fixing the names so that <code>--block-threshold</code> becomes <code>args.block_threshold</code>).</p>
<p>And that's it. You can use it to look up all sorts of interesting things:</p>
<pre class="python"><code>uni --count 10 --block runic runic

ᛮ	runic arlaug symbol
ᛰ	runic belgthor symbol
᛭	runic cross punctuation
ᚪ	runic letter ac a
ᚫ	runic letter aesc
ᛉ	runic letter algiz eolhx
ᚨ	runic letter ansuz a
ᛒ	runic letter berkanan beorc bjarkan b
ᛍ	runic letter c
ᛣ	runic letter calc</code></pre>
<p>(That will display better if you're using a font that includes Unicode range <code>16A0..16FF; Runic</code>.)</p>
<p>For the most part, I'll use it in this mode and then select characters to copy and paste. But you could also combine it with <a href="https://github.com/garybernhardt/selecta">selecta</a> and <code>pbcopy</code> (on OSX) to get something entirely more interesting:</p>
<pre class="bash"><code>$ uni --block runic runic | selecta | cut -f 1 | tr -d '\n' | pbcopy</code></pre>
<p><code>uni</code> will display a list of characters, <code>selecta</code> will let you search for one, <code>cut</code> will get just the character, <code>tr</code> will remove the newline, and <code>pbcopy</code> will send it to the clipboard. You could even shove it into a Bash/ZSH alias:</p>
<pre class="bash"><code>pbuni() {
    uni $@ | selecta | cut -f 1 | tr -d '\n' | pbcopy
}</code></pre>
<p>Very cool.</p>
<p>This is in my dotfiles, so you can find the full source here: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/uni">uni</a>. Enjoy!</p>]]></content></entry><entry><title>Command line emoji search</title><link href="//blog.jverkamp.com/2016/12/04/command-line-emoji-search" /><id>urn:uuid:cee40f17-a913-9d9b-f483-521c0bea600a</id><updated>2016-12-04T00:00:00Z</updated><summary type="html"><![CDATA[<p>Sometimes, I find myself wanting to communicate in <a href="https://en.wikipedia.org/wiki/emoji">emoji</a>.</p>
<p><img alt="chicken" class="emoji" src="/emoji/chicken.svg" /></p>
<p>How about this:</p>
<pre class="bash"><code>$ emoji chicken
🐔

$ emoji "which came first, the @emoji{:chicken:} or the :egg:"
which came first, the 🐔 or the 🍳</code></pre>
]]></summary><content type="html"><![CDATA[<p>Sometimes, I find myself wanting to communicate in <a href="https://en.wikipedia.org/wiki/emoji">emoji</a>.</p>
<p><img alt="chicken" class="emoji" src="/emoji/chicken.svg" /></p>
<p>How about this:</p>
<pre class="bash"><code>$ emoji chicken
🐔

$ emoji "which came first, the @emoji{:chicken:} or the :egg:"
which came first, the 🐔 or the 🍳</code></pre>
<!--more-->
<p>To start off, I'm going to use the data from muan's emojilib on GitHub: <a href="https://github.com/muan/emojilib/">github:muan/emojilib</a>. Specifically, their list of keywords that relate to any given emoji: <a href="https://raw.githubusercontent.com/muan/emojilib/master/emojis.json">emojis.json</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>We'll fetch that file if we haven't before and otherwise use a locally cached version:</p>
<pre class="python"><code>cache_path = os.path.expanduser('~/.emoji.json')
remote_url = 'https://raw.githubusercontent.com/muan/emojilib/master/emojis.json'

if not os.path.exists(cache_path):
    with open(cache_path, 'w') as fout:
        response = requests.get(remote_url)
        fout.write(response.text)

with open(cache_path, 'r') as fin:
    emoji = json.load(fin)</code></pre>
<p>After that, there are two different ways that we can look up Emoji. We can either look them up by a semi official name or by keyword. This function will search through the both, matching on names first and then falling back to the first which matches the given keyword (this script isn't designed to return choices for emoji, but rather just choose the first one that fits; because a Python <code>dict</code> isn't ordered, this is actually non-deterministic):</p>
<pre class="python"><code>def emoji_by_keyword(keyword):
    if keyword in emoji:
        return emoji[keyword]['char']

    for name in emoji:
        if name == 'keys':
            continue

        if keyword in emoji[name]['keywords']:
            return emoji[name]['char']

    return keyword</code></pre>
<p>Following that, we can use regular expressions (the <code>re</code> module) to replace emoji in a string--if they're set off <code>:emoji:</code> style (a la GitHub):</p>
<pre class="python"><code>def emojify(string):
    return re.sub(
        r'\:(\w+)\:',
        lambda m : emoji_by_keyword(m.group(1)),
        string
    )</code></pre>
<p>That's a neat trick that I use from time to time: the second argument to <code>re.sub</code> can be either a literal string or a function. If it's the latter, it's given the match object for each replacement, which we can then pass along to <code>emoji_by_keyword</code>.</p>
<p>And finally, let's mess with some command line arguments:</p>
<pre class="python"><code># Run replacement mode on stdin if no parameters
if len(sys.argv) == 1:
    for line in sys.stdin:
        print(emojify(line[:-1]))

# Othwise, run through the list
else:
    for arg in sys.argv[1:]:
        if ':' in arg:
            print(emojify(arg), end = ' ')
        else:
            print(emoji_by_keyword(arg), end = ' ')</code></pre>
<p>There are three modes we can be operating in:</p>
<ul>
    <li><code>stdin</code> mode, where we will read text from <code>stdin</code> and replace any <code>:emoji:</code> blocks with the corresponding emoji</li>
    <li>String mode, where we find any <code>:emoji:</code> in each argument in each input and replace them</li>
    <li>Single lookup mode, where we look up each argument as an individual emoji keyword, without the need for <code>:</code></li>
</ul>
<p>And, that's it.</p>
<pre class="bash"><code>$ emoji fireworks fireworks fireworks
🎆🎆🎆</code></pre>
<p>Since this is now one of my <a href="//blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a>, you can find the entire source here: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/emoji">emoji</a></p>]]></content></entry><entry><title>Inlining plaintext attachments in Gmail</title><link href="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail" /><id>urn:uuid:bc0d7956-f462-18f3-a332-a274b8c65941</id><updated>2016-12-02T00:00:00Z</updated><summary type="html"><![CDATA[<p>When you send a text message to a Gmail email address (at least from an iPhone using AT&T), you get something like this:</p>
<p><a href="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" /></a></p>
<p>It's vaguely annoying to have to click through every single time just to see what the message is, especially when various extensions (such as <a href="https://github.com/gorhill/uMatrix">uMatrix</a>) break overlay rendering or when you have multiple attachments.</p>
<p>Much better would be to just display the plaintext attachments inline:</p>
<p><a href="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>When you send a text message to a Gmail email address (at least from an iPhone using AT&T), you get something like this:</p>
<p><a href="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" /></a></p>
<p>It's vaguely annoying to have to click through every single time just to see what the message is, especially when various extensions (such as <a href="https://github.com/gorhill/uMatrix">uMatrix</a>) break overlay rendering or when you have multiple attachments.</p>
<p>Much better would be to just display the plaintext attachments inline:</p>
<p><a href="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/12/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" /></a></p>
<!--more-->
<p>Let's do it!</p>
<p>Essentially, I'm going to write a Javascript userscript, compatible with <a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/">Greasemonkey</a> or <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en">Tampermonkey</a> for Chrome. Either allows you to insert small bits of Javascript into web pages to modify their behavior.</p>
<p>After digging around a bit in the structure of Gmail's message pages, here's roughly what I ended up with:</p>
<pre class="javascript"><code>var checkForPlaintexts = function(evt) {
    jQuery('span[download_url]').each(function(i, el) {
        var parts = el.getAttribute('download_url').split(':');
        if (!parts || parts[0] != 'text/plain') return;
        var url = parts[3];

        var newElement = jQuery('&lt;pre id="GPTI_' + i + '"&gt;&lt;/pre&gt;');
        newElement.text('Loading: ' + url);

        jQuery(el).replaceWith(newElement);
        jQuery.ajax({
            url: url,
            success: function(data) {
                newElement.text(data);
            }
        });
    });
};</code></pre>
<p>Basically, we're going to look for a <code>span</code> containing a <code>download_url</code> attribute. For the moment at least, that's always present with attachments and not otherwise. If you take that <code>download_url</code> element, you get something like this:</p>
<p><code>text/plain:text_0.txt:https://mail.google.com/mail/u/0/?ui=...</code>`</p>
<p>The first part is a <a href="https://en.wikipedia.org/wiki/MIME_type">MIME type</a>--of which, we're only interested in plaintext. The last section is a URL under gmail which, when visited, contains the contents of the attachment.</p>
<p>Now that I have that (via jQuery<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>), I build a new <code>pre</code> element with the text content and shove it in place.</p>
<p>Voila.</p>
<p>All I have to do next is make sure that it's called when I either load the page or when I navigate from the Inbox (et al) to a message:</p>
<pre class="javascript"><code>jQuery(window).bind('hashchange', checkForPlaintexts);
jQuery(checkForPlaintexts);</code></pre>
<p>Unfortunately, this has some issues as well. It works if the message has already been viewed once, but not on the first load. Basically, I'm running into timing issues.</p>
<p>My original solution to this was to put in a quick delay and call it a day. Unfortunately, when using satellite internet... even that didn't work. So instead, I built a system that will delay the initial call and then--if it fails--try a few more times with increasing timeouts between then.</p>
<p>Something like this:</p>
<pre class="javascript"><code>var delayedEvent = function(f, timeout, retries) {
    timeout = timeout || 0;
    retries = retries || 0;

    return function(evt) {
        setTimeout(f, timeout, evt, retries, timeout * 2);
    }
};

var checkForPlaintexts = function(evt, retries, delay) {
    retries = retries || 0;
    var foundOne = false;

    jQuery('span[download_url]').each(function(i, el) {
        foundOne = true;

        ...
    });

    if (!foundOne && retries) {
        setTimeout(checkForPlaintexts, delay, evt, retries - 1, delay * 2);
    }
};

jQuery(window).bind('hashchange', delayedEvent(checkForPlaintexts, 125, 3));
jQuery(delayedEvent(checkForPlaintexts, 125, 3));</code></pre>
<p>So far, this has worked perfectly. Sometimes it takes a bit to fetch the ajax call in the background. That's why I put in the <code>Loading...</code> notification to tell the user it was working.</p>
<p>It's been a little while since I last wrote a userscript (pre-Chrome, to give you an idea). I forgot how much fun it can be to mess with websites a bit like that. I may write up a few more.</p>
<p>If you'd like to see the entire source (includes some debug messaging and the userscript header comments), you can do so on GitHub: <a href="https://github.com/jpverkamp/userscripts/blob/master/gmail-plaintext-inline.user.js">gmail-plaintext-inline.user.js</a></p>
<p>If you want to install it directly (and have Greasemonkey/Tampermonkey installed), you can directly from GitHub as well: <a href="https://github.com/jpverkamp/userscripts/raw/master/gmail-plaintext-inline.user.js">install gmail-plaintext-inline.user.js</a>.</p>
<p>As a side note, 'optional' parameters in Javascript are weird...</p>]]></content></entry><entry><title>Advent of Code: Day 25</title><link href="//blog.jverkamp.com/2015/12/25/advent-of-code-day-25" /><id>urn:uuid:76fab82b-01da-119f-da63-b163c5d488e0</id><updated>2015-12-25T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533F(n-1) \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533F(n-1) \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
<!--more-->
<pre class="python"><code>target_row = int(sys.argv[1])
target_col = int(sys.argv[2])

row = 1
col = 1
val = 20151125

while True:
    if target_row == row and target_col == col:
        print(val)
        sys.exit(0)
    else:
        val = (val * 252533) % 33554393

    if row == 1:
        row = col + 1
        col = 1
    else:
        row -= 1
        col += 1</code></pre>
<p>Merry Christmas!</p>]]></content></entry><entry><title>Advent of Code: Day 24</title><link href="//blog.jverkamp.com/2015/12/24/advent-of-code-day-24" /><id>urn:uuid:2035cd03-489e-dfec-f613-117529fa491f</id><updated>2015-12-24T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
<!--more-->
<p>My initial solution to this was to solve the <a href="https://en.wikipedia.org/wiki/subset_sum">subset sum</a> problem (or at least a slightly modified version thereof):</p>
<pre class="python"><code>def subsets_summing_to(target, items, cache = {}):
    if target == 0:
        yield set()
    else:
        for i, item in enumerate(items):
            if item &lt;= target:
                for recur in subsets_summing_to(target - item, items - {item}):
                    yield {item} | recur</code></pre>
<p>It's elegant code, and you can use that to generate the three groups fairly easily:</p>
<pre class="python"><code>packages = {int(line.strip()) for line in sys.stdin}
weight_per_package = sum(packages) // 3

for group1 in subsets_summing_to(weight_per_package, package):
    for group2 in subsets_summing_to(weight_per_package, package - group1):
        group3 = packages - group1 - group2
        ...</code></pre>
<p>And then while I let that run, I made a realization. If I generate the first group to be the smallest (by generating all groups of size 1, size 2, size 3, etc), then it doesn't actually matter what the other groups are. Furthermore, if I structure my iteration carefully so that I always return the smallest items first, I will get a minimal product<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Combining these two jumps, I get:</p>
<pre class="python"><code>def subset_sum_of_n(target, items, count):
    if target == 0 and count == 0:
        yield set()
    elif count == 0:
        return
    else:
        for i, item in enumerate(sorted(items)):
            if item &lt;= target:
                for recur in subset_sum_of_n(target - item, items - {item}, count - 1):
                    yield {item} | recur

def calculate_quantum_entanglement(group):
    product = 1
    for item in group:
        product *= item
    return product

def split_into(packages, n_groups):
    weight_per_section = sum(packages) / int(sys.argv[1])

    for n in range(1, len(packages)):
        for group in subset_sum_of_n(weight_per_section, packages, n):
            return (len(group), calculate_quantum_entanglement(group), group)

if __name__ == '__main__':
    packages = {int(line.strip()) for line in sys.stdin}
    n_groups = int(sys.argv[1])

    print(split_into(packages, n_groups))</code></pre>
<p>I'm greatly amused that it doesn't matter at all what any of the other groups are.</p>
<p><strong>Part 2:</strong> Split into four groups.</p>
<p>I already solved this with the <code>n_groups</code> parameter above.</p>
<p>Amusingly, because this solution (at least with my input) only has 4 items in the minimal group, it runs about 60 times faster than the first part. It still doesn't matter at all what the other groups are.</p>]]></content></entry><entry><title>Advent of Code: Day 23</title><link href="//blog.jverkamp.com/2015/12/23/advent-of-code-day-23" /><id>urn:uuid:2b737957-97d1-2db7-c18a-ef2b4bee221f</id><updated>2015-12-23T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
<!--more-->
<p>I do love writing a good virtual machine. Check out my <a href="//blog.jverkamp.com/2013/08/21/a-tiny-virtual-machine-in-racket">'Tiny' virtual machine in Racket</a>.</p>
<pre class="python"><code>def read_program():
    return [
        tuple(re.split('[, ]+', line.strip()))
        for line in sys.stdin
    ]

def run(program, **initial_state):
    pc = 0
    registers = {'a': 0, 'b': 0}
    registers.update(initial_state)

    while True:
        op = program[pc][0]
        args = program[pc][1:]

        if op == 'hlf':
            registers[args[0]] //= 2
            pc += 1
        elif op == 'tpl':
            registers[args[0]] *= 3
            pc += 1
        elif op == 'inc':
            registers[args[0]] += 1
            pc += 1
        elif op == 'jmp':
            pc += int(args[0])
        elif op == 'jie':
            if registers[args[0]] % 2 == 0:
                pc += int(args[1])
            else:
                pc += 1
        elif op == 'jio':
            if registers[args[0]] == 1:
                pc += int(args[1])
            else:
                pc += 1

        if not (0 &lt;= pc &lt; len(program)):
            break

    return registers

if __name__ == '__main__':
    program = read_program()
    output = run(program)
    print(output['b'])</code></pre>
<p>It's not the most abstracted thing ever, but it really doesn't matter. It works great.</p>
<p><strong>Part 2:</strong> Re-run with the initial state <code>a=1, b=0</code>.</p>
<p>I'll reuse the same trick I've used a few times before to load part 1:</p>
<pre class="python"><code>part1 = imp.load_source('part1', 'part-1.py')

if __name__ == '__main__':
    program = part1.read_program()
    output = part1.run(program, a = 1)
    print(output['b'])</code></pre>]]></content></entry><entry><title>Advent of Code: Day 22</title><link href="//blog.jverkamp.com/2015/12/22/advent-of-code-day-22" /><id>urn:uuid:9cebad4b-f376-fc86-db80-6136e90ab202</id><updated>2015-12-22T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
<!--more-->
<p>First, let's create some simple abstractions for the players:</p>
<pre class="python"><code>class Entity(dict):
    '''Represent a damagable entity such as the player or a boss'''

    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            self[key] = val

    def __getitem__(self, key):
        try:
            return dict.__getitem__(self, key)
        except:
            return 0

    def damage(self, points):
        '''Apply damage to this entity; minimum damage is always 1'''

        self['Hit Points'] -= max(1, points - self['Armor'])

    def tick_active_spells(self, target):
        '''Apply all active spells to the target, remove any that have expired.'''

        if self['Active Spells']:
            for spell in list(self['Active Spells']):
                self['History'].append(str(spell))
                spell.tick(self, target)
                spell.Duration -= 1
                if spell.Duration &lt;= 0:
                    self['History'].append('{} fades'.format(spell.__class__.__name__))
                    spell.fade(self, target)
                    self['Active Spells'].remove(spell)</code></pre>
<p>Basically, we have an extended <code>dict</code> that will default values to 0, includes a method for applying <code>damage</code> while taking armor into account, and applying an active spells to a given player. That will make more sense once you see the way spells are defined:</p>
<pre class="python"><code>class Spell(dict):
    '''
    Create a spell. Spells have &lt;code&gt;Cost&lt;/code&gt; mana and last &lt;code&gt;Duration&lt;/code&gt; turns.

    cast() is called when a spell is first cast
    tick() is called each turn (for Duration &gt; 0)
    fade() is called when a spell runs out of duration
    '''

    Cost = float("inf")
    Duration = 0

    def __init__(self):
        self['Duration'] = self.__class__.Duration

    def cast(self, caster, target):
        pass

    def tick(self, caster, target):
        pass

    def fade(self, caster, target):
        pass

    def __repr__(self):
        return '{}({})'.format(self.__class__.__name__, self.Duration)

    def __eq__(self, other):
        return self.__class__.__name__ == other.__class__.__name__

    def __hash__(self):
        return hash(self.__class__.__name__)

class MagicMissle(Spell):
    Cost = 53

    def cast(self, caster, target):
        target.damage(4)

class Drain(Spell):
    Cost = 73

    def cast(self, caster, target):
        target.damage(2)
        caster['Hit Points'] += 2

class Shield(Spell):
    Cost = 113
    Duration = 6

    def cast(self, caster, target):
        caster['Armor'] += 7

    def fade(self, caster, target):
        caster['Armor'] -= 7

class Poison(Spell):
    Cost = 173
    Duration = 6

    def tick(self, caster, target):
        target.damage(3)

class Recharge(Spell):
    Cost = 229
    Duration = 5

    def tick(self, caster, target):
        caster['Mana Points'] += 101

spells = [MagicMissle, Drain, Shield, Poison, Recharge]</code></pre>
<p>As noted in the comment for the <code>Spell</code> class, there are two interesting fields (<code>Cost</code> is the mana cost and <code>Duration</code> is how long an ongoing spell will last) and three functions that can be overridden. <code>cast</code> will be called when the spell is first cast, <code>tick</code> will be called each turn it runs for ongoing spells, and <code>fade</code> will be called when an ongoing spell runs out of time. That will let us encode the five spells in the <a href="http://adventofcode.com/day/22">problem statement</a>.</p>
<p>Finally, we can load the player and boss:</p>
<pre class="python"><code>boss = lib.Entity()
for line in sys.stdin:
    key, val = line.strip().split(': ')
    boss[key] = int(val)

player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [],
    'History': [],
})</code></pre>
<p>Now we have everything to solve the problem. My first take at a solution using a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> based on the mana spent. That means that as soon as we find a solution where <code>boss['Hit Points'] <= 0</code>, we have the minimal solution:</p>
<pre class="python"><code>queue_breaker = 0

states = queue.PriorityQueue()
states.put((0, queue_breaker, player, boss))

best_player = {'Mana Spent': float('inf')}

# This will be used to break ties in the queue since Entities are not orderable
queue_breaker += 1

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        return player

    # Player died, no point in continuing on this track
    if player['Hit Points'] &lt;= 0:
        continue

    # --- Player's turn ---
    player = copy.deepcopy(player)
    boss = copy.deepcopy(boss)
    player['History'].append('&gt;&gt; Player Turn &lt;&lt;')
    player.tick_active_spells(boss)

    # Branch (see the copy below) to applying each possible spell for the player's turn
    for potential_spell in lib.spells:
        if player['Mana Points'] &lt; potential_spell.Cost:
            continue

        spell = potential_spell()
        if spell in player['Active Spells']:
            continue

        current_player = copy.deepcopy(player)
        current_boss = copy.deepcopy(boss)

        # Cast the player's new spell
        current_player['Mana Points'] -= potential_spell.Cost
        current_player['Mana Spent'] += potential_spell.Cost
        spell.cast(current_player, current_boss)

        if spell['Duration']:
            current_player['Active Spells'].append(spell)

        current_player['History'].append(str(spell))

        # --- Boss's turn ---
        current_player['History'].append('&gt;&gt; Boss Turn &lt;&lt;')
        current_player.tick_active_spells(current_boss)
        current_player.damage(current_boss['Damage'])

        # Store the altered copies back in the queue
        states.put((current_player['Mana Spent'], queue_breaker, current_player, current_boss))
        queue_breaker += 1</code></pre>
<p>Most of the code is spent getting the order of events exactly correct. It's a bit weird, but it does work in the end (I think I rewrote exactly this code a dozen times and it finally worked...). The only problem with this solution: the search space is <em>huge</em>. I let it run for rather a while and it simulated literally millions of states still without finding a final solution. I need to cut that down.</p>
<p>My next trial was to tweak the scoring algorithm. By doing this, we lose the ability to return immediately once we have a solution, but we gain the ability to find <em>a</em> solution quickly and then throw out any solutions that would be worse than that one. We only have to make a few tweaks to the above code:</p>
<pre class="python"><code>best_player = {'Mana Spent': float('inf')}

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        if early_exit:
            return player
        elif player['Mana Spent'] &lt; best_player['Mana Spent']:
            print('New best mana spent:', player['Mana Spent'])
            best_player = player
            continue

    ...

    # Store the altered copies back in the queue
    score = scoring_function(current_player, current_boss)
    states.put((score, queue_breaker, current_player, current_boss))
    queue_breaker += 1

return best_player</code></pre>
<p>Interestingly, this converges very quickly (a few seconds) on my correct solution, then spends a (long) while making sure it's correct. In earlier (incorrect) simulations, it would find a few increasingly good solutions before finally ending up at a steady state.</p>
<p>This runs much more quickly, but guaranteeing that we have a correct solution is still difficult. Instead, let's try a quick <a href="https://en.wikipedia.org/wiki/Monte_Carlo simulation">Monte Carlo simulation</a>:</p>
<pre class="python"><code>def random_spells():
    while True:
        yield random.choice(lib.spells)

class GameOverException(Exception):
    def __init__(self, player_won, reason):
        self.player_won = player_won
        self.reason = reason

def check_game_over(player, boss):
    if boss['Hit Points'] &lt;= 0:
        raise GameOverException(True, 'boss died')

    if player['Hit Points'] &lt;= 0:
        raise GameOverException(False, 'player died')

def fight(player, boss, spell_iterator):
    while True:
        check_game_over(player, boss)

        # --- Player turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        for i, potential_spell in enumerate(spell_iterator):
            if i &gt;= 10:
                raise GameOverException(False, 'failed to cast 10 spells')

            if potential_spell.Cost &gt; player['Mana Points']:
                continue

            spell = potential_spell()
            if spell in player['Active Spells']:
                continue

            player['History'].append('Player casts {}'.format(potential_spell.__name__))
            player['Mana Points'] -= potential_spell.Cost
            player['Mana Spent'] += potential_spell.Cost

            spell.cast(player, boss)
            check_game_over(player, boss)

            if spell.Duration:
                player['Active Spells'].append(spell)

            break

        # --- Boss turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        player.damage(boss['Damage'])
        check_game_over(player, boss)

def monte_carlo(player, boss, timeout = TIME_TO_RUN):
    start = time.time()
    best_player = {'Mana Spent': float('inf')}
    simulations = 0
    wins = 0

    while True:
        if time.time() - start &gt; TIME_TO_RUN:
            break

        simulations += 1
        current_boss = copy.deepcopy(boss)
        current_player = copy.deepcopy(player)

        try:
            fight(current_player, current_boss, random_spells())
        except GameOverException as game_over:
            if game_over.player_won:
                wins += 1
                if current_player['Mana Spent'] &lt; best_player['Mana Spent']:
                    print('New best:', current_player['Mana Spent'])
                    best_player = current_player

    return simulations, wins, best_player</code></pre>
<p>Basically, just fire off random spells (trying up to 10 times in a given round to account for running low on mana and no duplicates) until one player wins (I'm using a <a href="https://en.wikipedia.org/wiki/try_catch">try catch</a> block to handle that so that I can check for winners more cleanly than in the first solution). If it's the player, see if we spent less mana than any solution we've found thus far. Rinse and repeat. Running it for a minute, it seems to find the best solution after roughly 2-3 minutes of running on my laptop. So not great, but at least an alternative.</p>
<p><strong>Part 2:</strong> On each of the player's turns (not on the boss's turns), the player loses 1 HP. Find the winning combination of spells that uses the least mana.</p>
<p>Based on the way that I structured the code, this is actually as easy as adding a new spell with unlimited <code>Duration</code>:</p>
<pre class="python"><code>class HardMode(Spell):
    Duration = float('inf')

    def tick(self, caster, target):
        self.toggle = not getattr(self, 'toggle', False)
        if self.toggle:
            caster.damage(1)</code></pre>
<p>There's a bit of weirdness there to make sure that it only runs half as often as most spells (since we don't have half hit points), but this works perfectly. We then start the player with this as an active spell:</p>
<pre class="python"><code>player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [lib.HardMode()],
    'History': [],
})</code></pre>
<p>And that's it. The rest of the simulation is identical. Since <code>HardMode</code> isn't in the <code>lib.spells</code> list, it won't get cast by either solution. Even if we wanted to we couldn't because of the limitation of only one of each ongoing spell at a time.</p>
<p>This actually makes the problem a bit harder computationally. There were already not <em>that</em> many combinations of spells that would win in the first case and there are even fewer this time around. I ran the Monte Carlo simulation several times for five minutes each without it randomly stumbling on a valid ordering that works for this case. I could probably have tweaked the generation algorithm to be a bit smarter, but it wasn't necessary. The priority queue solution with the boss HP weighting found the solution quickly enough.</p>
<p>Since the code for this one is a bit more complicated, feel free to check it out on GitHub to see the whole picture: <a href="https://github.com/jpverkamp/advent-of-code/tree/master/day-22">GitHub:jpverkamp/advent-of-code</a>. I've been (and will continue to) uploading my solutions there, but previously I've just directly included the entire code in order in the posts.</p>
<p>That all being said, I honestly think this was my least favorite problem of them thus far. It was interesting in that it actually mattered what algorithm you chose to solve it (I imagine that a recursive solution with memoization could be even faster), but the implementation details were just way too fiddly. As mentioned earlier, I wrote out more or less exactly the same algorithms a dozen times before I finally had one that actually returned the correct answer (for the most part, they were finding solutions that were too low). So it goes.</p>
<p>I look forward to the final three problems!</p>]]></content></entry><entry><title>Advent of Code: Day 21</title><link href="//blog.jverkamp.com/2015/12/21/advent-of-code-day-21" /><id>urn:uuid:2a910be6-afd8-d4dc-e437-c5c47fc1ed7a</id><updated>2015-12-21T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/21">Source</a></p>
<p><strong>Part 1:</strong> Given a shop full of weapons (buy exactly one), armor (buy zero or one), and rings (buy 0, 1, or 2), determine the set of items that will defeat a given enemy for the minimum cost (see the <a href="http://adventofcode.com/day/21">original writeup</a> for more details).</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/21">Source</a></p>
<p><strong>Part 1:</strong> Given a shop full of weapons (buy exactly one), armor (buy zero or one), and rings (buy 0, 1, or 2), determine the set of items that will defeat a given enemy for the minimum cost (see the <a href="http://adventofcode.com/day/21">original writeup</a> for more details).</p>
<!--more-->
<p>First, a bit of code to parse the shop:</p>
<pre class="python"><code>shop = {}
category = None

with open('shop.txt', 'r') as fin:
    for line in fin:
        line = line.strip()
        if not line:
            continue

        if ':' in line:
            category = line.split(':')[0]
            shop[category] = []
            continue

        name, cost, damage, armor = line.rsplit(maxsplit = 3)

        shop[category].append({
            'Name': name,
            'Cost': int(cost),
            'Damage': int(damage),
            'Armor': int(armor),
        })

# Allow for no armor or rings
shop['Armor'].append({'Name': None, 'Cost': 0, 'Damage': 0, 'Armor': 0})
shop['Rings'].append({'Name': None, 'Cost': 0, 'Damage': 0, 'Armor': 0})</code></pre>
<p>Using that, we can write some code to generate all possible players:</p>
<pre class="python"><code>def all_players():
    for weapon in shop['Weapons']:
        for armor in shop['Armor']:
            for left_ring in shop['Rings']:
                for right_ring in shop['Rings']:
                    # Cannot have two of the same ring unless they're both None
                    if left_ring and right_ring and left_ring == right_ring:
                        continue

                    items = [weapon, armor, left_ring, right_ring]

                    player = {
                        'Hit Points': 100,
                        'Items': [item['Name'] for item in items if item['Name']],
                        'Damage': sum(item['Damage'] for item in items),
                        'Armor': sum(item['Armor'] for item in items),
                        'Cost': sum(item['Cost'] for item in items),
                    }

                    yield player</code></pre>
<p>Additionally, we can read our opponent's stats from <code>stdin</code>:</p>
<pre class="python"><code>enemy = {}
for line in sys.stdin:
    key, val = line.strip().split(':')
    enemy[key] = int(val)

def get_enemy():
    return copy.copy(enemy)</code></pre>
<p>It's important to return a new copy each time; otherwise you end up badly beating up the same guy over and over again.</p>
<p>Finally, fight:</p>
<pre class="python"><code>def player_wins(player, enemy):
    while True:
        enemy['Hit Points'] -= max(1, player['Damage'] - enemy['Armor'])
        if enemy['Hit Points'] &lt;= 0:
            return True

        player['Hit Points'] -= max(1, enemy['Damage'] - player['Armor'])
        if player['Hit Points'] &lt;= 0:
            return False</code></pre>
<p>With all of this in a separate file called <code>lib.py</code> (I should probably refactor some of the previous days this way), we can solve the actual problem in about a half dozen lines:</p>
<pre class="python"><code>import lib

best_player = {'Cost': float("inf")}
for player in lib.all_players():
    if lib.player_wins(player, lib.get_enemy()):
        if player['Cost'] &lt; best_player['Cost']:
            best_player = player

print(best_player['Cost'])</code></pre>
<p>A brute force solution feels a bit ugly. We could instead have iterated over the solutions from the cheapest up until we found one that worked, or even done a <a href="https://en.wikipedia.org/wiki/binary_search">binary search</a> by cost, but what's the point? There are only 1260 possible inventories. That's nothing to a computer.</p>
<p><strong>Part 2:</strong> Invert the problem. Find the most expensive set of items you can buy and still lose.</p>
<p>This is why I factored out all of the library code. I know that something like this would be part 2. :)</p>
<pre class="python"><code>import lib

best_player = {'Cost': float("-inf")}
for player in lib.all_players():
    if not lib.player_wins(player, lib.get_enemy()):
        if player['Cost'] &gt; best_player['Cost']:
            best_player = player

print(best_player['Cost'])</code></pre>
<p>In case you were curious, my winner for part 1 had a longsword, chainmail, and a Ring of Damage +2. Part 2 had a Dagger, Leather Armor, and Rings of Damage +3 and Defense +3. It's interesting that the cheaper option actually had a more expensive weapon and armor, but the pair of rings more than made up for it.</p>]]></content></entry><entry><title>Advent of Code: Day 20</title><link href="//blog.jverkamp.com/2015/12/20/advent-of-code-day-20" /><id>urn:uuid:afd29395-b082-d1af-1e24-dc1d0df19418</id><updated>2015-12-20T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/20">Source</a></p>
<p><strong>Part 1:</strong> <em>P(n)</em> is defined such that for each number <em>i</em>, add <em>10i</em> to any number divisible by <em>i</em>. Find the first value <em>n</em> such that <em>P(n)</em> is at least a given target number.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/20">Source</a></p>
<p><strong>Part 1:</strong> <em>P(n)</em> is defined such that for each number <em>i</em>, add <em>10i</em> to any number divisible by <em>i</em>. Find the first value <em>n</em> such that <em>P(n)</em> is at least a given target number.</p>
<!--more-->
<p>Let's throw some memory (and <a href="http://www.numpy.org/">numpy</a>) at it:</p>
<pre class="python"><code>target = int(sys.argv[1])

presents = numpy.zeros(target)

for i in range(1, target):
    presents[i::i] += 10 * i

for i in range(len(presents)):
    if presents[i] &gt;= target:
        print(i)
        sys.exit(0)</code></pre>
<p>It barely makes it in under a minute, but it does. You can speed it up even more if you guess on where the answer will be an initialize to only the first <code>numpy.zeros(target / 10)</code>. In only shaves off about 1/6 of the time on my run though, so I'm not sure it's worth it.</p>
<p><strong>Part 2:</strong> Do the same thing, only use <em>11i</em> instead of <em>10i</em> but only to the first 50 multiples.</p>
<p>Nothing much changes:</p>
<pre class="python"><code>target = int(sys.argv[1])

presents = numpy.zeros(target / 10)

for i in range(1, target):
    presents[i:i*50:i] += 11 * i

for i in range(len(presents)):
    if presents[i] &gt;= target:
        print(i)
        sys.exit(0)</code></pre>]]></content></entry><entry><title>Advent of Code: Day 19</title><link href="//blog.jverkamp.com/2015/12/19/advent-of-code-day-19" /><id>urn:uuid:d3f72e70-8cbc-74c9-b51b-9829eebd4f72</id><updated>2015-12-19T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/19">Source</a></p>
<p><strong>Part 1:</strong> Given a list of list of string replacements and an input string, determine how many unique output strings are possible after one step.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/19">Source</a></p>
<p><strong>Part 1:</strong> Given a list of list of string replacements and an input string, determine how many unique output strings are possible after one step.</p>
<!--more-->
<pre class="python"><code>transitions = collections.defaultdict(set)

reading_transitions = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        reading_transitions = False
    elif reading_transitions:
        src, dst = line.split(' =&gt; ')
        transitions[src].add(dst)
    else:
        target = line

def expand_iter(input):
    for src in transitions:
        for dst in transitions[src]:
            for match in re.finditer(src, input):
                yield input[:match.start()] + dst + input[match.end():]

expansions = set(expand_iter(target))

print(len(expansions))</code></pre>
<p>The basic idea here is to iterate over each possible (non-overlapping) replacement and <code>yield</code> the results. Then we convert that to a <code>set</code> to remove duplicates and return the sizes. Shiny.</p>
<p>I bet I can guess where the second half is going.</p>
<p><strong>Part 2:</strong> This time, take the target as output and determine how many steps it would take to get from <code>e</code> to the target.</p>
<p>This one is actually more of a rewrite (since I'm inverting the <code>transition</code> map):</p>
<pre class="python"><code>transitions = {}

reading_transitions = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        reading_transitions = False
    elif reading_transitions:
        src, dst = line.split(' =&gt; ')
        transitions[dst] = src
    else:
        target = line

def build_iter(input):
    for dst in transitions:
        src = transitions[dst]
        for match in re.finditer(dst, input):
            yield input[:match.start()] + src + input[match.end():]

q = queue.PriorityQueue()
q.put((len(target), 0, target))

while True:
    length, iterations, current = q.get()

    if current == 'e':
        break

    for precursor in build_iter(current):
        q.put((len(precursor), iterations + 1, precursor))

print(iterations)</code></pre>
<p>Two basic insights here: Since each transition output is unique, we don't have multiple possibilities and we want to solve the problem as quickly as possible. Given that, we will use a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> indexing on the length of the current chemical. That way, we'll try the solutions that are already as far along as possible.</p>
<p>For my input, that worked very quickly. For slightly different inputs, the <a href="https://en.wikipedia.org/wiki/greedy_solution">greedy solution</a> doesn't find a result and it has to backtrack, leading to a <em>far</em> longer runtime. I'm not sure what would solve those quickly. I may play with this one a bit longer.</p>
<p>Also, technically this solution isn't strictly correct. It finds the first solution, rather than strictly speaking the shortest one. That could be fixed continuing to iterate on the priority queue until we've exhausted any branches with fewer iterations than the known best. That takes rather a while though. That's one advantage of a contest styles--you can check your input. O:)</p>]]></content></entry></feed>