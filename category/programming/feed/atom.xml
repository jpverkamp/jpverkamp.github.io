<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2016-04-19T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:e246205b-1f33-c07a-2aa5-10021f3fe725</id><entry><title>Ensuring docker-machine is running</title><link href="//blog.jverkamp.com/2016/04/19/ensuring-docker-machine-is-running" /><id>urn:uuid:0e62eb30-f56c-7441-a014-2f509ef5d9d5</id><updated>2016-04-19T00:00:00Z</updated><summary type="html"><![CDATA[<p>When developing using <a href="https://www.docker.com/">docker</a> on OS X, you'll currently<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> have to use <a href="https://docs.docker.com/machine/">docker-machine</a> to spin up a virtual machine that is actually running the docker containers. Running a virtual machine takes up a bit more in the way of resources than just the docker containers, so if you're not actually developing at the moment, it's helpful to be able to start up the virtual machine only when you need it.</p>
<p>The current way I have to do that:</p>
<pre class="bash"><code>$ docker-machine start default
$ eval $(docker-machine env default)</code></pre>
<p>What's worse, the latter command has to be run for every shell that you start up. It's by no means a hard pair of commands and you could easily wrap them in an alias or put them in your <code>.profile</code> equivalent (which is what I used to do). But unfortunately, I found a completely unrelated bug in <a href="https://github.com/tony/tmuxp"><code>tmuxp</code></a>: if the shell takes too long to start up, <code>tmuxp</code> essentially won't work. The above <code>eval</code> command took long enough to hit this limit.</p>
]]></summary><content type="html"><![CDATA[<p>When developing using <a href="https://www.docker.com/">docker</a> on OS X, you'll currently<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> have to use <a href="https://docs.docker.com/machine/">docker-machine</a> to spin up a virtual machine that is actually running the docker containers. Running a virtual machine takes up a bit more in the way of resources than just the docker containers, so if you're not actually developing at the moment, it's helpful to be able to start up the virtual machine only when you need it.</p>
<p>The current way I have to do that:</p>
<pre class="bash"><code>$ docker-machine start default
$ eval $(docker-machine env default)</code></pre>
<p>What's worse, the latter command has to be run for every shell that you start up. It's by no means a hard pair of commands and you could easily wrap them in an alias or put them in your <code>.profile</code> equivalent (which is what I used to do). But unfortunately, I found a completely unrelated bug in <a href="https://github.com/tony/tmuxp"><code>tmuxp</code></a>: if the shell takes too long to start up, <code>tmuxp</code> essentially won't work. The above <code>eval</code> command took long enough to hit this limit.</p>
<!--more-->
<p>So how do we fix it? Essentially (using <a href="http://www.zsh.org/">zsh</a>, my current shell of choice, although others should be similar):</p>
<pre class="zsh"><code>assert-docker() {
    command docker ps 2&gt; /dev/null &gt; /dev/null
    if [ $? -ne 0 ]; then
        echo "Starting docker..."
        docker-machine start default
        eval $(docker-machine env default)
        echo
    fi
}

docker () { assert-docker && command docker $@ }
docker-compose () { assert-docker && command docker-compose $@ }</code></pre>
<p>The basic idea is that <code>assert-docker</code> first checks if <code>docker</code> is running by trying to run <code>docker ps</code>. <code>$?</code> contains the status code, which will be non-zero if <code>docker ps</code> failed, so check that. If that's the case, assume <code>docker ps</code> failed because <code>docker-machine</code> wasn't running, so start it up. This will run <code>docker-machine start default</code> more often than needed, but it turns out it's a <code><a href="https://en.wikipedia.org/wiki/NOP">NOP</a></code> if it's already running.</p>
<p>The only interesting part here is the use of the keyword <code>command</code> that prefixes <code>docker</code> or <code>docker-machine</code> within the functions. Basically, this tells ZSH to use the system version of <code>docker</code> or <code>docker-compose</code> rather than the one that I defined, thus preventing an infinite loop. Whee!</p>
<p>How's it work?</p>
<pre class="bash"><code>$ docker ps

Starting docker...
(dev) OUT | Starting VM...
Started machines may have new IP addresses. You may need to re-run the &lt;code&gt;docker-machine env&lt;/code&gt; command.

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

$ docker ps

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre>
<p>Switching to another terminal:</p>
<pre class="bash"><code>$ docker ps

Starting docker...
Machine "default" is already running.

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

$ docker ps

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre>
<p>Neat. That should <a href="https://xkcd.com/1205/">eventually save me a fraction of the time</a> it took to get it right. :)</p>]]></content></entry><entry><title>Audiobooks to Podcasts</title><link href="//blog.jverkamp.com/2016/02/26/audiobooks-to-podcasts" /><id>urn:uuid:cfe78150-139b-aa1d-01bd-c73e7e91fd17</id><updated>2016-02-26T00:05:00Z</updated><summary type="html"><![CDATA[<p>I've recently started to listen to audiobooks again (<a href="//blog.jverkamp.com/2016/02/10/the-aeronauts-windlass">The Aeronaut's Windlass</a>). If you buy books through Audible or some other setup that has their own app, it's a straight forward enough process. On the other hand, if you have them on CD and want to play them on a mobile device... It's a little more interesting.</p>
<p>I tried a few different apps that purport to do exactly what I wanted: import an audiobook as a folder full of MP3s and play them, but none that quite meet what I wanted. Since I also listen to a lot of podcasts and have more than one podcast app that I really like (I've used and liked both <a href="http://www.downcastapp.com/">Downcast</a> and <a href="http://www.shiftyjelly.com/pocketcasts">Pocket Casts</a>), I decided to see if I couldn't use one of those as an audiobook player.</p>
]]></summary><content type="html"><![CDATA[<p>I've recently started to listen to audiobooks again (<a href="//blog.jverkamp.com/2016/02/10/the-aeronauts-windlass">The Aeronaut's Windlass</a>). If you buy books through Audible or some other setup that has their own app, it's a straight forward enough process. On the other hand, if you have them on CD and want to play them on a mobile device... It's a little more interesting.</p>
<p>I tried a few different apps that purport to do exactly what I wanted: import an audiobook as a folder full of MP3s and play them, but none that quite meet what I wanted. Since I also listen to a lot of podcasts and have more than one podcast app that I really like (I've used and liked both <a href="http://www.downcastapp.com/">Downcast</a> and <a href="http://www.shiftyjelly.com/pocketcasts">Pocket Casts</a>), I decided to see if I couldn't use one of those as an audiobook player.</p>
<!--more-->
<p>My basic set up is one that I've used before. I'll use <a href="https://docs.docker.com/compose/">docker-compose</a> to run a web server running <a href="http://flask.pocoo.org/">flask</a> behind an <a href="https://www.nginx.com/resources/wiki/">nginx reverse proxy</a> (for performance reasons and to serve static files).</p>
<p>Basically, I want a server that when I hit it will give a list of all books in a folder. If I click any of those, it will generate an RSS feed that I can then give to my podcasting application. That in turn can make requests for any of the MP3 files that make up the book, which should be served back to the app. Simple as pie, no? Well, mostly.</p>
<p>Creating a list of books is easy:</p>
<pre class="python"><code>@app.route('/')
def index():
    result = '&lt;ul&gt;'

    for path in sorted(os.listdir('books')):
        config_path = os.path.join('books', path, 'book.yml')
        print(config_path)

        if not os.path.exists(config_path):
            continue

        with open(config_path, 'r') as fin:
            config = yaml.load(fin)

        result += '&lt;li&gt;&lt;a href="feed/{path}.xml"&gt;{title} by {author}&lt;/a&gt;&lt;/li&gt;'.format(
            path = path,
            title = config['title'],
            author = config['author']
        )

    result += '&lt;/ul&gt;'
    return result</code></pre>
<p>Note: Each book is a subdirectory of the folder <code>books</code>. Each book must also contain at least one file named <code>book.yml</code> which defines the <code>title</code> and <code>author</code> of the book, along with any number of MP3 files (we'll see that in a moment).</p>
<p>All this script does is generate an HTML unordered list (<code>ul</code>) of links to individual RSS feeds. We generate those in turn with:</p>
<pre class="python"><code>@app.route('/feed/&lt;feed&gt;.xml')
def get_feed(feed):
    config_path = os.path.join('books', feed, 'book.yml')

    with open(config_path, 'r') as fin:
        config = yaml.load(fin)

    fg = feedgen.feed.FeedGenerator()
    fg.load_extension('podcast')

    host_url = flask.request.scheme + '://' + flask.request.host

    feed_link = host_url + '/feed/{feed}.xml'.format(feed = feed)

    fg.id = feed_link
    fg.title(config['title'])
    fg.description('{title} by {author}'.format(title = config['title'], author = config['author']))
    fg.author(name = config['author'])
    fg.link(href = feed_link, rel = 'alternate')

    fg.podcast.itunes_category('Arts')

    for file in sorted(os.listdir(os.path.join('books', feed))):
        if not file.endswith('.mp3'):
            continue

        name = file.rsplit('.', 1)[0]

        feed_entry_link = host_url + '/feed/{feed}/{file}'.format(feed = feed, file = file)

        fe = fg.add_entry()

        fe.id(feed_entry_link)
        fe.title(name)
        fe.description('{title} by {author} - {chapter}'.format(
            title = config['title'],
            author = config['author'],
            chapter = name,
        ))
        fe.enclosure(feed_entry_link, 0, 'audio/mpeg')

    return fg.rss_str(pretty = True)</code></pre>
<p>Here, I basically just read in the <code>book.yml</code> file and any MP3s in the directory and generate a feed. As I did previously in my post on <a href="//blog.jverkamp.com/2015/05/11/generating-youtube-user-rss-feeds">Generating YouTube user RSS feeds</a>, I'm using the <a href="https://lkiesow.github.io/python-feedgen/">feedgen</a> package to generate the RSS feeds. This time I'm using their built in <code>podcast</code> extension. Nice.</p>
<p>After that, we just need to serve the MP3s. Originally I was going to serve this with flask as well, but since I'm already going to use nginx as a performance / caching layer, we can use that to serve static files. Something like this for an nginx configuration:</p>
<pre class="nginx"><code>server {
    root /var/www/;

    location / {
        try_files $uri @server;
    }

    location @server {
        proxy_set_header Host $host;
        proxy_pass http://server:5000;
    }
}</code></pre>
<p>Essentially, it will <code>try_files</code> to see if there's a static file at the path requested first. If that fails, it will fall back to the <code>@server</code> reverse proxy, which just feeds traffic to the flask server.</p>
<p>To get everything working together, we'll use docker-compose:</p>
<pre class="yaml"><code>server:
    build: server
    # environment: {DEBUG: True}
    ports:
        - 5000
    volumes:
        - ./books:/app/books

nginx:
    image: nginx
    links:
        - server
    ports:
        - 80:80
    volumes:
        - ./books:/var/www/feed/
        - ./nginx:/etc/nginx/conf.d/</code></pre>
<p>Since I'm mounting the <code>./books</code> directory as a volume into both containers, the <code>nginx</code> container can use it to server static files while the <code>server</code> container can use it to list files.</p>
<p>And that's about it. I have mine running with <a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html">nginx HTTP authentication </a>, which means that I have to use <a href="http://www.downcastapp.com/">Downcast</a> (it's the only one I've used that seems to support it), but other than that it works great. It does require that you have your own server running to initially get the files onto the podcast app, but if you download them, almost all of the apps will let you turn off the server.</p>
<p>The combination of flask and docker is nice. Flask let's you quickly and easily write simple web applications. Docker makes deployment and dependency management a snap.</p>
<p>If you'd like to see the entire codebase, it's on GitHub: <a href="https://github.com/jpverkamp/podbook">podbook</a>. There are a few bits that I didn't include in the writeup above.</p>
<p>Any questions? Let me know below.</p>]]></content></entry><entry><title>Duplicating AeroSnap on OSX with Hammerspoon</title><link href="//blog.jverkamp.com/2016/02/08/duplicating-aerosnap-on-osx-with-hammerspoon" /><id>urn:uuid:09374126-32e6-69a9-1a73-8141f97dec1a</id><updated>2016-02-08T00:00:00Z</updated><summary type="html"><![CDATA[<p>Relatively recently, I switched my last Windows machine over to OSX. For the most part, it's been great. One bit of functionality that I've been missing though is AeroSnap. Specifically the ability to use a keyboard shortcut to move windows to the left/right half of a monitor.</p>
]]></summary><content type="html"><![CDATA[<p>Relatively recently, I switched my last Windows machine over to OSX. For the most part, it's been great. One bit of functionality that I've been missing though is AeroSnap. Specifically the ability to use a keyboard shortcut to move windows to the left/right half of a monitor.</p>
<!--more-->
<p>For a while, <a href="https://www.boastr.net/">BetterTouchTool</a> provided that functionality for me, among it's many (many) other options. Unfortunately (for me, it's a good move for them), the author(s) of BetterTouchTool are now moving to a paid model. Since I use only a tiny fraction of the functionality, I decided to see if there were other options.</p>
<p>The first thing that I stumbled across was <a href="https://github.com/fikovnik/ShiftIt">ShiftIt</a>. It actually has exactly the functionality that I wanted and was configurable enough that I could tweak the keybindings to what my fingers already expected them to be. If you don't particularly want to tweak the functionality and just want AeroSnapesqe functionality, this is probably a good enough option.</p>
<p>Me though? I love to tweak things.</p>
<p>With unusually precient timing, Lifehacker posted an article about <a href="http://www.hammerspoon.org/">Hammerspoon</a>: <a href="http://lifehacker.com/hammerspoon-is-powerful-free-automation-tool-for-os-x-1757351485">Hammerspoon Is Powerful, Free Automation Tool for OS X</a></p>
<p>Interesting.</p>
<p>After a bit of digging, I found that their <a href="http://www.hammerspoon.org/go/">Getting Started</a> document actually has an example that does exactly what I want to do: <a href="http://www.hammerspoon.org/go/#winresize">Window sizing</a> Shiny!</p>
<p>A bit of tweaking and this is what I ended up with:</p>
<h3><code>.hammerspoon/init.lua</code></h3>
<p>Base code, handles reloading, locking, and loading modules</p>
<pre class="lua"><code>-- Reload hammerspoon configs
hs.hotkey.bind({"cmd", "ctrl"}, "R", function()
    hs.reload()
end)
hs.alert.show("Config loaded")

-- Lock
hs.hotkey.bind({"cmd", "ctrl"}, 'L', function()
    os.execute("open '/System/Library/Frameworks/ScreenSaver.framework/Versions/A/Resources/ScreenSaverEngine.app'")
end)

require('aerosnap')</code></pre>
<p>The first is another example from their documentation of bind a keyboard shortcut to reloading the Hammerspoon documentation. The second is another keyboard shortcut I missed from Windows: the ability to lock the screen without logging out (the normal lock functionality disables networking and thus things like remote login).</p>
<h3><code>.hammerspoon/aerosnap/init.lua</code></h3>
<pre class="lua"><code>-- Aerosnap helper functions to get and set current window parameters
function aerosnap_get_parameters()
    local window = hs.window.focusedWindow()
    local frame = window:frame()
    local screen = window:screen()
    local bounds = screen:frame()

    return window, frame, bounds
end

-- Aerosnap help to move a window to a specified position
function aerosnap_move_window(x, y, w, h)
    local window, frame, bounds = aerosnap_get_parameters()

    frame.x = x
    frame.y = y
    frame.w = w
    frame.h = h

    window:setFrame(frame)
end

-- Save the current window's position so we can restore it
function aerosnap_save_window()
    local window, frame, bounds = aerosnap_get_parameters()
    saved_window_sizes = saved_window_sizes or {}
    saved_window_sizes[window:id()] = {x = frame.x, y = frame.y, w = frame.w, h = frame.h}
end

-- Aerosnap move window to the left half
hs.hotkey.bind({"cmd", "ctrl"}, "Left", function()
    local window, frame, bounds = aerosnap_get_parameters()
    aerosnap_save_window()
    aerosnap_move_window(bounds.x, bounds.y, bounds.w / 2, bounds.h)
end)

-- Aerosnap move window to the right half
hs.hotkey.bind({"cmd", "ctrl"}, "Right", function()
    local window, frame, bounds = aerosnap_get_parameters()
    aerosnap_save_window()
    aerosnap_move_window(bounds.x + bounds.w / 2, bounds.y, bounds.w / 2, bounds.h)
end)

-- Aerosnap maximize current window, saving size to restore
hs.hotkey.bind({"cmd", "ctrl"}, "Up", function()
    local window, frame, bounds = aerosnap_get_parameters()
    aerosnap_save_window()
    aerosnap_move_window(bounds.x, bounds.y, bounds.w, bounds.h)
end)

-- Restore the last saved window configuration for a window (basically, a one level undo)
hs.hotkey.bind({"cmd", "ctrl"}, "Down", function()
    local window, frame, bounds = aerosnap_get_parameters()

    old_bounds = saved_window_sizes[window:id()]
    if old_bounds ~= nil then
        aerosnap_move_window(old_bounds.x, old_bounds.y, old_bounds.w, old_bounds.h)
        saved_window_sizes[window:id()] = nil
    end
end)</code></pre>
<p>Basically, I took the same functionality that they had in the demo and factored out the functionality that gets the current window / sets the new sizes. The other interesting bit is the <code>aerosnap_save_window</code> function, which allows you to restore the size of a window you had just maximized. This does have something of a memory leak (in that it never clears up closed windows), but the amount should be small enough that it doesn't overly matter.</p>
<p>And that's it. My full configs are available in my dotfiles (if I make any further tweaks or add more functionality): <a href="https://github.com/jpverkamp/dotfiles/tree/master/hammerspoon">hammerspoon configs</a></p>
<p>I'm looking forward to seeing what else I can do with Hammerspoon. You can get fairly extensive: <a href="https://github.com/tstirrat/hammerspoon-config">example Hammerspoon config</a>.</p>
<p>Also, if you want an alternative to Hammerspoon with what looks like a more modular approach, check out <a href="https://github.com/sdegutis/mjolnir">Mjolnir</a>. It appears that Hammerspoon is a fork of Mjolnir, so their configs are rather similar.</p>]]></content></entry><entry><title>Command line unicode search</title><link href="//blog.jverkamp.com/2016/01/06/command-line-unicode-search" /><id>urn:uuid:842e94d5-f91e-d1f9-c793-73043fa69212</id><updated>2016-01-06T00:00:00Z</updated><summary type="html"><![CDATA[<p>Similar to Monday's post about <a href="//blog.jverkamp.com/2016/01/04/command-line-emoji-search">command line emoji search</a>, I often find myself wanting to look up Unicode characters. I have a custom search engine / bookmark set up in Chrome / Firefox (<code>uni %s</code> maps to <code>http://unicode-search.net/unicode-namesearch.pl?term=%s&.submit=Submit&subs=1</code>). That actually works great, but given how relatively much of my day I spend on the command line, I thought it would be interesting to do something there:</p>
<pre class="bash"><code>$ uni delta
⍋	apl functional symbol delta stile
⍙	apl functional symbol delta underbar
⍍	apl functional symbol quad delta
≜	delta equal to
Δ	greek capital letter delta
δ	greek small letter delta
ẟ	latin small letter delta
ƍ	latin small letter turned delta
𝚫	mathematical bold capital delta
𝜟	mathematical bold italic capital delta
𝜹	mathematical bold italic small delta
𝛅	mathematical bold small delta
𝛥	mathematical italic capital delta
𝛿	mathematical italic small delta
𝝙	mathematical sans-serif bold capital delta
𝞓	mathematical sans-serif bold italic capital delta
𝞭	mathematical sans-serif bold italic small delta
𝝳	mathematical sans-serif bold small delta
ᵟ	modifier letter small delta</code></pre>
]]></summary><content type="html"><![CDATA[<p>Similar to Monday's post about <a href="//blog.jverkamp.com/2016/01/04/command-line-emoji-search">command line emoji search</a>, I often find myself wanting to look up Unicode characters. I have a custom search engine / bookmark set up in Chrome / Firefox (<code>uni %s</code> maps to <code>http://unicode-search.net/unicode-namesearch.pl?term=%s&.submit=Submit&subs=1</code>). That actually works great, but given how relatively much of my day I spend on the command line, I thought it would be interesting to do something there:</p>
<pre class="bash"><code>$ uni delta
⍋	apl functional symbol delta stile
⍙	apl functional symbol delta underbar
⍍	apl functional symbol quad delta
≜	delta equal to
Δ	greek capital letter delta
δ	greek small letter delta
ẟ	latin small letter delta
ƍ	latin small letter turned delta
𝚫	mathematical bold capital delta
𝜟	mathematical bold italic capital delta
𝜹	mathematical bold italic small delta
𝛅	mathematical bold small delta
𝛥	mathematical italic capital delta
𝛿	mathematical italic small delta
𝝙	mathematical sans-serif bold capital delta
𝞓	mathematical sans-serif bold italic capital delta
𝞭	mathematical sans-serif bold italic small delta
𝝳	mathematical sans-serif bold small delta
ᵟ	modifier letter small delta</code></pre>
<!--more-->
<p>The basic idea is to take Python's <code>unicodedata</code> module and use that to get the names of characters, then to find those that best match user input. Of course one problem with that is that as of version 8 of the Unicode specification there are up to 263,994 characters defined in 262 different blocks. That's a bit much.</p>
<p>So instead, I'm going to select a handpicked list of blocks that I think might be vaguely interesting (see <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/uni#L284">here</a>) as a default and add the ability to select any other block as a command line switch:</p>
<pre class="bash"><code>$ uni --block currency euro
€	euro sign
₠	euro-currency sign</code></pre>
<p>So, how do I do it? First, let's assume I have a list of unicode blocks defined as such (available from the Unicode Consortium: <a href="ftp://ftp.unicode.org/Public/8.0.0/ucd/Blocks.txt">Blocks.txt</a>):</p>
<pre class="text"><code>0000..007F; Basic Latin
0080..00FF; Latin-1 Supplement
0100..017F; Latin Extended-A
0180..024F; Latin Extended-B
0250..02AF; IPA Extensions
...</code></pre>
<p>First, we'll want to either determine which block(s) we'll be looking at:</p>
<pre class="python"><code># Determine which unicode blocks we'll be searching through
blocks = []

if args.block:
    for line in all_blocks.split('\n'):
        if fuzz.token_set_ratio(args.block, line.split('; ')[-1]) &gt; 100 * args.block_threshold:
            blocks.append(line)
else:
    blocks = default_blocks.split('\n')

if not blocks:
    sys.stderr.write('No blocks found\n')
    sys.exit(-1)</code></pre>
<p><code>args</code> contains the parsed command line parameters, I'll get to that later. <code>fuzz</code> is from the <a href="https://github.com/seatgeek/fuzzywuzzy">fuzzywuzzy</a> Python library for fuzzy string matching. Basically, if the <code>--block</code> parameter was specified, we'll search for any that match closely enough, otherwise we'll use the default blocks.</p>
<p>Next, we'll look through and build a list of all possible matching characters within those blocks. Given the formats above, we can get the lower and upper bounds with <code>int</code>, specifying base 16 and then use <code>unicodedata</code> to get the character name. Again, we'll apply a fuzzy match to the character names.</p>
<pre class="python"><code># Search through all of those blocks, whee
results = []

for block in blocks:
    bounds, name = block.split('; ')
    lower_bound, upper_bound = bounds.split('..')

    lower_bound = int(lower_bound, 16)
    upper_bound = int(upper_bound, 16)

    for codepoint in range(lower_bound, upper_bound + 1):
        try:
            character = chr(codepoint)
            name = unicodedata.name(character, None).lower()
            score = fuzz.token_set_ratio(args.name, name)

            if score &gt; 100 * args.name_threshold:
                results.append((score, name, character))
        except:
            pass

if not results:
    sys.stderr.write('No characters found\n')
    sys.exit(-1)</code></pre>
<p>And after that, we have a few tweaks for output. We can print all of the results (default) or just a limited number and we can print just the character or also the name:</p>
<pre class="python"><code># Only print out the requested number of results
for count, (score, name, character) in enumerate(sorted(results)):
    if args.count and count &gt;= args.count:
        break

    if args.quiet:
        print(character)
    else:
        print(character, name, sep = '\t')</code></pre>
<p>I guess now would be a good time to go back to how we got the <code>args</code> object in the first place:</p>
<pre class="python"><code>parser = argparse.ArgumentParser('Search unicode characters')
parser.add_argument('name', nargs = '+', help = ...)
parser.add_argument('--block', '-b', help = ...)
parser.add_argument('--block-threshold', default = 0.9, help = ...)
parser.add_argument('--name-threshold', default = 0.9, help = ...)
parser.add_argument('--count', default = 0, type = int, help = ...)
parser.add_argument('--quiet', '-q', default = False, action = 'store_true', help = ...)
args = parser.parse_args()</code></pre>
<p><code>argparse</code> is a most excellent library. It allows you to declaratively specify what your command line parameters will be and then will parse it into an object with one field for each variable (fixing the names so that <code>--block-threshold</code> becomes <code>args.block_threshold</code>).</p>
<p>And that's it. You can use it to look up all sorts of interesting things:</p>
<pre class="python"><code>uni --count 10 --block runic runic

ᛮ	runic arlaug symbol
ᛰ	runic belgthor symbol
᛭	runic cross punctuation
ᚪ	runic letter ac a
ᚫ	runic letter aesc
ᛉ	runic letter algiz eolhx
ᚨ	runic letter ansuz a
ᛒ	runic letter berkanan beorc bjarkan b
ᛍ	runic letter c
ᛣ	runic letter calc</code></pre>
<p>(That will display better if you're using a font that includes Unicode range <code>16A0..16FF; Runic</code>.)</p>
<p>For the most part, I'll use it in this mode and then select characters to copy and paste. But you could also combine it with <a href="https://github.com/garybernhardt/selecta">selecta</a> and <code>pbcopy</code> (on OSX) to get something entirely more interesting:</p>
<pre class="bash"><code>$ uni --block runic runic | selecta | cut -f 1 | tr -d '\n' | pbcopy</code></pre>
<p><code>uni</code> will display a list of characters, <code>selecta</code> will let you search for one, <code>cut</code> will get just the character, <code>tr</code> will remove the newline, and <code>pbcopy</code> will send it to the clipboard. You could even shove it into a Bash/ZSH alias:</p>
<pre class="bash"><code>pbuni() {
    uni $@ | selecta | cut -f 1 | tr -d '\n' | pbcopy
}</code></pre>
<p>Very cool.</p>
<p>This is in my dotfiles, so you can find the full source here: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/uni">uni</a>. Enjoy!</p>]]></content></entry><entry><title>Command line emoji search</title><link href="//blog.jverkamp.com/2016/01/04/command-line-emoji-search" /><id>urn:uuid:97c23a50-ef50-9386-e54b-947be0817eeb</id><updated>2016-01-04T00:00:00Z</updated><summary type="html"><![CDATA[<p>Sometimes, I find myself wanting to communicate in <a href="https://en.wikipedia.org/wiki/emoji">emoji</a>.</p>
<p><img alt="chicken" class="emoji" src="/emoji/chicken.svg" /></p>
<p>How about this:</p>
<pre class="bash"><code>$ emoji chicken
🐔

$ emoji "which came first, the @emoji{:chicken:} or the :egg:"
which came first, the 🐔 or the 🍳</code></pre>
]]></summary><content type="html"><![CDATA[<p>Sometimes, I find myself wanting to communicate in <a href="https://en.wikipedia.org/wiki/emoji">emoji</a>.</p>
<p><img alt="chicken" class="emoji" src="/emoji/chicken.svg" /></p>
<p>How about this:</p>
<pre class="bash"><code>$ emoji chicken
🐔

$ emoji "which came first, the @emoji{:chicken:} or the :egg:"
which came first, the 🐔 or the 🍳</code></pre>
<!--more-->
<p>To start off, I'm going to use the data from muan's emojilib on GitHub: <a href="https://github.com/muan/emojilib/">github:muan/emojilib</a>. Specifically, their list of keywords that relate to any given emoji: <a href="https://raw.githubusercontent.com/muan/emojilib/master/emojis.json">emojis.json</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>We'll fetch that file if we haven't before and otherwise use a locally cached version:</p>
<pre class="python"><code>cache_path = os.path.expanduser('~/.emoji.json')
remote_url = 'https://raw.githubusercontent.com/muan/emojilib/master/emojis.json'

if not os.path.exists(cache_path):
    with open(cache_path, 'w') as fout:
        response = requests.get(remote_url)
        fout.write(response.text)

with open(cache_path, 'r') as fin:
    emoji = json.load(fin)</code></pre>
<p>After that, there are two different ways that we can look up Emoji. We can either look them up by a semi official name or by keyword. This function will search through the both, matching on names first and then falling back to the first which matches the given keyword (this script isn't designed to return choices for emoji, but rather just choose the first one that fits; because a Python <code>dict</code> isn't ordered, this is actually non-deterministic):</p>
<pre class="python"><code>def emoji_by_keyword(keyword):
    if keyword in emoji:
        return emoji[keyword]['char']

    for name in emoji:
        if name == 'keys':
            continue

        if keyword in emoji[name]['keywords']:
            return emoji[name]['char']

    return keyword</code></pre>
<p>Following that, we can use regular expressions (the <code>re</code> module) to replace emoji in a string--if they're set off <code>:emoji:</code> style (a la GitHub):</p>
<pre class="python"><code>def emojify(string):
    return re.sub(
        r'\:(\w+)\:',
        lambda m : emoji_by_keyword(m.group(1)),
        string
    )</code></pre>
<p>That's a neat trick that I use from time to time: the second argument to <code>re.sub</code> can be either a literal string or a function. If it's the latter, it's given the match object for each replacement, which we can then pass along to <code>emoji_by_keyword</code>.</p>
<p>And finally, let's mess with some command line arguments:</p>
<pre class="python"><code># Run replacement mode on stdin if no parameters
if len(sys.argv) == 1:
    for line in sys.stdin:
        print(emojify(line[:-1]))

# Othwise, run through the list
else:
    for arg in sys.argv[1:]:
        if ':' in arg:
            print(emojify(arg), end = ' ')
        else:
            print(emoji_by_keyword(arg), end = ' ')</code></pre>
<p>There are three modes we can be operating in:</p>
<ul>
    <li><code>stdin</code> mode, where we will read text from <code>stdin</code> and replace any <code>:emoji:</code> blocks with the corresponding emoji</li>
    <li>String mode, where we find any <code>:emoji:</code> in each argument in each input and replace them</li>
    <li>Single lookup mode, where we look up each argument as an individual emoji keyword, without the need for <code>:</code></li>
</ul>
<p>And, that's it.</p>
<pre class="bash"><code>$ emoji fireworks fireworks fireworks
🎆🎆🎆</code></pre>
<p>Since this is now one of my <a href="//blog.jverkamp.com/category/programming/by-language/dotfiles">dotfiles</a>, you can find the entire source here: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/emoji">emoji</a></p>]]></content></entry><entry><title>Inlining plaintext attachments in Gmail</title><link href="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail" /><id>urn:uuid:c7dbc6ed-89ac-4c30-fa24-92e8614e530d</id><updated>2016-01-02T00:00:00Z</updated><summary type="html"><![CDATA[<p>When you send a text message to a Gmail email address (at least from an iPhone using AT&T), you get something like this:</p>
<p><a href="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" /></a></p>
<p>It's vaguely annoying to have to click through every single time just to see what the message is, especially when various extensions (such as <a href="https://github.com/gorhill/uMatrix">uMatrix</a>) break overlay rendering or when you have multiple attachments.</p>
<p>Much better would be to just display the plaintext attachments inline:</p>
<p><a href="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>When you send a text message to a Gmail email address (at least from an iPhone using AT&T), you get something like this:</p>
<p><a href="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-before.png" /></a></p>
<p>It's vaguely annoying to have to click through every single time just to see what the message is, especially when various extensions (such as <a href="https://github.com/gorhill/uMatrix">uMatrix</a>) break overlay rendering or when you have multiple attachments.</p>
<p>Much better would be to just display the plaintext attachments inline:</p>
<p><a href="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2016/01/02/inlining-plaintext-attachments-in-gmail/gpti-after.png" /></a></p>
<!--more-->
<p>Let's do it!</p>
<p>Essentially, I'm going to write a Javascript userscript, compatible with <a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/">Greasemonkey</a> or <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en">Tampermonkey</a> for Chrome. Either allows you to insert small bits of Javascript into web pages to modify their behavior.</p>
<p>After digging around a bit in the structure of Gmail's message pages, here's roughly what I ended up with:</p>
<pre class="javascript"><code>var checkForPlaintexts = function(evt) {
    jQuery('span[download_url]').each(function(i, el) {
        var parts = el.getAttribute('download_url').split(':');
        if (!parts || parts[0] != 'text/plain') return;
        var url = parts[3];

        var newElement = jQuery('&lt;pre id="GPTI_' + i + '"&gt;&lt;/pre&gt;');
        newElement.text('Loading: ' + url);

        jQuery(el).replaceWith(newElement);
        jQuery.ajax({
            url: url,
            success: function(data) {
                newElement.text(data);
            }
        });
    });
};</code></pre>
<p>Basically, we're going to look for a <code>span</code> containing a <code>download_url</code> attribute. For the moment at least, that's always present with attachments and not otherwise. If you take that <code>download_url</code> element, you get something like this:</p>
<p><code>text/plain:text_0.txt:https://mail.google.com/mail/u/0/?ui=...</code>`</p>
<p>The first part is a <a href="https://en.wikipedia.org/wiki/MIME_type">MIME type</a>--of which, we're only interested in plaintext. The last section is a URL under gmail which, when visited, contains the contents of the attachment.</p>
<p>Now that I have that (via jQuery<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>), I build a new <code>pre</code> element with the text content and shove it in place.</p>
<p>Voila.</p>
<p>All I have to do next is make sure that it's called when I either load the page or when I navigate from the Inbox (et al) to a message:</p>
<pre class="javascript"><code>jQuery(window).bind('hashchange', checkForPlaintexts);
jQuery(checkForPlaintexts);</code></pre>
<p>Unfortunately, this has some issues as well. It works if the message has already been viewed once, but not on the first load. Basically, I'm running into timing issues.</p>
<p>My original solution to this was to put in a quick delay and call it a day. Unfortunately, when using satellite internet... even that didn't work. So instead, I built a system that will delay the initial call and then--if it fails--try a few more times with increasing timeouts between then.</p>
<p>Something like this:</p>
<pre class="javascript"><code>var delayedEvent = function(f, timeout, retries) {
    timeout = timeout || 0;
    retries = retries || 0;

    return function(evt) {
        setTimeout(f, timeout, evt, retries, timeout * 2);
    }
};

var checkForPlaintexts = function(evt, retries, delay) {
    retries = retries || 0;
    var foundOne = false;

    jQuery('span[download_url]').each(function(i, el) {
        foundOne = true;

        ...
    });

    if (!foundOne && retries) {
        setTimeout(checkForPlaintexts, delay, evt, retries - 1, delay * 2);
    }
};

jQuery(window).bind('hashchange', delayedEvent(checkForPlaintexts, 125, 3));
jQuery(delayedEvent(checkForPlaintexts, 125, 3));</code></pre>
<p>So far, this has worked perfectly. Sometimes it takes a bit to fetch the ajax call in the background. That's why I put in the <code>Loading...</code> notification to tell the user it was working.</p>
<p>It's been a little while since I last wrote a userscript (pre-Chrome, to give you an idea). I forgot how much fun it can be to mess with websites a bit like that. I may write up a few more.</p>
<p>If you'd like to see the entire source (includes some debug messaging and the userscript header comments), you can do so on GitHub: <a href="https://github.com/jpverkamp/userscripts/blob/master/gmail-plaintext-inline.user.js">gmail-plaintext-inline.user.js</a></p>
<p>If you want to install it directly (and have Greasemonkey/Tampermonkey installed), you can directly from GitHub as well: <a href="https://github.com/jpverkamp/userscripts/raw/master/gmail-plaintext-inline.user.js">install gmail-plaintext-inline.user.js</a>.</p>
<p>As a side note, 'optional' parameters in Javascript are weird...</p>]]></content></entry><entry><title>Advent of Code: Day 25</title><link href="//blog.jverkamp.com/2015/12/25/advent-of-code-day-25" /><id>urn:uuid:76fab82b-01da-119f-da63-b163c5d488e0</id><updated>2015-12-25T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533F(n-1) \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533F(n-1) \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
<!--more-->
<pre class="python"><code>target_row = int(sys.argv[1])
target_col = int(sys.argv[2])

row = 1
col = 1
val = 20151125

while True:
    if target_row == row and target_col == col:
        print(val)
        sys.exit(0)
    else:
        val = (val * 252533) % 33554393

    if row == 1:
        row = col + 1
        col = 1
    else:
        row -= 1
        col += 1</code></pre>
<p>Merry Christmas!</p>]]></content></entry><entry><title>Advent of Code: Day 24</title><link href="//blog.jverkamp.com/2015/12/24/advent-of-code-day-24" /><id>urn:uuid:2035cd03-489e-dfec-f613-117529fa491f</id><updated>2015-12-24T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
<!--more-->
<p>My initial solution to this was to solve the <a href="https://en.wikipedia.org/wiki/subset_sum">subset sum</a> problem (or at least a slightly modified version thereof):</p>
<pre class="python"><code>def subsets_summing_to(target, items, cache = {}):
    if target == 0:
        yield set()
    else:
        for i, item in enumerate(items):
            if item &lt;= target:
                for recur in subsets_summing_to(target - item, items - {item}):
                    yield {item} | recur</code></pre>
<p>It's elegant code, and you can use that to generate the three groups fairly easily:</p>
<pre class="python"><code>packages = {int(line.strip()) for line in sys.stdin}
weight_per_package = sum(packages) // 3

for group1 in subsets_summing_to(weight_per_package, package):
    for group2 in subsets_summing_to(weight_per_package, package - group1):
        group3 = packages - group1 - group2
        ...</code></pre>
<p>And then while I let that run, I made a realization. If I generate the first group to be the smallest (by generating all groups of size 1, size 2, size 3, etc), then it doesn't actually matter what the other groups are. Furthermore, if I structure my iteration carefully so that I always return the smallest items first, I will get a minimal product<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Combining these two jumps, I get:</p>
<pre class="python"><code>def subset_sum_of_n(target, items, count):
    if target == 0 and count == 0:
        yield set()
    elif count == 0:
        return
    else:
        for i, item in enumerate(sorted(items)):
            if item &lt;= target:
                for recur in subset_sum_of_n(target - item, items - {item}, count - 1):
                    yield {item} | recur

def calculate_quantum_entanglement(group):
    product = 1
    for item in group:
        product *= item
    return product

def split_into(packages, n_groups):
    weight_per_section = sum(packages) / int(sys.argv[1])

    for n in range(1, len(packages)):
        for group in subset_sum_of_n(weight_per_section, packages, n):
            return (len(group), calculate_quantum_entanglement(group), group)

if __name__ == '__main__':
    packages = {int(line.strip()) for line in sys.stdin}
    n_groups = int(sys.argv[1])

    print(split_into(packages, n_groups))</code></pre>
<p>I'm greatly amused that it doesn't matter at all what any of the other groups are.</p>
<p><strong>Part 2:</strong> Split into four groups.</p>
<p>I already solved this with the <code>n_groups</code> parameter above.</p>
<p>Amusingly, because this solution (at least with my input) only has 4 items in the minimal group, it runs about 60 times faster than the first part. It still doesn't matter at all what the other groups are.</p>]]></content></entry><entry><title>Advent of Code: Day 23</title><link href="//blog.jverkamp.com/2015/12/23/advent-of-code-day-23" /><id>urn:uuid:2b737957-97d1-2db7-c18a-ef2b4bee221f</id><updated>2015-12-23T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
<!--more-->
<p>I do love writing a good virtual machine. Check out my <a href="//blog.jverkamp.com/2013/08/21/a-tiny-virtual-machine-in-racket">'Tiny' virtual machine in Racket</a>.</p>
<pre class="python"><code>def read_program():
    return [
        tuple(re.split('[, ]+', line.strip()))
        for line in sys.stdin
    ]

def run(program, **initial_state):
    pc = 0
    registers = {'a': 0, 'b': 0}
    registers.update(initial_state)

    while True:
        op = program[pc][0]
        args = program[pc][1:]

        if op == 'hlf':
            registers[args[0]] //= 2
            pc += 1
        elif op == 'tpl':
            registers[args[0]] *= 3
            pc += 1
        elif op == 'inc':
            registers[args[0]] += 1
            pc += 1
        elif op == 'jmp':
            pc += int(args[0])
        elif op == 'jie':
            if registers[args[0]] % 2 == 0:
                pc += int(args[1])
            else:
                pc += 1
        elif op == 'jio':
            if registers[args[0]] == 1:
                pc += int(args[1])
            else:
                pc += 1

        if not (0 &lt;= pc &lt; len(program)):
            break

    return registers

if __name__ == '__main__':
    program = read_program()
    output = run(program)
    print(output['b'])</code></pre>
<p>It's not the most abstracted thing ever, but it really doesn't matter. It works great.</p>
<p><strong>Part 2:</strong> Re-run with the initial state <code>a=1, b=0</code>.</p>
<p>I'll reuse the same trick I've used a few times before to load part 1:</p>
<pre class="python"><code>part1 = imp.load_source('part1', 'part-1.py')

if __name__ == '__main__':
    program = part1.read_program()
    output = part1.run(program, a = 1)
    print(output['b'])</code></pre>]]></content></entry><entry><title>Advent of Code: Day 22</title><link href="//blog.jverkamp.com/2015/12/22/advent-of-code-day-22" /><id>urn:uuid:9cebad4b-f376-fc86-db80-6136e90ab202</id><updated>2015-12-22T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
<!--more-->
<p>First, let's create some simple abstractions for the players:</p>
<pre class="python"><code>class Entity(dict):
    '''Represent a damagable entity such as the player or a boss'''

    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            self[key] = val

    def __getitem__(self, key):
        try:
            return dict.__getitem__(self, key)
        except:
            return 0

    def damage(self, points):
        '''Apply damage to this entity; minimum damage is always 1'''

        self['Hit Points'] -= max(1, points - self['Armor'])

    def tick_active_spells(self, target):
        '''Apply all active spells to the target, remove any that have expired.'''

        if self['Active Spells']:
            for spell in list(self['Active Spells']):
                self['History'].append(str(spell))
                spell.tick(self, target)
                spell.Duration -= 1
                if spell.Duration &lt;= 0:
                    self['History'].append('{} fades'.format(spell.__class__.__name__))
                    spell.fade(self, target)
                    self['Active Spells'].remove(spell)</code></pre>
<p>Basically, we have an extended <code>dict</code> that will default values to 0, includes a method for applying <code>damage</code> while taking armor into account, and applying an active spells to a given player. That will make more sense once you see the way spells are defined:</p>
<pre class="python"><code>class Spell(dict):
    '''
    Create a spell. Spells have &lt;code&gt;Cost&lt;/code&gt; mana and last &lt;code&gt;Duration&lt;/code&gt; turns.

    cast() is called when a spell is first cast
    tick() is called each turn (for Duration &gt; 0)
    fade() is called when a spell runs out of duration
    '''

    Cost = float("inf")
    Duration = 0

    def __init__(self):
        self['Duration'] = self.__class__.Duration

    def cast(self, caster, target):
        pass

    def tick(self, caster, target):
        pass

    def fade(self, caster, target):
        pass

    def __repr__(self):
        return '{}({})'.format(self.__class__.__name__, self.Duration)

    def __eq__(self, other):
        return self.__class__.__name__ == other.__class__.__name__

    def __hash__(self):
        return hash(self.__class__.__name__)

class MagicMissle(Spell):
    Cost = 53

    def cast(self, caster, target):
        target.damage(4)

class Drain(Spell):
    Cost = 73

    def cast(self, caster, target):
        target.damage(2)
        caster['Hit Points'] += 2

class Shield(Spell):
    Cost = 113
    Duration = 6

    def cast(self, caster, target):
        caster['Armor'] += 7

    def fade(self, caster, target):
        caster['Armor'] -= 7

class Poison(Spell):
    Cost = 173
    Duration = 6

    def tick(self, caster, target):
        target.damage(3)

class Recharge(Spell):
    Cost = 229
    Duration = 5

    def tick(self, caster, target):
        caster['Mana Points'] += 101

spells = [MagicMissle, Drain, Shield, Poison, Recharge]</code></pre>
<p>As noted in the comment for the <code>Spell</code> class, there are two interesting fields (<code>Cost</code> is the mana cost and <code>Duration</code> is how long an ongoing spell will last) and three functions that can be overridden. <code>cast</code> will be called when the spell is first cast, <code>tick</code> will be called each turn it runs for ongoing spells, and <code>fade</code> will be called when an ongoing spell runs out of time. That will let us encode the five spells in the <a href="http://adventofcode.com/day/22">problem statement</a>.</p>
<p>Finally, we can load the player and boss:</p>
<pre class="python"><code>boss = lib.Entity()
for line in sys.stdin:
    key, val = line.strip().split(': ')
    boss[key] = int(val)

player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [],
    'History': [],
})</code></pre>
<p>Now we have everything to solve the problem. My first take at a solution using a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> based on the mana spent. That means that as soon as we find a solution where <code>boss['Hit Points'] <= 0</code>, we have the minimal solution:</p>
<pre class="python"><code>queue_breaker = 0

states = queue.PriorityQueue()
states.put((0, queue_breaker, player, boss))

best_player = {'Mana Spent': float('inf')}

# This will be used to break ties in the queue since Entities are not orderable
queue_breaker += 1

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        return player

    # Player died, no point in continuing on this track
    if player['Hit Points'] &lt;= 0:
        continue

    # --- Player's turn ---
    player = copy.deepcopy(player)
    boss = copy.deepcopy(boss)
    player['History'].append('&gt;&gt; Player Turn &lt;&lt;')
    player.tick_active_spells(boss)

    # Branch (see the copy below) to applying each possible spell for the player's turn
    for potential_spell in lib.spells:
        if player['Mana Points'] &lt; potential_spell.Cost:
            continue

        spell = potential_spell()
        if spell in player['Active Spells']:
            continue

        current_player = copy.deepcopy(player)
        current_boss = copy.deepcopy(boss)

        # Cast the player's new spell
        current_player['Mana Points'] -= potential_spell.Cost
        current_player['Mana Spent'] += potential_spell.Cost
        spell.cast(current_player, current_boss)

        if spell['Duration']:
            current_player['Active Spells'].append(spell)

        current_player['History'].append(str(spell))

        # --- Boss's turn ---
        current_player['History'].append('&gt;&gt; Boss Turn &lt;&lt;')
        current_player.tick_active_spells(current_boss)
        current_player.damage(current_boss['Damage'])

        # Store the altered copies back in the queue
        states.put((current_player['Mana Spent'], queue_breaker, current_player, current_boss))
        queue_breaker += 1</code></pre>
<p>Most of the code is spent getting the order of events exactly correct. It's a bit weird, but it does work in the end (I think I rewrote exactly this code a dozen times and it finally worked...). The only problem with this solution: the search space is <em>huge</em>. I let it run for rather a while and it simulated literally millions of states still without finding a final solution. I need to cut that down.</p>
<p>My next trial was to tweak the scoring algorithm. By doing this, we lose the ability to return immediately once we have a solution, but we gain the ability to find <em>a</em> solution quickly and then throw out any solutions that would be worse than that one. We only have to make a few tweaks to the above code:</p>
<pre class="python"><code>best_player = {'Mana Spent': float('inf')}

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        if early_exit:
            return player
        elif player['Mana Spent'] &lt; best_player['Mana Spent']:
            print('New best mana spent:', player['Mana Spent'])
            best_player = player
            continue

    ...

    # Store the altered copies back in the queue
    score = scoring_function(current_player, current_boss)
    states.put((score, queue_breaker, current_player, current_boss))
    queue_breaker += 1

return best_player</code></pre>
<p>Interestingly, this converges very quickly (a few seconds) on my correct solution, then spends a (long) while making sure it's correct. In earlier (incorrect) simulations, it would find a few increasingly good solutions before finally ending up at a steady state.</p>
<p>This runs much more quickly, but guaranteeing that we have a correct solution is still difficult. Instead, let's try a quick <a href="https://en.wikipedia.org/wiki/Monte_Carlo simulation">Monte Carlo simulation</a>:</p>
<pre class="python"><code>def random_spells():
    while True:
        yield random.choice(lib.spells)

class GameOverException(Exception):
    def __init__(self, player_won, reason):
        self.player_won = player_won
        self.reason = reason

def check_game_over(player, boss):
    if boss['Hit Points'] &lt;= 0:
        raise GameOverException(True, 'boss died')

    if player['Hit Points'] &lt;= 0:
        raise GameOverException(False, 'player died')

def fight(player, boss, spell_iterator):
    while True:
        check_game_over(player, boss)

        # --- Player turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        for i, potential_spell in enumerate(spell_iterator):
            if i &gt;= 10:
                raise GameOverException(False, 'failed to cast 10 spells')

            if potential_spell.Cost &gt; player['Mana Points']:
                continue

            spell = potential_spell()
            if spell in player['Active Spells']:
                continue

            player['History'].append('Player casts {}'.format(potential_spell.__name__))
            player['Mana Points'] -= potential_spell.Cost
            player['Mana Spent'] += potential_spell.Cost

            spell.cast(player, boss)
            check_game_over(player, boss)

            if spell.Duration:
                player['Active Spells'].append(spell)

            break

        # --- Boss turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        player.damage(boss['Damage'])
        check_game_over(player, boss)

def monte_carlo(player, boss, timeout = TIME_TO_RUN):
    start = time.time()
    best_player = {'Mana Spent': float('inf')}
    simulations = 0
    wins = 0

    while True:
        if time.time() - start &gt; TIME_TO_RUN:
            break

        simulations += 1
        current_boss = copy.deepcopy(boss)
        current_player = copy.deepcopy(player)

        try:
            fight(current_player, current_boss, random_spells())
        except GameOverException as game_over:
            if game_over.player_won:
                wins += 1
                if current_player['Mana Spent'] &lt; best_player['Mana Spent']:
                    print('New best:', current_player['Mana Spent'])
                    best_player = current_player

    return simulations, wins, best_player</code></pre>
<p>Basically, just fire off random spells (trying up to 10 times in a given round to account for running low on mana and no duplicates) until one player wins (I'm using a <a href="https://en.wikipedia.org/wiki/try_catch">try catch</a> block to handle that so that I can check for winners more cleanly than in the first solution). If it's the player, see if we spent less mana than any solution we've found thus far. Rinse and repeat. Running it for a minute, it seems to find the best solution after roughly 2-3 minutes of running on my laptop. So not great, but at least an alternative.</p>
<p><strong>Part 2:</strong> On each of the player's turns (not on the boss's turns), the player loses 1 HP. Find the winning combination of spells that uses the least mana.</p>
<p>Based on the way that I structured the code, this is actually as easy as adding a new spell with unlimited <code>Duration</code>:</p>
<pre class="python"><code>class HardMode(Spell):
    Duration = float('inf')

    def tick(self, caster, target):
        self.toggle = not getattr(self, 'toggle', False)
        if self.toggle:
            caster.damage(1)</code></pre>
<p>There's a bit of weirdness there to make sure that it only runs half as often as most spells (since we don't have half hit points), but this works perfectly. We then start the player with this as an active spell:</p>
<pre class="python"><code>player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [lib.HardMode()],
    'History': [],
})</code></pre>
<p>And that's it. The rest of the simulation is identical. Since <code>HardMode</code> isn't in the <code>lib.spells</code> list, it won't get cast by either solution. Even if we wanted to we couldn't because of the limitation of only one of each ongoing spell at a time.</p>
<p>This actually makes the problem a bit harder computationally. There were already not <em>that</em> many combinations of spells that would win in the first case and there are even fewer this time around. I ran the Monte Carlo simulation several times for five minutes each without it randomly stumbling on a valid ordering that works for this case. I could probably have tweaked the generation algorithm to be a bit smarter, but it wasn't necessary. The priority queue solution with the boss HP weighting found the solution quickly enough.</p>
<p>Since the code for this one is a bit more complicated, feel free to check it out on GitHub to see the whole picture: <a href="https://github.com/jpverkamp/advent-of-code/tree/master/day-22">GitHub:jpverkamp/advent-of-code</a>. I've been (and will continue to) uploading my solutions there, but previously I've just directly included the entire code in order in the posts.</p>
<p>That all being said, I honestly think this was my least favorite problem of them thus far. It was interesting in that it actually mattered what algorithm you chose to solve it (I imagine that a recursive solution with memoization could be even faster), but the implementation details were just way too fiddly. As mentioned earlier, I wrote out more or less exactly the same algorithms a dozen times before I finally had one that actually returned the correct answer (for the most part, they were finding solutions that were too low). So it goes.</p>
<p>I look forward to the final three problems!</p>]]></content></entry></feed>