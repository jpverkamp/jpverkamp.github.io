<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2015-12-25T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:e246205b-1f33-c07a-2aa5-10021f3fe725</id><entry><title>Advent of Code: Day 25</title><link href="//blog.jverkamp.com/2015/12/25/advent-of-code-day-25" /><id>urn:uuid:76fab82b-01da-119f-da63-b163c5d488e0</id><updated>2015-12-25T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533n \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/25">Source</a></p>
<p><strong>Part 1:</strong> Take the relation:</p>
<div>$$F(n) = \left\{\begin{matrix}
20151225 & \textrm{if}\ n = 1 \\
252533n \mod 33554393 & \textrm{otherwise}
\end{matrix}\right.$$</div>
<p>Arrange the values according to <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal argument">Cantor's diagonal argument</a>. Find the value at a specific cell.</p>
<!--more-->
<pre class="python"><code>target_row = int(sys.argv[1])
target_col = int(sys.argv[2])

row = 1
col = 1
val = 20151125

while True:
    if target_row == row and target_col == col:
        print(val)
        sys.exit(0)
    else:
        val = (val * 252533) % 33554393

    if row == 1:
        row = col + 1
        col = 1
    else:
        row -= 1
        col += 1</code></pre>
<p>Merry Christmas!</p>]]></content></entry><entry><title>Advent of Code: Day 24</title><link href="//blog.jverkamp.com/2015/12/24/advent-of-code-day-24" /><id>urn:uuid:2035cd03-489e-dfec-f613-117529fa491f</id><updated>2015-12-24T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/24">Source</a></p>
<p><strong>Part 1:</strong> Split a list of integers into three groups of equal sum. Find the grouping such that the smallest group has the least items, breaking ties by the smallest product for that group.</p>
<!--more-->
<p>My initial solution to this was to solve the <a href="https://en.wikipedia.org/wiki/subset_sum">subset sum</a> problem (or at least a slightly modified version thereof):</p>
<pre class="python"><code>def subsets_summing_to(target, items, cache = {}):
    if target == 0:
        yield set()
    else:
        for i, item in enumerate(items):
            if item &lt;= target:
                for recur in subsets_summing_to(target - item, items - {item}):
                    yield {item} | recur</code></pre>
<p>It's elegant code, and you can use that to generate the three groups fairly easily:</p>
<pre class="python"><code>packages = {int(line.strip()) for line in sys.stdin}
weight_per_package = sum(packages) // 3

for group1 in subsets_summing_to(weight_per_package, package):
    for group2 in subsets_summing_to(weight_per_package, package - group1):
        group3 = packages - group1 - group2
        ...</code></pre>
<p>And then while I let that run, I made a realization. If I generate the first group to be the smallest (by generating all groups of size 1, size 2, size 3, etc), then it doesn't actually matter what the other groups are. Furthermore, if I structure my iteration carefully so that I always return the smallest items first, I will get a minimal product<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Combining these two jumps, I get:</p>
<pre class="python"><code>def subset_sum_of_n(target, items, count):
    if target == 0 and count == 0:
        yield set()
    elif count == 0:
        return
    else:
        for i, item in enumerate(sorted(items)):
            if item &lt;= target:
                for recur in subset_sum_of_n(target - item, items - {item}, count - 1):
                    yield {item} | recur

def calculate_quantum_entanglement(group):
    product = 1
    for item in group:
        product *= item
    return product

def split_into(packages, n_groups):
    weight_per_section = sum(packages) / int(sys.argv[1])

    for n in range(1, len(packages)):
        for group in subset_sum_of_n(weight_per_section, packages, n):
            return (len(group), calculate_quantum_entanglement(group), group)

if __name__ == '__main__':
    packages = {int(line.strip()) for line in sys.stdin}
    n_groups = int(sys.argv[1])

    print(split_into(packages, n_groups))</code></pre>
<p>I'm greatly amused that it doesn't matter at all what any of the other groups are.</p>
<p><strong>Part 2:</strong> Split into four groups.</p>
<p>I already solved this with the <code>n_groups</code> parameter above.</p>
<p>Amusingly, because this solution (at least with my input) only has 4 items in the minimal group, it runs about 60 times faster than the first part. It still doesn't matter at all what the other groups are.</p>]]></content></entry><entry><title>Advent of Code: Day 23</title><link href="//blog.jverkamp.com/2015/12/23/advent-of-code-day-23" /><id>urn:uuid:2b737957-97d1-2db7-c18a-ef2b4bee221f</id><updated>2015-12-23T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/23">Source</a></p>
<p><strong>Part 1:</strong> Create a simple virtual machine with two registers (<code>a</code> and <code>b</code>, non-negative integers) and six instructions:</p>
<ul>
    <li><code>hlf (a|b)</code> - divide the given register by half, round down</li>
    <li><code>tpl (a|b)</code> - triple the given register</li>
    <li><code>inc (a|b)</code> - add 1 to the given register</li>
    <li><code>jmp [+-]\d+</code> - jump forward/backwards by the given number of instructions</li>
    <li><code>jie (a|b), [+-]\d+</code> - if the given register is even, jump</li>
    <li><code>jio (a|b), [+-]\d+</code> - if the given register equals one, jump</li>
</ul>
<!--more-->
<p>I do love writing a good virtual machine. Check out my <a href="//blog.jverkamp.com/2013/08/21/a-tiny-virtual-machine-in-racket">'Tiny' virtual machine in Racket</a>.</p>
<pre class="python"><code>def read_program():
    return [
        tuple(re.split('[, ]+', line.strip()))
        for line in sys.stdin
    ]

def run(program, **initial_state):
    pc = 0
    registers = {'a': 0, 'b': 0}
    registers.update(initial_state)

    while True:
        op = program[pc][0]
        args = program[pc][1:]

        if op == 'hlf':
            registers[args[0]] //= 2
            pc += 1
        elif op == 'tpl':
            registers[args[0]] *= 3
            pc += 1
        elif op == 'inc':
            registers[args[0]] += 1
            pc += 1
        elif op == 'jmp':
            pc += int(args[0])
        elif op == 'jie':
            if registers[args[0]] % 2 == 0:
                pc += int(args[1])
            else:
                pc += 1
        elif op == 'jio':
            if registers[args[0]] == 1:
                pc += int(args[1])
            else:
                pc += 1

        if not (0 &lt;= pc &lt; len(program)):
            break

    return registers

if __name__ == '__main__':
    program = read_program()
    output = run(program)
    print(output['b'])</code></pre>
<p>It's not the most abstracted thing ever, but it really doesn't matter. It works great.</p>
<p><strong>Part 2:</strong> Re-run with the initial state <code>a=1, b=0</code>.</p>
<p>I'll reuse the same trick I've used a few times before to load part 1:</p>
<pre class="python"><code>part1 = imp.load_source('part1', 'part-1.py')

if __name__ == '__main__':
    program = part1.read_program()
    output = part1.run(program, a = 1)
    print(output['b'])</code></pre>]]></content></entry><entry><title>Advent of Code: Day 22</title><link href="//blog.jverkamp.com/2015/12/22/advent-of-code-day-22" /><id>urn:uuid:9cebad4b-f376-fc86-db80-6136e90ab202</id><updated>2015-12-22T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/22">Source</a></p>
<p><strong>Part 1:</strong> Simulate an RPG mage battle; finding the winning solution using the least mana. See the <a href="http://adventofcode.com/day/22">original writeup</a> for more details.</p>
<!--more-->
<p>First, let's create some simple abstractions for the players:</p>
<pre class="python"><code>class Entity(dict):
    '''Represent a damagable entity such as the player or a boss'''

    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            self[key] = val

    def __getitem__(self, key):
        try:
            return dict.__getitem__(self, key)
        except:
            return 0

    def damage(self, points):
        '''Apply damage to this entity; minimum damage is always 1'''

        self['Hit Points'] -= max(1, points - self['Armor'])

    def tick_active_spells(self, target):
        '''Apply all active spells to the target, remove any that have expired.'''

        if self['Active Spells']:
            for spell in list(self['Active Spells']):
                self['History'].append(str(spell))
                spell.tick(self, target)
                spell.Duration -= 1
                if spell.Duration &lt;= 0:
                    self['History'].append('{} fades'.format(spell.__class__.__name__))
                    spell.fade(self, target)
                    self['Active Spells'].remove(spell)</code></pre>
<p>Basically, we have an extended <code>dict</code> that will default values to 0, includes a method for applying <code>damage</code> while taking armor into account, and applying an active spells to a given player. That will make more sense once you see the way spells are defined:</p>
<pre class="python"><code>class Spell(dict):
    '''
    Create a spell. Spells have &lt;code&gt;Cost&lt;/code&gt; mana and last &lt;code&gt;Duration&lt;/code&gt; turns.

    cast() is called when a spell is first cast
    tick() is called each turn (for Duration &gt; 0)
    fade() is called when a spell runs out of duration
    '''

    Cost = float("inf")
    Duration = 0

    def __init__(self):
        self['Duration'] = self.__class__.Duration

    def cast(self, caster, target):
        pass

    def tick(self, caster, target):
        pass

    def fade(self, caster, target):
        pass

    def __repr__(self):
        return '{}({})'.format(self.__class__.__name__, self.Duration)

    def __eq__(self, other):
        return self.__class__.__name__ == other.__class__.__name__

    def __hash__(self):
        return hash(self.__class__.__name__)

class MagicMissle(Spell):
    Cost = 53

    def cast(self, caster, target):
        target.damage(4)

class Drain(Spell):
    Cost = 73

    def cast(self, caster, target):
        target.damage(2)
        caster['Hit Points'] += 2

class Shield(Spell):
    Cost = 113
    Duration = 6

    def cast(self, caster, target):
        caster['Armor'] += 7

    def fade(self, caster, target):
        caster['Armor'] -= 7

class Poison(Spell):
    Cost = 173
    Duration = 6

    def tick(self, caster, target):
        target.damage(3)

class Recharge(Spell):
    Cost = 229
    Duration = 5

    def tick(self, caster, target):
        caster['Mana Points'] += 101

spells = [MagicMissle, Drain, Shield, Poison, Recharge]</code></pre>
<p>As noted in the comment for the <code>Spell</code> class, there are two interesting fields (<code>Cost</code> is the mana cost and <code>Duration</code> is how long an ongoing spell will last) and three functions that can be overridden. <code>cast</code> will be called when the spell is first cast, <code>tick</code> will be called each turn it runs for ongoing spells, and <code>fade</code> will be called when an ongoing spell runs out of time. That will let us encode the five spells in the <a href="http://adventofcode.com/day/22">problem statement</a>.</p>
<p>Finally, we can load the player and boss:</p>
<pre class="python"><code>boss = lib.Entity()
for line in sys.stdin:
    key, val = line.strip().split(': ')
    boss[key] = int(val)

player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [],
    'History': [],
})</code></pre>
<p>Now we have everything to solve the problem. My first take at a solution using a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> based on the mana spent. That means that as soon as we find a solution where <code>boss['Hit Points'] <= 0</code>, we have the minimal solution:</p>
<pre class="python"><code>queue_breaker = 0

states = queue.PriorityQueue()
states.put((0, queue_breaker, player, boss))

best_player = {'Mana Spent': float('inf')}

# This will be used to break ties in the queue since Entities are not orderable
queue_breaker += 1

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        return player

    # Player died, no point in continuing on this track
    if player['Hit Points'] &lt;= 0:
        continue

    # --- Player's turn ---
    player = copy.deepcopy(player)
    boss = copy.deepcopy(boss)
    player['History'].append('&gt;&gt; Player Turn &lt;&lt;')
    player.tick_active_spells(boss)

    # Branch (see the copy below) to applying each possible spell for the player's turn
    for potential_spell in lib.spells:
        if player['Mana Points'] &lt; potential_spell.Cost:
            continue

        spell = potential_spell()
        if spell in player['Active Spells']:
            continue

        current_player = copy.deepcopy(player)
        current_boss = copy.deepcopy(boss)

        # Cast the player's new spell
        current_player['Mana Points'] -= potential_spell.Cost
        current_player['Mana Spent'] += potential_spell.Cost
        spell.cast(current_player, current_boss)

        if spell['Duration']:
            current_player['Active Spells'].append(spell)

        current_player['History'].append(str(spell))

        # --- Boss's turn ---
        current_player['History'].append('&gt;&gt; Boss Turn &lt;&lt;')
        current_player.tick_active_spells(current_boss)
        current_player.damage(current_boss['Damage'])

        # Store the altered copies back in the queue
        states.put((current_player['Mana Spent'], queue_breaker, current_player, current_boss))
        queue_breaker += 1</code></pre>
<p>Most of the code is spent getting the order of events exactly correct. It's a bit weird, but it does work in the end (I think I rewrote exactly this code a dozen times and it finally worked...). The only problem with this solution: the search space is <em>huge</em>. I let it run for rather a while and it simulated literally millions of states still without finding a final solution. I need to cut that down.</p>
<p>My next trial was to tweak the scoring algorithm. By doing this, we lose the ability to return immediately once we have a solution, but we gain the ability to find <em>a</em> solution quickly and then throw out any solutions that would be worse than that one. We only have to make a few tweaks to the above code:</p>
<pre class="python"><code>best_player = {'Mana Spent': float('inf')}

while not states.empty():
    score, _, player, boss = states.get()

    # If we win, because of the priority queue, this is the best solution
    if boss['Hit Points'] &lt;= 0:
        if early_exit:
            return player
        elif player['Mana Spent'] &lt; best_player['Mana Spent']:
            print('New best mana spent:', player['Mana Spent'])
            best_player = player
            continue

    ...

    # Store the altered copies back in the queue
    score = scoring_function(current_player, current_boss)
    states.put((score, queue_breaker, current_player, current_boss))
    queue_breaker += 1

return best_player</code></pre>
<p>Interestingly, this converges very quickly (a few seconds) on my correct solution, then spends a (long) while making sure it's correct. In earlier (incorrect) simulations, it would find a few increasingly good solutions before finally ending up at a steady state.</p>
<p>This runs much more quickly, but guaranteeing that we have a correct solution is still difficult. Instead, let's try a quick <a href="https://en.wikipedia.org/wiki/Monte_Carlo simulation">Monte Carlo simulation</a>:</p>
<pre class="python"><code>def random_spells():
    while True:
        yield random.choice(lib.spells)

class GameOverException(Exception):
    def __init__(self, player_won, reason):
        self.player_won = player_won
        self.reason = reason

def check_game_over(player, boss):
    if boss['Hit Points'] &lt;= 0:
        raise GameOverException(True, 'boss died')

    if player['Hit Points'] &lt;= 0:
        raise GameOverException(False, 'player died')

def fight(player, boss, spell_iterator):
    while True:
        check_game_over(player, boss)

        # --- Player turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        for i, potential_spell in enumerate(spell_iterator):
            if i &gt;= 10:
                raise GameOverException(False, 'failed to cast 10 spells')

            if potential_spell.Cost &gt; player['Mana Points']:
                continue

            spell = potential_spell()
            if spell in player['Active Spells']:
                continue

            player['History'].append('Player casts {}'.format(potential_spell.__name__))
            player['Mana Points'] -= potential_spell.Cost
            player['Mana Spent'] += potential_spell.Cost

            spell.cast(player, boss)
            check_game_over(player, boss)

            if spell.Duration:
                player['Active Spells'].append(spell)

            break

        # --- Boss turn ---
        player.tick_active_spells(boss)
        check_game_over(player, boss)

        player.damage(boss['Damage'])
        check_game_over(player, boss)

def monte_carlo(player, boss, timeout = TIME_TO_RUN):
    start = time.time()
    best_player = {'Mana Spent': float('inf')}
    simulations = 0
    wins = 0

    while True:
        if time.time() - start &gt; TIME_TO_RUN:
            break

        simulations += 1
        current_boss = copy.deepcopy(boss)
        current_player = copy.deepcopy(player)

        try:
            fight(current_player, current_boss, random_spells())
        except GameOverException as game_over:
            if game_over.player_won:
                wins += 1
                if current_player['Mana Spent'] &lt; best_player['Mana Spent']:
                    print('New best:', current_player['Mana Spent'])
                    best_player = current_player

    return simulations, wins, best_player</code></pre>
<p>Basically, just fire off random spells (trying up to 10 times in a given round to account for running low on mana and no duplicates) until one player wins (I'm using a <a href="https://en.wikipedia.org/wiki/try_catch">try catch</a> block to handle that so that I can check for winners more cleanly than in the first solution). If it's the player, see if we spent less mana than any solution we've found thus far. Rinse and repeat. Running it for a minute, it seems to find the best solution after roughly 2-3 minutes of running on my laptop. So not great, but at least an alternative.</p>
<p><strong>Part 2:</strong> On each of the player's turns (not on the boss's turns), the player loses 1 HP. Find the winning combination of spells that uses the least mana.</p>
<p>Based on the way that I structured the code, this is actually as easy as adding a new spell with unlimited <code>Duration</code>:</p>
<pre class="python"><code>class HardMode(Spell):
    Duration = float('inf')

    def tick(self, caster, target):
        self.toggle = not getattr(self, 'toggle', False)
        if self.toggle:
            caster.damage(1)</code></pre>
<p>There's a bit of weirdness there to make sure that it only runs half as often as most spells (since we don't have half hit points), but this works perfectly. We then start the player with this as an active spell:</p>
<pre class="python"><code>player = lib.Entity(**{
    'Hit Points': 50,
    'Mana Points': 500,
    'Active Spells': [lib.HardMode()],
    'History': [],
})</code></pre>
<p>And that's it. The rest of the simulation is identical. Since <code>HardMode</code> isn't in the <code>lib.spells</code> list, it won't get cast by either solution. Even if we wanted to we couldn't because of the limitation of only one of each ongoing spell at a time.</p>
<p>This actually makes the problem a bit harder computationally. There were already not <em>that</em> many combinations of spells that would win in the first case and there are even fewer this time around. I ran the Monte Carlo simulation several times for five minutes each without it randomly stumbling on a valid ordering that works for this case. I could probably have tweaked the generation algorithm to be a bit smarter, but it wasn't necessary. The priority queue solution with the boss HP weighting found the solution quickly enough.</p>
<p>Since the code for this one is a bit more complicated, feel free to check it out on GitHub to see the whole picture: <a href="https://github.com/jpverkamp/advent-of-code/tree/master/day-22">GitHub:jpverkamp/advent-of-code</a>. I've been (and will continue to) uploading my solutions there, but previously I've just directly included the entire code in order in the posts.</p>
<p>That all being said, I honestly think this was my least favorite problem of them thus far. It was interesting in that it actually mattered what algorithm you chose to solve it (I imagine that a recursive solution with memoization could be even faster), but the implementation details were just way too fiddly. As mentioned earlier, I wrote out more or less exactly the same algorithms a dozen times before I finally had one that actually returned the correct answer (for the most part, they were finding solutions that were too low). So it goes.</p>
<p>I look forward to the final three problems!</p>]]></content></entry><entry><title>Advent of Code: Day 21</title><link href="//blog.jverkamp.com/2015/12/21/advent-of-code-day-21" /><id>urn:uuid:2a910be6-afd8-d4dc-e437-c5c47fc1ed7a</id><updated>2015-12-21T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/21">Source</a></p>
<p><strong>Part 1:</strong> Given a shop full of weapons (buy exactly one), armor (buy zero or one), and rings (buy 0, 1, or 2), determine the set of items that will defeat a given enemy for the minimum cost (see the <a href="http://adventofcode.com/day/21">original writeup</a> for more details).</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/21">Source</a></p>
<p><strong>Part 1:</strong> Given a shop full of weapons (buy exactly one), armor (buy zero or one), and rings (buy 0, 1, or 2), determine the set of items that will defeat a given enemy for the minimum cost (see the <a href="http://adventofcode.com/day/21">original writeup</a> for more details).</p>
<!--more-->
<p>First, a bit of code to parse the shop:</p>
<pre class="python"><code>shop = {}
category = None

with open('shop.txt', 'r') as fin:
    for line in fin:
        line = line.strip()
        if not line:
            continue

        if ':' in line:
            category = line.split(':')[0]
            shop[category] = []
            continue

        name, cost, damage, armor = line.rsplit(maxsplit = 3)

        shop[category].append({
            'Name': name,
            'Cost': int(cost),
            'Damage': int(damage),
            'Armor': int(armor),
        })

# Allow for no armor or rings
shop['Armor'].append({'Name': None, 'Cost': 0, 'Damage': 0, 'Armor': 0})
shop['Rings'].append({'Name': None, 'Cost': 0, 'Damage': 0, 'Armor': 0})</code></pre>
<p>Using that, we can write some code to generate all possible players:</p>
<pre class="python"><code>def all_players():
    for weapon in shop['Weapons']:
        for armor in shop['Armor']:
            for left_ring in shop['Rings']:
                for right_ring in shop['Rings']:
                    # Cannot have two of the same ring unless they're both None
                    if left_ring and right_ring and left_ring == right_ring:
                        continue

                    items = [weapon, armor, left_ring, right_ring]

                    player = {
                        'Hit Points': 100,
                        'Items': [item['Name'] for item in items if item['Name']],
                        'Damage': sum(item['Damage'] for item in items),
                        'Armor': sum(item['Armor'] for item in items),
                        'Cost': sum(item['Cost'] for item in items),
                    }

                    yield player</code></pre>
<p>Additionally, we can read our opponent's stats from <code>stdin</code>:</p>
<pre class="python"><code>enemy = {}
for line in sys.stdin:
    key, val = line.strip().split(':')
    enemy[key] = int(val)

def get_enemy():
    return copy.copy(enemy)</code></pre>
<p>It's important to return a new copy each time; otherwise you end up badly beating up the same guy over and over again.</p>
<p>Finally, fight:</p>
<pre class="python"><code>def player_wins(player, enemy):
    while True:
        enemy['Hit Points'] -= max(1, player['Damage'] - enemy['Armor'])
        if enemy['Hit Points'] &lt;= 0:
            return True

        player['Hit Points'] -= max(1, enemy['Damage'] - player['Armor'])
        if player['Hit Points'] &lt;= 0:
            return False</code></pre>
<p>With all of this in a separate file called <code>lib.py</code> (I should probably refactor some of the previous days this way), we can solve the actual problem in about a half dozen lines:</p>
<pre class="python"><code>import lib

best_player = {'Cost': float("inf")}
for player in lib.all_players():
    if lib.player_wins(player, lib.get_enemy()):
        if player['Cost'] &lt; best_player['Cost']:
            best_player = player

print(best_player['Cost'])</code></pre>
<p>A brute force solution feels a bit ugly. We could instead have iterated over the solutions from the cheapest up until we found one that worked, or even done a <a href="https://en.wikipedia.org/wiki/binary_search">binary search</a> by cost, but what's the point? There are only 1260 possible inventories. That's nothing to a computer.</p>
<p><strong>Part 2:</strong> Invert the problem. Find the most expensive set of items you can buy and still lose.</p>
<p>This is why I factored out all of the library code. I know that something like this would be part 2. :)</p>
<pre class="python"><code>import lib

best_player = {'Cost': float("-inf")}
for player in lib.all_players():
    if not lib.player_wins(player, lib.get_enemy()):
        if player['Cost'] &gt; best_player['Cost']:
            best_player = player

print(best_player['Cost'])</code></pre>
<p>In case you were curious, my winner for part 1 had a longsword, chainmail, and a Ring of Damage +2. Part 2 had a Dagger, Leather Armor, and Rings of Damage +3 and Defense +3. It's interesting that the cheaper option actually had a more expensive weapon and armor, but the pair of rings more than made up for it.</p>]]></content></entry><entry><title>Advent of Code: Day 20</title><link href="//blog.jverkamp.com/2015/12/20/advent-of-code-day-20" /><id>urn:uuid:afd29395-b082-d1af-1e24-dc1d0df19418</id><updated>2015-12-20T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/20">Source</a></p>
<p><strong>Part 1:</strong> <em>P(n)</em> is defined such that for each number <em>i</em>, add <em>10i</em> to any number divisible by <em>i</em>. Find the first value <em>n</em> such that <em>P(n)</em> is at least a given target number.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/20">Source</a></p>
<p><strong>Part 1:</strong> <em>P(n)</em> is defined such that for each number <em>i</em>, add <em>10i</em> to any number divisible by <em>i</em>. Find the first value <em>n</em> such that <em>P(n)</em> is at least a given target number.</p>
<!--more-->
<p>Let's throw some memory (and <a href="http://www.numpy.org/">numpy</a>) at it:</p>
<pre class="python"><code>target = int(sys.argv[1])

presents = numpy.zeros(target)

for i in range(1, target):
    presents[i::i] += 10 * i

for i in range(len(presents)):
    if presents[i] &gt;= target:
        print(i)
        sys.exit(0)</code></pre>
<p>It barely makes it in under a minute, but it does. You can speed it up even more if you guess on where the answer will be an initialize to only the first <code>numpy.zeros(target / 10)</code>. In only shaves off about 1/6 of the time on my run though, so I'm not sure it's worth it.</p>
<p><strong>Part 2:</strong> Do the same thing, only use <em>11i</em> instead of <em>10i</em> but only to the first 50 multiples.</p>
<p>Nothing much changes:</p>
<pre class="python"><code>target = int(sys.argv[1])

presents = numpy.zeros(target / 10)

for i in range(1, target):
    presents[i:i*50:i] += 11 * i

for i in range(len(presents)):
    if presents[i] &gt;= target:
        print(i)
        sys.exit(0)</code></pre>]]></content></entry><entry><title>Advent of Code: Day 19</title><link href="//blog.jverkamp.com/2015/12/19/advent-of-code-day-19" /><id>urn:uuid:d3f72e70-8cbc-74c9-b51b-9829eebd4f72</id><updated>2015-12-19T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/19">Source</a></p>
<p><strong>Part 1:</strong> Given a list of list of string replacements and an input string, determine how many unique output strings are possible after one step.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/19">Source</a></p>
<p><strong>Part 1:</strong> Given a list of list of string replacements and an input string, determine how many unique output strings are possible after one step.</p>
<!--more-->
<pre class="python"><code>transitions = collections.defaultdict(set)

reading_transitions = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        reading_transitions = False
    elif reading_transitions:
        src, dst = line.split(' =&gt; ')
        transitions[src].add(dst)
    else:
        target = line

def expand_iter(input):
    for src in transitions:
        for dst in transitions[src]:
            for match in re.finditer(src, input):
                yield input[:match.start()] + dst + input[match.end():]

expansions = set(expand_iter(target))

print(len(expansions))</code></pre>
<p>The basic idea here is to iterate over each possible (non-overlapping) replacement and <code>yield</code> the results. Then we convert that to a <code>set</code> to remove duplicates and return the sizes. Shiny.</p>
<p>I bet I can guess where the second half is going.</p>
<p><strong>Part 2:</strong> This time, take the target as output and determine how many steps it would take to get from <code>e</code> to the target.</p>
<p>This one is actually more of a rewrite (since I'm inverting the <code>transition</code> map):</p>
<pre class="python"><code>transitions = {}

reading_transitions = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        reading_transitions = False
    elif reading_transitions:
        src, dst = line.split(' =&gt; ')
        transitions[dst] = src
    else:
        target = line

def build_iter(input):
    for dst in transitions:
        src = transitions[dst]
        for match in re.finditer(dst, input):
            yield input[:match.start()] + src + input[match.end():]

q = queue.PriorityQueue()
q.put((len(target), 0, target))

while True:
    length, iterations, current = q.get()

    if current == 'e':
        break

    for precursor in build_iter(current):
        q.put((len(precursor), iterations + 1, precursor))

print(iterations)</code></pre>
<p>Two basic insights here: Since each transition output is unique, we don't have multiple possibilities and we want to solve the problem as quickly as possible. Given that, we will use a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> indexing on the length of the current chemical. That way, we'll try the solutions that are already as far along as possible.</p>
<p>For my input, that worked very quickly. For slightly different inputs, the <a href="https://en.wikipedia.org/wiki/greedy_solution">greedy solution</a> doesn't find a result and it has to backtrack, leading to a <em>far</em> longer runtime. I'm not sure what would solve those quickly. I may play with this one a bit longer.</p>
<p>Also, technically this solution isn't strictly correct. It finds the first solution, rather than strictly speaking the shortest one. That could be fixed continuing to iterate on the priority queue until we've exhausted any branches with fewer iterations than the known best. That takes rather a while though. That's one advantage of a contest styles--you can check your input. O:)</p>]]></content></entry><entry><title>Advent of Code: Day 18</title><link href="//blog.jverkamp.com/2015/12/18/advent-of-code-day-18" /><id>urn:uuid:51c1619c-25fa-1ae9-d84b-101769bddbc2</id><updated>2015-12-18T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/18">Source</a></p>
<p><strong>Part 1:</strong> Simulate <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. Count how many lights are on after 100 iterations.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/18">Source</a></p>
<p><strong>Part 1:</strong> Simulate <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. Count how many lights are on after 100 iterations.</p>
<!--more-->
<pre class="python"><code>class Grid(object):
    def __init__(self, str):
        self.data = [
            [(char == '#') for char in line]
            for line in str.split()
        ]
        self.width = len(self.data)
        self.height = len(self.data[0])

    def __getitem__(self, pt):
        row, col = pt
        if 0 &lt;= row &lt; self.height and 0 &lt;= col &lt; self.width:
            return self.data[row][col]
        else:
            return False

    def neighbors(self, row, col):
        return sum(
            (1 if self[row + row_delta, col + col_delta] else 0)
            for row_delta in range(-1, 2)
            for col_delta in range(-1, 2)
        ) - (1 if self[row, col] else 0)

    def step(self):
        new_data = copy.deepcopy(self.data)

        for row in range(self.height):
            for col in range(self.width):
                if self[row, col]:
                    new_data[row][col] = (2 &lt;= self.neighbors(row, col) &lt;= 3)
                else:
                    new_data[row][col] = (self.neighbors(row, col) == 3)

        self.data = new_data

    def __repr__(self):
        return '\n'.join(
            ''.join(
                '#' if self[row, col] else '.'
                for col in range(self.width)
            )
            for row in range(self.height)
        )

    def __len__(self):
        return sum(
            1 if self[row, col] else 0
            for row in range(self.height)
            for col in range(self.width)
        )

if __name__ == '__main__':
    grid = Grid(sys.stdin.read())

    for i in range(int(sys.argv[1])):
        grid.step()

    print(grid)
    print(len(grid))</code></pre>
<p>I don't use actually use <a href="https://en.wikipedia.org/wiki/object_oriented programming">object oriented programming</a> that much, but this problem just called for it. It let me abstract away the counting of accessing of elements while dealing with edge cases. Also, it will be even more helpful in part 2<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p>The three interesting bits are the <code>__getitem__</code>, <code>neighbors</code>, and <code>step</code> functions. The first is interesting, since it actually takes a tuple as as argument, but looks like it takes two parameters: <code>grid[row, col]</code> is actually equivalent to <code>grid[(row, col)]</code>, since it's actually the <code>,</code> that makes a tuple, not the parenthesis.</p>
<p>Next, <code>neighbors</code> will count up the positive neighboring elements using <code>__getitem__</code>. We subtract the one at the end if the node is enabled to account for the fact that we counted the node as its own neighbor.</p>
<p>With all of that, <code>step</code> becomes much easier. We just have to loop and using the <code>neighbors</code> function. Shiny.</p>
<p><strong>Part 2:</strong> Repeat, but this time the four lights in the corners will be stuck on.</p>
<p>This is another reason why I wanted to write this in an object oriented style (in highsight):</p>
<pre class="python"><code>part1 = imp.load_source('part1', 'part-1.py')

class FixedCornerGrid(part1.Grid):
    def __getitem__(self, pt):
        row, col = pt
        if (row in (0, self.width - 1) and col in (0, self.height - 1)):
            return True
        else:
            return part1.Grid.__getitem__(self, pt)

if __name__ == '__main__':
    grid = FixedCornerGrid(sys.stdin.read())

    for i in range(int(sys.argv[1])):
        grid.step()

    print(grid)
    print(len(grid))</code></pre>
<p>The weirdness comes from the fact that I for some reason decided to use dashes in my filenames. Otherwise, I could just have done <code>import part1</code>. But other than that, we only have to slightly tweak the <code>__getitem__</code> behavior for the four corners. Other than that, we just directly reuse all of the code from the original <code>Grid</code> class.</p>
<p>I actually really like how this turned out. It brings a slightly new twist to a problem I've solved a half dozen or more times before.</p>]]></content></entry><entry><title>Advent of Code: Day 17</title><link href="//blog.jverkamp.com/2015/12/17/advent-of-code-day-17" /><id>urn:uuid:4af56322-37f0-f74b-baf8-a837b63f521f</id><updated>2015-12-17T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/17">Source</a></p>
<p><strong>Part 1:</strong> Given a list of containers of varying sizes and a total volume to contain, determine how many different combinations of containers match exactly the given volume.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/17">Source</a></p>
<p><strong>Part 1:</strong> Given a list of containers of varying sizes and a total volume to contain, determine how many different combinations of containers match exactly the given volume.</p>
<!--more-->
<pre class="python"><code>containers = list(map(int, sys.stdin.readlines()))
quantity = int(sys.argv[1])

def fills(quantity, containers):
    if quantity == 0:
        yield []
    else:
        for index, container in enumerate(containers):
            if container &lt;= quantity:
                for sub_fill in fills(quantity - container, containers[index+1:]):
                    yield [container] + sub_fill

print(len(list(fills(quantity, containers))))</code></pre>
<p>Basically, <code>fills</code> will recursively build a generator for a given amount and containers remaining. For each step, it will try each of the containers and recursively determine any solutions that use that container.</p>
<p>On interesting aspect is the recursive call uses <code>containers[index+1:]</code>. That will guarantee that the containers used are always in the same order as the input list, rather than including all possible orderings for any set of containers.</p>
<p><strong>Part 2:</strong> How many of these combinations use the minimum number of containers?</p>
<p>The <code>fills</code> function still does what we need; we just need to <code>filter</code> it so that it only includes orderings that are the proper minimum length:</p>
<pre class="python"><code>smallest_fill = min(map(len, fills(quantity, containers)))

print(len(list(filter(
    lambda fill : len(fill) == smallest_fill,
    fills(quantity, containers)
))))</code></pre>]]></content></entry><entry><title>Advent of Code: Day 16</title><link href="//blog.jverkamp.com/2015/12/16/advent-of-code-day-16" /><id>urn:uuid:03ff5f24-7cd0-f74f-d7bd-db34d25cf913</id><updated>2015-12-16T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/16">Source</a></p>
<p><strong>Part 1:</strong> Given a list of target values of the form:</p>
<pre class="text"><code>children: 3
cats: 7
samoyeds: 2</code></pre>
<p>And a list of 'Aunt Sues', each with known values:</p>
<pre class="text"><code>Sue 1: children: 1, cars: 8, vizslas: 7
Sue 2: akitas: 10, perfumes: 10, children: 5
Sue 3: cars: 5, pomeranians: 4, vizslas: 1</code></pre>
<p>Determine which Sue has no unset but matching values.</p>
<p>For example, Sue 1 is invalid because <code>children</code> is 1 versus 3 and Sue 2 because <code>children</code> is 5 versus 3. Given only the values above, Sue 3 would be valid since there are no contradictions.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/16">Source</a></p>
<p><strong>Part 1:</strong> Given a list of target values of the form:</p>
<pre class="text"><code>children: 3
cats: 7
samoyeds: 2</code></pre>
<p>And a list of 'Aunt Sues', each with known values:</p>
<pre class="text"><code>Sue 1: children: 1, cars: 8, vizslas: 7
Sue 2: akitas: 10, perfumes: 10, children: 5
Sue 3: cars: 5, pomeranians: 4, vizslas: 1</code></pre>
<p>Determine which Sue has no unset but matching values.</p>
<p>For example, Sue 1 is invalid because <code>children</code> is 1 versus 3 and Sue 2 because <code>children</code> is 5 versus 3. Given only the values above, Sue 3 would be valid since there are no contradictions.</p>
<!--more-->
<p>I think understanding this problem took longer than solving it. Originally, I thought that missing values should be treated as <code>float('inf')</code>, but they should just be ignored entirely:</p>
<pre class="python"><code>targets = {}
sues = collections.defaultdict(dict)

loading_targets = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        loading_targets = False

    elif loading_targets:
        key, val = line.split(': ')
        targets[key] = int(val)

    else:
        sue, things = line.strip().split(': ', 1)
        for thing in things.split(', '):
            key, val = thing.split(': ')
            sues[sue][key] = int(val)

for sue in sues:
    valid = True

    for key in targets:
        if key in sues[sue] and sues[sue][key] != targets[key]:
            valid = False
            break

    if valid:
        print(sue)</code></pre>
<p>The longer half is correctly parsing and loading the data. For my case, I put both inputs in the same stream, separated by an empty line (similar to <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> and other protocols actually).</p>
<p>After that, it was just a matter of checking each Sue for the first existent but non-matching value.</p>
<p><strong>Part 2:</strong> Repeat the same algorithm, however assume that a Sue must have strictly more <code>cats</code> and <code>trees</code> than listed and strictly less <code>pomeranians</code> and <code>goldfish</code>.</p>
<p>For this, I introduced another <code>defaultdict</code> which contains the <code>comparators</code> to use for any given value:</p>
<pre class="python"><code>comparators = collections.defaultdict(lambda : operator.eq)
comparators['cats'] = comparators['trees'] = operator.gt
comparators['pomeranians'] = comparators['goldfish'] = operator.lt</code></pre>
<p>After that, we can change the <code>for sue in sues</code> loop to take the comparator into account:</p>
<pre class="python"><code>for sue in sues:
    valid = True

    for key in targets:
        if key in sues[sue] and not comparators[key](sues[sue][key], targets[key]):
                valid = False
                break

    if valid:
        print(sue)</code></pre>
<p>Neat.</p>]]></content></entry></feed>