<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2015-12-07T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:e246205b-1f33-c07a-2aa5-10021f3fe725</id><entry><title>Advent of Code: Day 7</title><link href="//blog.jverkamp.com/2015/12/07/advent-of-code-day-7" /><id>urn:uuid:43df33f1-13b4-5b4b-cbce-a7118aadaadd</id><updated>2015-12-07T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
<!--more-->
<p>This one is actually really cool. It's basically a full <a href="https://en.wikipedia.org/wiki/declarative_programming language">declarative programming language</a>.</p>
<pre class="python"><code>monops = {
    'NOT': lambda x : ~x & 0xFFFF,
}

binops = {
    'AND': operator.and_,
    'OR': operator.or_,
    'LSHIFT': operator.lshift,
    'RSHIFT': operator.rshift,
}

machine = {}

for line in sys.stdin:
    line = line.strip()

    m = (
        re.match(r'(\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) (\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) -&gt; (\w+)', line)
    ).groups()

    machine[m[-1]] = m[:-1]

def evaluate(register_or_value):
    try:
        return int(register_or_value)
    except:
        return run(register_or_value)

def run(register, state = {}):
    if not register in state:
        command = machine[register]

        if len(command) == 1:
            value, = command
            state[register] = evaluate(value)

        elif len(command) == 2:
            monop, input = command
            state[register] = monops[monop](evaluate(input))

        elif len(command) == 3:
            input_1, binop, input_2 = command
            state[register] = binops[binop](evaluate(input_1), evaluate(input_2))

    return state[register]

print(run('a'))</code></pre>
<p>Basically, we have two interesting functions: <code>evaluate</code> and <code>run</code>. Each of those will be applied to any parameters. <code>evaulate</code> will check first if the parameter is an integer, if so return it directly. If not, fall back to <code>run</code>, which is a <a href="https://en.wikipedia.org/wiki/memoized">memoized</a> virtual machine.</p>
<p>If we have the values of any inputs (either because they are numeric or because we've already calculated them), it will directly calculate the value for that gate and cache it. If not, it will calculate any recursive outputs it needs (caching them as well), and then calculate it's own. Through the power of <a href="https://en.wikipedia.org/wiki/dynamic_programming">dynamic programming</a>, this will naturally resolve the order the gates need to be run in while still running in <code>O(n)</code> time to the number of gates. Very cool, in my opinion<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p>The only other oddity is the definition of <code>NOT</code>. Since Python integers are not 16-bits, doing a bitwise and with <code>0xFFFF</code> (the maximum 16-bit value) will lock the result into that range.</p>
<p><strong>Part 2:</strong> Take the value of <code>a</code> after running part 1 and assign it to <code>b</code>. Run the simulation again.</p>
<p>Due to how I load in the instructions, this is as easy as adding a line of the form <code>14710 -> b</code> to the end of my input before running it. That will replace the previous command for <code>b</code>. You can do it in a <a href="http://www.zsh.org/"><code>zsh</code></a> one liner<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span> shells would work just as well}:</p>
<pre class="zsh"><code>{cat input.txt; (echo "\n" &#96;cat input.txt | python part-1.py&#96; "-&gt; b")} | python3 part-1.py</code></pre>]]></content></entry><entry><title>Advent of Code: Day 6</title><link href="//blog.jverkamp.com/2015/12/06/advent-of-code-day-6" /><id>urn:uuid:4b503edf-8fe1-cc51-66e7-ad352be59fb5</id><updated>2015-12-06T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/6">Source</a></p>
<p><strong>Part 1:</strong> Given a 1000 by 1000 grid of lights and a list of instructions of the form <code>(turn on|turn off|toggle) 5,10 through 15,20</code>, determine how many lights are on.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/6">Source</a></p>
<p><strong>Part 1:</strong> Given a 1000 by 1000 grid of lights and a list of instructions of the form <code>(turn on|turn off|toggle) 5,10 through 15,20</code>, determine how many lights are on.</p>
<!--more-->
<pre class="python"><code>lights = [
    [False for y in range(1000)]
    for x in range(1000)
]

for line in sys.stdin:
    mode, x1, y1, x2, y2 = re.match('(.*) (\d+),(\d+) through (\d+),(\d+)', line.strip()).groups()
    x1, y1, x2, y2 = map(int, (x1, y1, x2, y2))

    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            if mode == 'turn on':
                lights[x][y] = True
            elif mode == 'turn off':
                lights[x][y] = False
            else:
                lights[x][y] = not lights[x][y]

print(sum(
    1 if lights[x][y] else 0
    for x in range(1000)
    for y in range(1000)
))</code></pre>
<p>At first, I was going to use <a href="http://pyparsing.wikispaces.com/">pyparsing</a> to parse the input, but then I decided that it was far too heavy weight for what I was doing. All I needed was regular expressions. After that, it's just a matter of creating a relatively large two dimensional array and running each instruction.</p>
<p>This one I actually did twice. I was curious if CPU would be significantly faster than memory (it is) to the extent that it would be faster to just calculate each light as we went:</p>
<pre class="python"><code>filters = []
for line in sys.stdin:
    m = re.match('(.*) (\d+),(\d+) through (\d+),(\d+)', line.strip())
    filters.append([m.group(1)] + list(map(int, m.groups()[1:])))

def is_on(x, y):
    on = False
    for mode, x1, y1, x2, y2 in filters:
        if x1 &lt;= x &lt;= x2 and y1 &lt;= y &lt;= y2:
            if mode == 'turn on':
                on = True
            elif mode == 'turn off':
                on = False
            else:
                on = not on
    return on

print(sum(
    1 if is_on(x, y) else 0
    for x in range(1000)
    for y in range(1000)
))</code></pre>
<p>I works at least, giving the same answer, but it's roughly an order of magnitude slower. So it goes.</p>
<p><strong>Part 2:</strong> This time <code>turn on</code> is <code>+1</code>, <code>turn off</code> is <code>-1</code>, <code>toggle</code> is <code>+2</code> and you cannot go below zero for any single cell.</p>
<p>The code doesn't actually change much from the first solution to the first part, we just initialize to <code>0</code> instead of <code>False</code> and tweak the updates. The only interesting one is the <code>turn off</code> case:</p>
<pre class="python"><code>elif mode == 'turn off':
    if lights[x][y] &gt; 0:
        lights[x][y] -= 1</code></pre>
<p>Since this is the only case that can be negative, it's the only one we have to special case.</p>]]></content></entry><entry><title>Advent of Code: Day 5</title><link href="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5" /><id>urn:uuid:1d7592cf-1697-7d8b-e618-55152e623f25</id><updated>2015-12-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/5">Source</a></p>
<p><strong>Part 1:</strong> A 'nice' string contains at least three vowels, one double letter (such as <code>xx</code>), and none of the strings <code>ab</code>, <code>cd</code>, <code>pq</code>, or <code>xy</code>. Count nice strings.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/5">Source</a></p>
<p><strong>Part 1:</strong> A 'nice' string contains at least three vowels, one double letter (such as <code>xx</code>), and none of the strings <code>ab</code>, <code>cd</code>, <code>pq</code>, or <code>xy</code>. Count nice strings.</p>
<!--more-->
<pre class="python"><code>def is_nice(word):
    return (
        re.search(r'.*([aeiou].*){3}', word)
        and re.search(r'(.)\1', word)
        and not re.search(r'(ab|cd|pq|xy)', word)
    )

nice_count = 0
for line in sys.stdin:
    if is_nice(line.strip()):
        nice_count += 1

print(nice_count)</code></pre>
<p>This is a perfect application for regular expressions. In this case, <code>.*([aeiou].*){3}</code> says to match a vowel <code>[aeiou]</code> followed by any number (including zero) three times. <code>(.)\1</code> says to match any one character, then match that same character again (<code>\1</code> refers to the first matched group in parenthesis). <code>(ab|cd|pq|xy)</code> matches any one of the verboten sequences and then we negate it with <code>not</code>.</p>
<p><strong>Part 2:</strong> A 'nice' string now contains a pair of letters appearing twice in a string (such as <code>xy</code> in <code>axybcxydef</code>) and one pattern of the form <code>xyx</code> (with the first and third letters the same).</p>
<p>The code is the same, just change the regular expressions to two new patterns, each with a back reference:</p>
<pre class="python"><code>re.search(r'(..).*\1', word)
and re.search(r'(.).\1', word)</code></pre>
<p>The first matches any two characters followed by any number (including zero) uninteresting characters, followed by that same first two characters. The second does the same, only with a single character repeated group and exactly one random character in between.</p>
<p><a href="http://xkcd.com/208/"><img src="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5/xkcd-208.png" /></a></p>]]></content></entry><entry><title>Advent of Code: Day 4</title><link href="//blog.jverkamp.com/2015/12/04/advent-of-code-day-4" /><id>urn:uuid:216f239d-ca7c-12de-7b86-7275e8f4baab</id><updated>2015-12-04T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/4">Source</a></p>
<p><strong>Part 1:</strong> Mine Adventcoins. Basically, find the lowest integer such that the string <code>{prefix}{integer}</code> has an <a href="https://en.wikipedia.org/wiki/md5">md5</a> hash with at least 5 leading zeros. <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/4">Source</a></p>
<p><strong>Part 1:</strong> Mine Adventcoins. Basically, find the lowest integer such that the string <code>{prefix}{integer}</code> has an <a href="https://en.wikipedia.org/wiki/md5">md5</a> hash with at least 5 leading zeros. <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>
<!--more-->
<pre class="python"><code>def naturals(i = 0):
    while True:
        yield i
        i += 1

def mine(prefix, length):
    for i in naturals(1):
        coin = '{prefix}{suffix}'.format(prefix = prefix, suffix = i).encode('utf-8')
        hash = hashlib.md5(coin).hexdigest()
        if all(c == '0' for c in hash[0:length]):
            return (i, hash)

print(mine(sys.argv[1], 5))</code></pre>
<p><code>naturals</code> is code that I've used on a number of previous occasions and basically <del>stole</del> borrowed from Racket's <code><a href="http://docs.racket-lang.org/search/index.html?q=n-naturals">n-naturals</a></code>. It allows you to iterate indefinitely over the <a href="https://en.wikipedia.org/wiki/natural_numbers">natural numbers</a>. Then, just hash and look for enough leading zeros.</p>
<p><strong>Part 2:</strong> Do the same thing, only with six leading zeros.</p>
<p>Nothing changes; just change the <code>length</code> parameter and wait a bit longer. Moderns computers can still crunch through a whole heck of a lot of hashes (9958218 for my particular input) in next to no time at all.</p>]]></content></entry><entry><title>Advent of Code: Day 3</title><link href="//blog.jverkamp.com/2015/12/03/advent-of-code-day-3" /><id>urn:uuid:68885146-6356-7c02-ec5c-5f0fbb4bf956</id><updated>2015-12-03T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/3">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code><>^v</code> characters which mean move west, east, north, or south respectively and starting at the origin, how many unique positions do you pass through?</p>
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
location = 0+0j

directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for c in sys.stdin.read():
    location += directions.get(c, 0+0j)
    presents[location] += 1

print(len(presents))</code></pre>
<p>There are two tricks here, both of which I've used before. First, we have use <code>collections.defaultdict</code> to implement a basic counter. That way, we can safely do <code>+= 1</code> to any element without worrying if it exists first and without initializing the (potentially infinite) grid.</p>
<p>Second, we represent points using <a href="https://en.wikipedia.org/wiki/complex_numbers">complex numbers</a>. That has the advantage of meaning that movement is just adding two (complex) numbers together and we can directly index the <code>presents</code> dictionary with the locations.</p>
<p>At the end, the <code>len</code> of a dictionary is the number of keys, thus exactly equal to the number of locations visited (which thankfully works correctly even with a <code>defaultdict</code>). Neat.</p>
<p><strong>Part 2:</strong> Start with two actors, each at the origin. Apply alternating characters to first one then the other, such that <code>^v^v</code> would result in one moving north twice, the other two south.</p>
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
presents[0+0j] = 2

locations = [0+0j, 0+0j]
directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for i, c in enumerate(sys.stdin.read()):
    which = i % len(location)
    locations[which] += directions.get(c, 0+0j)
    presents[locations[which]] += 1

print(len(presents))</code></pre>
<p>The basic code is the same here, the only difference is that we determine <code>which</code> actor is moving using <a href="https://en.wikipedia.org/wiki/modular_arithmatic">modular arithmatic</a> (<code>%</code>). One neat thing about this is that it scales without any other changes to any number of actors merely by putting more elements in the initial <code>locations</code> array.</p>]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/3">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code><>^v</code> characters which mean move west, east, north, or south respectively and starting at the origin, how many unique positions do you pass through?</p>
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
location = 0+0j

directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for c in sys.stdin.read():
    location += directions.get(c, 0+0j)
    presents[location] += 1

print(len(presents))</code></pre>
<p>There are two tricks here, both of which I've used before. First, we have use <code>collections.defaultdict</code> to implement a basic counter. That way, we can safely do <code>+= 1</code> to any element without worrying if it exists first and without initializing the (potentially infinite) grid.</p>
<p>Second, we represent points using <a href="https://en.wikipedia.org/wiki/complex_numbers">complex numbers</a>. That has the advantage of meaning that movement is just adding two (complex) numbers together and we can directly index the <code>presents</code> dictionary with the locations.</p>
<p>At the end, the <code>len</code> of a dictionary is the number of keys, thus exactly equal to the number of locations visited (which thankfully works correctly even with a <code>defaultdict</code>). Neat.</p>
<p><strong>Part 2:</strong> Start with two actors, each at the origin. Apply alternating characters to first one then the other, such that <code>^v^v</code> would result in one moving north twice, the other two south.</p>
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
presents[0+0j] = 2

locations = [0+0j, 0+0j]
directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for i, c in enumerate(sys.stdin.read()):
    which = i % len(location)
    locations[which] += directions.get(c, 0+0j)
    presents[locations[which]] += 1

print(len(presents))</code></pre>
<p>The basic code is the same here, the only difference is that we determine <code>which</code> actor is moving using <a href="https://en.wikipedia.org/wiki/modular_arithmatic">modular arithmatic</a> (<code>%</code>). One neat thing about this is that it scales without any other changes to any number of actors merely by putting more elements in the initial <code>locations</code> array.</p>]]></content></entry><entry><title>Advent of Code: Day 2</title><link href="//blog.jverkamp.com/2015/12/02/advent-of-code-day-2" /><id>urn:uuid:7acbe2e4-c172-21ea-ec12-8be3477262de</id><updated>2015-12-02T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/2">Source</a></p>
<p><strong>Part 1:</strong> A gift requires enough wrapping paper to cover the surface plus an additional amount equal to the area smallest side. Calculate the total wrapping paper needed for a list of dimensions of the form <code>2x3x4</code>.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/2">Source</a></p>
<p><strong>Part 1:</strong> A gift requires enough wrapping paper to cover the surface plus an additional amount equal to the area smallest side. Calculate the total wrapping paper needed for a list of dimensions of the form <code>2x3x4</code>.</p>
<!--more-->
<pre class="python"><code>total_area = 0

for line in sys.stdin:
    l, w, h = list(sorted(map(int, line.strip().split('x'))))
    area = 3 * l * w + 2 * w * h + 2 * h * l
    total_area += area

print(total_area)</code></pre>
<p>The only real trick here is the use of <code>list(sorted(...))</code>. This will guarantee that <code>l</code> and <code>w</code> are the smallest dimensions and thus represent the extra area to add.</p>
<p><strong>Part 2:</strong> Given the same input, calculate the amount of ribbon needed. You need the larger of either the shortest distance around the outside or the smallest perimeter of any one face. In addition, you need an additional amount equal to the volume in cubic feet.</p>
<pre class="python"><code>total_ribbon = 0

for line in sys.stdin:
    l, w, h = list(sorted(map(int, line.strip().split('x'))))

    total_ribbon += max(
        2 * (l + w), # smallest distance around sides
        4 * l,       # smallest perimeter
    )

    total_ribbon += l * w * h

print(total_ribbon)</code></pre>
<p>This one was a little stranger since the original description was unclear if you needed the larger or smaller of the first two measurements, but it was easy enough to calculate both. Turns out, they meant the larger of those two.</p>]]></content></entry><entry><title>Glorious Gification of HipChat Rooms</title><link href="//blog.jverkamp.com/2015/12/02/glorious-gification-of-hipchat-rooms" /><id>urn:uuid:359d720d-d37a-ff8c-6784-f0cf5a724486</id><updated>2015-12-02T00:00:00Z</updated><summary type="html"><![CDATA[<p>To counter yesterday's post on <a href="//blog.jverkamp.com/2015/12/01/iterating-the-github-api">Iterating the GitHub API</a>, how about something a little more lighthearted today: GIFs<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p><a href="//blog.jverkamp.com/2015/12/02/glorious-gification-of-hipchat-rooms/no-regrets.gif" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/02/glorious-gification-of-hipchat-rooms/no-regrets.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>To counter yesterday's post on <a href="//blog.jverkamp.com/2015/12/01/iterating-the-github-api">Iterating the GitHub API</a>, how about something a little more lighthearted today: GIFs<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p><a href="//blog.jverkamp.com/2015/12/02/glorious-gification-of-hipchat-rooms/no-regrets.gif" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/02/glorious-gification-of-hipchat-rooms/no-regrets.gif" /></a></p>
<!--more-->
<p>Animated GIFs are an amusing--if arguably useful--way of communicating. But hey, if something is worth doing, it's worth OVERDOING, no<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>?</p>
<p>So I wrote a script to upload my entire collection of GIFs to a HipChat room<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>:</p>
<pre class="python"><code>#!/usr/bin/env python3

import os
import random
import re
import requests
import sys
import time

ACCESS_TOKEN = '{redacted}'
ROOM_ID = 8675309
GIF_PATH = '{redacted}'
TIMEOUT = 60

from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

headers = {
    'Authorization': 'Bearer {}'.format(ACCESS_TOKEN),
    'Accept-Charset': 'UTF-8',
    'Content-Type': 'multipart/related',
}

url = 'https://api.hipchat.com/v2/room/{}/share/file'.format(ROOM_ID)

paths = [
    os.path.join(path, file)
    for path, dirs, files in os.walk(GIF_PATH)
    for file in files
    if file.endswith('.gif')
]
random.shuffle(paths)

for path in paths:
    print(path)

    raw_body = MIMEMultipart('related')
    with open(path, 'rb') as fin:
        img = MIMEImage(fin.read())
        img.add_header(
            'Content-Disposition',
            'attachment',
            name = 'file',
            filename = path.split('/')[-1]
        )
        raw_body.attach(img)

    raw_headers, body = raw_body.as_string().split('\n\n', 1)
    boundary = re.search('boundary="([^"]*)"', raw_headers).group(1)

    headers['Content-Type'] = 'multipart/related; boundary="{}"'.format(boundary)

    r = requests.post(url, data = body, headers = headers)
    time.sleep(TIMEOUT)</code></pre>
<p>The main reason that this script is at all interesting is that the API excepts (and requires) a <code>multipart/related</code> request, but the <a href="http://docs.python-requests.org/en/latest/">Requests</a> won't send one. So instead we have to pull in Python's email libraries in order to generate the request body. It's a bit annoying, but an interesting dive into some of the more esoteric details of web requests.</p>
<p>Also, I've been on a kick of using slightly more complicated list comprehension:</p>
<pre class="python"><code>paths = [
    os.path.join(path, file)
    for path, dirs, files in os.walk(GIF_PATH)
    for file in files
    if file.endswith('.gif')
]</code></pre>
<p>Basically, if you put multiple <code>for</code> loops in a list comprehension body, it will return a single iterable, nested from the first to the last. So this is equivalent to:</p>
<pre class="python"><code>paths = []
for path, dirs, files in os.walk(GIF_PATH):
    for file in files:
        if file.endswith('.gif'):
            os.path.join(path, file)</code></pre>
<p>It's arguable which is more Pythonic (probably the latter), but I do find it interesting what impact writing piles of functional code (<a href="//blog.jverkamp.com/category/programming/by-language/racket">Racket</a>) will do to code in other languages.</p>
<p>And, that's it. Short and sweet. Use responsibly.</p>]]></content></entry><entry><title>Advent of Code</title><link href="//blog.jverkamp.com/2015/12/01/advent-of-code" /><id>urn:uuid:5f4c0cf6-ad53-c952-fd22-723d73c08e90</id><updated>2015-12-01T00:00:00Z</updated><summary type="html"><![CDATA[<p>I'm always on the lookout for new sources of quick<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> coding puzzles. This holiday season, <a href="http://adventofcode.com/">Advent of Code</a> scratches precisely that itch.</p>
<blockquote>Advent of Code is a series of small programming puzzles for a variety of skill levels. They are self-contained and are just as appropriate for an expert who wants to stay sharp as they are for a beginner who is just learning to code. Each puzzle calls upon different skills and has two parts that build on a theme. -- <a href="http://adventofcode.com/about">About - Advent of Code</a></blockquote>
<p>I've been working out each problem thus far in Python (my language of choice; along with Racket). I'm backfilling the first seven posts (along with this one), but I'll try to do the rest daily.</p>
]]></summary><content type="html"><![CDATA[<p>I'm always on the lookout for new sources of quick<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> coding puzzles. This holiday season, <a href="http://adventofcode.com/">Advent of Code</a> scratches precisely that itch.</p>
<blockquote>Advent of Code is a series of small programming puzzles for a variety of skill levels. They are self-contained and are just as appropriate for an expert who wants to stay sharp as they are for a beginner who is just learning to code. Each puzzle calls upon different skills and has two parts that build on a theme. -- <a href="http://adventofcode.com/about">About - Advent of Code</a></blockquote>
<p>I've been working out each problem thus far in Python (my language of choice; along with Racket). I'm backfilling the first seven posts (along with this one), but I'll try to do the rest daily.</p>
<!--more-->
<p>If you'd like to see all of the solutions, here's a list:</p>
<ul class="list-unstyled"></ul>
<p>As with my <a href="//blog.jverkamp.com/2012/11/03/project-euler">Project Euler</a> posts<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>, I generally feel that these problems are more interesting if you take a crack at solving them yourself first. If you feel the same way, <em>stop reading</em>. This post will still be here when you're done, I promise<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>.</p>
<p>For each post, I suggest you click through on the title to read the entire descriptions. They're amusing. I'll summarize the core of the problem here though.</p>
<p>If you've solved the puzzles as well and posted your solutions, post a link below. I'd love to see how others approach the problems.</p>]]></content></entry><entry><title>Advent of Code: Day 1</title><link href="//blog.jverkamp.com/2015/12/01/advent-of-code-day-1" /><id>urn:uuid:8083e9c3-690d-9e5c-c890-c178ccc89c50</id><updated>2015-12-01T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/1">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code>()</code> characters controlling a simulated elevator, where <code>(</code> means 'go up' and <code>)</code> means 'go down', what floor do you end up on?</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/1">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code>()</code> characters controlling a simulated elevator, where <code>(</code> means 'go up' and <code>)</code> means 'go down', what floor do you end up on?</p>
<!--more-->
<pre class="python"><code>data = sys.stdin.read()
print(data.count('(') - data.count(')'))</code></pre>
<p>Basically, <code>count</code> the number of up, subtract the number of down. Nothing much more to say for this one.</p>
<p><strong>Part 2:</strong> How far do you make it in the instructions before the current floor is negative?</p>
<pre class="python"><code>floor = 0
for index, char in enumerate(sys.stdin.read()):
    floor += (1 if char == '(' else -1)
    if floor &lt; 0:
        print(index)
        sys.exit(0)</code></pre>
<p>There might be a more elegant way to do this one, but this is clean enough so far as I'm concerned.</p>]]></content></entry><entry><title>Iterating the GitHub API (For users sans MFA)</title><link href="//blog.jverkamp.com/2015/12/01/iterating-the-github-api" /><id>urn:uuid:796d4e1c-d1a7-f844-33e9-d5bdad0ad636</id><updated>2015-12-01T00:00:00Z</updated><summary type="html"><![CDATA[<p>Today I found myself auditing an organization's users to see which have <a href="https://en.wikipedia.org/wiki/multifactor_authentication">multifactor authentication</a> enabled<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Since we have a not insignificant number of users, I wanted to write a quick script to automate it. Down the rabbit hole I go... and now I have a clean way of iterating across paginated GitHub API responses.</p>
]]></summary><content type="html"><![CDATA[<p>Today I found myself auditing an organization's users to see which have <a href="https://en.wikipedia.org/wiki/multifactor_authentication">multifactor authentication</a> enabled<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Since we have a not insignificant number of users, I wanted to write a quick script to automate it. Down the rabbit hole I go... and now I have a clean way of iterating across paginated GitHub API responses.</p>
<!--more-->
<p>First, the full script:</p>
<pre class="python"><code>#!/usr/bin/env python3

import requests
import os

try:
    token = os.environ['GITHUB_TOKEN']
except:
    print('$GITHUB_TOKEN must be set with proper permission')
    sys.exit(0)

headers = {'Authorization': 'token {}'.format(token)}

def api_iterator(endpoint):
    url = 'https://api.github.com' + endpoint

    while True:
        response = requests.get(url, headers = headers)
        yield from response.json()

        if 'next' in response.links:
            url = response.links['next']['url']
        else:
            return</code></pre>
<p>The core of this script once again leans against the excellent <a href="http://docs.python-requests.org/en/latest/">Requests</a> library for Python. It makes making simple requests and parsing the <a href="http://www.w3.org/wiki/LinkHeader">HTTP Link Header</a> trivial. Also, <code>yield from</code> is pretty cool.</p>
<p>Basically, we use these instructions to <a href="https://help.github.com/articles/creating-an-access-token-for-command-line-use/">create a GitHub access token</a>. You'll need at least the organization rights, I don't have an exact list. Unfortunately, it doesn't look like there is a way to do this with a username, password, and MFA token. I tried a few variations but it kept claiming that I wasn't an owner of the organization. So it goes.</p>
<p>Now, if we wanted to use this for my original goal of finding users without MFA, you need the <code>/orgs/:organization/members</code> endpoint, with a specific filter:</p>
<pre class="python"><code>endpoint = '/orgs/{}/members?filter=2fa_disabled'.format(organization)
for user in api_iterator(endpoint):
    print(user['login'])</code></pre>
<p>Alternatively, you can use it just as easily to get all of your repositories (similar to what I did for my post on <a href="//blog.jverkamp.com/2015/09/08/backing-up-github-repositories">backing up GitHub repositories</a>):</p>
<pre class="python"><code>for repo in api_iterator('/user/repos'):
    print(repo['url'])</code></pre>
<p>Cool. Hope it's helpful!</p>
<p>The full source for the MFA version is also available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/missing-mfa.py">missing-mfa.py</a></p>]]></content></entry></feed>