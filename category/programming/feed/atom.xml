<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-04-07T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>Generating perfect portmaneaus</title><link href="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmaneaus" /><id>urn:uuid:b6a3a5ba-c315-27de-adb0-f5871a3c83c9</id><updated>2015-04-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>A quick programming post, since it's been a while, inspired by this video:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/QVn2PZGZxaI" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>I'm not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
]]></summary><content type="html"><![CDATA[<p>A quick programming post, since it's been a while, inspired by this video:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/QVn2PZGZxaI" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>I'm not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<!--more-->
<p>Basically<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>, a portmanteau is a combination of two words, smooshing them together<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span> and dropping some letters from each. In this case, what I'm specifically interested in is 'perfect' portmanteaus (I'm not sure if there is a better term for it), where the suffix of one word exactly matches the prefix of the other.</p>
<p>As an example, consider the words <code>hamster</code> and <code>termine</code>. The last three letters of the former, perfectly matches the first three of the latter, so let's overlap them. <code>hamstermite</code>. Bam.</p>
<p>So how do we do it?</p>
<pre class="racket"><code>(define current-minimum-overlap (make-parameter 3))

(define (portmanteau left right)
  (define maximum-overlap (- (min (string-length left) (string-length right)) 1))

  (for*/first ([overlap (in-range maximum-overlap (- (current-minimum-overlap) 1) -1)]
               #:when (equal? (substring left (- (string-length left) overlap))
                              (substring right 0 overlap)))
    (list left
          right
          (string-append
           (substring left 0 (- (string-length left) overlap))
           right))))</code></pre>
<p>Should be straight forward enough. Basically, we start with the longest possible overlap (1 less than the length of the shorter word, since we don't want to completely subsume a word), counting down until we reach some minimum overlap. For each possible sequence, we compare the prefix and suffix of the two words, only proceeding into the body of the loop when they match. That's the beauty of <code><a href="http://docs.racket-lang.org/search/index.html?q=for*/first">for*/first</a></code>, it will loop until it gets a valid value, returning when it does.</p>
<p>And that's really it. Try it out with the example from earlier:</p>
<pre class="racket"><code>&gt; (portmanteau "hamster" "termite")
'("hamster" "termite" "hamstermite")</code></pre>
<p>Since that was so quick, let's put some simple wrapper code around it in order to find all portmanteaus from a given word list. First, do the heavy lifting of finding portmanteaus:</p>
<pre class="racket"><code>(define (portmanteaus)
  (define words
    (for*/list ([raw-line (in-lines)]
                [line (in-value (string-trim (string-downcase raw-line)))]
                #:when (not (equal? "" line)))
      line))

  (for*/list ([left (in-list words)]
              [right (in-list words)]
              #:when (not (eq? left right))
              [portmanteau (in-value (portmanteau left right))]
              #:when portmanteau)
    portmanteau))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=in-value">in-value</a></code> is useful in <code><a href="http://docs.racket-lang.org/search/index.html?q=for*">for*</a></code> since it lets you bind a single value for future <code>#:when</code> blocks without having to recalculate anything.</p>
<p>After that, a wrapper to process some command line parameters and render output in a few different ways:</p>
<pre class="racket"><code>(define paths
  (command-line
   #:program "portmanteau"
   #:once-each
   [("--minimum-overlap")
    overlap
    "Specify the minimum necessary overlap (default = 3)"
    (cond
      [(string-&gt;number overlap) =&gt; current-minimum-overlap]
      [else (error '--minimum-overlap "must specify a number")])]
   #:once-any
   [("--verbose")
    "Print in verbose mode (default = false)"
    (verbose-mode #t)]
   [("--graph")
    "Print out a dotfile"
    (graph-mode #t)]
   #:args paths

   paths))

(when (null? paths)
  (set! paths '("-")))

(for ([path (in-list paths)])
  (define results
    (cond
      [(equal? path "-")
       (portmanteaus)]
      [else
       (with-input-from-file path portmanteaus)]))

  (define g (unweighted-graph/directed '()))

  (for ([result (in-list results)])
    (match-define (list left right portmanteau) result)
    (cond
      [(verbose-mode)
       (printf "~a + ~a = ~a\n" left right portmanteau)]
      [(graph-mode)
       (add-edge! g (~a "\"" left "\"") (~a "\"" right "\""))]
      [else
       (displayln portmanteau)]))

  (when (graph-mode)
    (displayln (graphviz g))))</code></pre>
<p>Now you can do some interesting things:</p>
<pre class="bash"><code>$ racket portmanteau.rkt animals.txt

brown recluse spider monkey
gila monstermite
grasshopperegrine falcon
hamstermite
leechidna
ottermite</code></pre>
<p>Just in case you cannot figure out what animals actually went into that list:</p>
<pre class="bash"><code>$ racket portmanteau.rkt --verbose animals.txt

brown recluse spider + spider monkey = brown recluse spider monkey
gila monster + termite = gila monstermite
grasshopper + peregrine falcon = grasshopperegrine falcon
hamster + termite = hamstermite
leech + echidna = leechidna
otter + termite = ottermite</code></pre>
<p>Or if you want to be a little more general, matching with only 2 characters rather than the default 3:</p>
<pre class="bash"><code>$ racket portmanteau.rkt --minimum-overlap 2 --verbose animals.txt

armadillo + loon = armadilloon
armadillo + lorikeet = armadillorikeet
armadillo + louse = armadillouse
black mamba + badger = black mambadger
brown bear + armadillo = brown bearmadillo
brown recluse spider + spider monkey = brown recluse spider monkey
chinchilaa + aardvark = chinchilaardvark
copperhead snake + kestrel = copperhead snakestrel
coyote + termite = coyotermite
crow + owl = crowl
eagle + leech = eagleech
eagle + leopard seal = eagleopard seal
echidna + narwhal = echidnarwhal
gecko + koala = geckoala
gila monster + termite = gila monstermite
grasshopper + peregrine falcon = grasshopperegrine falcon
hamster + termite = hamstermite
hyena + narwhal = hyenarwhal
jackal + albatross = jackalbatross
king cobra + rattlesnake = king cobrattlesnake
king cobra + raven = king cobraven
kingsnake + kestrel = kingsnakestrel
kiwi + wild boar = kiwild boar
leech + chinchilaa = leechinchilaa
leech + echidna = leechidna
leopard seal + albatross = leopard sealbatross
narwhal + albatross = narwhalbatross
ostrich + chinchilaa = ostrichinchilaa
otter + termite = ottermite
polar bear + armadillo = polar bearmadillo
rattlesnake + kestrel = rattlesnakestrel
sloth bear + armadillo = sloth bearmadillo
snapping turtle + leech = snapping turtleech
snapping turtle + leopard seal = snapping turtleopard seal
sparrow + owl = sparrowl
sperm whale + leech = sperm whaleech
sperm whale + leopard seal = sperm whaleopard seal
sponge + gecko = spongecko
swan + anaconda = swanaconda
wild boar + armadillo = wild boarmadillo</code></pre>
<p>Heh. Narwhalbatross. Wild boarmadillo. <img alt="smile" class="emoji" src="/emoji/smile.svg" /></p>
<p>And as a final bonus, using the <a href="https://github.com/stchang/graph/tree/master">graph</a> library I've used (and contributed to) before, we can render the structure of the thing):</p>
<pre class="bash"><code>$ racket portmanteau.rkt --graph --minimum-overlap 2 animals.txt \
    | sed "s/edge \[dir=none\];//g" \
    | fdp -Tpng &gt; animals.png \
    && open animals.png</code></pre>
<p><a href="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmaneaus/animals.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmaneaus/animals.png" /></a></p>
<p>Fun. :)</p>
<p>Think of the arrows as going from the stuck on word to where it's sticking rather than in the order the words would be written. It's easy enough to change though if you'd like, just swap the arguments in the <code>add-edge!</code> call above.</p>
<p>And... that's it. Not much more to do with this one, unless I want to duplicate the above video and portmanteau all the things! We'll see.</p>
<p>As with all my code, you can see the entire thing on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/portmanteau.rkt">portmanteau.rkt</a></p>]]></content></entry><entry><title>Performance problems with Flask and Docker</title><link href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker" /><id>urn:uuid:8d7d8e5b-effe-34a6-b190-d0068d5879a0</id><updated>2015-04-03T00:00:00Z</updated><summary type="html"><![CDATA[<p>I had an interesting problem recently on a project I was working on. It's a simple <a href="http://flask.pocoo.org/">Flask</a>-based webapp, designed to be deployed to <a href="https://aws.amazon.com/">AWS</a> using <a href="https://www.docker.com/">Docker</a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container...</p>
<p>Latency spikes. Bad enough that the application was failing AWS's healthy host checks, cycling in and out of existence<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>I had an interesting problem recently on a project I was working on. It's a simple <a href="http://flask.pocoo.org/">Flask</a>-based webapp, designed to be deployed to <a href="https://aws.amazon.com/">AWS</a> using <a href="https://www.docker.com/">Docker</a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container...</p>
<p>Latency spikes. Bad enough that the application was failing AWS's healthy host checks, cycling in and out of existence<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" /></a></p>
<!--more-->
<p>At that time, the only traffic to the container was the health checks, every 30 seconds, as regular as clockwork. So it wasn't load that was making them fail. And it was exactly the same code each time<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>:</p>
<pre class="python"><code>@app.route('/', methods = ['GET'])
def healthcheck():
    return "I'm a teapot"</code></pre>
<p>So not that either. So what in the world was going on?</p>
<p>Google to the rescue! <code><a href="https://www.google.com/search?q=flask application periodically slow">flask application periodically slow</a></code></p>
<p>The very first link is a response on StackOverflow:</p>
<blockquote>
    On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes “localhost” is configured to be available on both ipv4 and ipv6 socktes and some browsers will try to access ipv6 first and then ivp4. -- <a href="http://stackoverflow.com/questions/11150343/slow-requests-on-local-flask-server">Slow Requests on Local Flask Server</a>
</blockquote>
<p>Huh. Get a shell into my docker container, and what do you know:</p>
<pre class="bash"><code>$ cat /etc/hosts
172.17.1.112	27392a3e0fa5
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters</code></pre>
<p>Yup. <code>localhost</code> routes to both IPv4's <code>127.0.0.1</code> and IPv6's <code>::1</code>. Comment out the <code>::1</code> line and give it a shot... Yup. That did it. Waited ten minutes and the hosts weren't marked unhealthy once. All I should need to do is add it to the <code>Dockerfile</code> and we should be golden, yes?</p>
<pre class="text"><code>$ vi Dockerfile
...
RUN sed -i "s/::1.*//g"
...

$ docker build .
...
Step 9 : RUN sed -i "s/::1.*//g" /etc/hosts
 ---&gt; Running in 7c73dc473507
sed: cannot rename /etc/sedXZv0Yy: Device or resource busy</code></pre>
<p>What.</p>
<pre class="text"><code>$ vi Dockerfile
...
RUN sed "s/::1.*//g" /etc/hosts &gt; /etc/hosts-new && mv /etc/hosts-new /etc/hosts
...

$ docker build .
...
RUN sed "s/::1.*//g" /etc/hosts &gt; /etc/hosts-new && mv /etc/hosts-new /etc/hosts
 ---&gt; Running in d6b896f4fc9e
sed: cannot rename /etc/sedqYrfxO: Device or resource busy</code></pre>
<p>Double what.</p>
<p>Back to Google: <code><a href="https://www.google.com/search?q=docker edit hosts">docker edit hosts</a></code></p>
<p>Specifically: <a href="https://github.com/docker/docker/issues/1951">Unable to modify /etc/hosts file in a container #1951</a>. Looks like there was a fix that would let you edit <code>/etc/hosts</code> if you were in a container (that used to not be possible), but (because it's actually mounted rather than just a container file), it's non-trivial to edit it as part of a build.</p>
<p>All righty then.</p>
<p>That's about when I decided to listen to the Flask documentation:</p>
<blockquote>You can use the builtin server during development, but you should use a full deployment option for production applications. (Do not use the builtin development server in production.)</blockquote>
<p>All right. Not only is it what I'm actually supposed to be doing, but if I used CGI, I can avoid Flask trying to resolve <code>localhost</code> at all. I've worked with <a href="http://wiki.nginx.org/Main">nginx</a> before. Let's use that.</p>
<p>Picking some documentation from a hat, I decided to use <a href="https://uwsgi-docs.readthedocs.org/en/latest/">uWSGI</a> as the glue between nginx and Flask. Easy enough to install with pip (although I had to grab a C compiler from the apt package <code>build-essential</code>) and off we go.</p>
<p>First, a small <code>nginx</code> config:</p>
<pre class="nginx"><code>location / { try_files $uri @project; }
location @project {
    include uwsgi_params;
    uwsgi_pass unix:/tmp/uwsgi.sock;
}</code></pre>
<p>Then, to start it all up, a change to the <code>Dockerfile</code> <code>CMD</code>:</p>
<pre class="bash"><code>CMD uwsgi -s /tmp/uwsgi.sock -w project:app --chown-socket=www-data:www-data --enable-threads & \
    nginx -g 'daemon off;'</code></pre>
<p>That <code>--chown-socket</code> flag really drove me a bit batty. Basically, <code>uwsgi</code> was starting as the <code>root</code> user (within the Docker container). <code>nginx</code> was starting as <code>root</code>. But the <code>nginx</code> threads were not. They were starting as <code>www-data</code> and thus couldn't read the Unix socket between the two.</p>
<p>All righty then.</p>
<p>Let's go!</p>
<p>Starting successfully... And it's running. Not on the first try or even the 10th (I left out quite a bit of fumbling around tweaking flags), but eventually as was well in the world.</p>
<p>Push it out to AWS...</p>
<p>Health check passed.</p>
<p>Bam.</p>
<p>Awesome.</p>
<p>Now I not only have a neat little webapp, I have one that doesn't randomly decide to take forever on every other request or so.</p>
<p>If you're looking for the bare minimum <code>requirements.txt</code> and <code>Dockerfile</code> that I'm using (in addition to that <code>nginx</code> host configuration file above), here they are:</p>
<p><code>requirements.txt</code></p>
<pre class="text"><code>flask
flup6
uwsgi</code></pre>
<p><code>Dockerfile</code>:</p>
<pre class="text"><code>FROM ubuntu:14.04

RUN apt-get update && apt-get install -y build-essential nginx python3.4 python3.4-dev
RUN easy_install3 pip

WORKDIR /project

ADD requirements.txt /project/requirements.txt
RUN pip install -r requirements.txt

ADD . /project

ADD nginx /etc/nginx

CMD uwsgi -s /tmp/uwsgi.sock -w project:app --chown-socket=www-data:www-data --enable-threads & \
    nginx -g 'daemon off;'</code></pre>
<p>It's for moments like these that I do software. That little moment when everything comes together just right and it all just ... works.</p>]]></content></entry><entry><title>Parsing AWS instance data with jq</title><link href="http://blog.jverkamp.com/2015/04/01/parsing-aws-instance-data-with-jq" /><id>urn:uuid:db7917d7-1267-4fde-d9a4-c2d153f23979</id><updated>2015-04-01T00:00:00Z</updated><summary type="html"><![CDATA[<p>Semi-random amusing code snippet of the day:</p>
<pre class="bash"><code>aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF</code></pre>
]]></summary><content type="html"><![CDATA[<p>Semi-random amusing code snippet of the day:</p>
<pre class="bash"><code>aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF</code></pre>
<!--more-->
<p>Basically, it's combining the <a href="https://aws.amazon.com/cli/">AWS command line tools</a> and the excellent <a href="https://stedolan.github.io/jq/"><code>jq</code></a> tool for parsing JSON to extract a field from all instances with a particular tag on your AWS account (whatever account you have configured in your <code>~/.aws/</code> directory).</p>
<p>To describe it a little bit more, the data is structured as a list of <code>Instance</code> objects. The first line of the <code>jq</code> query loops over each instance object.</p>
<p>Next, each of those has zero or more <code>Tags</code> (the <code>[]?</code> is to not fail if the tag object is empty), with <code>Key</code> and <code>Value</code> entries. <code>select</code> is a new feature I hadn't seen before which will pass along an object if the condition holds. These are essentially equivalent:</p>
<pre class="text"><code> select(condition) </code></pre>
<pre class="text"><code> if condition then . else empty end </code></pre>
<p>After that, we extract a given field. In this particular case, I wanted IP addresses, but there are a bunch of other fields you can access. Here are a few other interesting ones:</p>
<ul>
    <li>AmiLaunchIndex</li>
    <li>Architecture</li>
    <li>ImageId</li>
    <li>InstanceId</li>
    <li>InstanceType</li>
    <li>LaunchTime</li>
    <li>PrivateDnsName</li>
    <li>PrivateIpAddress</li>
    <li>PublicDnsName</li>
    <li>PublicIpAddress</li>
    <li>SecurityGroups</li>
    <li>State</li>
    <li>SubnetId</li>
    <li>Tags</li>
</ul>
<p>The beauty of doing this directly in the shell is that you can then chain it to something else. For example, what if I wanted to log into every production server in turn and ask how much free disk space they have:</p>
<pre class="bash"><code>for IP in aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF
do
    echo $IP
    ssh $IP du -h
    echo
done</code></pre>
<p>I'm really starting to admire the 'Do One Thing and Do It Well' philosophy of Unix and chaining things together.</p>]]></content></entry><entry><title>gif shrinkage with ImageMagick</title><link href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick" /><id>urn:uuid:ca361209-13d0-9725-3b15-9d0d7f368a98</id><updated>2015-03-05T00:00:00Z</updated><summary type="html"><![CDATA[<p>I have a gif collection now. :)</p>
<p><a href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>I have a gif collection now. :)</p>
<p><a href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" /></a></p>
<!--more-->
<p>One problem with gifs is that they tend to be somewhat sizable. To keep that at least a little under control, I've added a quick script to my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> to trim all files passed on the command line to a maximum edge size of 256 pixels:</p>
<pre class="bash"><code>#!/bin/bash

tmpdir=&lt;code&gt;mktemp -d /tmp/shrink-gifs.XXXX&lt;/code&gt;
echo "$tmpdir"

for file in "$@"
do
  echo "$file"
  convert "$file" -alpha on -channel rgba -coalesce -resize 256x256 -layers OptimizeFrame -colors 64 "$tmpdir/$file"
  mv "$tmpdir/$file" "$file"
done</code></pre>
<p>Basically, I'm using the excellent <a href="http://www.imagemagick.org/">ImageMagick</a> software, specifically the <code>convert</code> utility. All of those flags are necessary since gifs have layers. This results in both a properly converted gif but also a somewhat optimized palette.</p>
<p>Also, we're using a temporary directory rather than using the in place version of <code>convert</code>: <code>mogrify</code>. For whatever reason, <code>mogrify</code> doesn't seem to work on gifs. So it goes.</p>
<p>As a side note, <code>identify</code> (another tool that comes with ImageMagick) is really useful. Give it an image and it will tell you how large it is, all on the command line.</p>
<p>This script (and all of my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a>) is available on GitHub: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/shrink-gifs">shrink-gifs</a></p>]]></content></entry><entry><title>ts: Timestamping stdout</title><link href="http://blog.jverkamp.com/2015/02/26/ts-timestamping-stdout" /><id>urn:uuid:43f98a4d-4ef7-1979-023a-32bf8724a10d</id><updated>2015-02-26T00:00:00Z</updated><summary type="html"><![CDATA[<p>Loving data as much as I do, I like to <a href="http://blog.jverkamp.com/category/programming/by-topic/optimization">optimize</a> things. To make sure I'm actually going the right way, it's useful to time things. While it's trivial in most languages to add timing, it's even easier if you don't have to.</p>
]]></summary><content type="html"><![CDATA[<p>Loving data as much as I do, I like to <a href="http://blog.jverkamp.com/category/programming/by-topic/optimization">optimize</a> things. To make sure I'm actually going the right way, it's useful to time things. While it's trivial in most languages to add timing, it's even easier if you don't have to.</p>
<!--more-->
<p>To that end, here is <code>ts</code>, a tool for adding timestamps to each line of <code>stdin</code>:</p>
<pre class="python"><code>#!/usr/bin/env python3

import sys
import time

def stamp(line):
    now = time.strftime("[%Y-%m-%d %H:%M:%S]", time.localtime())
    sys.stdout.write('{0} {1}\n'.format(now, line.strip('\n')))
    sys.stdout.flush()

stamp('--- &lt;ts&gt; ---')

for line in sys.stdin:
    stamp(line)

stamp('--- &lt;/ts&gt; ---')</code></pre>
<p>For example:</p>
<pre class="bash"><code>$ python long-running-script.py | ts

[2015-02-25 17:05:35] --- &lt;ts&gt; ---
[2015-02-25 17:05:35] things
[2015-02-25 17:05:43] stuff
[2015-02-25 17:05:53] all done
[2015-02-25 17:05:53] --- &lt;/ts&gt; ---</code></pre>
<p>Whee!</p>
<p>If you'd like to download this or any of my other <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a>, you can do so on on GitHub: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/ts">ts</a>.</p>]]></content></entry><entry><title>update-dotfiles encryption</title><link href="http://blog.jverkamp.com/2015/02/11/update-dotfiles-encryption" /><id>urn:uuid:da93efa1-4aa3-e880-6082-ac2b0647ffa5</id><updated>2015-02-11T00:00:00Z</updated><summary type="html"><![CDATA[<p>I do like having my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> on GitHub. For one, it means that they're always available when I set up a new machine. For two, others can see them and take whatever is interesting for their own dotfiles. But all that has a disadvantage: what if I want to store my SSH configs?</p>
]]></summary><content type="html"><![CDATA[<p>I do like having my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> on GitHub. For one, it means that they're always available when I set up a new machine. For two, others can see them and take whatever is interesting for their own dotfiles. But all that has a disadvantage: what if I want to store my SSH configs?</p>
<!--more-->
<p>Technically, they're not secret. I don't have my actual SSH keys in there. But I do have some names of machines and at least not having those on the GitHub means that the spiders trolling the repos have at least one more step before finding them. Especially those running on non-standard ports.</p>
<p>To that end, here's a quick script to AES encrypt / decrypt files with Python.</p>
<p>First, we want something that can turn any password into an AES key. Since they have to be an exact number of bits a hashing function works particularly well here:</p>
<pre class="python"><code>def get_key():
    if 'AESKEY' in os.environ:
        key = os.environ['AESKEY']
    else:
        key = getpass.getpass('AES passphrase: ')

    return hashlib.sha256(key.encode('utf-8')).digest()</code></pre>
<p>(Yes, I should be using a <a href="https://en.wikipedia.org/wiki/Password-Based_Key Derivation Function">Password-Based Key Derivation Function</a>. So it goes.)</p>
<p>Next, the encryption function. We need to set up a random <a href="https://en.wikipedia.org/wiki/initialization_vector">initialization vector</a>.</p>
<p>Then, since the file might not be evenly divisible into blocks, we'll need to pad it. Since we want this to be able to deal with binary or other files, there's no guarantee that we can tell when a file has ended. So we'll use the <code>struct</code> library to store the file length as well. Given that we're storing the size as a 64-bit integer, we'll be able to store files up to 18.56 exabytes. Yeah, I think we'll be fine for a while.</p>
<p>Finally, we want to add a hash so we can verify that the file was not tampered with via <a href="https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac">encrypt-then-MAC</a>. All together:</p>
<pre class="python"><code>def encrypt(file):

    key = get_key()

    iv = os.urandom(16)
    encryptor = AES.new(key, AES.MODE_CBC, IV = iv)

    with open(file, 'rb') as fin:
        content = fin.read()

    # Store the original file size as uint64 and pad to 16 bytes
    content = struct.pack('&gt;Q', len(content)) + content
    content = content + (b'\0' * (16 - len(content) % 16))

    content = encryptor.encrypt(content)
    hash = hashlib.sha256(content).digest()

    content = base64.b64encode(iv + hash + content)

    outfile = file + '.aes'
    with open(outfile, 'wb') as fout:
        fout.write(content)</code></pre>
<p>Straight forward.</p>
<p>Likewise, decryption pulls apart the parts of the file, checks the integrity with the hash, then decrypts:</p>
<pre class="python"><code>def decrypt(file):

    key = get_key()

    with open(file, 'r') as fin:
        content = fin.read()

    content = base64.b64decode(content)
    if len(content) &lt; 32:
        print('Malformed content: not enough data')
        sys.exit(1)

    iv = content[:16]
    hash = content[16:48]
    content = content[48:]

    if hash != hashlib.sha256(content).digest():
        print('Failed hash check')
        sys.exit(1)

    decryptor = AES.new(key, AES.MODE_CBC, IV = iv)
    content = decryptor.decrypt(content)

    fileSize = struct.unpack('&gt;Q', content[:8])[0]
    content = content[8:fileSize+8]

    outfile = file[:-4]
    with open(outfile, 'wb') as fout:
        fout.write(content)</code></pre>
<p>Shiny. Now let's tweak the script that updates dotfiles to handle encrypted files:</p>
<p>Basically, the only code that changes is if the user choose <code>y</code> to replace a file. If that file ends with <code>.aes</code>, ask for the password and try to decrypt it.</p>
<pre class="python"><code>...

# If the file is encrypted, decrypt it
if path.endswith('.aes'):
    try:
        if not aes:
            aes = imp.load_source('aes', os.path.expanduser('~/.bin/aes'))

        if aes:
            print('{0} decrypting'.format(path))
            aes.decrypt(path)
            shutil.copymode(path, path[:-4])
            path = path[:-4]
    except:
        print('{0} cannot decrypt, aes does not exist'.format(path))

...</code></pre>
<p>One caveat is that since the <code>aes</code> library is stored without the <code>py</code> suffix, we load it dynamically with the <code>imp</code> module. I love how that's possible (even easy) in Python.</p>
<p>And that's about it. I've moved my SSH configs over and vastly expended them with a number of servers that I work with on a daily basis. Also there's another level which allows for different environments (work or home) and operating systems (to deal with different keyboard standards).</p>
<p>Very cool.</p>
<p>If you'd like to see the full source for either piece, you can on GitHub:</p>
<ul>
    <li><a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/aes">aes</a></li>
    <li><a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/update-dotfiles">update-dotfiles</a></li>
</ul>]]></content></entry><entry><title>docker-bash and docker-stop-all</title><link href="http://blog.jverkamp.com/2015/02/04/docker-bash-and-docker-stop-all" /><id>urn:uuid:37898d58-3ad2-b30c-7f9e-5b00c18e6e8a</id><updated>2015-02-04T00:00:00Z</updated><summary type="html"><![CDATA[<p>I've been using <a href="https://www.docker.com/">Docker</a> a fair bit at work, so I've added a few quick aliases to my dotfiles make that a little bit easier:</p>
<ul>
    <li><code>docker-bash</code> - attach a <code>bash</code> shell to the first available docker instance</li>
    <li><code>docker-stop-all</code> - stop all running docker instances</li>
</ul>
]]></summary><content type="html"><![CDATA[<p>I've been using <a href="https://www.docker.com/">Docker</a> a fair bit at work, so I've added a few quick aliases to my dotfiles make that a little bit easier:</p>
<ul>
    <li><code>docker-bash</code> - attach a <code>bash</code> shell to the first available docker instance</li>
    <li><code>docker-stop-all</code> - stop all running docker instances</li>
</ul>
<!--more-->
<p>The implementation for both is pretty straight forward:</p>
<p><code>docker-bash</code>:</p>
<pre class="bash"><code> docker exec -it &#96;docker ps -q | head -n 1&#96; bash </code></pre>
<p><code>docker-stop-all</code>:</p>
<pre class="bash"><code>  docker ps -q | xargs docker stop </code></pre>
<p>Neither is <em>that</em> complicated to remember, but I type both often enough throughout the day that it's nice to save that dozen or so characters.</p>]]></content></entry><entry><title>iOS Backups in Racket: Apps</title><link href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps" /><id>urn:uuid:761445ba-06be-d1cd-b496-1e52081d2f71</id><updated>2015-01-29T00:00:00Z</updated><summary type="html"><![CDATA[<p>So far we've read <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">backup files</a>, parsed <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>, and parsed <a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">messages</a>. Today we're going to dig a little deeper and start parsing apps specifically.</p>
]]></summary><content type="html"><![CDATA[<p>So far we've read <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">backup files</a>, parsed <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>, and parsed <a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">messages</a>. Today we're going to dig a little deeper and start parsing apps specifically.</p>
<!--more-->
<p>First things first, let's get a list of applications. That's actually in two different files: <code>Manifest.plist</code> and <code>Manifest.mbdb</code>. In versions of iTunes prior to 9.2, <code>Manifest.plist</code> had a nice listing of files, but now it only contains the list of applications. Still, that's a good enough place to start.</p>
<p>Remember back in the <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">first post</a>? We learned how how to read plist files. In this one in particular, we have a list of installed applications, using their internal names:</p>
<pre class="racket"><code>(struct app (name plist files) #:prefab #:mutable)
(struct file (name path) #:prefab)

; List all installed applications
(define (list-apps)
  (hash-ref!
   apps-by-backup
   (current-backup)
   (λ ()
     (for/list ([name (in-list
                       (hash-ref
                        (call-with-input-file
                          (build-path (backup-path (current-backup))
                                                   "Info.plist")
                          read-plist/jsexpr)
                        '|Installed Applications|))])
       (app name #f #f)))))</code></pre>
<p>For the moment, we'll leave out the plist and files. Eventually, plist is going to store a list of properties stored with the application (all apps have it, even if some don't store anything interesting). Files will store any files stored in the local filesystem for app in specific.</p>
<p>So how does it work?</p>
<pre class="racket"><code>&gt; (with-backup "86b1...aa36"
    (map app-name (list-apps)))
'("com.google.Maps"
  "com.apple.mobilesms.notification"
  "com.roku.ios.roku"
  ...
  "com.apple.iBooks"
  "com.apple.MobileSMS"
  "com.apple.CoreAuthUI")</code></pre>
<p>Neat. That's pretty much exactly what I was hoping to see.</p>
<p>Next, let's load up the plists. On doing some digging around, it looks like every app will have a file with a path something like <code>AppDomain-Library/Preferences/{app-name}.plist</code>, so let's try to load that:</p>
<pre class="racket"><code>; Load an app's plist file
(define (load-plist! app)
  (set-app-plist!
   app
   (let ([plist-path
          (build-path
           (backup-path (current-backup))
           (hash-filename
            (~a "Library/Preferences/" (app-name app) ".plist")
            (~a "AppDomain-" (app-name app))))])

     ; Try to load in text mode first, if that fails fall back to binary
     (with-handlers ([exn? (λ (exn)
                             (call-with-input-file plist-path
                               read-plist/jsexpr/binary))])
       (call-with-input-file plist-path read-plist/jsexpr)))))</code></pre>
<p>Here we run into our first wrinkle. It turns out that while the <code><a href="http://docs.racket-lang.org/search/index.html?q=xml/plist">xml/plist</a></code> file works just fine on the text format plist files, it doesn't deal well with binary ones. And unfortunately most (if not all) apps use the binary format. So we need something that will be able to convert and load those (warning, this is ugly):</p>
<pre class="racket"><code>; Read a plist file as a JSON expression from a binary plist file
(define (read-plist/jsexpr/binary [in (current-input-port)])
  ; Copy the file to a temporary path
  (define temp-filename (~a (gensym) ".plist"))
  (call-with-output-file temp-filename
    (λ (out) (copy-port in out)))

  ; Run Apple's plutil to convert it
  ; Redirect err to suppress from missing programs
  (parameterize ([current-error-port (open-output-nowhere)])
    (for* ([path
            (in-list
              '("plutil"
                "plutil.exe"
                "\"C:\\Program Files (x86)\\Common Files\\Apple\\Apple Application Support\\plutil.exe\""
                ""\"C:\\Program Files\\Common Files\\Apple\\Apple Application Support\\plutil.exe\""))]
           [return (in-value (system (~a path " -convert xml1 " temp-filename)))]
           #:break return)
      #t))

  ; Patch over xml/plist's handling of empty string element
  (define plist-fixed-content
    (regexp-replace* #px"&lt;string&gt;&lt;/string&gt;"
                     (file-&gt;string temp-filename)
                     "&lt;string&gt; &lt;/string&gt;"))
  (delete-file temp-filename)

  ; Read the plist into memory and remove the temporary file
  (call-with-input-string plist-fixed-content read-plist/jsexpr))</code></pre>
<p>Basically, if you have iTunes installed, it comes with a program (on Windows, it's built in on OSX) called <code>plutil</code>. That can be used to convert between binary, xml, and json formats of plist files. Unfortunately though, the json format cannont handle a lot of plists, so we have to convert to xml and then use our previous <code>plist->jsexpr</code> function to convert it.</p>
<p>Other hacks: we have to copy it to a temporary file. It's probably possible to open <code>plutil</code> and pass the file on stdin and read from stdout instead, but this works so we'll leave it as is for the moment.</p>
<p>Finally, another caveat of the <code><a href="http://docs.racket-lang.org/search/index.html?q=xml/plist">xml/plist</a></code> library: it breaks on empty string elements. So there's a fix above to take any empty string elements and insert a single space into them. Hacky, but so it goes. When all this is said and done though, we can use this to read in the plist data for an application:</p>
<pre class="racket"><code>&gt; (with-backup "86b18eea28a991f4dd569d1f59737a842e24aa36"
    (let ([app (list-ref (list-apps) 12)])
      (load-plist! app)
      app))

'#s((app #(0 1 2))
    "com.google.Maps"
    #hash((WebKitCacheModelPreferenceKey . 1)
          (WebKitDiskImageCacheSavedCacheDirectory . " ")
          (WebKitMediaPlaybackAllowsInline . #t)
          (WebKitOfflineWebApplicationCacheEnabled . #t)
          (WebKitShrinksStandaloneImagesToFit . #t)
          ...
          (kGIPMicPermissionControllerPermissionRequested . #t)
          (kGMSMapsUserClientLegalCountry . "US")
          (kGMSUserEvent3LoggerSequenceIDKey . 8860))
    #f)</code></pre>
<p>Whee! For any particular app, I'm not entirely sure what I'm looking for, but there's a whole heck of a lot of information there.</p>
<p>But one thing that I was hoping to find is still missing: a list of files for a given application. I was hoping each application would know that, but apparently not. Then again, why would they? A given application probably knows exactly what files it's looking for, it doesn't have to list them.</p>
<p>Fine. I guess I have to read that <code>Manifest.mbdb</code> file.</p>
<pre class="bash"><code>$ xxd "Manifest.mbdb"

0000000: 6d62 6462 0500 001d 4170 7044 6f6d 6169  mbdb....AppDomai
0000010: 6e2d 636f 6d2e 6f6f 6b6c 612e 7370 6565  n-com.ookla.spee
0000020: 6474 6573 7400 00ff ffff ffff ff41 ed00  dtest........A..
0000030: 0000 0000 005f bc00 0001 f500 0001 f554  ....._.........T
0000040: 3044 1354 3044 1354 2757 c900 0000 0000  0D.T0D.T'W......
0000050: 0000 0000 0000 1d41 7070 446f 6d61 696e  .......AppDomain
0000060: 2d63 6f6d 2e6f 6f6b 6c61 2e73 7065 6564  -com.ookla.speed
0000070: 7465 7374 0007 4c69 6272 6172 79ff ffff  test..Library...
0000080: ffff ff41 ed00 0000 0000 0013 b600 0001  ...A............
0000090: f500 0001 f554 2757 c954 2758 1f54 1b09  .....T'W.T'X.T..
00000a0: df00 0000 0000 0000 0000 0000 1d41 7070  .............App
00000b0: 446f 6d61 696e 2d63 6f6d 2e6f 6f6b 6c61  Domain-com.ookla
...</code></pre>
<p>Right. That's some sort of binary file. I can see the app names repeated several times for each app, but we're still going to have to figure out the format.</p>
<p>Luckily for me, the format has already been relatively well reverse engineered<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. First, we have a file header, the bytes <code>mbdb\5\0</code>. The last two are probably versioning, but so far as I can tell, it hasn't changed. So we'll skip over that for the moment.</p>
<p>Next, we have a sequence of records:</p>
<table class="table">
    <thead>
        <tr><td>Type</td><td>Name</td><td>Note</td></tr>
    </thead>
    <tbody>
        <tr><td>string</td><td>domain</td><td>Used for <code>hash-filename</code></td></tr>
        <tr><td>string</td><td>path</td><td></td></tr>
        <tr><td>string</td><td>target</td><td>Absolute path, only for <a href="https://en.wikipedia.org/wiki/symlinks">symlinks</a></td></tr>
        <tr><td>string</td><td>data hash</td><td>SHA1 (for encrypted files)</td></tr>
        <tr><td>string</td><td>encryption key </td><td></td></tr>
        <tr><td>uint16</td><td>mode</td><td>file/directory/symlink (see below)</td></tr>
        <tr><td>uint64</td><td><a href="https://en.wikipedia.org/wiki/inode">inode</a></td><td></td></tr>
        <tr><td>uint32</td><td>user id</td><td></td></tr>
        <tr><td>uint32</td><td>group id</td><td></td></tr>
        <tr><td>uint32</td><td>last modified</td><td></td></tr>
        <tr><td>uint32</td><td>last accessed</td><td></td></tr>
        <tr><td>uint32</td><td>created at</td><td></td></tr>
        <tr><td>uint64</td><td>file size</td><td>0 for symlinks and directories</td></tr>
        <tr><td>uint8</td><td>data protection class</td><td>0 if special (link, directory), otherwise ranges from 1-11</td></tr>
        <tr><td>uint8</td><td>property count</td><td>number of properties following</td></tr>
    </tbody>
</table>
<p>This is then followed by a list of properties:</p>
<table class="table">
    <thead>
        <tr><td>Type</td><td>Name</td><td>Note</td></tr>
    </thead>
    <tbody>
        <tr><td>string</td><td>name</td><td></td></tr>
        <tr><td>string</td><td>value</td><td>either UTF8 or binary data</td></tr>
    </tbody>
</table>
<p>That sounds pretty straight forward (relatively speaking). Let's write a function to read it. We want to fill out this structure:</p>
<pre class="racket"><code>(struct record (domain path hash mode size properties) #:prefab)
(struct property (name value) #:prefab)</code></pre>
<p>In general LISP style (so far as I understand it), we will write a series of functions named <code>read-*</code>, each of which will read the specified form of data from the current input port. Then, for example, we can have a <code>read-mbdb</code> function, which calls <code>read-record</code>, which in turn has a bunch of calls to either <code>read-uint</code> or <code>read-string</code> followed by zero or more calls to <code>read-property</code>.</p>
<p>Starting at the outermost layer, lets read an entire file. Specifically, we want a function that will read off those 6 header bytes then continuously read records until the end of the file:</p>
<pre class="racket"><code>; Read mdbd records until eof
(define (read-mbdb [in (current-input-port)])
  (read-bytes 6 in)
  (let loop ()
    (cond
      [(eof-object? (peek-char in)) '()]
      [else
       (cons (read-record in) (loop))])))</code></pre>
<p>Having that, we need the ability to read an individual record:</p>
<pre class="racket"><code>; Read an mbdb record
(define (read-record [in (current-input-port)])

  (define domain (read-string-data in))
  (define path (read-string-data in))
  (define link-target (read-string-data in))
  (define data-hash (read-string-data in))
  (define encryption-key (read-string-data in))

  (define raw-mode (read-uint 2 in))
  (define mode
    (case (arithmetic-shift raw-mode -12)
      [(#xA) (list 'symlink link-target)]
      [(#x8) 'file]
      [(#x4) 'directory]))

  (define inode (read-uint 8 in))
  (define user-id (read-uint 4 in))
  (define group-id (read-uint 4 in))

  (define last-modified (read-uint 4 in))
  (define last-accessed (read-uint 4 in))
  (define created-at (read-uint 4 in))
  (define file-size (read-uint 8 in))

  (define data-protection-class (read-uint 1 in)) ; 0x1 to 0xB
  (define property-count (read-uint 1 in))

  (define properties
    (for/list ([i (in-range property-count)])
      (define name (read-string-data in))
      (define value (read-string-data in))
      (property name value)))

  (define hash (hash-filename path domain))

  (record domain path hash mode file-size properties))</code></pre>
<p>Other than the missing functions, one caveat here is the definition of <code>mode</code>. I'm not actually sure what's in the other three half bytes, but all we care about is in the first. If it's <code>A</code>, it's a symlink. <code>8</code> is a file; <code>4</code> is a directory. That handles every entry at least on my phone.</p>
<p>Also, you may note that we're not returning all of the data in the records. Honestly, for most of it I just don't need it. It's useful if you're trying to do more interesting things and then write back to the backup, but just to read it? We don't care about user/group ids, et al. It's all there though, with just a tweak. Perhaps I'll figure out a way to pull out the full record if wanted in the future.</p>
<p>Okay, so next, what does it mean to <code>read-uint</code>? Well, we're going to have anywhere from 1 to 8 bytes, which we then need to turn into a single value. That's easy enough doing a base conversion (from essentially base 256 to base 10):</p>
<pre class="racket"><code>; Read size bytes as a big-endian unsigned integer
(define (read-uint size [in (current-input-port)])
  (define b* (read-bytes size in))
  (for/sum ([i (in-naturals)]
            [b (in-bytes b*)])
    (* (expt 256 (- (bytes-length b*) i 1)) b)))</code></pre>
<p>Cool. That means that all that's left is reading strings. Luckily, they have a nice format. Rather than <a href="https://en.wikipedia.org/wiki/null_terminated strings">null terminated strings</a> a la C/C++, they store first the length of the string (as a <code>uint16</code>) and then that many bytes. There are two caveats though:</p>
<ul>
    <li>If the size is maxed (<code>#xFFFF</code>), it's actually empty</li>
    <li>This same datatype can be either a UTF8 string or raw binary data (try to parse it as a string, fall back to bytes)</li>
</ul>
<p>Codewise:</p>
<pre class="racket"><code>; Read a length + string, if length if #xFFFF the string is empty
; Note: Sometimes 'strings' are actually binary data, return those as bytes
(define (read-string-data [in (current-input-port)])
  (define size (read-uint 2 in))
  (cond
    [(equal? size #xFFFF) ""]
    [else
     (define raw (read-bytes size in))
     (with-handlers ([exn? (λ (_) raw)])
       (bytes-&gt;string/utf-8 raw))]))</code></pre>
<p>Cool.</p>
<pre class="racket"><code>&gt; (with-backup "86b1...aa36"
    (call-with-input-file (build-path (backup-path (current-backup))
                                      "Manifest.mbdb")
      read-mbdb))
'(#s(record "AppDomain-com.ookla.speedtest" "" #f directory 0 ())
  #s(record "AppDomain-com.ookla.speedtest" "Library" "83fee2b4383a3d59c99185862e220d5a0a77d546" directory 0 ())
  #s(record "AppDomain-com.ookla.speedtest" "Library/Preferences" "726b41739d2c95794288f354134f75515db58dbd" directory 0 ())
  #s(record
     "AppDomain-com.ookla.speedtest"
     "Library/Preferences/com.ookla.speedtest.plist"
     "dc4081fac8bf5bdf6ed025d3da24e6b8a287c4fb"
     file
     620
     ())
  #s(record
     "AppDomain-com.ookla.speedtest"
     "Library/Preferences/com.apple.PeoplePicker.plist"
     "f9e644265dbcc0a7179c631e0ba3173868663b04"
     (symlink "/private/var/mobile/Library/Preferences/com.apple.PeoplePicker.plist")
     0
     ())
  ...)</code></pre>
<p>It's kind of neat how cleanly binary formats can actually be read at least if they're relatively well documented.</p>
<p>Let's go ahead and add this to the <code>app</code> structure and then write a helper as we have before to find a specific app:</p>
<pre class="racket"><code>; Load the list of files associated with an app
(define (load-files! app)
  (define app-domain (~a "AppDomain-" (app-name app)))

  (set-app-files!
   app
   (for/list ([record (in-list (list-mdbd-records))]
              #:when (and (equal? (record-domain record) app-domain)
                          (eq? 'file (record-mode record))))
     (file (record-path record)
           (build-path (backup-path (current-backup)) (record-hash record))))))

; Find an app by name (actually a case insensative regex)
; plists and files in domain are loaded when this is called and cached
(define (find-app name)
  (define app
    (for/first ([app (in-list (list-apps))]
                #:when (regexp-match (~a "(?i:" name ")") (app-name app)))
      app))

  ; If this app is missing it's plist / files, load them
  (when (and app (not (app-plist app))) (load-plist! app))
  (when (and app (not (app-files app))) (load-files! app))

  app)</code></pre>
<p>Yes, this does has the disadvantage that if you just <code>list-apps</code>, you won't get the plists and file lists. On the flip side though, this one uses a regex, so you can just search by app name. Most developers (although not all I've found) will include that as part of their internal name. They take a bit to load though, especially if you have a lot of apps, so I think that's a fair enough trade off. It's still caching <code>Manifest.mbdb</code> though, so at least that only has to be read once:</p>
<pre class="racket"><code>(define mdbd-records-by-backup (make-hash))
(hash-set! mdbd-records-by-backup #f '())

; Get all MDBD records
(define (list-mdbd-records)
  (hash-ref!
   mdbd-records-by-backup
   (current-backup)
   (λ ()
     (call-with-input-file (build-path (backup-path (current-backup))
                                       "Manifest.mbdb")
       read-mbdb))))</code></pre>
<p>Once you start digging through these lists, there are some pretty interesting files ... but that will have to wait for another post. This one is already pretty long. I think I'll have at least one more post in this series taking everything I've done thus far and turning it into an actual backup solution. Keep an eye out!</p>
<p>The full source thus far (and I've finally caught up) is on GitHub: <a href="https://github.com/jpverkamp/ios-backup">ios-backup</a>.</p>
<p>If you've installed <code>ios-backup</code> as a library, you can import these new functions with <code>(require ios-backup/apps)</code> or if you really want to get adventerous <code>(require ios-backup/mbdb)</code>.</p>
<p>Here is a list of all of the posts in this series:</p>
<ul class="list-unstyled"><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">iOS Backups in Racket: Groundwork</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">iOS Backups in Racket: Contacts</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">iOS Backups in Racket: Messages</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps">iOS Backups in Racket: Apps</a></li></ul>]]></content></entry><entry><title>iOS Backups in Racket: Messages</title><link href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages" /><id>urn:uuid:5a638d35-714a-ea03-68c1-9a6ac3d30dcd</id><updated>2015-01-27T00:00:00Z</updated><summary type="html"><![CDATA[<p>So far we've <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">laid the groundwork</a>, loading local iOS backups and parsed out <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>. Today let's take another step down the rabbit hole and figure out how messages are stored.</p>
]]></summary><content type="html"><![CDATA[<p>So far we've <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">laid the groundwork</a>, loading local iOS backups and parsed out <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>. Today let's take another step down the rabbit hole and figure out how messages are stored.</p>
<!--more-->
<p>Okay, first things first, we need to find the database(s) that messages are stored in. Using the <a href="https://theiphonewiki.com/wiki/ITunes_Backup#Files">same source</a> as last time, we have:</p>
<pre class="racket"><code>&gt; (hash-filename "Library/SMS/sms.db" "HomeDomain")
"3d0d7e5fb2ce288813306e4d4636395e047a3d28"</code></pre>
<p>Interesting. What's in there?</p>
<pre class="sql"><code>sqlite&gt; .tables
_SqliteDatabaseProperties  chat_message_join
attachment                 handle
chat                       message
chat_handle_join           message_attachment_join</code></pre>
<p>Dang. That's rather less than there was when dealing with contacts. From a first guess, I would say that <code>message</code> contains the text itself, <code>chat</code> is a group of messages with the same people, and <code>*_join</code> are tables that related those. <code>handle</code> could perhaps be a way of relating who is in a chat to the information in contacts from last week. Let's see how I did:</p>
<pre class="sql"><code>CREATE TABLE message (ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
    guid TEXT UNIQUE NOT NULL,
    text TEXT,
    replace INTEGER DEFAULT 0,
    service_center TEXT,
    handle_id INTEGER DEFAULT 0,
    subject TEXT,
    country TEXT,
    attributedBody BLOB,
    version INTEGER DEFAULT 0,
    type INTEGER DEFAULT 0,
    service TEXT,
    account TEXT,
    account_guid TEXT,
    error INTEGER DEFAULT 0,
    date INTEGER,
    date_read INTEGER,
    date_delivered INTEGER,
    is_delivered INTEGER DEFAULT 0,
    is_finished INTEGER DEFAULT 0,
    is_emote INTEGER DEFAULT 0,
    is_from_me INTEGER DEFAULT 0,
    is_empty INTEGER DEFAULT 0,
    is_delayed INTEGER DEFAULT 0,
    is_auto_reply INTEGER DEFAULT 0,
    is_prepared INTEGER DEFAULT 0,
    is_read INTEGER DEFAULT 0,
    is_system_message INTEGER DEFAULT 0,
    is_sent INTEGER DEFAULT 0,
    has_dd_results INTEGER DEFAULT 0,
    is_service_message INTEGER DEFAULT 0,
    is_forward INTEGER DEFAULT 0,
    was_downgraded INTEGER DEFAULT 0,
    is_archive INTEGER DEFAULT 0,
    cache_has_attachments INTEGER DEFAULT 0,
    cache_roomnames TEXT,
    was_data_detected INTEGER DEFAULT 0,
    was_deduplicated INTEGER DEFAULT 0,
    is_audio_message INTEGER DEFAULT 0,
    is_played INTEGER DEFAULT 0,
    date_played INTEGER,
    item_type INTEGER DEFAULT 0,
    other_handle INTEGER DEFAULT -1,
    group_title TEXT,
    group_action_type INTEGER DEFAULT 0,
    share_status INTEGER,
    share_direction INTEGER,
    is_expirable INTEGER DEFAULT 0,
    expire_state INTEGER DEFAULT 0,
    message_action_type INTEGER DEFAULT 0,
    message_source INTEGER DEFAULT 0
 );</code></pre>
<p>Oof. Okay, that's more like what I was expecting. In particular though, it looks like we don't care about most of those fields. In particular, I think the interesting fields will be <code>guid</code>, <code>text</code>, <code>handle_id</code> (it looks like we will need the <code>handle</code> table), <code>date</code>, and <code>is_from_me</code>.</p>
<p>Next, <code>chat</code>:</p>
<pre class="sql"><code>sqlite&gt; .schema chat
CREATE TABLE chat (ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
    guid TEXT UNIQUE NOT NULL,
    style INTEGER,
    state INTEGER,
    account_id TEXT,
    properties BLOB,
    chat_identifier TEXT,
    service_name TEXT,
    room_name TEXT,
    account_login TEXT,
    is_archived INTEGER DEFAULT 0,
    last_addressed_handle TEXT,
    display_name TEXT,
    group_id TEXT
);</code></pre>
<p>Hmm. It turns out that we don't actually need anything there. All that we need to know about chats is which ID we need, which because it's a join table, that will be in <code>chat_message_join</code>:</p>
<pre class="sql"><code>sqlite&gt; .schema chat_message_join
CREATE TABLE chat_message_join (
    chat_id INTEGER REFERENCES chat (ROWID) ON DELETE CASCADE,
    message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE,
    PRIMARY KEY (chat_id, message_id)
);</code></pre>
<p>So if we have a chat ID, we can get all of that information:</p>
<pre class="sql"><code>SELECT
  message.ROWID as message_id,
  message.date,
  message.service,
  message.is_from_me,
  (CASE WHEN message.subject IS NULL THEN '' ELSE message.subject END),
  (CASE WHEN message.text IS NULL THEN '' ELSE message.text END)
FROM
  chat_message_join,
  message
WHERE
  chat_id = ?
  AND message_id = message.ROWID
ORDER BY date ASC</code></pre>
<p>The conversion from <code>NULL</code> to an empty string is mostly for later. I know that I'll want to serialize these, most likely to JSON and I don't particularly care about the difference between a <code>NULL</code> entry and an empty string.</p>
<p>That's a good start. We still need to know who they're from though.</p>
<pre class="sql"><code>sqlite&gt; .schema handle
CREATE TABLE handle (
    ROWID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
    id TEXT NOT NULL,
    country TEXT,
    service TEXT NOT NULL,
    uncanonicalized_id TEXT,
    UNIQUE (id,
    service)
);</code></pre>
<p>Looking at some of the values, it seems that <code>id</code> is either an email or a phone number, while service is either SMS or iMessage (at least in my case). Country might be interesting later, but we'll ignore it for the moment.</p>
<p>So let's expand the query to include that information:</p>
<pre class="sql"><code>SELECT
  message.ROWID as message_id,
  message.date,
  message.service,
  message.is_from_me,
  handle.id as them,
  (CASE WHEN message.subject IS NULL THEN '' ELSE message.subject END),
  (CASE WHEN message.text IS NULL THEN '' ELSE message.text END)
FROM
  chat_message_join,
  message,
  handle
WHERE
  chat_id = ?
  AND message_id = message.ROWID
  AND handle_id = handle.ROWID
ORDER BY date ASC</code></pre>
<p>Cool. One last thing. Remember that <code>attachment</code> table? Let's go ahead and add that in, just loading the attachments as a single string:</p>
<pre class="sql"><code>SELECT
  message.ROWID as message_id,
  message.date,
  message.service,
  message.is_from_me,
  handle.id as them,
  (CASE WHEN message.subject IS NULL THEN '' ELSE message.subject END),
  (CASE WHEN message.text IS NULL THEN '' ELSE message.text END),
  (SELECT group_concat(attachment.filename)
     FROM message_attachment_join, attachment
     WHERE message_attachment_join.message_id = message.ROWID
       AND message_attachment_join.attachment_id = attachment.ROWID)
FROM
  chat_message_join,
  message,
  handle
WHERE
  chat_id = ?
  AND message_id = message.ROWID
  AND handle_id = handle.ROWID
ORDER BY date ASC</code></pre>
<p>Okay. They say that <a href="https://www.youtube.com/watch?v=pele5vptVgc" data-toggle="lightbox">knowing is half the battle</a>, so having all of the structure and that SQL query should translate pretty directly to code:</p>
<pre class="racket"><code>(struct chat (contacts messages) #:prefab)
(struct message (date service sender subject text attachments) #:prefab)
(struct attachment (name path) #:prefab)

; Load all chats from a backup directory
(define (list-chats)
  (hash-ref!
   chats-by-backup
   (current-backup)
   (λ ()
     (parameterize ([date-display-format 'iso-8601])
       ; Connect to the correct DB
       (define sms-db
         (sqlite3-connect
           #:database (build-path (backup-path (current-backup))
                                  MESSAGES-DB)))

       ; Loop over the individual chat ids
       (for/list ([(chat-id) (in-query sms-db "SELECT ROWID FROM chat")])
         ; Determine which contacts were involved in the conversation by contact
         ; Use models/contacts.rkt to figure out who belongs to contact information
         (define user-query "SELECT id FROM chat_handle_join, handle
                             WHERE chat_id = $1 AND handle_id = ROWID
                             ORDER BY handle_id ASC")
         (define contacts
           (for/list ([(contact) (in-query sms-db user-query chat-id)])
             (find-contact (normalize-contact contact))))

         ; Load the individual messages
         (define msg-query "
SELECT
  message.ROWID as message_id,
  message.date,
  message.service,
  message.is_from_me,
  handle.id as them,
  (CASE WHEN message.subject IS NULL THEN '' ELSE message.subject END),
  (CASE WHEN message.text IS NULL THEN '' ELSE message.text END),
  (SELECT group_concat(attachment.filename)
     FROM message_attachment_join, attachment
     WHERE message_attachment_join.message_id = message.ROWID
       AND message_attachment_join.attachment_id = attachment.ROWID)
FROM
  chat_message_join,
  message,
  handle
WHERE
  chat_id = ?
  AND message_id = message.ROWID
  AND handle_id = handle.ROWID
ORDER BY date ASC")
         (define messages
           (for/list ([(message-id
                        raw-date
                        service
                        from-me?
                        other-party
                        subject
                        text
                        raw-attachments)
                       (in-query sms-db msg-query chat-id)])
             ; Correct dates from Apple time to unix time
             ; TODO: Account for timezones?
             (define date (seconds-&gt;date (+ raw-date 978336000 (- (* 16 60 60))) #f))

             (define sender
               (if (= 1 from-me?)
                   (backup-phone-number (current-backup))
                   (normalize-contact other-party)))

             ; Load attachments,
             (define attachments
               (if (sql-null? raw-attachments)
                   '()
                   (for/list ([path (in-list (string-split raw-attachments ","))])
                     (attachment
                      (path-&gt;string (last (explode-path path)))
                      (build-path (backup-path (current-backup))
                                  (hash-filename path))))))

             (message date service sender subject text attachments)))

         ; Create the chat object
         (chat contacts messages))))))</code></pre>
<p>Theoretically, that should be a fairly direct translation. One interesting bit is the format of <code>date</code>. It's actually a timestamp, but not a normal <a href="https://en.wikipedia.org/wiki/Unix_timestamp">Unix timestamp</a>. So I have a bit of a <a href="https://en.wikipedia.org/wiki/magic_number">magic number</a>, but it works correctly for my backups, so we'll just leave it for the moment. Other than that, we use the <code>hash-filename</code> function from last time to get a local path for any <code>attachment</code> and we've got everything pretty much written.</p>
<p>And that's really all we need. One thing that would be nice to be able to do though is, given a contact, filter for only the messages with that contact (either directly or in group chats as well):</p>
<pre class="racket"><code>; Get all chats involving a specific chat
(define (find-chats-by-contact contact #:direct? [direct? #f])
  ; Allow the user to specify the contact by name / phone number / email / etc
  (when (not (contact? contact))
    (set! contact (find-contact contact)))

  ; Filter the list of chats
  (for/list ([chat (in-list (list-chats))]
             #:when (if direct?
                        (equal? (list contact) (chat-contacts chat))
                        (member contact (chat-contacts chat))))
    chat))</code></pre>
<p>If you have an iOS device, check it out. It makes certain things really easy. For example, if I want to have a log of every word that I've ever said in a conversation with Jenny:</p>
<pre class="racket"><code>&gt; (with-backup "86b18...aa36"
    (for*/list ([chat (in-list (find-chats-by-contact "Jenny" #:direct? #t))]
                [message (in-list (chat-messages chat))])
      (message-text message)))
'("Jenny, Jenny, who can I turn to?"
  "You give me somethin' I can hold on to"
  ...)</code></pre>
<p>That's exactly the sort of that prompted this entire thought: the ability to take the fairly opaque structure of iOS backups and dump them into an easily readable / easily diffable format for my own purposes. Sweet.</p>
<p>If you'd like to see the entire project, you can do so on GitHub: <a href="https://github.com/jpverkamp/ios-backup">ios-backup</a>. Alternatively, it's set up as a package, so you should be able to install it with <code>raco pkg install</code>. If you do, just import one or more of these:</p>
<pre class="racket"><code>(require ios-backup
         ios-backup/contacts
         ios-backup/messages)</code></pre>
<p>Here is a list of all of the posts in this series:</p>
<ul class="list-unstyled"><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">iOS Backups in Racket: Groundwork</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">iOS Backups in Racket: Contacts</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">iOS Backups in Racket: Messages</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps">iOS Backups in Racket: Apps</a></li></ul>]]></content></entry><entry><title>iOS Backups in Racket: Contacts</title><link href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts" /><id>urn:uuid:e4d2594c-e305-b796-553b-77a2ca28a8fb</id><updated>2015-01-23T00:00:00Z</updated><summary type="html"><![CDATA[<p>After <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">yesterday's post</a> laying the groundwork for looking into <a href="http://blog.jverkamp.com/category/programming/by-project/ios-backup">iOS Backups</a>, today why don't we actually start digging into one of the more interesting files: your list of contacts.</p>
]]></summary><content type="html"><![CDATA[<p>After <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">yesterday's post</a> laying the groundwork for looking into <a href="http://blog.jverkamp.com/category/programming/by-project/ios-backup">iOS Backups</a>, today why don't we actually start digging into one of the more interesting files: your list of contacts.</p>
<!--more-->
<p>First things first, we have to find where the list of contacts is stored. That's the problem with the backup format--we have a giant list of files each of which is a SHA-1 hash. But of what?</p>
<p>Doing a little bit of digging, it looks like each of those hashes is based more or less on the filename of the source file. So if we happened to know that contacts are stored in the file <code>Library/AddressBook/AddressBook.sqlitedb</code><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, we should just be able to hash that:</p>
<pre class="racket"><code>&gt; (call-with-input-string "Library/AddressBook/AddressBook.sqlitedb" sha1)
"adb8c77534444e97c31ff15924d50f3ed1fbd3b1"</code></pre>
<p>Hmm. That file doesn't exist. But all of my sources are telling me that <code>AddressBook.sqlitedb</code> is in <code>HomeDomain</code>. What does that mean? Well it seems that iOS has some amount of sandboxing in it's filesystem, rather than a more traditional Unix style. Basically, the path is actually:</p>
<p><code>Domain-Path</code></p>
<p>Specifically:</p>
<pre class="racket"><code>; Hash attachments so that we can find the local path
(define (hash-filename path [domain "MediaDomain"])
  (for*/first ([prefix (in-list (list "/var/mobile/"
                                      "~/"
                                      ""))]
               #:when (and (&gt; (string-length path) (string-length prefix))
                           (equal? (substring path 0 (string-length prefix)) prefix)))
    (define path-w/o-prefix (substring path (string-length prefix)))
    (call-with-input-string (~a domain "-" path-w/o-prefix) sha1)))</code></pre>
<p>There's a bit of complication there. If a file uses a traditional Unix path, starting with with <code>/var/mobile/</code> or <code>~/</code> (the home directory), that is stripped off before adding the domain. If we try it again:</p>
<pre class="racket"><code>&gt; (hash-filename "Library/AddressBook/AddressBook.sqlitedb" "HomeDomain")
"31bb7ba8914766d4ba40d6dfb6113c8b614be442"</code></pre>
<p>Ah hah! That file actually exists (and matches the hash I've found online).</p>
<p>Let's poke around. First things first, let's load it up in <code>sqlite3</code>:</p>
<pre class="sql"><code>sqlite&gt; .tables
ABAccount                        ABPersonFullTextSearch_segdir
ABGroup                          ABPersonFullTextSearch_segments
ABGroupChanges                   ABPersonFullTextSearch_stat
ABGroupMembers                   ABPersonLink
ABMultiValue                     ABPersonMultiValueDeletes
ABMultiValueEntry                ABPersonSearchKey
ABMultiValueEntryKey             ABPhoneLastFour
ABMultiValueLabel                ABRecent
ABPerson                         ABStore
ABPersonBasicChanges             FirstSortSectionCount
ABPersonChanges                  FirstSortSectionCountTotal
ABPersonFullTextSearch           LastSortSectionCount
ABPersonFullTextSearch_content   LastSortSectionCountTotal
ABPersonFullTextSearch_docsize   _SqliteDatabaseProperties</code></pre>
<p>A lot of those are indicies or other things that we don't necessarily care about, but the first one that jumps out to me is <code>ABPerson</code>:</p>
<pre class="sql"><code>sqlite&gt; .schema ABPerson
CREATE TABLE ABPerson (
  ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
  First TEXT,
  Last TEXT,
  Middle TEXT,
  FirstPhonetic TEXT,
  MiddlePhonetic TEXT,
  LastPhonetic TEXT,
  Organization TEXT,
  Department TEXT,
  Note TEXT,
  Kind INTEGER,
  Birthday TEXT,
  JobTitle TEXT,
  Nickname TEXT,
  Prefix TEXT,
  Suffix TEXT,
  FirstSort TEXT,
  LastSort TEXT,
  CreationDate INTEGER,
  ModificationDate INTEGER,
  CompositeNameFallback TEXT,
  ExternalIdentifier TEXT,
  ExternalModificationTag TEXT,
  ExternalUUID TEXT,
  StoreID INTEGER,
  DisplayName TEXT,
  ExternalRepresentation BLOB,
  FirstSortSection TEXT,
  LastSortSection TEXT,
  FirstSortLanguageIndex INTEGER DEFAULT 2147483647,
  LastSortLanguageIndex INTEGER DEFAULT 2147483647,
  PersonLink INTEGER DEFAULT -1,
  ImageURI TEXT,
  IsPreferredName INTEGER DEFAULT 1,
  guid TEXT DEFAULT (ab_generate_guid()),
  PhonemeData TEXT,
  AlternateBirthday TEXT,
  MapsData TEXT,
  UNIQUE(guid)
);
...</code></pre>
<p>There is rather a pile of other statements after that, but that's the table that we're interested in. Specifically, that at least has the names and organizations (which at the moment is what I'm really interested in). What's suspiciously absent though, is the phone numbers. Hmm...</p>
<p>After a little bit of digging, I came across this table:</p>
<pre class="sql"><code>sqlite&gt; .schema ABMultiValue
CREATE TABLE ABMultiValue (
  UID INTEGER PRIMARY KEY,
  record_id INTEGER,
  property INTEGER,
  identifier INTEGER,
  label INTEGER,
  value TEXT,
  guid TEXT DEFAULT (ab_generate_guid()),
  UNIQUE(guid)
);</code></pre>
<p>Specifically, <code>record_id</code> matches <code>ABPerson.ROWID</code> and <code>value</code> contains phone numbers, email address, etc. (This is the real reason that I wrote the <code>normalize-contact</code> function).</p>
<p>Okay. That should be enough for the moment. Let's switch gears and lay out a similar framework to <code>backup</code>.</p>
<pre class="racket"><code>(define CONTACTS-DB
  (hash-filename "Library/AddressBook/AddressBook.sqlitedb" "HomeDomain"))

; Name is a human readable name for a contact
; Identifiers is a list of phone numbers / emails / etc
(struct contact (name identifiers) #:prefab)

; Store a separate list of contacts for each backup (potentially)
(define contacts-by-backup (make-hash))
(hash-set! contacts-by-backup #f '())</code></pre>
<p>Cool. Now we want to load the specific list of contacts, caching them the same way we did with the backups themselves:</p>
<pre class="racket"><code>; Load all contacts stored in a specific backup
(define (list-contacts)
  (hash-ref!
   contacts-by-backup
   (current-backup)
   (λ ()
     (define contacts-db
       (sqlite3-connect #:database (build-path (backup-path (current-backup))
                                               CONTACTS-DB)))

     (for/list ([(user-id first-name middle-name last-name organization)
                 (in-query contacts-db "SELECT ROWID, First, Middle, Last, Organization FROM ABPerson")])

       (define (fix str) (if (sql-null? str) "" str))

       (define name
         (let* ([name (~a (fix first-name) " "
                          (fix middle-name) " "
                          (fix last-name) " "
                          "(" (fix organization) ")")]
                [name (regexp-replace* #px"\\(\\)" name "")]
                [name (regexp-replace* #px"\\s+" name " ")]
                [name (string-trim name)]
                [name (regexp-replace* #px"^\\((.*)\\)$" name "\\1")])
           name))

       (define identifiers
         (for*/list ([raw-value (in-list (query-list contacts-db "SELECT value FROM ABMultiValue WHERE record_id = $1" user-id))]
                     [value (in-value (normalize-contact raw-value))]
                     #:when value)
           value))

       (contact name identifiers)))))</code></pre>
<p>Basically, we want to make a nested set of queries, first one for each user and then another for all contact information for that user. It's Not the perfect way of doing itl as theoretically we could have done a sql join, but it works well enough.</p>
<p>As far as the name formatting, that's just the way I needed it to work. When I get around to it, I'll probably write a <code>name-display-format</code> parameter akin to <code><a href="http://docs.racket-lang.org/search/index.html?q=date-display-format">date-display-format</a></code> from <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/date">racket/date</a></code>. Not today though!</p>
<p>So let's see how it works:</p>
<pre class="racket"><code>&gt; (with-backup "86b18eea28a991f4dd569d1f59737a842e24aa36"
    (list-contacts))
'(#s(contact "Charles I. Clarke" ("555.555.1234" "charlie.c@example.com"))
  #s(contact "Jenny Reichert (Catsitter)" ("555.867.5309"))
  #s(contact "Mary Orndorff" ("555.555.0000"))
  #s(contact "Pizza Palace" ("555.555.1123"))
  #s(contact "Willie S. Culpepper" ("555.555.1491"))
  ...)</code></pre>
<p>Sweet.</p>
<p>And as a bonus, let's include a basic search function:</p>
<pre class="racket"><code>; Load a user by name or value
(define (find-contact key)
  (for/first ([contact (in-list (list-contacts))]
              #:when (or (equal? key (contact-name contact))
                         (member key (contact-identifiers contact))))
    contact))</code></pre>
<p>Again, it's not a fuzzy match (you have to have the name exact), but that's something I'll probably clean up later.</p>
<pre class="racket"><code>&gt; (with-backup "86b18eea28a991f4dd569d1f59737a842e24aa36"
    (find-contact "Charles I. Clarke"))
#s(contact
   "Charles I. Clarke"
   ("555.555.1234" "charlie.c@example.com")</code></pre>
<p>And there you have it. Contacts. We're really starting to get somewhere here. Next week (probably Monday or Tuesday), I'll write up messages (both SMS and iMessage). That one will really be fun.</p>
<p>As always entire code for today's post is available on GitHub: <a href="https://github.com/jpverkamp/ios-backup">ios-backup</a></p>
<p>Here is a list of all of the posts in this series:</p>
<ul class="list-unstyled"><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">iOS Backups in Racket: Groundwork</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">iOS Backups in Racket: Contacts</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">iOS Backups in Racket: Messages</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps">iOS Backups in Racket: Apps</a></li></ul>]]></content></entry></feed>