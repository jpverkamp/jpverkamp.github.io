<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-08-28T20:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>Chess Puzzles 2: Board?</title><link href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board" /><id>urn:uuid:6d64e14c-c731-a12d-4a38-7070fa6e6e9e</id><updated>2014-08-28T20:00:00Z</updated><summary type="html"><![CDATA[<p>Now that we've got <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a> out of the way, back to chess! <a href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving">Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p>
<ul>
    <li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li>
    <li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href="https://en.wikipedia.org/wiki/fairy_chess">fairy chess</a> pieces)</li>
</ul>
<p>I think that's about enough for the moment. Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Now that we've got <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a> out of the way, back to chess! <a href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving">Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p>
<ul>
    <li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li>
    <li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href="https://en.wikipedia.org/wiki/fairy_chess">fairy chess</a> pieces)</li>
</ul>
<p>I think that's about enough for the moment. Let's do it!</p>
<!--more-->
<p>First things first, let's create a representation of the board. We'll start with only regular grids, although theoretically it should be possible to define arbitrary connections. That would mess somewhat with the move definitions we have, so let's not.</p>
<p>First, the board:</p>
<pre class="scheme"><code>; Stored as a vector of vectors where every element is either:
; (player, piece) if there is a piece there
; #f if empty
(struct board (pieces data) #:transparent)</code></pre>
<p>So what we should have is something like this:</p>
<pre class="scheme"><code>(define (make-standard-board)
  (board (hash 'Rook   Rook
               'Knight Knight
               'Bishop Bishop
               'Queen  Queen
               'King   King
               'Pawn   Pawn)
         '#(#((Black Rook) (Black Knight) (Black Bishop) (Black Queen)
              (Black King) (Black Bishop) (Black Knight) (Black Rook))
            #((Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn)
              (Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn))
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #((White Pawn) (White Pawn) (White Pawn) (White Pawn)
              (White Pawn) (White Pawn) (White Pawn) (White Pawn))
            #((White Rook) (White Knight) (White Bishop) (White Queen)
              (White King) (White Bishop) (White Knight) (White Rook)))))</code></pre>
<p>Vectors will allow both <code>O(1)</code> reading of elements, but also a nice way of doing mutation. I'm just going to go right out now and say that I'll allow mutating the board, although I might make a non-mutable version that copies if I have a chance<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>.</p>
<p>Next, a getter and a sanity check (which should make it cleaner to generate moves):</p>
<pre class="scheme"><code>; Test if a point is on the given board
(define (on-board? b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (and (&lt;= 0 x (- (vector-length (vector-ref data 0)) 1))
       (&lt;= 0 y (- (vector-length data) 1))))

; Get the current player/piece at a square
(define (board-ref b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (cond
    [(on-board? b p)
     (vector-ref (vector-ref data y) x)]
    [else
     #f]))</code></pre>
<p>And finally, a setter. In this case, it doesn't make sense to just set a single piece (except in set up I guess?)<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>. So instead, we will allow movement, overwriting whatever is at the target square:</p>
<pre class="scheme"><code>; Move a piece from one square to another, overwriting whatever is in the destination square
(define (board-move! b src dst)
  (match-define (board pieces data) b)
  (match-define (pt src-x src-y) src)
  (match-define (pt dst-x dst-y) dst)
  (define piece (board-ref data src))
  (vector-set! (vector-ref data dst-y) dst-x piece)
  (vector-set! (vector-ref data src-y) src-x #f))</code></pre>
<p>And that's about all we need for the board representation. Let's check out rendering next, since it should (theoretically) make debugging the move list generation much better.</p>
<p>First, let's generalize the tile for a piece to a <code>glyph</code>:</p>
<pre class="scheme"><code>; The hash associating piece names with glyphs
(define current-glyphs (make-parameter #f))

; A single glyph containing a string and the rotation (default to upright)
(struct glyph (character rotation) #:transparent)
(define (make-glyph character [rotation 0])
  (glyph (~a character) rotation))

; Render a single character with some sanity checking for different types
(define (render-glyph/pict g tile-size)
  (cond
    [(glyph? g)
     (match-define (glyph character rotation) g)
     (rotate (text character 'default (* 3/4 tile-size)) rotation)]
    [else
     (render-glyph/pict (make-glyph g) tile-size)]))</code></pre>
<p>This way, we can specify characters in several different ways. We can pass just about anything directly and use the <code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code> function to 'string' it. Or we can pass both the former and a rotation. That will let us do things like an inverted knight being the representation for the nightrider, etc.</p>
<p>One thing that amuses me entirely too much about this?</p>
<pre class="scheme"><code>(define (set-standard-glyphs)
  (current-glyphs (hash 'Rook   "♜"
                        'Knight "♞"
                        'Bishop "♝"
                        'Queen  "♛"
                        'King   "♚"
                        'Pawn   "♟")))</code></pre>
<p>Those are unicode characters for the chess symbols. Nice. :)</p>
<p>Okay, so we have a way to represent a single tile, what do we have to do to render all of them? Well, as often before, we can use the <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code> library:</p>
<pre class="scheme"><code>; Render a board to a pict with the given tile size
(define (render/pict b #:tile-size [tile-size 20])
  ; Sanity check and unpack, we don't care about the actual pieces at this point
  (when (not (current-glyphs))
    (error 'render/pict "must specify (current-glyphs) as a hash of name -&gt; glyph"))
  (match-define (board _ board-data) b)

  ; Render each tile into a list of lists
  (define tiles
    (for/list ([row-index (in-naturals)]
               [row       (in-vector board-data)])
      (for/list ([col-index (in-naturals)]
                 [col       (in-vector row)])
        ; Get the background tile
        ; TODO: Parameterize the tile colors
        ; TODO: Figure out how to do borders
        (define tile-color
          (cond
            [(even? (+ row-index col-index))
             "LightGray"]
            [else
             "DarkGray"]))
        (define tile (colorize (filled-rectangle 20 20) tile-color))

        (cond
          ; If there is a piece here, render the piece, colorize based on the player,
          ; and overlay on the tile
          [col
           (match-define (list player piece) col)
           (define glyph
             (render-glyph/pict (hash-ref (current-glyphs) piece) tile-size))
           (cc-superimpose tile (colorize glyph (~a player)))]
          ; If not, just return the empty tile
          [else
           tile]))))

  ; Smash together all the lists of lists
  (apply vc-append
         (for/list ([row (in-list tiles)])
           (apply hc-append row))))</code></pre>
<p>Okay, that looks like a lot, but most of it is comments. Basically, we loop over the board (the pair of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/list">for/list</a></code>), building nested lists. Then, for each tile, we determine if we're on a white or black square (light and dark gray so that the white and black actually stand out). After that, we get the string from the <code>glyph</code> and render it as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code>. There's one thing I haven't done yet: support strings of multiple characters. Essentially, I would scale horizontally to make it be the correct width. Good enough for now though.</p>
<p>So how does it work? Well combine <code>make-standard-board</code> and <code>render/pict</code>:</p>
<pre class="scheme"><code>&gt; (render/pict (make-standard-board))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/initial-board.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/initial-board.png" /></a></p>
<p>Fair enough. But to visualize, what we really want is an ability to show off certain squares. So let's add a <code>#:highlight</code> keyword parameter of a hash of points to colors to color them specially. Something like this:</p>
<pre class="scheme"><code>; Render a board to a pict with the given tile size
(define (render/pict b #:tile-size [tile-size 20] #:highlights [special-tiles (hash)])
  ...

  ; Get the background tile
  ; TODO: Parameterize the tile colors
  ; TODO: Figure out how to do borders
  (define tile-color
    (cond
      [(hash-ref special-tiles (pt col-index row-index) #f)
       =&gt; identity]
      [(even? (+ row-index col-index))
       "LightGray"]
      [else
       "DarkGray"]))

  ...)</code></pre>
<p>This way, we can highlight any square we want:</p>
<pre class="scheme"><code>&gt; (render/pict (make-standard-board)
               #:highlights (hash (pt 2 2) "green"
                                  (pt 5 2) "green"
                                  (pt 2 4) "red"
                                  (pt 3 5) "red"
                                  (pt 4 5) "red"
                                  (pt 5 4) "red"))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/highlights.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/highlights.png" /></a></p>
<p>(Remember that indices are 0-based)</p>
<p>Shiny!</p>
<p>Okay, that's enough to test. Let's work on a function to determine moves. We want something like this:</p>
<pre class="scheme"><code>; Return a list of moves that a piece can make on the given board given it's origin point
(define (moves-from b origin #:initial [initial #f])
  ...)</code></pre>
<p>We'll have a flag if the piece is on the initial turn, otherwise we pull everything out (like which player we're dealing with) from the piece on the board:</p>
<pre class="scheme"><code>...
(cond
  [(board-ref b origin)
   =&gt; (λ (ls)
        (match-define (list player name) ls)
        (match-define (piece _ moves) (hash-ref pieces name))

        ; White has inverse moves since they're moving 'up'
        ; TODO: Generalize to more players
        ; TODO: This moves the wrong way if you have 'left only' pieces
        (define player-multiplier
          (case player
            [(BLACK Black black)  1]
            [(WHITE White white) -1]
            [else     1]))

...</code></pre>
<p>This is the case when we have a piece (if not, the location is <code>#f</code>). If we have that, we unpack the piece and then determine which player we have. For the black player, we're moving down on the board / up in the y-coordinate, so the numbers are correct. Otherwise, we'll multiply moves my negative one. This has the effect of reflecting the moves. Unfortunately, it's on both axes, but at least with any piece I've seen, that doesn't actually matter.</p>
<p>Next, we're going to take the move sequences we generated last time and filter each one so that we only include the moves from that sequence that are viable. For that, we first need to find the <code>first-target</code>--the first piece that we would hit if moving along this path.</p>
<pre class="scheme"><code>...
(define move-sublists
 (for*/list ([move-seq (in-list moves)])
   (match-define (move-sequence tags original-offset*) move-seq)
   (define offset* (map (λ (offset) (pt* player-multiplier offset)) original-offset*))

   ; Find the first target
   (define first-target
     (for/first ([i (in-naturals)]
                 [offset (in-list offset*)]
                 #:when (board-ref b (pt+ origin offset)))
       (list i (board-ref b (pt+ origin offset)))))

   ; If the first target belongs to the owner, remove it (no self captures)
   ; TODO: Add an option for self-captures
   (define self-capture
     (and first-target
          (eq? (first (second first-target)) player)))
   ...</code></pre>
<p>Another amusing option that I'm sure there are fairy chess pieces that use: self-captures.</p>
<p>Next, we want to unfold those lists based on how we found the <code>first-target</code>:</p>
<pre class="scheme"><code>...
             (map (λ (offset) (pt+ origin offset))
                  (cond
                    ; Bail out if we're initial only but not on the initial move
                    [(and (set-member? tags 'initial-only) (not initial))
                     (list)]
                    ; If we're capturing only, can only move if we have a target
                    ; and to that square
                    [(set-member? tags 'capture-only)
                     (if (and first-target (not self-capture))
                         (list (list-ref offset* (first first-target)))
                         (list))]
                    ; If we're not capturing, get everything up until the target
                    ; (or everything if no target)
                    [(set-member? tags 'non-capture)
                     (if (and first-target (&gt; (first first-target) 0))
                         (take offset* (- (first first-target) 1))
                         offset*)]
                    ; If we're a locust, we have to check the space after the self
                    ; target is empty
                    [(set-member? tags 'as-locust)
                     (cond
                       [(and first-target
                             (not self-capture)
                             (&gt; (length offset*) (+ (first first-target) 1)))
                        (define next-target
                          (board-ref b (list-ref offset* (+ (first first-target) 1))))
                        (if (not next-target)
                            (list (list-ref offset* (+ 1 (first first-target))))
                            (list))]
                       [else
                        (list)])]
                    ; If the target is an enemy, capture it and stop
                    ; Otherwise, if the target is a piece but we own, don't land there
                    [first-target
                     (if self-capture
                         (if (&gt; (first first-target) 0)
                             (take offset* (first first-target))
                             (list))
                         (take offset* (+ (first first-target) 1)))]
                    ; Otherwise, include the entire range
                    [else
                     offset*]))))

          ...</code></pre>
<p>Oof. That's a lot of code. But luckily, each case is fairly straight forward. We remove non-initial moves (like for pawns), set the capturing / non-capturing conditions, or move like a locust (that have to jump to capture). And then finally, if the first thing is our own, just cut that off (this is where a self-capture tag would come in).</p>
<p>And then to finish it off:</p>
<pre class="scheme"><code>      ...
      ; Stick all the lists together since we no longer care how they got there
      ; And remove all moves that jump off of the board somehow
      (filter (λ (p) (on-board? b p)) (apply append move-sublists)))]
[else
 '()]))</code></pre>
<p>Bam. We have moves. Let's try it out:</p>
<pre class="scheme"><code>; Black pawn
&gt; (moves-from (make-standard-board) (pt 3 1) #:initial #t)
(list (pt 3 3) (pt 3 2))

; White knight
&gt; (moves-from (make-standard-board) (pt 6 7))
(list (pt 7 5) (pt 5 5))</code></pre>
<p>And using our highlighting code:</p>
<pre class="scheme"><code>&gt; (let* ([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt 3 1) #:initial #t)])
                        (values pt "green"))])
    (render/pict board #:highlights highlight))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-pawn.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-pawn.png" /></a></p>
<pre class="scheme"><code>&gt; (let* ([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt 6 7))])
                        (values pt "green"))])
    (render/pict board #:highlights highlight))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-knight.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-knight.png" /></a></p>
<p>Shiny!</p>
<p>Looks like it's working great. Let's generate images for all of the pieces:</p>
<pre class="scheme"><code>&gt; (for/list ([piece (in-list '(Pawn Rook Knight Bishop Queen King))])
    (define test-board
      (board (hash 'Rook   Rook
                   'Knight Knight
                   'Bishop Bishop
                   'Queen  Queen
                   'King   King
                   'Pawn   Pawn)
             `#(#(#f #f #f #f #f #f #f #f)
                #(#f #f #f #f #f #f (White Pawn) #f)
                #(#f #f #f #f (White Pawn) #f #f #f)
                #(#f #f #f (White Pawn) #f (Black Pawn) #f #f)
                #(#f #f #f #f (White ,piece) #f #f (Black Pawn))
                #(#f #f #f #f (Black Pawn) #f #f #f)
                #(#f #f #f #f #f #f (Black Pawn) #f)
                #(#f #f #f #f #f #f #f #f))))

    (define highlights
      (for/hash ([pt (in-list (moves-from test-board (pt 4 4)))])
        (values pt "green")))

    (render/pict test-board #:highlights highlights))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-pawn.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-pawn.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-rook.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-rook.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-knight.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-knight.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-bishop.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-bishop.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-queen.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-queen.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-king.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-king.png" /></a></p>
<p>That is cool. I love it when something works like that!</p>
<p>(Note: Yes, the king can currently move into check. That's on the list of things to fix yet, along with castling and en passant.)</p>
<p>Here's actually a lesson too, until I generated those images for this post, I actually had a bug where I wasn't stopping after hitting an enemy piece. Good thing I checked otherwise who knows what would have happened?</p>
<p>And that's about it for today. We now have move lists, a board, and some rendering. Should be enough so that next time we can <em>actually</em> write up a chess puzzle. Third time's a charm, eh?</p>
<p>If you'd like to see the entire code, it's on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles">jpverkamp/chess-puzzles</a></p>]]></content></entry><entry><title>Sandbox Battle!</title><link href="http://blog.jverkamp.com/2014/08/24/sandbox-battle" /><id>urn:uuid:645b48c8-e1d6-e804-d919-58df438ef692</id><updated>2014-08-24T18:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
<!--more-->
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/sandbox-battle.embed.htm"></iframe></p>
<h2>Created for <a href="http://www.ludumdare.com/compo/ludum-dare-30/">Ludum Dare 30</a></h2>
<h3><a href="http://www.ludumdare.com/compo/ludum-dare-30/?action=preview&uid=19702">Entry</a></h3>
<h3><a href="https://github.com/jpverkamp/sandbox-battle">Source code</a></h3>
<h4>Note: Runs best in <a href="https://www.google.com/chrome/browser/">Chrome</a>.</h4>
<h3>Instructions</h3>
<ul>
  <li>You have 60 seconds to collect as much sand as you can</li>
  <li>Each player's sand falls to the bottom of their tile</li>
  <li>Colliding with other players will steal their sand</li>
  <li>Choose options for keyboard controls and to enable multiplayer</li>
</ul>
<h3>Comments</h3>
<ul>
  <li>Libraries used: <a href="https://jquery.com/">jQuery</a>, <a href="http://getbootstrap.com/">Boostrap</a></li>
  <li>Graphics generated in Photoshop CS6</li>
</li>]]></content></entry><entry><title>Ludum Dare 30: Demo mode</title><link href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode" /><id>urn:uuid:eaf9e838-2040-375f-db84-612ac3daf122</id><updated>2014-08-24T12:00:00Z</updated><summary type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
]]></summary><content type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png" /></a></p>
<p>As soon as you start, you'll go right back to the normal mode. Between rounds, there's no demo, since it's still showing the last round's game.</p>
<p>Unfortunately, it doesn't stop, so if you just let it sit for a while, strange things may happen:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png" /></a></p>
<p>Also, instructions (technically, these were in last night, but I don't think I mentioned them):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png" /></a></p>
<p>Up to date code (as always): <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Programmer art and simple AI</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai" /><id>urn:uuid:f2360aa3-c003-b836-c4a8-ea379a7ef8de</id><updated>2014-08-23T23:00:00Z</updated><summary type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
]]></summary><content type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<!--more-->
<p>More specifically, here's how you can change the AIs:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png" /></a></p>
<p>Those are the three AIs currently implemented. I've tied them into the same framework as the player movement. It's a bit hacky and could be in its own file, but for a 48 hour game, it works well enough.</p>
<p>The first, the <code>Wiggle</code>, is straight forward:</p>
<pre class="javascript"><code>// Randomly wiggle about, changing directions no slower than every second
case 'wiggle':
  ai['nextWiggle'] = ai['nextWiggle'] || new Date().getTime() + 1000 * Math.random();
  ai['xAccel'] = ai['xAccel'] || 0;
  ai['yAccel'] = ai['yAccel'] || 0;

  if (new Date().getTime() &gt; ai['nextWiggle']) {
    ai['xAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;
    ai['yAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;

    ai['nextWiggle'] = new Date().getTime() + 1000 * Math.random();
  }

  vel[player][0] += ai['xAccel'];
  vel[player][1] += ai['yAccel'];

  break;</code></pre>
<p>The other two (<code>Chicken</code> and <code>Shark</code>) are actually really similar. Enough so that they share almost all of their code. The only difference is that the former runs from the closest neighbor while the latter chases it. It's a bit of math, but it runs great:</p>
<pre class="javascript"><code>case 'chicken': // Run away from the nearest other tile
case 'shark':   // Run towards the nearest other tile
  $me = $('#tiles *[data-player="' + player + '"]');
  var myCenterX = $me.offset().left + $me.width() / 2;
  var myCenterY = $me.offset().top + $me.height() / 2;

  // Find the closest target
  var otherCenterX, otherCenterY, distance;
  var minimumDistance = +Infinity, $target;
  $('#tiles *[data-player]').each(function(otherPlayer, other) {
    $other = $(other);

    var otherCenterX = $other.offset().left + $other.width() / 2;
    var otherCenterY = $other.offset().top + $other.height() / 2;

    distance = (
      (myCenterX - otherCenterX) * (myCenterX - otherCenterX) +
      (myCenterY - otherCenterY) * (myCenterY - otherCenterY)
    );

    if (distance &gt; 0 && distance &lt; minimumDistance) {
      minimumDistance = distance;
      $target = $other;
    }
  });

  // Calculate the direction to that target
  var targetCenterX = $target.offset().left + $target.width() / 2;
  var targetCenterY = $target.offset().top + $target.height() / 2;

  // Get the length and normalized direciton
  var length = Math.sqrt(
    (targetCenterX - myCenterX) * (targetCenterX - myCenterX) +
    (targetCenterY - myCenterY) * (targetCenterY - myCenterY)
  );

  var directionX = (targetCenterX - myCenterX) / length;
  var directionY = (targetCenterY - myCenterY) / length;

  // If we're the chicken, invert that and run away rather than towards
  // Sharks also move away, once they've come in for the kill
  if (ai['type'] == 'chicken' || distance &lt; 25) {
    directionX *= -1;
    directionY *= -1;
  }

  // Apply a force in that direction
  // Sharks and chickens accelerate more slowly or they'll stay right on the player
  vel[player][0] += directionX * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);
  vel[player][1] += directionY * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);

  break;</code></pre>
<p>Shiny.</p>
<p>Up to date code: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: 24 hours</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours" /><id>urn:uuid:37f85de8-ca29-d5a8-2c0f-d57f53b84283</id><updated>2014-08-23T18:00:00Z</updated><summary type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
]]></summary><content type="html"><![CDATA[<p>Here we are, 24 hours into the competition.</p>
<p>A lot of the last few hours has been spent doing a fair amount of restructing. Before, I had a single 'thread'<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> for each of the tiles, along with another thread listening for user input. Unfortunately though, that lead to all sorts of race conditions. Specifically, whenever two tiles overlapped, it was often the case that one was doing the falling step (which copies from one internal buffer to another) while the other was in the swap step (which copies from tile to another). Then after the first finished, it would copy the second buffer over... overwriting anything that had been swapped.</p>
<p>Oops.</p>
<!--more-->
<p>Well, it turns out that the solution wasn't that bad. Rather than having a bunch of threads running around, I've just put the entire thing into lockstep. Now, we go through the entire sequence (sand falls, swaps happen, rendering happens, move tiles) once ever frame, in that order. It's a bit more expensive when it comes to performance, but really not that much, since technically JavaScript doesn't do more than one thing at a time anyways.</p>
<p>In exchange though, the game is playing great:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-2.png" /></a></p>
<p>Another thing that I did was to do some styling, converting the game from a big mess of an HTML page into a nice layered style that all fits within the 600x400 game area that I've set aside (I doubt I'll make that changeable, although it shouldn't be hard). Specifically:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/start-screen.png" /></a></p>
<p>If you click options, these fade in (jQuery transitions are awesome for this):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/options.png" /></a></p>
<p>If you click play, all of the button and options fading out, taking you into the game:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/in-game-1.png" /></a></p>
<p>At the end of the game (the timer is in the bottom right, set to a static 1 minute at the moment), you get the new scoring screen. I think I worked about 2 hours on this, which sounds crazy, but I think the effect is pretty awesome:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/scoring-in-progress.png" /></a></p>
<p>You can't see it in the screenshot there, but it will go through each player one by one, scoring the region from bottom to top, counting up each kind of sand individually. That should make scoring modes much easier if/when I add more options. I can just do things like discount (or even count negative) your own sand, or only count it.</p>
<p>And finally, once it's done counting:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/game-over.png" /></a></p>
<p>I'd like to have some sort of background motion going on both here and during the opening menu. Something like having the tiles bounce around using some sort of AI. Speaking of which, here is a tentative feature list that I'd like to see in the next 24 hours (in no particular order):</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Pending the first, AI players playing in the background, periodically resetting before the game has started and between games</li>
  <li>Music and/or sound effects; of course with options to turn those on and off</li>
  <li>Some sort of high score menu, probably not live (although I certainly could)</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<p>I think that's about it. If you have any ideas, I'd love to hear them. There's not much (well, any) code this time, since nothing major has changed (other than refactoring). It's pretty much all tweaks. If you'd like to see the entire source (warning: ugly, bit getting a little better), it's still right here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Demo time!</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-24-hours/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Hints of a game</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game" /><id>urn:uuid:7e16e7ce-b97f-2d28-ba95-ea26c1b8a027</id><updated>2014-08-23T12:00:00Z</updated><summary type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
]]></summary><content type="html"><![CDATA[<p>We're getting there. 18 hours in and I have the first hints of what might actually be a game...</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-hints-of-a-game/screenshot.png" /></a></p>
<p>(I'll include a demo at the bottom of the post)</p>
<p>Basically, I went with allowing each box to be controlled individually by the keyboard. There will be some problems with having that many people on the keyboard at once, but we'll deal with that later (if we can).</p>
<p>One additional thing I wanted (and mostly figured out) is somewhat 'loose' controls. Basically, rather than explicitly dealing with moving only when a key is down, we'll accelerate when the key is down, preserving velocity even after  keys are raised. There will be some small amount of friction as well, to make sure that eventually pieces will slow down.</p>
<p>It's actually not too hard to implement a system like this:</p>
<p>First, load in the keybindings from the interface you can see in the screenshot above:</p>
<pre class="javascript"><code>// Load key bindings
var loadKeyBindings = function() {
  keys = {};

  console.log('Loading key bindings...');

  $('#controls table').each(function(i, eli) {
    var player = parseInt($(eli).attr('data-player'));

    console.log('loading controls for player ' + player);

    $(eli).find('input').each(function(j, elj) {
      var command = $(elj).attr('name');
      var key = $(elj).val();

      keys[key] = [player, command, false];
    });
  });
};</code></pre>
<p>This will put everything into the <code>key</code> array, indexed by key name and storing the player it refers to, the direction you are going (one of <code>left</code>, <code>right</code>, <code>up</code>, or <code>down</code>), and if that key is currently active (pressed down). If I can, I may add additional key bindings (such as rotation or powerups), otherwise, that's pretty good for the moment.</p>
<p>Next, we'll add a function to tell when keys are active:</p>
<pre class="javascript"><code>var onkey = function(event) {
  switch (event.keyCode) {
    case  37: key = 'LEFT'; break;
    case  38: key = 'UP'; break;
    case  39: key = 'RIGHT'; break;
    case  40: key = 'DOWN'; break;
    case  97: key = 'NUM1'; break;
    case  98: key = 'NUM2'; break;
    case  99: key = 'NUM3'; break;
    case 100: key = 'NUM4'; break;
    case 101: key = 'NUM5'; break;
    case 102: key = 'NUM6'; break;
    case 103: key = 'NUM7'; break;
    case 104: key = 'NUM8'; break;
    case 105: key = 'NUM9'; break;
    default: key = String.fromCharCode(event.keyCode).toUpperCase();
  }

  if (key in keys) {
    if (event.type == 'keydown') {
      keys[key][2] = true;
    } else if (event.type == 'keyup') {
      keys[key][2] = false;
    }
  }
};</code></pre>
<p>Longer than I wanted, but it correctly deals with both the numpad and arrow keys, which is kind of necessary if you want to support 4 human players all at the same time. Perhaps I'll implement AIs, but until I do, we're going to have to allow for a bunch of players...</p>
<p>Okay, so what do we do with all of this information? Well, just like before, we have a <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function(event) {
  $.each(keys, function(i, el) {
    var player = el[0];
    var command = el[1];
    var active = el[2];

    $game = $('#tiles');
    $tile = $('#tiles *[data-player="' + player + '"]');

    // Update velocity
    ...

    // Use friction to slow each box down over time
    ...

    // Cap velocity so we don't go too fast
    ...

    // Update the current position based on velocity
    ...

    // Bounce off the edges of the screen
    ...

    // Finally, update the position
    $tile.css({'top': top, 'left': left});
  });

  if (running) {
    setTimeout(tick, 1000/30);
  }
};</code></pre>
<p>Oof. That's a heck of a function. Luckily, the individual parts aren't <em>that</em> bad. First, we want to update the velocity. This is where the <code>active</code> parameter (the third in each key definition) comes into play:</p>
<pre class="javascript"><code>// Update velocity
if (active) {
  if (command == 'up') {
    vel[player][1] -= PER_TICK_ACCELERATION;
  } else if (command == 'down') {
    vel[player][1] += PER_TICK_ACCELERATION;
  } else if (command == 'left') {
    vel[player][0] -= PER_TICK_ACCELERATION;
  } else if (command == 'right') {
    vel[player][0] += PER_TICK_ACCELERATION;
  }
}</code></pre>
<p>That's simple enough. As before, we have to decide that <code>up</code> and <code>down</code> are inverted (they almost always are when it comes to computers), but once you've decided that's easy enough.</p>
<p>Now, outside of that black, the next thing we'll do is apply friction. This way the boxes will slow down over time, forcing players both to pay attention and to let them bounce around like madmen.</p>
<pre class="javascript"><code>// Use friction to slow each box down over time
// If we're close enough to zero that friction will accelerate us, just stop
if (Math.abs(vel[player][0]) &lt; PER_TICK_FRICTION) {
  vel[player][0] = 0;
} else {
  vel[player][0] += (vel[player][0] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

if (Math.abs(vel[player][1]) &lt; PER_TICK_FRICTION) {
  vel[player][1] = 0;
} else {
  vel[player][1] += (vel[player][1] &gt; 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
}

// Cap velcity so we don't go too fast
vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));</code></pre>
<p>Also at the end there, we make sure we don't keep accelerating indefinitely. That both helps keep the game a little easier to play and prevents edge cases (such as moving further in one tick than we're allowed).</p>
<p>Next, we can finally update the position:</p>
<pre class="javascript"><code>// Update the current position based on velocity
var left = $tile[0].offsetLeft + vel[player][0];
var top = $tile[0].offsetTop + vel[player][1];

// Bounce off the edges of the screen
if (left &lt; 0) {
  left = 0;
  vel[player][0] = Math.abs(vel[player][0]);
} else if (left &gt; $game.width() - $tile.width()) {
  left = $game.width() - $tile.width();
  vel[player][0] = -1 * Math.abs(vel[player][0]);
}

if (top &lt; 0) {
  top = 0;
  vel[player][1] = Math.abs(vel[player][1]);
} else if (top &gt; $game.height() - $tile.height()) {
  top =  $game.height() - $tile.height();
  vel[player][1] = -1 * Math.abs(vel[player][1]);
}</code></pre>
<p>Once again, we want to clip the positions. This time though, we're actually going to use the velocities we have rather than zeroing them out. Instead: bounce! It's nice, because it makes the game feel more 'realistic' (for some definitions of the word).</p>
<p>And that's about it. With that, we can have the boxes moving around and interacting as they did last night. We're actually starting to get a game going here. One other tweak is the control code:</p>
<pre class="javascript"><code>var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec &gt; 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}</code></pre>
<p>Technically, it's not a gameloop, since everything is done asynchronously via <code>setTimeout</code> (and make <strong>absolutely sure</strong> that you don't use <code>setInterval</code>...), but it's close enough. What this does give us though is a strict time before the game ends. Otherwise, the boxes will eventually fill up, and where's the fun in that? (Although that might be an interesting alternative end condition).</p>
<p>After that, all I have to figure out is scoring. And I have another 6 hours until the one day mark. If I can make it by then, I'll feel pretty good--and can use all of the rest of the time for polish. I'm thinking some simple music, sound effects, a title screen (initial letters in sand?). Of course, I still have to figure out the scoring algorithm..</p>
<p>Same as yesterday, the entire source (warning: still ugly) if available on GitHub: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<hr />
<p>Demo:</p>
<style>
#controls table {
  border: 1px solid black;
  display: inline-block;
  margin: 1em;
  padding: 0.5em;
  border-radius: 0.5em;

}

#controls table td {
  padding: 0.1em;
}

#controls table td:first-child {
  text-align: right;
}

#controls table input {
  width: 50px;
  text-align: center;
}

#tiles {
  position: relative;
  width: 600px;
  height: 400px;
  background: black;
  border: 1px solid black;
}

#tiles canvas {
  position: absolute;
  border: 1px solid black;
}

#tiles canvas[data-player="0"] { border: 1px solid blue; }
#tiles canvas[data-player="1"] { border: 1px solid red; }
#tiles canvas[data-player="2"] { border: 1px solid green; }
#tiles canvas[data-player="3"] { border: 1px solid hotPink; }

#tiles #countdown {
  color: white;
}
</style>
<script>
function Tiles() {
  var running = false;
  var allData = {};
  var ordering = [];

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  // Make a 2D array initialized all to a given valu
  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  // Update the given grid
  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  // Animate a given frame
  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;
      var imageData = frame_ctx.createImageData(width, height);

      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // Bail out if we haven't loaded the data yet
              if (!(frameIndex in allData && otherIndex in allData)) {
                return;
              }

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                    a = 0;
                  } else if (data[x][y] == 1) {
                    b = 255;
                  } else if (data[x][y] == 2) {
                    r = 255;
                  } else if (data[x][y] == 3) {
                    g = 255;
                  } else if (data[x][y] == 4) {
                    r = 246;
                    g = 96;
                    b = 171;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (running) {
              setTimeout(tick, 1000/60);
          }
      }
      tick();
  };

  this.run = function() {
    running = true;
    $('canvas').each(animate);
  };

  this.stop = function() {
    running = false;
  };
};

function Controls() {
  var keys = {};
  var running = false;
  var PER_TICK_ACCELERATION = 0.1;
  var PER_TICK_FRICTION = 0.01;
  var VELOCITY_CAP = 10;

  var vel = {};

  // Load key bindings
  var loadKeyBindings = function() {
    keys = {};

    console.log('Loading key bindings...');

    $('#controls table').each(function(i, eli) {
      var player = parseInt($(eli).attr('data-player'));

      console.log('loading controls for player ' + player);

      $(eli).find('input').each(function(j, elj) {
        var command = $(elj).attr('name');
        var key = $(elj).val();

        keys[key] = [player, command, false];
      });
    });
  };

  var onkey = function(event) {
    switch (event.keyCode) {
      case  37: key = 'LEFT'; break;
      case  38: key = 'UP'; break;
      case  39: key = 'RIGHT'; break;
      case  40: key = 'DOWN'; break;
      case  97: key = 'NUM1'; break;
      case  98: key = 'NUM2'; break;
      case  99: key = 'NUM3'; break;
      case 100: key = 'NUM4'; break;
      case 101: key = 'NUM5'; break;
      case 102: key = 'NUM6'; break;
      case 103: key = 'NUM7'; break;
      case 104: key = 'NUM8'; break;
      case 105: key = 'NUM9'; break;
      default: key = String.fromCharCode(event.keyCode).toUpperCase();
    }

    if (key in keys) {
      if (event.type == 'keydown') {
        keys[key][2] = true;
      } else if (event.type == 'keyup') {
        keys[key][2] = false;
      }
    }
  };

  var tick = function(event) {
    $.each(keys, function(i, el) {
      var player = el[0];
      var command = el[1];
      var active = el[2];

      $game = $('#tiles');
      $tile = $('#tiles *[data-player="' + player + '"]');

      // Update velocity
      if (active) {
        if (command == 'up') {
          vel[player][1] -= PER_TICK_ACCELERATION;
        } else if (command == 'down') {
          vel[player][1] += PER_TICK_ACCELERATION;
        } else if (command == 'left') {
          vel[player][0] -= PER_TICK_ACCELERATION;
        } else if (command == 'right') {
          vel[player][0] += PER_TICK_ACCELERATION;
        }
      }

      // Use friction to slow each box down over time
      // If we're close enough to zero that friction will accelerate us, just stop
      if (Math.abs(vel[player][0]) < PER_TICK_FRICTION) {
        vel[player][0] = 0;
      } else {
        vel[player][0] += (vel[player][0] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      if (Math.abs(vel[player][1]) < PER_TICK_FRICTION) {
        vel[player][1] = 0;
      } else {
        vel[player][1] += (vel[player][1] > 0 ? -PER_TICK_FRICTION : PER_TICK_FRICTION);
      }

      // Cap velocity so we don't go too fast
      vel[player][0] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][0]));
      vel[player][1] = Math.min(VELOCITY_CAP, Math.max(-VELOCITY_CAP, vel[player][1]));

      // Update the current position based on velocity
      var left = $tile[0].offsetLeft + vel[player][0];
      var top = $tile[0].offsetTop + vel[player][1];

      // Bounce off the edges of the screen
      if (left < 0) {
        left = 0;
        vel[player][0] = Math.abs(vel[player][0]);
      } else if (left > $game.width() - $tile.width()) {
        left = $game.width() - $tile.width();
        vel[player][0] = -1 * Math.abs(vel[player][0]);
      }

      if (top < 0) {
        top = 0;
        vel[player][1] = Math.abs(vel[player][1]);
      } else if (top > $game.height() - $tile.height()) {
        top =  $game.height() - $tile.height();
        vel[player][1] = -1 * Math.abs(vel[player][1]);
      }

      // Finally, update the position
      $tile.css({'top': top, 'left': left});
    });

    if (running) {
      setTimeout(tick, 1000/30);
    }
  };

  this.run = function() {
    // Reload keybindings in case they've changed
    loadKeyBindings();

    // Initialize velocities to zero
    $game = $('#tiles');
    $('#tiles canvas').each(function(i, eli) {
      vel[i] = [0, 0];
      $(eli).css({
        top: Math.random() * ($game.height() - $(eli).height()),
        left: Math.random() * ($game.width() - $(eli).width())
      });
    });

    // Add keybindings, we can use the same function since it can check type
    $(document).unbind('keydown').bind('keydown', onkey);
    $(document).unbind('keyup').bind('keyup', onkey);

    running = true;
    tick();
  }

  this.stop = function() {
    running = false;

    $(document).unbind('keydown');
    $(document).unbind('keyup');
  }
};

var tiles = new Tiles();
var controls = new Controls();

var MS_PER_GAME = 60 * 1000;
var startTime = new Date().getTime();
var running = true;

$(function() {
  controls.run();
});

function tick() {
  var soFar = new Date().getTime() - startTime;
  var remainingSec = Math.floor((MS_PER_GAME - soFar) / 1000);

  if (remainingSec > 0) {
    $('#tiles #countdown').text(remainingSec + ' sec remaining');
  } else {
    stop();
  }

  if (running) {
    setTimeout(tick, 1000/30);
  }
}

function run() {
  tiles.run();
  controls.run();

  startTime = new Date().getTime();
  running = true;
  tick();

  return false;
}

function stop() {
  tiles.stop();
  controls.stop();

  startTime = new Date().getTime() - MS_PER_GAME;
  running = false;
  $('#tiles #countdown').text('game over');

  return false;
}
</script>
<div class="table" id="controls">
  <table data-player="0">
    <tr><td colspan="2">Player 1 - Blue</tr>
    <tr><td>Up</td><td><input name="up" value="W"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="A"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="D"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="S"></input></td></tr>
  </table>

  <table data-player="1">
    <tr><td colspan="2">Player 2 - Red</tr>
    <tr><td>Up</td><td><input name="up" value="I"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="J"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="L"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="K"></input></td></tr>
  </table>

  <table data-player="2">
    <tr><td colspan="2">Player 3 - Green</tr>
    <tr><td>Up</td><td><input name="up" value="UP"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="LEFT"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="RIGHT"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="DOWN"></input></td></tr>
  </table>

  <table data-player="3">
    <tr><td colspan="2">Player 4 - Pink</tr>
    <tr><td>Up</td><td><input name="up" value="NUM8"></input></td></tr>
    <tr><td>Left</td><td><input name="left" value="NUM4"></input></td></tr>
    <tr><td>Right</td><td><input name="right" value="NUM6"></input></td></tr>
    <tr><td>Down</td><td><input name="down" value="NUM2"></input></td></tr>
  </table>
</div>
<div>
  [ <a href="javascript:run()">Run!</a> ]
  [ <a href="javascript:stop()">Stop!</a> ]
</div>
<div width="600" height="400">
  <div id="tiles">
    <p id="countdown"></p>
    <canvas data-player="0" width="100" height="100"></canvas>
    <canvas data-player="1" width="100" height="100"></canvas>
    <canvas data-player="2" width="100" height="100"></canvas>
    <canvas data-player="3" width="100" height="100"></canvas>
  </div>
</div>
<hr />
<p>I'm sure there are bugs... And I'm working on it right at the moment. If you have any questions or comments though, feel free to drop me a line below.</p>]]></content></entry><entry><title>Ludum Dare 30: Sandbox Battle</title><link href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle" /><id>urn:uuid:60fce17b-2d64-c87b-a259-90aa26aa5803</id><updated>2014-08-22T23:00:00Z</updated><summary type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
]]></summary><content type="html"><![CDATA[<p>And here we are again. <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>. Taken directly from their about page...</p>
<blockquote>Ludum Dare is a regular accelerated game development Event.  Participants develop games from scratch in a weekend, based on a theme suggested by community.</blockquote>
<p>More specifically, the goal is to make a game from scratch in 48 hours. You're allowed to use publicly available frameworks and code libraries, but no art or other assets. Previously, I missed the original start time. So although I made my game in 48 hours, it didn't qualify. This time around, I'm starting on time.</p>
<!--more-->
<p>The theme this time is <a href="http://www.ludumdare.com/compo/2014/08/16/ludum-dare-30-theme-voting-begins/">Connected Worlds</a>. I like that a lot more than many of the previous themes, so let's see what ideas we can come up with.</p>
<p>Taking about an hour at the start of the compo to both work out and think, I ended up basically going in two directions:</p>
<ul>
  <li>A <a href="https://en.wikipedia.org/wiki/falling_sand">falling sand</a> style game, only with discrete 'bubbles' with different particles / physics</li>
  <li>A <a href="https://en.wikipedia.org/wiki/Platform_game#Puzzle_platformers">puzzle platformer</a> based around portals that split you into two realities you play at the same time</li>
</ul>
<p>Of the two, the second has the advantages of 1) actually sounding like a game (that's always been my problem with falling sand style simulations) and 2) being much easier to code. I've worked on falling sand style games before (<a href="http://blog.jverkamp.com/category/programming/by-project/games/sandbox">Sandbox</a>) and they take a lot of tuning to get reasonable performance. Certainly worth doing... but not the best idea for a 48 hour time window.</p>
<p>So of course I'm going with option A. :)</p>
<p>About 6 hours in, and so far this is what I have:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/22/ludum-dare-30-sandbox-battle/screenshot.png" /></a></p>
<hr />
<p>Real-life demo! (Click run, then try dragging the boxes around)</p>
<canvas id="frame1" width="100" height="100"></canvas>
<canvas id="frame2" width="100" height="100"></canvas>
<canvas id="frame3" width="100" height="100"></canvas>
<p><button id="runGame" type="button">Run!</button></p>
<style>
canvas { border: 1px solid black; }
</style>
<script>
$(function() {
  var maxFrames = 10000;

  // Assign an index to each canvas so we can order them
  $('canvas').each(function(index, canvas) {
     $(canvas).attr('data-index', index);
  });

  // Keep a list of the current z-ordering of the canvases
  var ordering = [];
  $('canvas').each(function(i) { ordering.push(i); });

  // Make them draggable, on drag udate the index
  $('canvas').draggable({
      stack: '*',
      drag: function(event, ui) {

      },
      stop: function(event, ui) {
          var i = parseInt($(event.target).attr('data-index'));
          var index = ordering.indexOf(i);
          ordering.splice(index, 1);
          ordering.unshift(i);
      }
  });

  var make2DArray = function(width, height, def) {
      var array = new Array(width);
      for (var x = 0; x < width; x++) {
          array[x] = new Array(height);
          for (var y = 0; y < height; y++) {
              array[x][y] = def;
          }
      }
      return array;
  }

  var update = function(data, buffer, width, height) {
      // Clear the buffer
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              buffer[x][y] = 0;
          }
      }

      // Update the buffer with falling cells
      var r = 0, xt = 0, yt = 0;
      for (var y = height - 1; y >= 0; y--) {
          for (var x = 0; x < width; x++) {
              // Skip empty cells
              if (data[x][y] == 0) continue;
              xt = x;
              yt = y;

              // Determine which way it's going to fall
              r = Math.random();
              if (r < 0.5) { // Straight down
                  if (y > 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
              } else if (r < 0.7) { // Down left
                  if (x > 0 && y > 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
              } else if (r < 0.9) { // Down right
                  if (x < width - 1 && y > 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
              } else if (r < 0.95) { // Straight left
                  if (x > 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
              } else { // Straight right
                  if (x < width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
              }

              if (data[xt][yt] != 0) { xt = x; yt = y; }

              // Update the buffer
              buffer[xt][yt] = data[x][y];
          }
      }
  }

  var allData = {};

  var animate = function(frameIndex, frame) {
      var start = new Date().getTime();

      var frame_ctx = frame.getContext('2d');
      frame_ctx.imageSmoothingEnabled = false;

      var width = frame.width;
      var height = frame.height;

      var data = make2DArray(width, height, 0);
      var buffer = make2DArray(width, height, 0);
      var temp;
      var i = 0, r = 0, g = 0, b = 0, a = 0;

      allData[frameIndex] = data;

      var imageData = frame_ctx.createImageData(width, height);

      var count = 0;
      var tick = function() {
          // Debug: For add a pixel
          data[width / 2][height - 1] = frameIndex + 1;

          // Update from data to buffer; swap the arrays for the next iteration
          update(data, buffer, width, height);
          temp = data;
          data = buffer;
          buffer = temp;

          // Detect overlapping buffers, if so swap randomly
          $('canvas').each(function(otherIndex, other) {
              // If we're comparing to ourself, we'll always overlap, skip
              if (frame == other) return;

              /*
              // We only want to run this once, so only for the frame on top
              // If we see the frame first, we're golden (break out of the loop)
              // If we see the other first, we're in the wrong order (stop processing)
              for (var i = 0; i < ordering.length; i++) {
                  if (ordering[i] == frameIndex) break;
                  if (ordering[i] == otherIndex) return;
              }
              */

              // If the two canvases don't overlap, don't look at them
              var frameBounds = frame.getBoundingClientRect();
              var otherBounds = other.getBoundingClientRect();
              if (frameBounds.right < otherBounds.left ||
                  frameBounds.left > otherBounds.right ||
                  frameBounds.bottom < otherBounds.top ||
                  frameBounds.top > otherBounds.bottom) {
                  return;
              }

              // We only want this once, so give priority to whichever frame is 'lower' on the screen
              if (frameBounds.top < otherBounds.top) return;

              // TODO: Find the actual offset rather than looping over an entire image
              var otherX, otherY, temp;
              for (var frameY = 0; frameY < height; frameY++) {
                  for (var frameX = 0; frameX < width; frameX++) {
                      otherX = Math.floor(frameBounds.left - otherBounds.left + frameX);
                      otherY = Math.floor(otherBounds.top - frameBounds.top + frameY);

                      if (0 <= otherX && otherX < width && 0 <= otherY && otherY < height) {
                          if (allData[frameIndex][frameX][frameY] == 0
                              /* && allData[otherIndex][otherX][otherY] != 0*/) {
                              temp = allData[frameIndex][frameX][frameY];
                              allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                              allData[otherIndex][otherX][otherY] = temp;
                          }
                      }
                  }
              }
          });

          // Render to the image data
          for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                  i = x + (height - y) * width;

                  r = g = b = 0;
                  a = 255;

                  if (data[x][y] == 0) {
                      a = 0;
                  } else if (data[x][y] == 1) {
                      b = 255;
                  } else if (data[x][y] == 2) {
                      r = 255;
                  } else if (data[x][y] == 3) {
                      g = 255;
                  }

                  imageData.data[i * 4 + 0] = r;
                  imageData.data[i * 4 + 1] = g;
                  imageData.data[i * 4 + 2] = b;
                  imageData.data[i * 4 + 3] = a;
              }
          }

          // Copy back to the GUI
          frame_ctx.putImageData(imageData, 0, 0);

          if (count < maxFrames) {
              count += 1;
              setTimeout(tick, 0);
          } else {
              end = new Date().getTime();
              console.log(
                  maxFrames + ' frames in ' +
                  (end - start) + ' ms = ' +
                  (maxFrames / ((end - start) / 1000)) + ' fps'
              );
          }
      }
      tick();
  }

  $('#runGame').click(function() {
    console.log('starting...');
    $('canvas').each(animate);
  });
});
</script>
<p>You can click and drag the blocks around and the sand will from from box to box. At first, I was trying to figure out goals where you could--for example--use water in one box to put out fire in another. But right at the end, I had an even better idea (hopefully not just the long day talking): SANDBOX BATTLE! Basically, some sort of multiplayer / AI madness, where you are trying to steal the other box's sand before they can steal yours... I'm going to have to think about that...</p>
<p>Anyways, here are some of the interesting bits (in JavaScript for once!):</p>
<p>First, the core of the whole thing, the update function:</p>
<pre class="javascript"><code>var update = function(data, buffer, width, height) {
    // Clear the buffer
    for (var x = 0; x &lt; width; x++) {
        for (var y = 0; y &lt; height; y++) {
            buffer[x][y] = 0;
        }
    }

    // Update the buffer with falling cells
    var r = 0, xt = 0, yt = 0;
    for (var y = height - 1; y &gt;= 0; y--) {
        for (var x = 0; x &lt; width; x++) {
            // Skip empty cells
            if (data[x][y] == 0) continue;
            xt = x;
            yt = y;

            // Determine which way it's going to fall
            r = Math.random();
            if (r &lt; 0.5) { // Straight down
                if (y &gt; 0 && buffer[x][y - 1] == 0) { xt = x; yt = y - 1; }
            } else if (r &lt; 0.7) { // Down left
                if (x &gt; 0 && y &gt; 0 && buffer[x - 1][y - 1] == 0) { xt = x - 1; yt = y - 1; }
            } else if (r &lt; 0.9) { // Down right
                if (x &lt; width - 1 && y &gt; 1 && buffer[x + 1][y - 1] == 0) { xt = x + 1; yt = y - 1; }
            } else if (r &lt; 0.95) { // Straight left
                if (x &gt; 0 && buffer[x - 1][y] == 0) { xt = x - 1; yt = y; }
            } else { // Straight right
                if (x &lt; width - 1 && buffer[x + 1][y] == 0) { xt = x + 1; yt = y; }
            }

            if (data[xt][yt] != 0) { xt = x; yt = y; }

            // Update the buffer
            buffer[xt][yt] = data[x][y];
        }
    }
}</code></pre>
<p>The basic idea is two have two data arrays: <code>data</code> and <code>buffer</code>. We will trust the rest of the code to swap them the other way and spend all of the effort in this function creating buffer as the next frame. Specifically, we're going to loop through all of the tiles from bottom to top (because sand falls) then left to right. For each particle (non-<code>0</code> space), there are five possibilities:</p>
<ul>
  <li>50% chance of trying to move directly down</li>
  <li>20% chance of trying to move down and left, 20% down and right</li>
  <li>5% chance each of moving directly left or right</li>
</ul>
<p>Sounds pretty good. It's the same sort of code I've written rather a lot of times... This time around, we're not going to do any optimizations. We'll deal with that later if we have time.</p>
<p>Next, we have to deal with the <code>tick</code> function:</p>
<pre class="javascript"><code>var tick = function() {
    // Debug: Add a pixel
    data[width / 2][height - 1] = frameIndex + 1;

    // Update from data to buffer; swap the arrays for the next iteration
    update(data, buffer, width, height);
    temp = data;
    data = buffer;
    buffer = temp;

    // Detect overlapping buffers, if so swap randomly
    ...

    // Render to the image data
    ...
}</code></pre>
<p>So we start with pixels dumping in from the ceiling and we update the world. We have space for two more functions: copying between worlds (pretty much the core idea of the game :)) and rendering. Let's look at the latter first.</p>
<p>In order to render quickly, I'm going to use the <code>canvas</code> element's context's <code>createImageData</code> and <code>putImageData</code> to write data directly into the image. That will be a lot faster than setting pixels individually, especially since we're going to be changing rather a lot of pixels at the indiviual level. So... rendering:</p>
<pre class="javascript"><code>// Render to the image data
for (var y = 0; y &lt; height; y++) {
    for (var x = 0; x &lt; width; x++) {
        i = x + (height - y) * width;

        r = g = b = 0;
        a = 255;

        if (data[x][y] == 0) {
            a = 0;
        } else if (data[x][y] == 1) {
            b = 255;
        } else if (data[x][y] == 2) {
            r = 255;
        } else if (data[x][y] == 3) {
            g = 255;
        }

        imageData.data[i * 4 + 0] = r;
        imageData.data[i * 4 + 1] = g;
        imageData.data[i * 4 + 2] = b;
        imageData.data[i * 4 + 3] = a;

    }
}

// Copy back to the GUI
frame_ctx.putImageData(imageData, 0, 0);</code></pre>
<p>We've previously set up <code>imageData</code> using <code>createImageData</code> (we only have to do this once and then can reuse that same memory) and the <code>frame_ctx</code> as the context object of the canvas.</p>
<p>One interesting part that I changed right before this writeup was the transparency of empty cells. That way the page will shine through. I'm not entirely sure that's what I want, but it's an interesting effect, so I'll leave it for the time being.</p>
<p>And then last but not least, the combination function. This one is honestly kind of weird:</p>
<pre class="javascript"><code>// Detect overlapping buffers, if so swap randomly
$('canvas').each(function(otherIndex, other) {
    // If we're comparing to ourself, we'll always overlap, skip
    if (frame == other) return;

    // If the two canvases don't overlap, don't look at them
    var frameBounds = frame.getBoundingClientRect();
    var otherBounds = other.getBoundingClientRect();
    if (frameBounds.right &lt; otherBounds.left ||
        frameBounds.left &gt; otherBounds.right ||
        frameBounds.bottom &lt; otherBounds.top ||
        frameBounds.top &gt; otherBounds.bottom) {
        return;
    }

    // We only want this once, so give priority to whichever frame is 'lower' on the screen
    if (frameBounds.top &lt; otherBounds.top) return;

    // TODO: Find the actual offset rather than looping over an entire image
    var otherX, otherY, temp;
    for (var frameY = 0; frameY &lt; height; frameY++) {
        for (var frameX = 0; frameX &lt; width; frameX++) {
            otherX = frameBounds.left - otherBounds.left + frameX;
            otherY = otherBounds.top - frameBounds.top + frameY;

            if (0 &lt;= otherX && otherX &lt; width && 0 &lt;= otherY && otherY &lt; height) {
                if (allData[frameIndex][frameX][frameY] == 0 ) {
                    temp = allData[frameIndex][frameX][frameY];
                    allData[frameIndex][frameX][frameY] = allData[otherIndex][otherX][otherY];
                    allData[otherIndex][otherX][otherY] = temp;
                }
            }
        }
    }
});</code></pre>
<p>Theoretically the comments should be enough, but if not, the basic idea is to first find if we have two overlapping regions (the <code>frameIndex</code> and <code>otherIndex</code> will make more sense if you look at the full code). If you have one, then loop over the shared region and copy pixels to the lower of the two boxes. I'm going to have to figure out a better rule for that. I tried using z-index, but that didn't work much better... Essentially, we need to be able to move particles from one box to another, but we need to be careful to neither lose nor duplicate particles. There are a number of weird edges cases (as I'm sure you've found if you played with the simulation).</p>
<p>And, that's it. I have until 5pm Pacific on Sunday. I'm actually feeling pretty good about this. The best plan is to have a playable game after 24 hours and to spend the second day on polish. I'm not sure if I'll quite hit that... but maybe!</p>
<p>If you'd like to see the entire source (warning: ugly) and potentially spoilers, check it out here: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>]]></content></entry><entry><title>Chess Puzzles 1: Get moving!</title><link href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving" /><id>urn:uuid:c9a01028-c833-db3c-8a7b-1118c75bc69f</id><updated>2014-08-21T20:00:00Z</updated><summary type="html"><![CDATA[<p>Here's something I haven't done much<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>: chess puzzles! I'm still not sure entirely what I think about the game in general. There is certainly quite a lot of strategy, which I like, but to really get good at chess, there's also some amount of memorizing openings and closings. That's something I'm a little less thrilled with.</p>
<p>Still, it's the perfect sort of came to work out programming exercises with. It's a game of <a href="https://en.wikipedia.org/wiki/perfect_information">perfect information</a>, so you don't have to deal with what a player knows and doesn't. The pieces have well defined, regular moves<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> There's a fairly intense branching factor, but not insurmountable--<a href="https://en.wikipedia.org/wiki/Deep_Blue (chess computer)">Deep Blue</a> proved that.</p>
<p>Anyways, enough chatter. Let's play some chess!</p>
]]></summary><content type="html"><![CDATA[<p>Here's something I haven't done much<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>: chess puzzles! I'm still not sure entirely what I think about the game in general. There is certainly quite a lot of strategy, which I like, but to really get good at chess, there's also some amount of memorizing openings and closings. That's something I'm a little less thrilled with.</p>
<p>Still, it's the perfect sort of came to work out programming exercises with. It's a game of <a href="https://en.wikipedia.org/wiki/perfect_information">perfect information</a>, so you don't have to deal with what a player knows and doesn't. The pieces have well defined, regular moves<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> There's a fairly intense branching factor, but not insurmountable--<a href="https://en.wikipedia.org/wiki/Deep_Blue (chess computer)">Deep Blue</a> proved that.</p>
<p>Anyways, enough chatter. Let's play some chess!</p>
<!--more-->
<p>Okay, first things first, we're going to have to lay some ground work. Despite how straight forward chess pieces are, it will still take a bit of effort to turn that into something that a computer can deal with. So first, let's work out a way of defining chess piece movement.</p>
<p>Here, I'm going a little ambitious. I want to be able to support arbitrary <a href="https://en.wikipedia.org/wiki/fairy_chess pieces">fairy chess pieces</a>. In addition to the more standard pieces, we have  strictly more powerful pieces like the Princess (Knight + Bishop) or the Empress (Knight + Rook). Or we have alternatives, like the Camel (like the Knight, only 3:1 instead of 2:1). Or the Nightrider, which moves like the Knight, but keeps on going. I want to be able to support all of these...</p>
<p>Okay, first things first. A basic struct for points and another to use for a <code>move-sequence</code>:</p>
<pre class="scheme"><code>; Points, with associated methods; can also be used as offsets
(struct pt (x y) #:transparent)

; Move sequences for a piece; used for special flags (eg initial, capturing)
(struct move-sequence (tag moves) #:transparent)</code></pre>
<p>The tags are mostly used for Pawns or the like, since they move one way when capturing and another when not. The rest is going to be a list of moves. So for something like the Rook, we'll have something like this:</p>
<pre class="scheme"><code>(list
 (move-sequence (set) (list (pt 0 1) (pt 0 2) (pt 0 3) (pt 0 4) (pt 0 5) (pt 0 6) (pt 0 7) (pt 0 8)))
 (move-sequence (set) (list (pt -1 0) (pt -2 0) (pt -3 0) (pt -4 0) (pt -5 0) (pt -6 0) (pt -7 0) (pt -8 0)))
 (move-sequence (set) (list (pt 1 0) (pt 2 0) (pt 3 0) (pt 4 0) (pt 5 0) (pt 6 0) (pt 7 0) (pt 8 0)))
 (move-sequence (set) (list (pt 0 -1) (pt 0 -2) (pt 0 -3) (pt 0 -4) (pt 0 -5) (pt 0 -6) (pt 0 -7) (pt 0 -8))))</code></pre>
<p>When we get around to it, the idea is we can run down any of these lists until we run into something. If we run into an enemy piece, we'll allow the move; if not, we won't. Similarly, the Pawn:</p>
<pre class="scheme"><code>(list
 (move-sequence (set 'initial-only 'non-capture) (list (pt 0 2)))
 (move-sequence (set 'non-capture) (list (pt 0 1)))
 (move-sequence (set 'capture-only) (list (pt -1 1)))
 (move-sequence (set 'capture-only) (list (pt 1 1))))</code></pre>
<p>On the other hand though, these are kind of a pain to type in by hand. Let's make some helper functions. First, basic movement:</p>
<pre class="scheme"><code>; A sequence of moves along a specific direction
; Distance is either not specified (exactly 1)
;   a number (exactly that number), n (unlimited)
;   or a range (min/max inclusive)
; Direction is either from the list '(* + &gt; &lt; &lt;&gt; = &gt;= &lt;= X X&gt; X&lt;)
;   or a list of possible single offsets
(define move
  (case-lambda
    [(direction)
     (move 1 1 direction)]
    [(distance direction)
     (if (eq? distance 'n)
         (move 1        +inf.0   direction)
         (move distance distance direction))]
    [(minimum-distance maximum-distance direction)
     (for/list ([offset (in-list (offsets-by-direction direction))])
       (move-sequence
        (set)
        (for*/list ([distance (in-range minimum-distance (+ maximum-distance 1))]
                    [p (in-value (pt* distance offset))])
                    #:break (or (&gt; (abs (pt-x p)) (current-board-size))
                                (&gt; (abs (pt-y p)) (current-board-size)))
          p)))]))</code></pre>
<p>Basically, we have three different ways of specifying moves:</p>
<ul>
    <li><code>(move direction)</code> - moves one square in a given direction (like a pawn)</li>
    <li><code>(move distance direction)</code> - moves either exactly a specific number of tiles or an unlimited number (if <code>distance</code> is <code>n</code>)</li>
    <li><code>(move minimum-distance maximum-distance direction)</code> - a range of movement, so you can move between the minimum and maximum inclusive but no more or less</li>
</ul>
<p>But what does direction mean? If it's specified as a point, that's straight forward enough, but still, we want to be able to specify these things more simply. Let's take a page out of <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Parlett.27s_movement_notation">Parlett's movement notation</a>. Specifically the direction specifications:</p>
<ul>
        <li><code>*</code> – orthogonally or diagonally (all eight possible directions)</li>
    <li><code>+</code> – orthogonally (four possible directions)</li>
    <li><code>&gt;</code> – orthogonally forwards</li>
    <li><code>&lt;</code> – orthogonally backwards</li>
    <li><code>&lt;&gt;</code> – orthogonally forwards and backwards</li>
    <li><code>=</code> – orthogonally sideways (used here instead of Parlett's divide symbol.)</li>
    <li><code>&gt;=</code> – orthogonally forwards or sideways</li>
    <li><code>&lt;=</code> – orthogonally backwards or sideways</li>
    <li><code>X</code> – diagonally (four possible directions)</li>
    <li><code>X&gt;</code> – diagonally forwards</li>
    <li><code>X&lt;</code> – diagonally backwards</li>
</ul>
<p>Turn it into code:</p>
<pre class="scheme"><code>; Return a sequence of all possible offsets for a given direction
; Order specified front to back, left to right
(define (offsets-by-direction direction)
  `(,@(if (member direction '(*                  X X&gt;   )) (list (pt -1  1)) '())
    ,@(if (member direction '(* + &gt;   &lt;&gt;   &gt;=           )) (list (pt  0  1)) '())
    ,@(if (member direction '(*                  X X&gt;   )) (list (pt  1  1)) '())
    ,@(if (member direction '(* +        = &gt;= &lt;=        )) (list (pt -1  0)) '())
    ,@(if (member direction '(* +        = &gt;= &lt;=        )) (list (pt  1  0)) '())
    ,@(if (member direction '(*                  X    X&lt;)) (list (pt -1 -1)) '())
    ,@(if (member direction '(* +   &lt; &lt;&gt;      &lt;=        )) (list (pt  0 -1)) '())
    ,@(if (member direction '(*                  X    X&lt;)) (list (pt  1 -1)) '())
    ,@(if (pt? direction)   (list direction) '())
    ,@(if (list? direction) direction        '())))</code></pre>
<p>We're going to set it out now: <code>pt</code> is specified as <code>x, y</code>, not <code>row, column</code>. That's something that will bite you if you don't pay attention, so make sure to be consistent.</p>
<p>That's enough to define most of the pieces we want.</p>
<pre class="scheme"><code>(define King   (move  1 '*))
(define Queen  (move 'n '*))
(define Rook   (move 'n '+))
(define Bishop (move 'n 'X))</code></pre>
<p>Two are still left: the Knight and the Pawn. For the Knight, we need to specify something that will let us jump in arbitrary directions:</p>
<pre class="scheme"><code>; Make a leaper from a given offset
(define (leaper xΔ yΔ)
  (set-&gt;list
   (list-&gt;set
    `(,(pt    xΔ     yΔ )
      ,(pt (- xΔ)    yΔ )
      ,(pt    xΔ  (- yΔ))
      ,(pt (- xΔ) (- yΔ))
      ,(pt    yΔ     xΔ )
      ,(pt (- yΔ)    xΔ )
      ,(pt    yΔ  (- xΔ))
      ,(pt (- yΔ) (- xΔ))))))</code></pre>
<p>The <code>list-&gt;set</code> and set-&gt;list` calls are to avoid duplicates. Otherwise, it's every combination of leaps in a given ratio. So if you want to define a Knight:</p>
<pre class="scheme"><code>(define Knight (move 1 (leaper 1 2)))</code></pre>
<p>If you want to define the Nightrider though, it's just as simple:</p>
<pre class="scheme"><code>(define Nightrider (move 'n (leaper 1 2)))</code></pre>
<p>And... that leaves us the Pawn. It's funny how perhaps the simplest of the pieces is the most complicated to define. But if you think about it, the behavior is also the longest to describe. You can move two spaces on the first move, one space any other move, but only capture diagonally. Something like this:</p>
<pre class="scheme"><code>(define Pawn
  (alternatives
   (on-non-capture (on-initial (move 2 '&gt;)))
   (on-non-capture             (move 1 '&gt;))
   (on-capture                 (move 1 'X&gt;))))</code></pre>
<p>What's that? We don't have <code>on-non-capture</code> / <code>on-capture</code> functions defined? Well, all we have to do is set the <code>tag</code> field we defined earlier. Something like this:</p>
<pre class="scheme"><code>; Set special flags for move lists
(define (set-flag flag movelist*)
  (for/list ([movelist (in-list movelist*)])
    (match-define (move-sequence flags moves) movelist)
    (move-sequence (set-add flags flag) moves)))

(define (on-initial     movelist*) (set-flag 'initial-only movelist*))
(define (on-capture     movelist*) (set-flag 'capture-only movelist*))
(define (on-non-capture movelist*) (set-flag 'non-capture  movelist*))
(define (as-locust      movelist*) (set-flag 'locust       movelist*))</code></pre>
<p>Locusts are something we'll get to eventually. Those are pieces that move like checkers: they capture by jumping. Other than that, we just need the <code>alternatives</code>:</p>
<pre class="scheme"><code>; Merge multiple move lists by allowing any of them
(define (alternatives . list*)
  (apply append list*))</code></pre>
<p>Feels like cheating. And there we have the pawn:</p>
<pre class="scheme"><code>&gt; Pawn
(list
 (move-sequence (set 'initial-only 'non-capture) (list (pt 0 2)))
 (move-sequence (set 'non-capture) (list (pt 0 1)))
 (move-sequence (set 'capture-only) (list (pt -1 1)))
 (move-sequence (set 'capture-only) (list (pt 1 1))))</code></pre>
<p>Sweet.</p>
<p>Okay, what about other kinds of pieces. Say... the Aanca. That's a piece that moves one square orthogonally than diagonally outwards. It's a bit complicated by the fact that we don't want to double back with the diagonals and we need one more function. A sequencer:</p>
<pre class="scheme"><code>; Merge multiple move lists by doing one and then the next, each relative to the previous endpoint
(define (and-then first* rest*)
  (for*/list ([first (in-list first*)]
              [rest  (in-list rest*)])
    (match-define (move-sequence first-flags first-moves) first)
    (match-define (move-sequence rest-flags  rest-moves)  rest)
    (define offset (last first-moves))
    (move-sequence
     (set-union first-flags rest-flags)
     (append first-moves (map (λ (each) (pt+ offset each)) rest-moves)))))</code></pre>
<p>Now we can have the Aanca:</p>
<pre class="scheme"><code>; Move one square like a rook, followed by any number of spaces diagonally outwards
(define Aanca
  (alternatives
   (and-then (move 1 '&gt;) (move 'n 'X&gt;))
   (and-then (move 1 (pt 1 0))  (alternatives (move 'n (pt  1 -1))
                                              (move 'n (pt  1  1))))
   (and-then (move 1 '&lt;) (move 'n 'X&lt;))
   (and-then (move 1 (pt -1 0)) (alternatives (move 'n (pt -1 -1))
                                              (move 'n (pt -1  1))))))</code></pre>
<p>And that's it. We can define a whole pile of the other <a href="https://en.wikipedia.org/wiki/Fairy_chess pieces">Fairy chess pieces</a>:</p>
<pre class="scheme"><code>(define Adjutant     (move  1 '&lt;&gt;))
(define Advisor      (move  1 'X))
(define Alfil        (move  1 (leaper 2 2)))
(define Afilrider    (move 'n (leaper 2 2)))
(define Alibaba      (alternatives (move 'n (leaper 2 2)) (move 'n (leaper 0 2))))
(define Amazon       (alternatives (move 1 (leaper 1 2)) (move 'n '*)))
(define Antelope     (move  1 (leaper 3 4)))
(define Archbishop   (alternatives (move 'n 'X) (move 1 (leaper 1 2))))
(define ArrowPawn    (alternatives (on-non-capture (move 1 '+))
                                   (on-capture (move 1 'X))))
(define Backslider   (move  1 '&lt;))
(define Banshee      (alternatives (move 'n 'X) (move 'n (leaper 1 2))))
(define Bede         (alternatives (move 'n 'X) (move 'n (leaper 0 2))))
(define BerolinaPawn (alternatives (on-non-capture (on-initial (move 2 'X&gt;)))
                                   (on-non-capture (move 1 'X&gt;))
                                   (on-capture (move 1 '&gt;))))
...</code></pre>
<p>(Feel free to submit a <a href="https://github.com/jpverkamp/chess-puzzles/pulls">pull request</a> if you want to add more. :))</p>
<p>Oof. That's a lot of code. I think that's about enough for today.</p>
<p>You can see the full code on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles">jpverkamp/chess-puzzles</a>. Warning though: I'm a bit further ahead code-wise than blog-wise. That way lies spoilers...</p>
<p>Speaking of which:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/chessboard.png"><img src="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/chessboard.png" /></a></p>
<p>:)</p>]]></content></entry><entry><title>Minimal palindromic base</title><link href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base" /><id>urn:uuid:dccae1c2-8231-ed96-21a1-54145cd10b47</id><updated>2014-08-13T17:00:00Z</updated><summary type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
<!--more-->
<p>More specifically, consider the number 15:</p>
<div>$$15_{10} = 1111_2 = 120_3 = 33_4 = 30_5 = 23_6 = 21_7 = 17_8 = 16_9$$</div>
<div>$$15_{10} = 14_{11} = 13_{12} = 12_{13} = 11_{14} = 10_{15}$$</div>
<p>In this case, <code>2</code> is our golden number, since <code>1111</code> is a palindrome. But if it wasn't, 14 is the next case, with <code>11</code>.</p>
<p>So, what do we need? Well, first we want a generic way to convert bases. We could use different characters up to base 64, but we'll eventually get beyond that. So instead, we'll use lists of digits, each of which can be any integer:</p>
<pre class="scheme"><code>; Convert a decimal number n to base b
(define (rebase n b)
  (let loop ([n n] [ls '()])
     (if (= n 0)
        ls
        (loop (quotient n b)
              (cons (remainder n b) ls)))))</code></pre>
<pre class="scheme"><code>&gt; (rebase 15 2)
'(1 1 1 1)

&gt; (rebase 15 5)
'(3 0)

&gt; (rebase 15 10)
'(1 5)

&gt; (rebase 15 14)
'(1 1)</code></pre>
<p>Looks good. Next, we'll use a macro we've often used before: <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>. It's perfect for our uses, since it will return the first value that is non-<code>#f</code>. In this case, our base:</p>
<pre class="scheme"><code>; Find the minimal base b such that n in base b is a palindrome
(define (minimal-palindromic-base n)
  (for/first ([b (in-naturals 2)]
              #:when (let ([nb (rebase n b)])
                       (equal? nb (reverse nb))))
    b))</code></pre>
<p>Bam. Let's try a few:</p>
<pre class="scheme"><code>&gt; (minimal-palindromic-base 15)
2

&gt; (minimal-palindromic-base 1234)
22

&gt; (rebase 1234 22)
'(2 12 2)

&gt; (minimal-palindromic-base 8675309)
8675308</code></pre>
<p>Huh. I think <a href="https://en.wikipedia.org/wiki/867-5309/Jenny">Jenny</a> has a secret. :)</p>
<p>That's pretty much it for the puzzle as stated, but there are still a few things that we can do. For example, we've only seen small examples. What if we want to find the number with the largest minimal palindromic base:</p>
<pre class="scheme"><code>; Find the number n which has the largest palindromic base
(define (maximal-minimal-palindromic-base n-min n-max)
  (for/fold ([b -1] [n #f]) ([i (in-range n-min (+ n-max 1))])
    (define mpb (minimal-palindromic-base i))
    (if (&gt; i b)
        (values mpb i)
        (values b   n))))</code></pre>
<p>I may or may not have just wanted an excuse to use a crazy long function name. :)</p>
<p>Give it a try:</p>
<pre class="scheme"><code>&gt; (maximal-minimal-palindromic-base 100 200)
7
200

&gt; (rebase 200 7)
'(4 0 4)</code></pre>
<p>Error, <code>maximal-minimal-palindromic-base</code> not found!</p>
<p>Okay, more seriously, what does that even look like? Let's <code><a href="http://docs.racket-lang.org/search/index.html?q=plot">plot</a></code>!</p>
<pre class="scheme"><code>(require plot)

; Plot a whole range of minimal palindromic bases
(define (plot-minimal-palindromic-bases n-min n-max)
  (plot (lines (for/list ([i (in-range n-min (+ n-max 1))])
                 (vector i (minimal-palindromic-base i)))
               #:color 6
               #:label "minimal palindromic base")))</code></pre>
<p>Basically, we're going to draw a chart relating each number to it's minimal palindromic base.</p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 100)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png" /></a></p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 1000)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png" /></a></p>
<p>Looks like like there's basically two behaviors. A background noise of really low bases (binary or trinary is often palindromic just because there aren't many digits) and a few spikes growing ever larger. Neat.</p>
<p>And that's it. Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/minimal-palindromic-base.rkt">minimal-palindromic-base.rkt</a></p>]]></content></entry><entry><title>Number words</title><link href="http://blog.jverkamp.com/2014/08/13/number-words" /><id>urn:uuid:67236730-531b-effa-30b3-b69308ea8187</id><updated>2014-08-13T14:00:00Z</updated><summary type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
<!--more-->
<p>That may look fairly straight forward. Basically, it's a <a href="https://en.wikipedia.org/wiki/parsing">parsing</a>/<a href="https://en.wikipedia.org/wiki/lexing">lexing</a> problem. You take a string as input and break it into a series of tokens (in this case, numbers 1-26); then each token is converted into a letter.</p>
<p>Unfortunately, it's a bit more complicated than that, since the grammar is ambiguous. Taking the example <code>1234</code> from above, should you parse that as <code>1 2 3 4 = ABCD</code>? Or what about <code>1 23 4 = AWD</code>? Or even <code>12 3 4 = LCD</code>? In a nutshell, we have to do all of them. So we want some sort of branching lexer that will try all possible routes.</p>
<p>So let's start with a function that meta-function that can make such a parser:</p>
<pre class="scheme"><code>; Make an optional parser
; If the regex matches, add it to each possible next parse
; If it does not, return an empty list (to be appendable)
(define (make-parser re)
  (λ (str)
    (match str
      [(regexp re (list _ n rest))
       (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
      [any
       '()])))</code></pre>
<p>Looks a bit funny, (especially since we haven't defined <code>number-&gt;words</code> yet), but basically we try to match the regular expression. If that works, make the recursive call (to <code>number-&gt;words</code>) and then append that string (as a character via <code>n->char</code>) to each recursive result. If there are no recursive results, this <code>map</code> will return an empty list. Likewise, if the regular expression doesn't match.</p>
<p>Next step, write the two parsers. We want to parse either a single digit number or a two digit number:</p>
<pre class="scheme"><code>; Create parsers for valid 1 digit and 2 digit letter numbers
(define parse-1 (make-parser #px"([1-9])(.*)"))
(define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))</code></pre>
<p>That's what makes the ambiguity the most interesting. If only <code>0</code> were a valid digit... As it is, there are four possible cases (and these two functions handle them all!):</p>
<ul>
    <li><code>str</code> starts with 1 and a digit 0-9, parse both</li>
    <li><code>str</code> starts with 2 and a digit 0-6, parse both</li>
    <li><code>str</code> starts with 2 and a digit 7-9, parse 2 digits only</li>
    <li><code>str</code> starts with 3-9, parse 1 digit only</li>
</ul>
<p>And finally, try both:</p>
<pre class="scheme"><code>; Base case, so we can stop eventually
(if (equal? str "")
    '("")
    (append (parse-1 str) (parse-2 str)))</code></pre>
<p>The base case looks a bit funny, since you might assume that if neither case matches we'll get there. That's the difference between the empty list <code>'()</code> and the list containing just an empty string <code>'("")</code>. In the latter, there's nothing to map against, ergo necessary.</p>
<p>And then all we need is the <code>n->char</code> function:</p>
<pre class="scheme"><code>; Convert a number 1-26 to a letter A-Z
(define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))</code></pre>
<p>And that's it. Put it all together:</p>
<pre class="scheme"><code>; Given 1-26 mapping to A-Z, determine all possible words represented by a number
; Correctly resolve ambiguities where 1234 -&gt; 1 2 3 4 = ABCD / 1 23 4 -&gt; AWD / 12 3 4 -&gt; LCD
(define (number-&gt;words str)
  ; Convert a number 1-26 to a letter A-Z
  (define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))

  ; Make an optional parser
  ; If the regex matches, add it to each possible next parse
  ; If it does not, return an empty list (to be appendable)
  (define (make-parser re)
    (λ (str)
      (match str
        [(regexp re (list _ n rest))
         (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
        [any
         '()])))

  ; Create parsers for valid 1 digit and 2 digit letter numbers
  (define parse-1 (make-parser #px"([1-9])(.*)"))
  (define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))

  ; Base case, so we can stop eventually
  (if (equal? str "")
      '("")
      (append (parse-1 str) (parse-2 str))))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (number-&gt;words "1234")
'("ABCD" "AWD" "LCD")

&gt; (number-&gt;words "8675309")
'("HFGECI")

&gt; (length (number-&gt;words "85121215231518124"))

1181

&gt; (number-&gt;words "85121215231518124")
'(... "HELLOWORLD" ...)</code></pre>
<p>I could claim that I just happen to know the number code for <code>HELLOWORLD</code>, but really I wrote a quick inverse function:</p>
<pre class="scheme"><code>; Convert words back to numbers
(define (words-&gt;number str)
  (define (char-&gt;n c) (number-&gt;string (- (char-&gt;integer c) 64)))
  (apply ~a (for/list ([c (in-string str)]) (char-&gt;n c))))</code></pre>
<p>Shiny!</p>
<p>Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/number-words.rkt">number-words.rkt</a></p>]]></content></entry></feed>