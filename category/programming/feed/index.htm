<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-04-17T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:bdbdd0f8-f9c2-fda3-168c-52092e959085</id><entry><title>It's all Greek to me</title><link href="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me" /><id>urn:uuid:b361ed4c-c170-609c-a31d-3fbc5642e648</id><updated>2015-04-17T00:00:00Z</updated><summary type="html"><![CDATA[<p>A few days ago an interesting article came across my RSS feeds: <a href="http://flowingdata.com/2015/04/14/its-all-greek-or-chinese-or-spanish-or-to-me/">It’s All Greek (or Chinese or Spanish or…) to Me</a>. Basically, in English, when you're confused, you'll often say 'It's all Greek to me'. It turns out that man (if not all) languages around the world have a similar saying, but the target varies. Luckily, Wikipedia has a lovely page about it: <a href="https://en.wikipedia.org/wiki/Greek_to me">Greek to me</a>.</p>
]]></summary><content type="html"><![CDATA[<p>A few days ago an interesting article came across my RSS feeds: <a href="http://flowingdata.com/2015/04/14/its-all-greek-or-chinese-or-spanish-or-to-me/">It’s All Greek (or Chinese or Spanish or…) to Me</a>. Basically, in English, when you're confused, you'll often say 'It's all Greek to me'. It turns out that man (if not all) languages around the world have a similar saying, but the target varies. Luckily, Wikipedia has a lovely page about it: <a href="https://en.wikipedia.org/wiki/Greek_to me">Greek to me</a>.</p>
<!--more-->
<p>When I posted the link to Facebook, I got a quick question: are there any cycles? While one could just scan through the document, it would be a lot more interesting (at least to me!) if you could do it automatically. Let's toss together a quick script to do it.</p>
<p>First thing we need: a way to get the content of the Wikipedia page. Python is great for this, with <a href="http://docs.python-requests.org/en/latest/">requests</a> to grab the page and <a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a> to process it:</p>
<pre class="python"><code>content = requests.get('https://en.wikipedia.org/wiki/Greek_to_me').text
soup = bs4.BeautifulSoup(content)

table = soup.find('table', {'class': 'wikitable sortable'})

pairs = collections.defaultdict(set)

for row in table.findAll('tr'):
    cols = row.findAll('td')
    if not cols:
        continue

    if len(cols) == 5:
        srcs = [src.strip() for src in cols[0].text.split(',')]

    dsts = [dst.strip() for dst in cols[-1].text.split(',')]
    for i, dst in enumerate(dsts):
        dsts[i] = re.sub(r'[\[(].*?[\])]', '', dst)

    for src in srcs:
        if ' ' in src: continue

        for dst in dsts:
            if ' ' in dst: continue

            pairs[src].add(dst)</code></pre>
<p>Basically, we download the page. Then we go through each of the rows (<code>tr</code>). Skip any rows without column elements (<code>td</code>) as that's probably the header, otherwise, pull them out. The first column (index <code>0</code>) is the language with the idiom (English in the example) while the last column (index <code>-1</code>) is the target (Greek). There's one caveat though, that sometimes the table uses a <code>rowspan</code> when one source can have multiple targets but is only listed once. We check that by only changing the <code>srcs</code> when there are 5 columns.</p>
<p>Parse through all of that and what do you have?</p>
<pre class="python"><code>&gt;&gt;&gt; import pprint
&gt;&gt;&gt; pprint.pprint(dict(pairs))
{u'': set([]),
 u'Afrikaans': set([u'Greek']),
 u'Albanian': set([u'Chinese']),
 u'Arabic': set([u'Chinese', u'Garshuni']),
 ...
 u'Vietnamese': set([u'Cambodian']),
 u'Volap\xfck': set([]),
 u'Yiddish': set([u'Aramaic'])}</code></pre>
<p>Exactly what I was looking for. Okay, next step. Find any cycles in the graph. This is straight forward enough by performing a <a href="https://en.wikipedia.org/wiki/depth_first search">depth first search</a>:</p>
<pre class="python"><code>def cycle(node, seen):

    for neighbor in pairs[node]:
        new_seen = seen + [neighbor]

        if neighbor in seen:
            yield new_seen[new_seen.index(neighbor):]
        else:
            for recur in cycle(neighbor, new_seen):
                yield recur</code></pre>
<p>The basic idea is to make a generator that returns each cycle as it finds it. It does so by search down each branch, maintaining a list of all nodes it has <code>seen</code>. If it sees the same node twice, that's a cycle. Otherwise, try all of the neighbors. We avoid infinite loops since there's a guaranteed base case to the recursion: <code>seen</code> is always one bigger on each step and it's maximum size is the number of nodes in the graph.</p>
<p>So how does it work?</p>
<pre class="python"><code>&gt;&gt;&gt; for result in cycle('English', ['English']):
...     print result
...
['English', u'Greek', u'Chinese', u'English']
['English', u'Greek', u'Turkish', u'Arabic', u'Chinese', u'English']
['English', u'Greek', u'Turkish', u'French', u'Chinese', u'English']
['English', u'Greek', u'Turkish', u'French', u'Hebrew', u'Chinese', u'English']
['English', u'Dutch', u'Chinese', u'English']</code></pre>
<p>Neat! We've already found 5 cycles that involve English alone. But how many cycles are there all together? For that, we need a way to determine if a cycle is actually unique. If you have the cycles <code>A -> B -> C -> A</code>, that's the same as <code>B -> C -> A -> B</code>. You can do this by putting the cycles in <a href="https://en.wikipedia.org/wiki/lexical_order">lexical order</a> (so that the 'smallest' element in the cycle is first).</p>
<pre class="python"><code>def reorder(cycle):
    if cycle[0] == cycle[-1]:
        cycle = cycle[1:]

    smallest = min(cycle)
    for el in list(cycle):
        if el == smallest:
            break
        else:
            cycle = cycle[1:] + [cycle[0]]

    return cycle</code></pre>
<p>It also is smart enough that if we pass it a list with the first and last node the same (as we will), it trims that off automatically.</p>
<pre class="python"><code>&gt;&gt;&gt; reorder(['A', 'B', 'C', 'A'])
['A', 'B', 'C']
&gt;&gt;&gt; reorder(['B', 'C', 'A', 'B'])
['A', 'B', 'C']</code></pre>
<p>Bam. So we use that and a <code>set</code> to keep track of what we've seen:</p>
<pre class="python"><code>&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; for src in pairs.keys():
...     for result in cycle(src, [src]):
...         result = reorder(result)
...         if not str(result) in seen:
...             print(result)
...             seen.add(str(result))
...
[u'Chinese', u'English', u'Greek']
[u'Chinese', u'English', u'Dutch']
[u'Arabic', u'Chinese', u'English', u'Greek', u'Turkish']
[u'Chinese', u'English', u'Greek', u'Turkish', u'French']
[u'Chinese', u'English', u'Greek', u'Turkish', u'French', u'Hebrew']</code></pre>
<p>Huh. So they all go through English. I didn't actually expect that. :) Still, it's cool to be able to unify them like that.</p>
<p>Okay, one last trick. Let's visualize them. Luckily, there's a nice Python interface for <a href="https://pypi.python.org/pypi/graphviz">graphviz</a> that we can use:</p>
<pre class="python"><code># --- Render a nice graph ---

g = graphviz.Digraph()
for src in pairs.keys():
    for dst in pairs[src]:
        g.edge(src, dst)

g.graph_attr['overlap'] = 'false'
g.graph_attr['splines'] = 'true'

g.format = 'png'
g.engine = 'neato'

g.render('greek-to-me')</code></pre>
<p><a href="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me.png" /></a></p>
<p>Awesome.</p>
<p>It's not the easiest thing in the world to read, but if you look carefully you can pick out a few interesting things. Let's tweak it a bit to color nodes if and only if they have both an inward edge and an outward one:</p>
<pre class="python"><code>for src in pairs.keys():
    # Does this node lead to another
    has_out = pairs[src]

    # Does any node lead to this one
    has_in = False
    for dst in pairs.keys():
        if src in pairs[dst]:
            has_in = True
            break

    # If both, color it
    if has_out and has_in:
        g.node(src, color = 'blue')
</code></pre>
<p><a href="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me-color-nodes.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me-color-nodes.png" /></a></p>
<p>That's a little better, all of the nodes in any cycle are in there. Let's go ahead and show all of the edges in any cycle:</p>
<pre class="python"><code># Get all edges that are part of a cycle
cycle_edges = set()
for cycle in cycles:
    for src, dst in zip(cycle, cycle[1:]):
        cycle_edges.add((src, dst))
    cycle_edges.add((cycle[-1], cycle[0]))

for src in pairs.keys():
    for dst in pairs[src]:
        if (src, dst) in cycle_edges:
            g.edge(src, dst, color = 'blue')
        else:
            g.edge(src, dst)</code></pre>
<p><a href="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me-color.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/17/its-all-greek-to-me/greek-to-me-color.png" /></a></p>
<p>So they're all in that pocket. If I had a few more minutes, I could show all of the cycles as different colors, but that gets complicated in that many re-use the same paths. So it goes.</p>
<p>If you'd like to see / run the code, you can grab it from GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/greek-to-me.py">greek-to-me.py</a></p>]]></content></entry><entry><title>A Quick Look at RC4</title><link href="http://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4" /><id>urn:uuid:7faa7241-8deb-6230-5db2-37d89e5af00c</id><updated>2015-04-14T00:00:00Z</updated><summary type="html"><![CDATA[<p>In cryptography work, <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> (Rivest Cipher 4) is well known as both one of the easiest to implement and fastest to run <a href="https://en.wikipedia.org/wiki/symmetric_encryption">symmetric encryption</a> algorithms. Unfortunately, over time there have been a number of attacks on RC4, both in poorly written protocols (such as in the case of <a href="https://en.wikipedia.org/wiki/WEP">WEP</a>) or statistical attacks against the protocol itself.</p>
<p>Still, for how well it formed, it's an amazingly simple algorithm, so I decided to try my hand at implementing it.</p>
]]></summary><content type="html"><![CDATA[<p>In cryptography work, <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> (Rivest Cipher 4) is well known as both one of the easiest to implement and fastest to run <a href="https://en.wikipedia.org/wiki/symmetric_encryption">symmetric encryption</a> algorithms. Unfortunately, over time there have been a number of attacks on RC4, both in poorly written protocols (such as in the case of <a href="https://en.wikipedia.org/wiki/WEP">WEP</a>) or statistical attacks against the protocol itself.</p>
<p>Still, for how well it formed, it's an amazingly simple algorithm, so I decided to try my hand at implementing it.</p>
<!--more-->
<p>Basically, RC4 is what is known as a '<a href="https://en.wikipedia.org/wiki/stream_cipher">stream cipher</a>', implying that each byte in the input message is encrypted individually (generally taking into account feedback from previous bytes). This runs counter to the perhaps more well known <a href="https://en.wikipedia.org/wiki/block_ciphers">block ciphers</a> such as DES and AES, where bytes are instead encrypted together (although feedback between blocks is still of course possible).</p>
<p>The first step of the algorithm is to take your encryption key (a password or the like) and convert it into a sequence of bytes at least as long as your input. For RC4, this is done in two pieces. First, prepare the index:</p>
<pre class="python"><code>def rc4(key, msg):
    S = list(range(256))

    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    ...</code></pre>
<p>Or in Racket:</p>
<pre class="racket"><code>(define (rc4 key msg)
  (define (mod256 n) (modulo n 256))

  (define permutation (make-bytes 256))
  (for ([i (in-range 256)])
    (bytes-set! permutation i i))

  (define (S i)
    (bytes-ref permutation i))

  (define (swap! i j)
    (let ([pi (bytes-ref permutation i)]
          [pj (bytes-ref permutation j)])
      (bytes-set! permutation i pj)
      (bytes-set! permutation j pi)))

  ; Key-scheduling algorithm
  (for/fold ([j 0]) ([i (in-range 256)])
    (let ([j (mod256 (+ j
                        (S i)
                        (bytes-ref key (modulo i (bytes-length key)))))])
      (swap! i j)
      j))

  ...)</code></pre>
<p>I made the Racket version a little more verbose with helper functions, since I know I'll both be indexing the permutation and swapping values again in the next step. That's one of the reasons that I'll sometimes go for Python over Racket in on off scripts.</p>
<p>Still, relatively simple in both cases.</p>
<p>The next step is to turn that into a stream, essentially creating an infinite number generator. Luckily, both Python and Racket have generators, which are perfectly suited for this sort of thing (assuming in both cases that <code>S</code> / <code>permutation</code> are in scope from above):</p>
<pre class="python"><code>def rc4(key, msg):
    ...

    def prga():
        i = j = 0
        while True:
            i = (i + 1) % 256
            j = (j + S[i]) % 256
            S[i], S[j] = S[j], S[i]
            yield S[(S[i] + S[j]) % 256]

    return prga # DEBUG</code></pre>
<pre class="racket"><code>(define (rc4 key msg)
  ...

  ; Pseudo-random generation algorithm
  (define prga
    (generator ()
      (let loop ([i 1] [j (S 1)])
        (swap! i j)
        (yield (S (mod256 (+ (S i) (S j)))))
        (loop (mod256 (+ i 1)) (mod256 (+ j (S (+ i 1))))))))

  prng) ; DEBUG</code></pre>
<p>Now that we have a stream, we can generate a few bytes and take a look if we wanted:</p>
<pre class="python"><code>&gt;&gt;&gt; import binascii, itertools
&gt;&gt;&gt; prga = rc4(b'Secret', b'Attack at dawn')
&gt;&gt;&gt; print(binascii.hexlify(bytes(itertools.islice(prga(), 10))))
b'04d46b053ca87b594172'</code></pre>
<pre class="racket"><code>(define (bytes-&gt;hex b*)
  (apply ~a (for/list ([b (in-bytes b*)])
        (~a (number-&gt;string (quotient b 16) 16)
            (number-&gt;string (modulo b 16) 16)))))

&gt; (define prga (rc4 "Secret" "Attack at dawn"))
&gt; (bytes-&gt;hex (apply bytes (for/list ([i (in-range 10)] [b (in-producer prga)]) b)))
"04d46b053ca87b594172"</code></pre>
<p>Both of them the same? Good sign. Both matching the example on the Wikipedia page? Even better!</p>
<p>So, we have an infinite stream of bytes. What next?</p>
<p>Well, this is actually the crazy part: You just <a href="https://en.wikipedia.org/wiki/xor">xor</a> them.</p>
<pre class="python"><code>def rc4(key, msg):
    ...

    return bytes(msgbyte ^ keybyte for msgbyte, keybyte in zip(msg, prga()))</code></pre>
<pre class="racket"><code>(define (rc4 key msg)
  ...

  ; Encryption
  (apply bytes
    (for/list ([input-byte (in-bytes msg)] [key-byte (in-producer prga)])
      (bitwise-xor input-byte key-byte))))</code></pre>
<p>And now we can encrypt!</p>
<pre class="python"><code>&gt;&gt;&gt; print(binascii.hexlify(rc4(b'Secret', b'Attack at dawn')))
b'45a01f645fc35b383552544b9bf5'</code></pre>
<pre class="racket"><code>&gt; (bytes-&gt;hex (rc4 "Secret" "Attack at dawn"))
"45a01f645fc35b383552544b9bf5"</code></pre>
<p>And decrypt!</p>
<pre class="python"><code>&gt;&gt;&gt; rc4(b'Secret', rc4(b'Secret', b'Attack at dawn'))
b'Attack at dawn'</code></pre>
<pre class="racket"><code>&gt; (rc4 "Secret" (rc4 "Secret" "Attack at dawn"))
#"Attack at dawn"</code></pre>
<p>Very cool. I'm really starting to see the appeal of RC4. A couple dozen lines of Python/Racket and you're encrypting. Bam. As mentioned, it's not really an algorithm you should use in encryption any more (the author has released a slightly more complicated algorithm called Spritz that works very similarly).</p>
<p>And that's it. If you'd like to see the entire code in one place (along with some fiddling in both cases to deal with Unicode keys/messages as well as pure bytes), it's on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/rc4.py">rc4.py</a>, <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/rc4.rkt">rc4.rkt</a>.</p>
<p><code>7b82 c5cf 12c4 e168 8a4a 5cbe 9300</code></p>
<p><img alt="smile" class="emoji" src="/emoji/smile.svg" /></p>]]></content></entry><entry><title>Generating perfect portmanteaus</title><link href="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus" /><id>urn:uuid:0b6a158d-e441-c880-5fcf-4d4a1394e61d</id><updated>2015-04-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>A quick programming post, since it's been a while, inspired by this video:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/QVn2PZGZxaI" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>I'm not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
]]></summary><content type="html"><![CDATA[<p>A quick programming post, since it's been a while, inspired by this video:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/QVn2PZGZxaI" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>I'm not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<!--more-->
<p>Basically<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>, a portmanteau is a combination of two words, smooshing them together<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span> and dropping some letters from each. In this case, what I'm specifically interested in is 'perfect' portmanteaus (I'm not sure if there is a better term for it), where the suffix of one word exactly matches the prefix of the other.</p>
<p>As an example, consider the words <code>hamster</code> and <code>termine</code>. The last three letters of the former, perfectly matches the first three of the latter, so let's overlap them. <code>hamstermite</code>. Bam.</p>
<p>So how do we do it?</p>
<pre class="racket"><code>(define current-minimum-overlap (make-parameter 3))

(define (portmanteau left right)
  (define maximum-overlap (- (min (string-length left) (string-length right)) 1))

  (for*/first ([overlap (in-range maximum-overlap (- (current-minimum-overlap) 1) -1)]
               #:when (equal? (substring left (- (string-length left) overlap))
                              (substring right 0 overlap)))
    (list left
          right
          (string-append
           (substring left 0 (- (string-length left) overlap))
           right))))</code></pre>
<p>Should be straight forward enough. Basically, we start with the longest possible overlap (1 less than the length of the shorter word, since we don't want to completely subsume a word), counting down until we reach some minimum overlap. For each possible sequence, we compare the prefix and suffix of the two words, only proceeding into the body of the loop when they match. That's the beauty of <code><a href="http://docs.racket-lang.org/search/index.html?q=for*/first">for*/first</a></code>, it will loop until it gets a valid value, returning when it does.</p>
<p>And that's really it. Try it out with the example from earlier:</p>
<pre class="racket"><code>&gt; (portmanteau "hamster" "termite")
'("hamster" "termite" "hamstermite")</code></pre>
<p>Since that was so quick, let's put some simple wrapper code around it in order to find all portmanteaus from a given word list. First, do the heavy lifting of finding portmanteaus:</p>
<pre class="racket"><code>(define (portmanteaus)
  (define words
    (for*/list ([raw-line (in-lines)]
                [line (in-value (string-trim (string-downcase raw-line)))]
                #:when (not (equal? "" line)))
      line))

  (for*/list ([left (in-list words)]
              [right (in-list words)]
              #:when (not (eq? left right))
              [portmanteau (in-value (portmanteau left right))]
              #:when portmanteau)
    portmanteau))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=in-value">in-value</a></code> is useful in <code><a href="http://docs.racket-lang.org/search/index.html?q=for*">for*</a></code> since it lets you bind a single value for future <code>#:when</code> blocks without having to recalculate anything.</p>
<p>After that, a wrapper to process some command line parameters and render output in a few different ways:</p>
<pre class="racket"><code>(define paths
  (command-line
   #:program "portmanteau"
   #:once-each
   [("--minimum-overlap")
    overlap
    "Specify the minimum necessary overlap (default = 3)"
    (cond
      [(string-&gt;number overlap) =&gt; current-minimum-overlap]
      [else (error '--minimum-overlap "must specify a number")])]
   #:once-any
   [("--verbose")
    "Print in verbose mode (default = false)"
    (verbose-mode #t)]
   [("--graph")
    "Print out a dotfile"
    (graph-mode #t)]
   #:args paths

   paths))

(when (null? paths)
  (set! paths '("-")))

(for ([path (in-list paths)])
  (define results
    (cond
      [(equal? path "-")
       (portmanteaus)]
      [else
       (with-input-from-file path portmanteaus)]))

  (define g (unweighted-graph/directed '()))

  (for ([result (in-list results)])
    (match-define (list left right portmanteau) result)
    (cond
      [(verbose-mode)
       (printf "~a + ~a = ~a\n" left right portmanteau)]
      [(graph-mode)
       (add-edge! g (~a "\"" left "\"") (~a "\"" right "\""))]
      [else
       (displayln portmanteau)]))

  (when (graph-mode)
    (displayln (graphviz g))))</code></pre>
<p>Now you can do some interesting things:</p>
<pre class="bash"><code>$ racket portmanteau.rkt animals.txt

brown recluse spider monkey
gila monstermite
grasshopperegrine falcon
hamstermite
leechidna
ottermite</code></pre>
<p>Just in case you cannot figure out what animals actually went into that list:</p>
<pre class="bash"><code>$ racket portmanteau.rkt --verbose animals.txt

brown recluse spider + spider monkey = brown recluse spider monkey
gila monster + termite = gila monstermite
grasshopper + peregrine falcon = grasshopperegrine falcon
hamster + termite = hamstermite
leech + echidna = leechidna
otter + termite = ottermite</code></pre>
<p>Or if you want to be a little more general, matching with only 2 characters rather than the default 3:</p>
<pre class="bash"><code>$ racket portmanteau.rkt --minimum-overlap 2 --verbose animals.txt

armadillo + loon = armadilloon
armadillo + lorikeet = armadillorikeet
armadillo + louse = armadillouse
black mamba + badger = black mambadger
brown bear + armadillo = brown bearmadillo
brown recluse spider + spider monkey = brown recluse spider monkey
chinchilaa + aardvark = chinchilaardvark
copperhead snake + kestrel = copperhead snakestrel
coyote + termite = coyotermite
crow + owl = crowl
eagle + leech = eagleech
eagle + leopard seal = eagleopard seal
echidna + narwhal = echidnarwhal
gecko + koala = geckoala
gila monster + termite = gila monstermite
grasshopper + peregrine falcon = grasshopperegrine falcon
hamster + termite = hamstermite
hyena + narwhal = hyenarwhal
jackal + albatross = jackalbatross
king cobra + rattlesnake = king cobrattlesnake
king cobra + raven = king cobraven
kingsnake + kestrel = kingsnakestrel
kiwi + wild boar = kiwild boar
leech + chinchilaa = leechinchilaa
leech + echidna = leechidna
leopard seal + albatross = leopard sealbatross
narwhal + albatross = narwhalbatross
ostrich + chinchilaa = ostrichinchilaa
otter + termite = ottermite
polar bear + armadillo = polar bearmadillo
rattlesnake + kestrel = rattlesnakestrel
sloth bear + armadillo = sloth bearmadillo
snapping turtle + leech = snapping turtleech
snapping turtle + leopard seal = snapping turtleopard seal
sparrow + owl = sparrowl
sperm whale + leech = sperm whaleech
sperm whale + leopard seal = sperm whaleopard seal
sponge + gecko = spongecko
swan + anaconda = swanaconda
wild boar + armadillo = wild boarmadillo</code></pre>
<p>Heh. Narwhalbatross. Wild boarmadillo. <img alt="smile" class="emoji" src="/emoji/smile.svg" /></p>
<p>And as a final bonus, using the <a href="https://github.com/stchang/graph/tree/master">graph</a> library I've used (and contributed to) before, we can render the structure of the thing):</p>
<pre class="bash"><code>$ racket portmanteau.rkt --graph --minimum-overlap 2 animals.txt \
    | sed "s/edge \[dir=none\];//g" \
    | fdp -Tpng &gt; animals.png \
    && open animals.png</code></pre>
<p><a href="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/animals.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/animals.png" /></a></p>
<p>Fun. :)</p>
<p>Think of the arrows as going from the stuck on word to where it's sticking rather than in the order the words would be written. It's easy enough to change though if you'd like, just swap the arguments in the <code>add-edge!</code> call above.</p>
<p>And... that's it. Not much more to do with this one, unless I want to duplicate the above video and portmanteau all the things! We'll see.</p>
<p>As with all my code, you can see the entire thing on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/portmanteau.rkt">portmanteau.rkt</a></p>]]></content></entry><entry><title>Performance problems with Flask and Docker</title><link href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker" /><id>urn:uuid:8d7d8e5b-effe-34a6-b190-d0068d5879a0</id><updated>2015-04-03T00:00:00Z</updated><summary type="html"><![CDATA[<p>I had an interesting problem recently on a project I was working on. It's a simple <a href="http://flask.pocoo.org/">Flask</a>-based webapp, designed to be deployed to <a href="https://aws.amazon.com/">AWS</a> using <a href="https://www.docker.com/">Docker</a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container...</p>
<p>Latency spikes. Bad enough that the application was failing AWS's healthy host checks, cycling in and out of existence<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>I had an interesting problem recently on a project I was working on. It's a simple <a href="http://flask.pocoo.org/">Flask</a>-based webapp, designed to be deployed to <a href="https://aws.amazon.com/">AWS</a> using <a href="https://www.docker.com/">Docker</a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container...</p>
<p>Latency spikes. Bad enough that the application was failing AWS's healthy host checks, cycling in and out of existence<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/health-check.png" /></a></p>
<!--more-->
<p>At that time, the only traffic to the container was the health checks, every 30 seconds, as regular as clockwork. So it wasn't load that was making them fail. And it was exactly the same code each time<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>:</p>
<pre class="python"><code>@app.route('/', methods = ['GET'])
def healthcheck():
    return "I'm a teapot"</code></pre>
<p>So not that either. So what in the world was going on?</p>
<p>Google to the rescue! <code><a href="https://www.google.com/search?q=flask application periodically slow">flask application periodically slow</a></code></p>
<p>The very first link is a response on StackOverflow:</p>
<blockquote>
    On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes “localhost” is configured to be available on both ipv4 and ipv6 socktes and some browsers will try to access ipv6 first and then ivp4. -- <a href="http://stackoverflow.com/questions/11150343/slow-requests-on-local-flask-server">Slow Requests on Local Flask Server</a>
</blockquote>
<p>Huh. Get a shell into my docker container, and what do you know:</p>
<pre class="bash"><code>$ cat /etc/hosts
172.17.1.112	27392a3e0fa5
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters</code></pre>
<p>Yup. <code>localhost</code> routes to both IPv4's <code>127.0.0.1</code> and IPv6's <code>::1</code>. Comment out the <code>::1</code> line and give it a shot... Yup. That did it. Waited ten minutes and the hosts weren't marked unhealthy once. All I should need to do is add it to the <code>Dockerfile</code> and we should be golden, yes?</p>
<pre class="text"><code>$ vi Dockerfile
...
RUN sed -i "s/::1.*//g"
...

$ docker build .
...
Step 9 : RUN sed -i "s/::1.*//g" /etc/hosts
 ---&gt; Running in 7c73dc473507
sed: cannot rename /etc/sedXZv0Yy: Device or resource busy</code></pre>
<p>What.</p>
<pre class="text"><code>$ vi Dockerfile
...
RUN sed "s/::1.*//g" /etc/hosts &gt; /etc/hosts-new && mv /etc/hosts-new /etc/hosts
...

$ docker build .
...
RUN sed "s/::1.*//g" /etc/hosts &gt; /etc/hosts-new && mv /etc/hosts-new /etc/hosts
 ---&gt; Running in d6b896f4fc9e
sed: cannot rename /etc/sedqYrfxO: Device or resource busy</code></pre>
<p>Double what.</p>
<p>Back to Google: <code><a href="https://www.google.com/search?q=docker edit hosts">docker edit hosts</a></code></p>
<p>Specifically: <a href="https://github.com/docker/docker/issues/1951">Unable to modify /etc/hosts file in a container #1951</a>. Looks like there was a fix that would let you edit <code>/etc/hosts</code> if you were in a container (that used to not be possible), but (because it's actually mounted rather than just a container file), it's non-trivial to edit it as part of a build.</p>
<p>All righty then.</p>
<p>That's about when I decided to listen to the Flask documentation:</p>
<blockquote>You can use the builtin server during development, but you should use a full deployment option for production applications. (Do not use the builtin development server in production.)</blockquote>
<p>All right. Not only is it what I'm actually supposed to be doing, but if I used CGI, I can avoid Flask trying to resolve <code>localhost</code> at all. I've worked with <a href="http://wiki.nginx.org/Main">nginx</a> before. Let's use that.</p>
<p>Picking some documentation from a hat, I decided to use <a href="https://uwsgi-docs.readthedocs.org/en/latest/">uWSGI</a> as the glue between nginx and Flask. Easy enough to install with pip (although I had to grab a C compiler from the apt package <code>build-essential</code>) and off we go.</p>
<p>First, a small <code>nginx</code> config:</p>
<pre class="nginx"><code>location / { try_files $uri @project; }
location @project {
    include uwsgi_params;
    uwsgi_pass unix:/tmp/uwsgi.sock;
}</code></pre>
<p>Then, to start it all up, a change to the <code>Dockerfile</code> <code>CMD</code>:</p>
<pre class="bash"><code>CMD uwsgi -s /tmp/uwsgi.sock -w project:app --chown-socket=www-data:www-data --enable-threads & \
    nginx -g 'daemon off;'</code></pre>
<p>That <code>--chown-socket</code> flag really drove me a bit batty. Basically, <code>uwsgi</code> was starting as the <code>root</code> user (within the Docker container). <code>nginx</code> was starting as <code>root</code>. But the <code>nginx</code> threads were not. They were starting as <code>www-data</code> and thus couldn't read the Unix socket between the two.</p>
<p>All righty then.</p>
<p>Let's go!</p>
<p>Starting successfully... And it's running. Not on the first try or even the 10th (I left out quite a bit of fumbling around tweaking flags), but eventually as was well in the world.</p>
<p>Push it out to AWS...</p>
<p>Health check passed.</p>
<p>Bam.</p>
<p>Awesome.</p>
<p>Now I not only have a neat little webapp, I have one that doesn't randomly decide to take forever on every other request or so.</p>
<p>If you're looking for the bare minimum <code>requirements.txt</code> and <code>Dockerfile</code> that I'm using (in addition to that <code>nginx</code> host configuration file above), here they are:</p>
<p><code>requirements.txt</code></p>
<pre class="text"><code>flask
flup6
uwsgi</code></pre>
<p><code>Dockerfile</code>:</p>
<pre class="text"><code>FROM ubuntu:14.04

RUN apt-get update && apt-get install -y build-essential nginx python3.4 python3.4-dev
RUN easy_install3 pip

WORKDIR /project

ADD requirements.txt /project/requirements.txt
RUN pip install -r requirements.txt

ADD . /project

ADD nginx /etc/nginx

CMD uwsgi -s /tmp/uwsgi.sock -w project:app --chown-socket=www-data:www-data --enable-threads & \
    nginx -g 'daemon off;'</code></pre>
<p>It's for moments like these that I do software. That little moment when everything comes together just right and it all just ... works.</p>]]></content></entry><entry><title>Parsing AWS instance data with jq</title><link href="http://blog.jverkamp.com/2015/04/01/parsing-aws-instance-data-with-jq" /><id>urn:uuid:db7917d7-1267-4fde-d9a4-c2d153f23979</id><updated>2015-04-01T00:00:00Z</updated><summary type="html"><![CDATA[<p>Semi-random amusing code snippet of the day:</p>
<pre class="bash"><code>aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF</code></pre>
]]></summary><content type="html"><![CDATA[<p>Semi-random amusing code snippet of the day:</p>
<pre class="bash"><code>aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF</code></pre>
<!--more-->
<p>Basically, it's combining the <a href="https://aws.amazon.com/cli/">AWS command line tools</a> and the excellent <a href="https://stedolan.github.io/jq/"><code>jq</code></a> tool for parsing JSON to extract a field from all instances with a particular tag on your AWS account (whatever account you have configured in your <code>~/.aws/</code> directory).</p>
<p>To describe it a little bit more, the data is structured as a list of <code>Instance</code> objects. The first line of the <code>jq</code> query loops over each instance object.</p>
<p>Next, each of those has zero or more <code>Tags</code> (the <code>[]?</code> is to not fail if the tag object is empty), with <code>Key</code> and <code>Value</code> entries. <code>select</code> is a new feature I hadn't seen before which will pass along an object if the condition holds. These are essentially equivalent:</p>
<pre class="text"><code> select(condition) </code></pre>
<pre class="text"><code> if condition then . else empty end </code></pre>
<p>After that, we extract a given field. In this particular case, I wanted IP addresses, but there are a bunch of other fields you can access. Here are a few other interesting ones:</p>
<ul>
    <li>AmiLaunchIndex</li>
    <li>Architecture</li>
    <li>ImageId</li>
    <li>InstanceId</li>
    <li>InstanceType</li>
    <li>LaunchTime</li>
    <li>PrivateDnsName</li>
    <li>PrivateIpAddress</li>
    <li>PublicDnsName</li>
    <li>PublicIpAddress</li>
    <li>SecurityGroups</li>
    <li>State</li>
    <li>SubnetId</li>
    <li>Tags</li>
</ul>
<p>The beauty of doing this directly in the shell is that you can then chain it to something else. For example, what if I wanted to log into every production server in turn and ask how much free disk space they have:</p>
<pre class="bash"><code>for IP in aws ec2 describe-instances | jq &lt;&lt; EOF
    .[][].Instances[]
    | select(.Tags[]?.Value == "production")
    | .PrivateIpAddress
EOF
do
    echo $IP
    ssh $IP du -h
    echo
done</code></pre>
<p>I'm really starting to admire the 'Do One Thing and Do It Well' philosophy of Unix and chaining things together.</p>]]></content></entry><entry><title>gif shrinkage with ImageMagick</title><link href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick" /><id>urn:uuid:ca361209-13d0-9725-3b15-9d0d7f368a98</id><updated>2015-03-05T00:00:00Z</updated><summary type="html"><![CDATA[<p>I have a gif collection now. :)</p>
<p><a href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>I have a gif collection now. :)</p>
<p><a href="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/03/05/gif-shrinkage-with-imagemagick/dun-dun-dunnnnn.gif" /></a></p>
<!--more-->
<p>One problem with gifs is that they tend to be somewhat sizable. To keep that at least a little under control, I've added a quick script to my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> to trim all files passed on the command line to a maximum edge size of 256 pixels:</p>
<pre class="bash"><code>#!/bin/bash

tmpdir=&lt;code&gt;mktemp -d /tmp/shrink-gifs.XXXX&lt;/code&gt;
echo "$tmpdir"

for file in "$@"
do
  echo "$file"
  convert "$file" -alpha on -channel rgba -coalesce -resize 256x256 -layers OptimizeFrame -colors 64 "$tmpdir/$file"
  mv "$tmpdir/$file" "$file"
done</code></pre>
<p>Basically, I'm using the excellent <a href="http://www.imagemagick.org/">ImageMagick</a> software, specifically the <code>convert</code> utility. All of those flags are necessary since gifs have layers. This results in both a properly converted gif but also a somewhat optimized palette.</p>
<p>Also, we're using a temporary directory rather than using the in place version of <code>convert</code>: <code>mogrify</code>. For whatever reason, <code>mogrify</code> doesn't seem to work on gifs. So it goes.</p>
<p>As a side note, <code>identify</code> (another tool that comes with ImageMagick) is really useful. Give it an image and it will tell you how large it is, all on the command line.</p>
<p>This script (and all of my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a>) is available on GitHub: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/shrink-gifs">shrink-gifs</a></p>]]></content></entry><entry><title>ts: Timestamping stdout</title><link href="http://blog.jverkamp.com/2015/02/26/ts-timestamping-stdout" /><id>urn:uuid:43f98a4d-4ef7-1979-023a-32bf8724a10d</id><updated>2015-02-26T00:00:00Z</updated><summary type="html"><![CDATA[<p>Loving data as much as I do, I like to <a href="http://blog.jverkamp.com/category/programming/by-topic/optimization">optimize</a> things. To make sure I'm actually going the right way, it's useful to time things. While it's trivial in most languages to add timing, it's even easier if you don't have to.</p>
]]></summary><content type="html"><![CDATA[<p>Loving data as much as I do, I like to <a href="http://blog.jverkamp.com/category/programming/by-topic/optimization">optimize</a> things. To make sure I'm actually going the right way, it's useful to time things. While it's trivial in most languages to add timing, it's even easier if you don't have to.</p>
<!--more-->
<p>To that end, here is <code>ts</code>, a tool for adding timestamps to each line of <code>stdin</code>:</p>
<pre class="python"><code>#!/usr/bin/env python3

import sys
import time

def stamp(line):
    now = time.strftime("[%Y-%m-%d %H:%M:%S]", time.localtime())
    sys.stdout.write('{0} {1}\n'.format(now, line.strip('\n')))
    sys.stdout.flush()

stamp('--- &lt;ts&gt; ---')

for line in sys.stdin:
    stamp(line)

stamp('--- &lt;/ts&gt; ---')</code></pre>
<p>For example:</p>
<pre class="bash"><code>$ python long-running-script.py | ts

[2015-02-25 17:05:35] --- &lt;ts&gt; ---
[2015-02-25 17:05:35] things
[2015-02-25 17:05:43] stuff
[2015-02-25 17:05:53] all done
[2015-02-25 17:05:53] --- &lt;/ts&gt; ---</code></pre>
<p>Whee!</p>
<p>If you'd like to download this or any of my other <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a>, you can do so on on GitHub: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/ts">ts</a>.</p>]]></content></entry><entry><title>update-dotfiles encryption</title><link href="http://blog.jverkamp.com/2015/02/11/update-dotfiles-encryption" /><id>urn:uuid:da93efa1-4aa3-e880-6082-ac2b0647ffa5</id><updated>2015-02-11T00:00:00Z</updated><summary type="html"><![CDATA[<p>I do like having my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> on GitHub. For one, it means that they're always available when I set up a new machine. For two, others can see them and take whatever is interesting for their own dotfiles. But all that has a disadvantage: what if I want to store my SSH configs?</p>
]]></summary><content type="html"><![CDATA[<p>I do like having my <a href="http://blog.jverkamp.com/category/programming/by-topic/dotfiles">dotfiles</a> on GitHub. For one, it means that they're always available when I set up a new machine. For two, others can see them and take whatever is interesting for their own dotfiles. But all that has a disadvantage: what if I want to store my SSH configs?</p>
<!--more-->
<p>Technically, they're not secret. I don't have my actual SSH keys in there. But I do have some names of machines and at least not having those on the GitHub means that the spiders trolling the repos have at least one more step before finding them. Especially those running on non-standard ports.</p>
<p>To that end, here's a quick script to AES encrypt / decrypt files with Python.</p>
<p>First, we want something that can turn any password into an AES key. Since they have to be an exact number of bits a hashing function works particularly well here:</p>
<pre class="python"><code>def get_key():
    if 'AESKEY' in os.environ:
        key = os.environ['AESKEY']
    else:
        key = getpass.getpass('AES passphrase: ')

    return hashlib.sha256(key.encode('utf-8')).digest()</code></pre>
<p>(Yes, I should be using a <a href="https://en.wikipedia.org/wiki/Password-Based_Key Derivation Function">Password-Based Key Derivation Function</a>. So it goes.)</p>
<p>Next, the encryption function. We need to set up a random <a href="https://en.wikipedia.org/wiki/initialization_vector">initialization vector</a>.</p>
<p>Then, since the file might not be evenly divisible into blocks, we'll need to pad it. Since we want this to be able to deal with binary or other files, there's no guarantee that we can tell when a file has ended. So we'll use the <code>struct</code> library to store the file length as well. Given that we're storing the size as a 64-bit integer, we'll be able to store files up to 18.56 exabytes. Yeah, I think we'll be fine for a while.</p>
<p>Finally, we want to add a hash so we can verify that the file was not tampered with via <a href="https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac">encrypt-then-MAC</a>. All together:</p>
<pre class="python"><code>def encrypt(file):

    key = get_key()

    iv = os.urandom(16)
    encryptor = AES.new(key, AES.MODE_CBC, IV = iv)

    with open(file, 'rb') as fin:
        content = fin.read()

    # Store the original file size as uint64 and pad to 16 bytes
    content = struct.pack('&gt;Q', len(content)) + content
    content = content + (b'\0' * (16 - len(content) % 16))

    content = encryptor.encrypt(content)
    hash = hashlib.sha256(content).digest()

    content = base64.b64encode(iv + hash + content)

    outfile = file + '.aes'
    with open(outfile, 'wb') as fout:
        fout.write(content)</code></pre>
<p>Straight forward.</p>
<p>Likewise, decryption pulls apart the parts of the file, checks the integrity with the hash, then decrypts:</p>
<pre class="python"><code>def decrypt(file):

    key = get_key()

    with open(file, 'r') as fin:
        content = fin.read()

    content = base64.b64decode(content)
    if len(content) &lt; 32:
        print('Malformed content: not enough data')
        sys.exit(1)

    iv = content[:16]
    hash = content[16:48]
    content = content[48:]

    if hash != hashlib.sha256(content).digest():
        print('Failed hash check')
        sys.exit(1)

    decryptor = AES.new(key, AES.MODE_CBC, IV = iv)
    content = decryptor.decrypt(content)

    fileSize = struct.unpack('&gt;Q', content[:8])[0]
    content = content[8:fileSize+8]

    outfile = file[:-4]
    with open(outfile, 'wb') as fout:
        fout.write(content)</code></pre>
<p>Shiny. Now let's tweak the script that updates dotfiles to handle encrypted files:</p>
<p>Basically, the only code that changes is if the user choose <code>y</code> to replace a file. If that file ends with <code>.aes</code>, ask for the password and try to decrypt it.</p>
<pre class="python"><code>...

# If the file is encrypted, decrypt it
if path.endswith('.aes'):
    try:
        if not aes:
            aes = imp.load_source('aes', os.path.expanduser('~/.bin/aes'))

        if aes:
            print('{0} decrypting'.format(path))
            aes.decrypt(path)
            shutil.copymode(path, path[:-4])
            path = path[:-4]
    except:
        print('{0} cannot decrypt, aes does not exist'.format(path))

...</code></pre>
<p>One caveat is that since the <code>aes</code> library is stored without the <code>py</code> suffix, we load it dynamically with the <code>imp</code> module. I love how that's possible (even easy) in Python.</p>
<p>And that's about it. I've moved my SSH configs over and vastly expended them with a number of servers that I work with on a daily basis. Also there's another level which allows for different environments (work or home) and operating systems (to deal with different keyboard standards).</p>
<p>Very cool.</p>
<p>If you'd like to see the full source for either piece, you can on GitHub:</p>
<ul>
    <li><a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/aes">aes</a></li>
    <li><a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/update-dotfiles">update-dotfiles</a></li>
</ul>]]></content></entry><entry><title>docker-bash and docker-stop-all</title><link href="http://blog.jverkamp.com/2015/02/04/docker-bash-and-docker-stop-all" /><id>urn:uuid:37898d58-3ad2-b30c-7f9e-5b00c18e6e8a</id><updated>2015-02-04T00:00:00Z</updated><summary type="html"><![CDATA[<p>I've been using <a href="https://www.docker.com/">Docker</a> a fair bit at work, so I've added a few quick aliases to my dotfiles make that a little bit easier:</p>
<ul>
    <li><code>docker-bash</code> - attach a <code>bash</code> shell to the first available docker instance</li>
    <li><code>docker-stop-all</code> - stop all running docker instances</li>
</ul>
]]></summary><content type="html"><![CDATA[<p>I've been using <a href="https://www.docker.com/">Docker</a> a fair bit at work, so I've added a few quick aliases to my dotfiles make that a little bit easier:</p>
<ul>
    <li><code>docker-bash</code> - attach a <code>bash</code> shell to the first available docker instance</li>
    <li><code>docker-stop-all</code> - stop all running docker instances</li>
</ul>
<!--more-->
<p>The implementation for both is pretty straight forward:</p>
<p><code>docker-bash</code>:</p>
<pre class="bash"><code> docker exec -it &#96;docker ps -q | head -n 1&#96; bash </code></pre>
<p><code>docker-stop-all</code>:</p>
<pre class="bash"><code>  docker ps -q | xargs docker stop </code></pre>
<p>Neither is <em>that</em> complicated to remember, but I type both often enough throughout the day that it's nice to save that dozen or so characters.</p>]]></content></entry><entry><title>iOS Backups in Racket: Apps</title><link href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps" /><id>urn:uuid:761445ba-06be-d1cd-b496-1e52081d2f71</id><updated>2015-01-29T00:00:00Z</updated><summary type="html"><![CDATA[<p>So far we've read <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">backup files</a>, parsed <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>, and parsed <a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">messages</a>. Today we're going to dig a little deeper and start parsing apps specifically.</p>
]]></summary><content type="html"><![CDATA[<p>So far we've read <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">backup files</a>, parsed <a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">contacts</a>, and parsed <a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">messages</a>. Today we're going to dig a little deeper and start parsing apps specifically.</p>
<!--more-->
<p>First things first, let's get a list of applications. That's actually in two different files: <code>Manifest.plist</code> and <code>Manifest.mbdb</code>. In versions of iTunes prior to 9.2, <code>Manifest.plist</code> had a nice listing of files, but now it only contains the list of applications. Still, that's a good enough place to start.</p>
<p>Remember back in the <a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">first post</a>? We learned how how to read plist files. In this one in particular, we have a list of installed applications, using their internal names:</p>
<pre class="racket"><code>(struct app (name plist files) #:prefab #:mutable)
(struct file (name path) #:prefab)

; List all installed applications
(define (list-apps)
  (hash-ref!
   apps-by-backup
   (current-backup)
   (λ ()
     (for/list ([name (in-list
                       (hash-ref
                        (call-with-input-file
                          (build-path (backup-path (current-backup))
                                                   "Info.plist")
                          read-plist/jsexpr)
                        '|Installed Applications|))])
       (app name #f #f)))))</code></pre>
<p>For the moment, we'll leave out the plist and files. Eventually, plist is going to store a list of properties stored with the application (all apps have it, even if some don't store anything interesting). Files will store any files stored in the local filesystem for app in specific.</p>
<p>So how does it work?</p>
<pre class="racket"><code>&gt; (with-backup "86b1...aa36"
    (map app-name (list-apps)))
'("com.google.Maps"
  "com.apple.mobilesms.notification"
  "com.roku.ios.roku"
  ...
  "com.apple.iBooks"
  "com.apple.MobileSMS"
  "com.apple.CoreAuthUI")</code></pre>
<p>Neat. That's pretty much exactly what I was hoping to see.</p>
<p>Next, let's load up the plists. On doing some digging around, it looks like every app will have a file with a path something like <code>AppDomain-Library/Preferences/{app-name}.plist</code>, so let's try to load that:</p>
<pre class="racket"><code>; Load an app's plist file
(define (load-plist! app)
  (set-app-plist!
   app
   (let ([plist-path
          (build-path
           (backup-path (current-backup))
           (hash-filename
            (~a "Library/Preferences/" (app-name app) ".plist")
            (~a "AppDomain-" (app-name app))))])

     ; Try to load in text mode first, if that fails fall back to binary
     (with-handlers ([exn? (λ (exn)
                             (call-with-input-file plist-path
                               read-plist/jsexpr/binary))])
       (call-with-input-file plist-path read-plist/jsexpr)))))</code></pre>
<p>Here we run into our first wrinkle. It turns out that while the <code><a href="http://docs.racket-lang.org/search/index.html?q=xml/plist">xml/plist</a></code> file works just fine on the text format plist files, it doesn't deal well with binary ones. And unfortunately most (if not all) apps use the binary format. So we need something that will be able to convert and load those (warning, this is ugly):</p>
<pre class="racket"><code>; Read a plist file as a JSON expression from a binary plist file
(define (read-plist/jsexpr/binary [in (current-input-port)])
  ; Copy the file to a temporary path
  (define temp-filename (~a (gensym) ".plist"))
  (call-with-output-file temp-filename
    (λ (out) (copy-port in out)))

  ; Run Apple's plutil to convert it
  ; Redirect err to suppress from missing programs
  (parameterize ([current-error-port (open-output-nowhere)])
    (for* ([path
            (in-list
              '("plutil"
                "plutil.exe"
                "\"C:\\Program Files (x86)\\Common Files\\Apple\\Apple Application Support\\plutil.exe\""
                ""\"C:\\Program Files\\Common Files\\Apple\\Apple Application Support\\plutil.exe\""))]
           [return (in-value (system (~a path " -convert xml1 " temp-filename)))]
           #:break return)
      #t))

  ; Patch over xml/plist's handling of empty string element
  (define plist-fixed-content
    (regexp-replace* #px"&lt;string&gt;&lt;/string&gt;"
                     (file-&gt;string temp-filename)
                     "&lt;string&gt; &lt;/string&gt;"))
  (delete-file temp-filename)

  ; Read the plist into memory and remove the temporary file
  (call-with-input-string plist-fixed-content read-plist/jsexpr))</code></pre>
<p>Basically, if you have iTunes installed, it comes with a program (on Windows, it's built in on OSX) called <code>plutil</code>. That can be used to convert between binary, xml, and json formats of plist files. Unfortunately though, the json format cannont handle a lot of plists, so we have to convert to xml and then use our previous <code>plist->jsexpr</code> function to convert it.</p>
<p>Other hacks: we have to copy it to a temporary file. It's probably possible to open <code>plutil</code> and pass the file on stdin and read from stdout instead, but this works so we'll leave it as is for the moment.</p>
<p>Finally, another caveat of the <code><a href="http://docs.racket-lang.org/search/index.html?q=xml/plist">xml/plist</a></code> library: it breaks on empty string elements. So there's a fix above to take any empty string elements and insert a single space into them. Hacky, but so it goes. When all this is said and done though, we can use this to read in the plist data for an application:</p>
<pre class="racket"><code>&gt; (with-backup "86b18eea28a991f4dd569d1f59737a842e24aa36"
    (let ([app (list-ref (list-apps) 12)])
      (load-plist! app)
      app))

'#s((app #(0 1 2))
    "com.google.Maps"
    #hash((WebKitCacheModelPreferenceKey . 1)
          (WebKitDiskImageCacheSavedCacheDirectory . " ")
          (WebKitMediaPlaybackAllowsInline . #t)
          (WebKitOfflineWebApplicationCacheEnabled . #t)
          (WebKitShrinksStandaloneImagesToFit . #t)
          ...
          (kGIPMicPermissionControllerPermissionRequested . #t)
          (kGMSMapsUserClientLegalCountry . "US")
          (kGMSUserEvent3LoggerSequenceIDKey . 8860))
    #f)</code></pre>
<p>Whee! For any particular app, I'm not entirely sure what I'm looking for, but there's a whole heck of a lot of information there.</p>
<p>But one thing that I was hoping to find is still missing: a list of files for a given application. I was hoping each application would know that, but apparently not. Then again, why would they? A given application probably knows exactly what files it's looking for, it doesn't have to list them.</p>
<p>Fine. I guess I have to read that <code>Manifest.mbdb</code> file.</p>
<pre class="bash"><code>$ xxd "Manifest.mbdb"

0000000: 6d62 6462 0500 001d 4170 7044 6f6d 6169  mbdb....AppDomai
0000010: 6e2d 636f 6d2e 6f6f 6b6c 612e 7370 6565  n-com.ookla.spee
0000020: 6474 6573 7400 00ff ffff ffff ff41 ed00  dtest........A..
0000030: 0000 0000 005f bc00 0001 f500 0001 f554  ....._.........T
0000040: 3044 1354 3044 1354 2757 c900 0000 0000  0D.T0D.T'W......
0000050: 0000 0000 0000 1d41 7070 446f 6d61 696e  .......AppDomain
0000060: 2d63 6f6d 2e6f 6f6b 6c61 2e73 7065 6564  -com.ookla.speed
0000070: 7465 7374 0007 4c69 6272 6172 79ff ffff  test..Library...
0000080: ffff ff41 ed00 0000 0000 0013 b600 0001  ...A............
0000090: f500 0001 f554 2757 c954 2758 1f54 1b09  .....T'W.T'X.T..
00000a0: df00 0000 0000 0000 0000 0000 1d41 7070  .............App
00000b0: 446f 6d61 696e 2d63 6f6d 2e6f 6f6b 6c61  Domain-com.ookla
...</code></pre>
<p>Right. That's some sort of binary file. I can see the app names repeated several times for each app, but we're still going to have to figure out the format.</p>
<p>Luckily for me, the format has already been relatively well reverse engineered<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. First, we have a file header, the bytes <code>mbdb\5\0</code>. The last two are probably versioning, but so far as I can tell, it hasn't changed. So we'll skip over that for the moment.</p>
<p>Next, we have a sequence of records:</p>
<table class="table">
    <thead>
        <tr><td>Type</td><td>Name</td><td>Note</td></tr>
    </thead>
    <tbody>
        <tr><td>string</td><td>domain</td><td>Used for <code>hash-filename</code></td></tr>
        <tr><td>string</td><td>path</td><td></td></tr>
        <tr><td>string</td><td>target</td><td>Absolute path, only for <a href="https://en.wikipedia.org/wiki/symlinks">symlinks</a></td></tr>
        <tr><td>string</td><td>data hash</td><td>SHA1 (for encrypted files)</td></tr>
        <tr><td>string</td><td>encryption key </td><td></td></tr>
        <tr><td>uint16</td><td>mode</td><td>file/directory/symlink (see below)</td></tr>
        <tr><td>uint64</td><td><a href="https://en.wikipedia.org/wiki/inode">inode</a></td><td></td></tr>
        <tr><td>uint32</td><td>user id</td><td></td></tr>
        <tr><td>uint32</td><td>group id</td><td></td></tr>
        <tr><td>uint32</td><td>last modified</td><td></td></tr>
        <tr><td>uint32</td><td>last accessed</td><td></td></tr>
        <tr><td>uint32</td><td>created at</td><td></td></tr>
        <tr><td>uint64</td><td>file size</td><td>0 for symlinks and directories</td></tr>
        <tr><td>uint8</td><td>data protection class</td><td>0 if special (link, directory), otherwise ranges from 1-11</td></tr>
        <tr><td>uint8</td><td>property count</td><td>number of properties following</td></tr>
    </tbody>
</table>
<p>This is then followed by a list of properties:</p>
<table class="table">
    <thead>
        <tr><td>Type</td><td>Name</td><td>Note</td></tr>
    </thead>
    <tbody>
        <tr><td>string</td><td>name</td><td></td></tr>
        <tr><td>string</td><td>value</td><td>either UTF8 or binary data</td></tr>
    </tbody>
</table>
<p>That sounds pretty straight forward (relatively speaking). Let's write a function to read it. We want to fill out this structure:</p>
<pre class="racket"><code>(struct record (domain path hash mode size properties) #:prefab)
(struct property (name value) #:prefab)</code></pre>
<p>In general LISP style (so far as I understand it), we will write a series of functions named <code>read-*</code>, each of which will read the specified form of data from the current input port. Then, for example, we can have a <code>read-mbdb</code> function, which calls <code>read-record</code>, which in turn has a bunch of calls to either <code>read-uint</code> or <code>read-string</code> followed by zero or more calls to <code>read-property</code>.</p>
<p>Starting at the outermost layer, lets read an entire file. Specifically, we want a function that will read off those 6 header bytes then continuously read records until the end of the file:</p>
<pre class="racket"><code>; Read mdbd records until eof
(define (read-mbdb [in (current-input-port)])
  (read-bytes 6 in)
  (let loop ()
    (cond
      [(eof-object? (peek-char in)) '()]
      [else
       (cons (read-record in) (loop))])))</code></pre>
<p>Having that, we need the ability to read an individual record:</p>
<pre class="racket"><code>; Read an mbdb record
(define (read-record [in (current-input-port)])

  (define domain (read-string-data in))
  (define path (read-string-data in))
  (define link-target (read-string-data in))
  (define data-hash (read-string-data in))
  (define encryption-key (read-string-data in))

  (define raw-mode (read-uint 2 in))
  (define mode
    (case (arithmetic-shift raw-mode -12)
      [(#xA) (list 'symlink link-target)]
      [(#x8) 'file]
      [(#x4) 'directory]))

  (define inode (read-uint 8 in))
  (define user-id (read-uint 4 in))
  (define group-id (read-uint 4 in))

  (define last-modified (read-uint 4 in))
  (define last-accessed (read-uint 4 in))
  (define created-at (read-uint 4 in))
  (define file-size (read-uint 8 in))

  (define data-protection-class (read-uint 1 in)) ; 0x1 to 0xB
  (define property-count (read-uint 1 in))

  (define properties
    (for/list ([i (in-range property-count)])
      (define name (read-string-data in))
      (define value (read-string-data in))
      (property name value)))

  (define hash (hash-filename path domain))

  (record domain path hash mode file-size properties))</code></pre>
<p>Other than the missing functions, one caveat here is the definition of <code>mode</code>. I'm not actually sure what's in the other three half bytes, but all we care about is in the first. If it's <code>A</code>, it's a symlink. <code>8</code> is a file; <code>4</code> is a directory. That handles every entry at least on my phone.</p>
<p>Also, you may note that we're not returning all of the data in the records. Honestly, for most of it I just don't need it. It's useful if you're trying to do more interesting things and then write back to the backup, but just to read it? We don't care about user/group ids, et al. It's all there though, with just a tweak. Perhaps I'll figure out a way to pull out the full record if wanted in the future.</p>
<p>Okay, so next, what does it mean to <code>read-uint</code>? Well, we're going to have anywhere from 1 to 8 bytes, which we then need to turn into a single value. That's easy enough doing a base conversion (from essentially base 256 to base 10):</p>
<pre class="racket"><code>; Read size bytes as a big-endian unsigned integer
(define (read-uint size [in (current-input-port)])
  (define b* (read-bytes size in))
  (for/sum ([i (in-naturals)]
            [b (in-bytes b*)])
    (* (expt 256 (- (bytes-length b*) i 1)) b)))</code></pre>
<p>Cool. That means that all that's left is reading strings. Luckily, they have a nice format. Rather than <a href="https://en.wikipedia.org/wiki/null_terminated strings">null terminated strings</a> a la C/C++, they store first the length of the string (as a <code>uint16</code>) and then that many bytes. There are two caveats though:</p>
<ul>
    <li>If the size is maxed (<code>#xFFFF</code>), it's actually empty</li>
    <li>This same datatype can be either a UTF8 string or raw binary data (try to parse it as a string, fall back to bytes)</li>
</ul>
<p>Codewise:</p>
<pre class="racket"><code>; Read a length + string, if length if #xFFFF the string is empty
; Note: Sometimes 'strings' are actually binary data, return those as bytes
(define (read-string-data [in (current-input-port)])
  (define size (read-uint 2 in))
  (cond
    [(equal? size #xFFFF) ""]
    [else
     (define raw (read-bytes size in))
     (with-handlers ([exn? (λ (_) raw)])
       (bytes-&gt;string/utf-8 raw))]))</code></pre>
<p>Cool.</p>
<pre class="racket"><code>&gt; (with-backup "86b1...aa36"
    (call-with-input-file (build-path (backup-path (current-backup))
                                      "Manifest.mbdb")
      read-mbdb))
'(#s(record "AppDomain-com.ookla.speedtest" "" #f directory 0 ())
  #s(record "AppDomain-com.ookla.speedtest" "Library" "83fee2b4383a3d59c99185862e220d5a0a77d546" directory 0 ())
  #s(record "AppDomain-com.ookla.speedtest" "Library/Preferences" "726b41739d2c95794288f354134f75515db58dbd" directory 0 ())
  #s(record
     "AppDomain-com.ookla.speedtest"
     "Library/Preferences/com.ookla.speedtest.plist"
     "dc4081fac8bf5bdf6ed025d3da24e6b8a287c4fb"
     file
     620
     ())
  #s(record
     "AppDomain-com.ookla.speedtest"
     "Library/Preferences/com.apple.PeoplePicker.plist"
     "f9e644265dbcc0a7179c631e0ba3173868663b04"
     (symlink "/private/var/mobile/Library/Preferences/com.apple.PeoplePicker.plist")
     0
     ())
  ...)</code></pre>
<p>It's kind of neat how cleanly binary formats can actually be read at least if they're relatively well documented.</p>
<p>Let's go ahead and add this to the <code>app</code> structure and then write a helper as we have before to find a specific app:</p>
<pre class="racket"><code>; Load the list of files associated with an app
(define (load-files! app)
  (define app-domain (~a "AppDomain-" (app-name app)))

  (set-app-files!
   app
   (for/list ([record (in-list (list-mdbd-records))]
              #:when (and (equal? (record-domain record) app-domain)
                          (eq? 'file (record-mode record))))
     (file (record-path record)
           (build-path (backup-path (current-backup)) (record-hash record))))))

; Find an app by name (actually a case insensative regex)
; plists and files in domain are loaded when this is called and cached
(define (find-app name)
  (define app
    (for/first ([app (in-list (list-apps))]
                #:when (regexp-match (~a "(?i:" name ")") (app-name app)))
      app))

  ; If this app is missing it's plist / files, load them
  (when (and app (not (app-plist app))) (load-plist! app))
  (when (and app (not (app-files app))) (load-files! app))

  app)</code></pre>
<p>Yes, this does has the disadvantage that if you just <code>list-apps</code>, you won't get the plists and file lists. On the flip side though, this one uses a regex, so you can just search by app name. Most developers (although not all I've found) will include that as part of their internal name. They take a bit to load though, especially if you have a lot of apps, so I think that's a fair enough trade off. It's still caching <code>Manifest.mbdb</code> though, so at least that only has to be read once:</p>
<pre class="racket"><code>(define mdbd-records-by-backup (make-hash))
(hash-set! mdbd-records-by-backup #f '())

; Get all MDBD records
(define (list-mdbd-records)
  (hash-ref!
   mdbd-records-by-backup
   (current-backup)
   (λ ()
     (call-with-input-file (build-path (backup-path (current-backup))
                                       "Manifest.mbdb")
       read-mbdb))))</code></pre>
<p>Once you start digging through these lists, there are some pretty interesting files ... but that will have to wait for another post. This one is already pretty long. I think I'll have at least one more post in this series taking everything I've done thus far and turning it into an actual backup solution. Keep an eye out!</p>
<p>The full source thus far (and I've finally caught up) is on GitHub: <a href="https://github.com/jpverkamp/ios-backup">ios-backup</a>.</p>
<p>If you've installed <code>ios-backup</code> as a library, you can import these new functions with <code>(require ios-backup/apps)</code> or if you really want to get adventerous <code>(require ios-backup/mbdb)</code>.</p>
<p>Here is a list of all of the posts in this series:</p>
<ul class="list-unstyled"><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/22/ios-backups-in-racket-groundwork">iOS Backups in Racket: Groundwork</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/23/ios-backups-in-racket-contacts">iOS Backups in Racket: Contacts</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/27/ios-backups-in-racket-messages">iOS Backups in Racket: Messages</a></li><li class="post-listing"><a href="http://blog.jverkamp.com/2015/01/29/ios-backups-in-racket-apps">iOS Backups in Racket: Apps</a></li></ul>]]></content></entry></feed>