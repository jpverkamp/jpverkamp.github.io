<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Word Games on jverkamp.com</title><link>https://blog.jverkamp.com/2015/04/07/word-games/</link><description>Recent content in Word Games on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 07 Apr 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/2015/04/07/word-games/atom.xml" rel="self" type="application/rss+xml"/><item><title>Generating perfect portmanteaus</title><link>https://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/</guid><description>&lt;p>A quick programming post, since it&amp;rsquo;s been a while, inspired by this video:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
 &lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/QVn2PZGZxaI?autoplay=0&amp;amp;controls=1&amp;amp;end=0&amp;amp;loop=0&amp;amp;mute=0&amp;amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video">&lt;/iframe>
 &lt;/div>

&lt;p>I&amp;rsquo;m not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>Number words</title><link>https://blog.jverkamp.com/2014/08/13/number-words/</link><pubDate>Wed, 13 Aug 2014 14:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2014/08/13/number-words/</guid><description>&lt;p>Today&amp;rsquo;s five minute post brought to you via &lt;a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis&lt;/a> / &lt;a href="http://www.careercup.com/question?id=5120347909128192">Career Cup&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -&amp;gt; A, 2 -&amp;gt; B, …, 26 -&amp;gt; Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.&lt;/p>&lt;/blockquote></description></item><item><title>Dis/re-emvowelification</title><link>https://blog.jverkamp.com/2014/02/27/dis/re-emvowelification/</link><pubDate>Thu, 27 Feb 2014 14:00:21 +0000</pubDate><guid>https://blog.jverkamp.com/2014/02/27/dis/re-emvowelification/</guid><description>&lt;p>So far this week we&amp;rsquo;ve had a pair of related posts at the DailyProgrammer subreddit&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/" target="_blank" rel="noopener">[02/24/14] Challenge #149 [Easy] Disemvoweler&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/1yzlde/022614_challenge_150_intermediate_reemvoweler_1/" target="_blank" rel="noopener">[02/26/14] Challenge #150 [Intermediate] Re-emvoweler 1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Basically, if you&amp;rsquo;re given a string with vowels, take them out. If you&amp;rsquo;re given one without vowels, put them back in. One of the two is certainly easier than the other&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. :)&lt;/p></description></item><item><title>Path to philosophy</title><link>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</link><pubDate>Thu, 28 Mar 2013 14:00:05 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</guid><description>&lt;p>Yesterday, &lt;a title="Daily programmer sub-reddit" href="http://www.reddit.com/r/dailyprogrammer/">the daily programmer Subreddit&lt;/a> had &lt;a title="[03/27/13] Challenge #121 [Intermediate] Path to Philosophy" href="http://www.reddit.com/r/dailyprogrammer/comments/1b3ka1/032713_challenge_121_intermediate_path_to/">a post that&lt;/a> mirrored a problem I&amp;rsquo;ve often seen before: the idea that if you follow first links ((With some caveats)) on &lt;a href="https://en.wikipedia.org/wiki/Main%20Page">Wikipedia&lt;/a>, you eventually end with &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>. For example, if you follow the first links from &lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a>, you get the following path:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Atom">Atom&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Matter">Matter&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Rest%20Mass">Rest Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Invariant%20Mass">Invariant Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Energy">Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Kinetic%20Energy">Kinetic Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Physics">Physics&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Natural%20Philosophy">Natural Philosophy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>&lt;/p>&lt;/blockquote></description></item><item><title>NPR Sunday Puzzle</title><link>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</link><pubDate>Wed, 20 Feb 2013 14:00:26 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</guid><description>&lt;p>&lt;a title="NPR Sunday Puzzle" href="https://programmingpraxis.com/2013/02/19/npr-sunday-puzzle/">Yesterday&amp;rsquo;s puzzle&lt;/a> from Programming Praxis asks us to solve a Sunday Puzzle from NPR:&lt;/p>
&lt;blockquote>
&lt;p>Think of two familiar, unhyphenated, eight-letter words that contain the letters A, B, C, D, E and F, plus two others, in any order. What words are these?&lt;/p>&lt;/blockquote>
&lt;p>It&amp;rsquo;s another in a &lt;a title="jverkamp.com: Word games" href="http://blog.jverkamp.com/tag/word-games/">long history of word games&lt;/a>, my favorite sort of puzzle.&lt;/p></description></item><item><title>Numbers as words in arbitrary bases</title><link>https://blog.jverkamp.com/2013/02/06/numbers-as-words-in-arbitrary-bases/</link><pubDate>Wed, 06 Feb 2013 23:00:10 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/06/numbers-as-words-in-arbitrary-bases/</guid><description>&lt;p>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/17zn6g/020613_challenge_120_intermediate_base_conversion/" title="Challenge #120 [Intermediate] Base Conversion Words">Today&amp;rsquo;s intermediate challenge&lt;/a> on Reddit&amp;rsquo;s /r/dailyprogrammer intrigued me somewhat, so I decided to take a crack at it. The basic idea is if you are given a number, try converting it to all bases from 2 to 64 (with a special encoding). Print out any of those that are words.&lt;/p>
&lt;p>For example, if you interpret the number 44,269 as a &lt;a href="https://en.wikipedia.org/wiki/Hexadecimal">base 16 (Hexadecimal)&lt;/a> number, you get the word &amp;ldquo;aced&amp;rdquo;. So just how many of these words are there out there?&lt;/p></description></item><item><title>Chopping words</title><link>https://blog.jverkamp.com/2012/10/15/chopping-words/</link><pubDate>Mon, 15 Oct 2012 14:00:13 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/15/chopping-words/</guid><description>&lt;p>&lt;a title="Programming Praxis: Chopping Words" href="http://programmingpraxis.com/2012/07/03/chopping-words/">One more challenge&lt;/a> from Programming Praxis&amp;rsquo; &lt;a title="Programming Praxis: Themes: Word Games" href="http://programmingpraxis.com/contents/themes/#Word Games">Word Games&lt;/a> today (there are only a few left!). This time we have the challenge of cutting off bits of words, one letter at a time, such that each step is still a word.&lt;/p>
&lt;p>The example given in their post is &lt;code>planet → plane → plan → pan → an → a&lt;/code>, although surely many such examples exist.&lt;/p></description></item><item><title>Dodgson’s Doublets</title><link>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</link><pubDate>Sun, 14 Oct 2012 14:00:20 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</guid><description>&lt;p>Today we have &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt" target="_blank" rel="noopener">doublets source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt" target="_blank" rel="noopener">dictionary source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt" target="_blank" rel="noopener">queue source code&lt;/a>.&lt;/p>
&lt;p>Using the same source code as the previous two posts (&lt;a href="https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/">here&lt;/a> and &lt;a href="https://blog.jverkamp.com/2012/10/13/word-cubes/">here&lt;/a>, described originally &lt;a href="https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/">here&lt;/a>) for the dictionary, the code is a pretty straight forward case of using &lt;a href="https://en.wikipedia.org/wiki/recursion">recursion&lt;/a> to do &lt;a href="https://en.wikipedia.org/wiki/backtracking">backtracking&lt;/a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; find the path between two words, changing one letters at a time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; use call/cc to bail out when we find an answer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">direct-doublet&lt;/span> dict src dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">call/cc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">λ&lt;/span> (&lt;span style="color:#a6e22e">exit&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([src (&lt;span style="color:#a6e22e">string-upcase&lt;/span> src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [dst (&lt;span style="color:#a6e22e">string-upcase&lt;/span> dst)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; loop down possible solutions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>loop ([current src] [words (list src)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; when we find one, bail out entirely&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(equal? current dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> (reverse words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; try all possible values&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">for*/list&lt;/span> ([i (string-length src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [c &lt;span style="color:#e6db74">&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([next (&lt;span style="color:#a6e22e">string-set&lt;/span> current i c)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">when&lt;/span> (&lt;span style="color:#66d9ef">and &lt;/span>(not (member next words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">contains?&lt;/span> dict next))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">loop&lt;/span> next (cons next words))))))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> &lt;span style="color:#66d9ef">#f&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, I&amp;rsquo;m using a neat trick I last used on the post about &lt;a href="https://blog.jverkamp.com/2012/08/27/4sum/">4SUM&lt;/a> where &lt;code>call/cc&lt;/code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it&amp;rsquo;s a simple matter of using &lt;code>for*&lt;/code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we&amp;rsquo;ve seen before in this path), keep going. Eventually, we&amp;rsquo;ll find a solution and can bail out. On the off chance that we don&amp;rsquo;t, return &lt;code>#f&lt;/code>.&lt;/p></description></item><item><title>Word cubes</title><link>https://blog.jverkamp.com/2012/10/13/word-cubes/</link><pubDate>Sat, 13 Oct 2012 14:00:38 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/13/word-cubes/</guid><description>&lt;p>Continuing in my recent set of &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/word-cube.rkt" target="_blank" rel="noopener">word-cube source code&lt;/a>. Like yesterday, it&amp;rsquo;s designed to work in &lt;a href="http://racket-lang.org" title="(((? Racket)))">Racket 5.3+&lt;/a>.&lt;/p></description></item><item><title>Squaring the Bishop</title><link>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</link><pubDate>Thu, 11 Oct 2012 14:00:40 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</guid><description>&lt;p>Okay, this one was just neat. Based on &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/word-squares.rkt" target="_blank" rel="noopener">word-squares source&lt;/a>. I&amp;rsquo;ve only tested it in &lt;a href="http://racket-lang.org/" title="(((? Racket)))">Racket 5.3+&lt;/a>, but newer versions should work as well. Racket 5.2 won&amp;rsquo;t work without some tweaking as (at the very least) it&amp;rsquo;s missing a definition for &lt;code>string-trim&lt;/code>.&lt;/p></description></item><item><title>Dictionary tries in Racket</title><link>https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/</link><pubDate>Thu, 11 Oct 2012 13:55:38 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/</guid><description>&lt;p>For the next few posts, we&amp;rsquo;re going to need a way to represent a dictionary. You could go with just a flat list containing all of the words in the dictionary, but the runtime doesn&amp;rsquo;t seem optimal. Instead, we want a data structure that lets you easily get all possible words that start with a given prefix. We want a &lt;a href="https://en.wikipedia.org/wiki/trie">trie&lt;/a>.&lt;/p>
&lt;p>&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2012/trie_example.png">
&lt;/figure>
.
Source: &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt" target="_blank" rel="noopener">dictionary source code&lt;/a>&lt;/p></description></item><item><title>Two Word Games</title><link>https://blog.jverkamp.com/2012/10/10/two-word-games/</link><pubDate>Wed, 10 Oct 2012 14:00:09 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/10/two-word-games/</guid><description>&lt;p>Another day, &lt;a title="Programming Praxis: Two Word Games" href="http://programmingpraxis.com/2012/10/09/two-word-games/">another post&lt;/a> from Programming Praxis. Today they posted a word game that seems simple enough: first find all words in a given dictionary that contain all five vowels (a, e, i, o, u) in ascending order and then find any words (at least six letters long) where the letters are all in ascending alphabetical order.&lt;/p></description></item></channel></rss>