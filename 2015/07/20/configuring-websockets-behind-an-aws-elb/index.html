<!doctype html><html><head><title>Configuring Websockets behind an AWS ELB – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Configuring Websockets behind an AWS ELB</h1><div class=entry-meta><span class=entry-date>2015-07-20</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2015/07/16/automagically-storing-python-objects-in-redis/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/aws>AWS</a><a href=https://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/aws-elb>AWS ELB</a></li><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/docker>Docker</a><a href=https://blog.jverkamp.com/2016/04/19/ensuring-docker-machine-is-running/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/flask>Flask</a><a href=https://blog.jverkamp.com/2016/02/26/audiobooks-to-podcasts/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/networks>Networks</a></li><li><a href=https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/websites>Websites</a><a href=https://blog.jverkamp.com/2020/06/10/observation-server/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2015/07/16/automagically-storing-python-objects-in-redis/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/photography/2015/2015-07-19-pacifica-ii/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Recently at work, we were trying to get an application that uses <a href=https://en.wikipedia.org/wiki/websockets>websockets</a> working on an <a href=https://aws.amazon.com/>AWS</a> instance behind an <a href=https://aws.amazon.com/elasticloadbalancing/>ELB (load balancer)</a> and <a href=http://nginx.org/>nginx</a> on the instance.</p><p>If you&rsquo;re either not using a secure connection or handling the cryptography on the instance (either in nginx or Flask), it works right out of the box. But if you want the ELB to handle TLS termination it doesn&rsquo;t work nearly as well&mldr; Luckily, after a bit of fiddling, I got it working.</p><p><strong>Update 2018-05-31:</strong> A much easier solution, [https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/](just use an ALB):</p><blockquote><p><strong>WebSocket</strong> allows you to set up long-standing TCP connections between your client and your server. This is a more efficient alternative to the old-school method which involved HTTP connections that were held open with a “heartbeat” for very long periods of time. WebSocket is great for mobile devices and can be used to deliver stock quotes, sports scores, and other dynamic data while minimizing power consumption. ALB provides native support for WebSocket via the <code>ws://</code> and <code>wss://</code> protocols.</p></blockquote><p>First, we have a basic application. For my purposes, I wrote a quick Websocket chat app: <a href=https://github.com/jpverkamp/ws-chat>ws-chat</a>. The particular implementation details aren&rsquo;t as important. We&rsquo;ll start with the nginx config file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>webserver</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> 127.0.0.1:<span style=color:#ae81ff>8000</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>wsserver</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> 127.0.0.1:<span style=color:#ae81ff>9000</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>server</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>listen</span> <span style=color:#ae81ff>80</span> <span style=color:#e6db74>proxy_protocol</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> <span style=color:#e6db74>/</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>if</span> <span style=color:#e6db74>(</span>$http_x_forwarded_proto = <span style=color:#e6db74>&#34;http&#34;)</span> {
</span></span><span style=display:flex><span>            <span style=color:#f92672>return</span> <span style=color:#ae81ff>301</span> <span style=color:#e6db74>https://</span>$host$request_uri;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://webserver</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> <span style=color:#e6db74>/ws/</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://wsserver</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>proxy_http_version</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>.1</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>Upgrade</span> $http_upgrade;
</span></span><span style=display:flex><span>        <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>Connection</span> <span style=color:#e6db74>&#34;upgrade&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Straight forward enough. We have two backend services: a <a href=https://github.com/jpverkamp/ws-chat/blob/master/app/web-server.py>web server</a> running on port 8000 (a simple Flask server that just servers a single <a href=https://github.com/jpverkamp/ws-chat/blob/master/app/templates/index.html>HTML page</a>) and the <a href=https://github.com/jpverkamp/ws-chat/blob/master/app/ws-server.py>websocket backend</a> running on port 9000. Alternatively, these could be the same codebase. The important parts are that you allow the Websocket <code>upgrade</code> header to pass through to establish the connection and that you tell nginx to listen using the <code>proxy_protocol</code>, an extra header that passes through extra information:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>PROXY_STRING + single space + INET_PROTOCOL + single space + CLIENT_IP + single space + PROXY_IP + single space + CLIENT_PORT + single space + PROXY_PORT + &#34;\r\n&#34;
</span></span></code></pre></div><p>This seems like it wouldn&rsquo;t be necessary, except that without <code>proxy_protocol</code> AWS ELBs seem to strip something important to the connection.</p><p>Next, we need to configure the load balancer. One complication here is that telling the load balancer to forward HTTPS traffic to HTTP will not work for the websockets. Instead, you have to configure it to forward TCP (SSL) to TCP. This will still work for HTTP/HTTPS traffic (as HTTP is just a specific protocol over TCP and HTTPS is just HTTP with a TLS layer), but it will also allow the non-HTTP websocket traffic to pass through successfully. Something like this:</p><figure><img src=/embeds/2015/configure-elb.png></figure><p>(Don&rsquo;t forget to set the certificate :))</p><p>Finally, you have to configure the ELB also to speak proxy protocol. This part is slightly more annoying, since (at least now), there&rsquo;s no way to configure this through the AWS console. You have to use the <a href=https://aws.amazon.com/cli/>AWS CLI</a>.</p><p>First, create the new policy (assuming you have an environment variable <code>ELB_NAME</code> defined):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb create-load-balancer-policy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --load-balancer-name $ELB_NAME <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --policy-name $ELB_NAME-proxy-protocol <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --policy-type-name ProxyProtocolPolicyType <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --policy-attributes AttributeName<span style=color:#f92672>=</span>ProxyProtocol,AttributeValue<span style=color:#f92672>=</span>True
</span></span></code></pre></div><p>Then, attach it to the load balancer. You will have to run this once for each port that the instance is listening on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb set-load-balancer-policies-for-backend-server <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --load-balancer-name $ELB_NAME <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --instance-port <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --policy-names $ELB_NAME-proxy-protocol
</span></span></code></pre></div><p>Make sure that you&rsquo;re using <code>https://</code> for the web traffic and <code>wss://</code> for the websocket and you&rsquo;re golden. Encrypted websockets behind an AWS ELB. Now if only they would expose the proxy protocol options in the console&mldr;</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>