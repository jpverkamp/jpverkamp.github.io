<!doctype html><html><head><title>StackLang Part VII: New CLI and Datatypes â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>StackLang Part VII: New CLI and Datatypes</h1><div class=entry-meta><span class=entry-date>2023-08-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/15/project-euler-9/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/project-euler>Project Euler</a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/assemblers>Assemblers</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/caching>Caching</a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/compilers>Compilers</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/10/02/cleaner-lunar-arithmetic-in-rust/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a></li><li><a class=taxonomy-value href=/programming/topics/memoization>Memoization</a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memory>Memory</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/stacks>Stacks</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/virtual-machines>Virtual Machines</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link></a><a class=taxonomy-value href=/series/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/08/05/guardians-of-the-galaxy-vol.-3/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/08/08/the-goblin-emperor/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another day, another Stacklang!</p><div class=ranking><h3 class=title>Posts in <a href=/series/stacklang/>StackLang</a>:</h3><div class=content><ul><li><a href=https://blog.jverkamp.com/2023/04/14/stacklang-part-i-the-idea/>StackLang Part I: The Idea</a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/>StackLang Part II: The Lexer</a></li><li><a href=https://blog.jverkamp.com/2023/04/24/stacklang-part-iii-the-parser/>StackLang Part III: The Parser</a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/>StackLang Part IV: An Interpreter</a></li><li><a href=https://blog.jverkamp.com/2023/07/12/stacklang-part-v-compiling-to-c/>StackLang Part V: Compiling to C</a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/>StackLang Part VI: Some Examples</a></li><li><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/>StackLang Part VII: New CLI and Datatypes</a></li><li><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/>StackLang Part VIII: Compiler Stacks</a></li><li><a href=https://blog.jverkamp.com/2023/08/12/stacklang-part-ix-better-testing/>StackLang Part IX: Better Testing</a></li></ul></div></div><p>Today, we&rsquo;ve got two main parts to work on:</p><nav id=TableOfContents><ul><li><a href=#a-new-cli>A new CLI</a></li><li><a href=#new-datatypes-vm-only-so-far>New datatypes (VM only; so far!)</a><ul><li><a href=#hash>Hash</a></li><li><a href=#list-stack>List Stack</a></li><li><a href=#cond-statements>Cond statements</a></li><li><a href=#project-euler-problem-14>Project Euler: Problem 14</a></li></ul></li></ul></nav><p>Full source code for StackLang: <a href=https://github.com/jpverkamp/stacklang/ target=_blank rel=noopener>github:jpverkamp/stacklang</a></p><h2 id=a-new-cli>A new CLI</h2><p>In a nutshell:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/stacklang --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The specific subcommands that can be run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: stacklang <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;COMMAND&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  vm       Run a StackLang program using the VM
</span></span><span style=display:flex><span>  compile  Compile a StackLang program to C
</span></span><span style=display:flex><span>  help     Print this message or the help of the given subcommand<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -d, --debug
</span></span><span style=display:flex><span>  -h, --help     Print help
</span></span><span style=display:flex><span>  -V, --version  Print version
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/stacklang vm --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Run a StackLang program using the VM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: stacklang vm &lt;PATH&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arguments:
</span></span><span style=display:flex><span>  &lt;PATH&gt;  Input filename
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -h, --help  Print help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/stacklang compile --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Compile a StackLang program to C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: stacklang compile <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;PATH&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arguments:
</span></span><span style=display:flex><span>  &lt;PATH&gt;  Input filename
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -r, --run              Pass to compile <span style=color:#f92672>(</span>Clang<span style=color:#f92672>)</span> and automatically run
</span></span><span style=display:flex><span>  -o, --output &lt;OUTPUT&gt;  Output filename, defaults to <span style=color:#f92672>{</span>path<span style=color:#f92672>}</span>.c
</span></span><span style=display:flex><span>  -h, --help             Print help
</span></span></code></pre></div><p>I&rsquo;d previously been using a <a href=/2023/07/12/stacklang-part-v-compiling-to-c/#justfile>Justfile</a> to run more complicated examples, but something about that just doesn&rsquo;t feel right.</p><p>Plus, there are different ways to run the different subsystems. For the interpreter/vm, really all you can do is choose the file to run (and possibly the <code>--debug</code> flag), while the compiler can also optionally specify an output filename (for the C file) and a flag to automatically invoke <code>clang</code> to compile the C and run the resulting executable.</p><p>And also, although it&rsquo;s not done yet, I really want to add a <code>stacklang --test</code> harness that can take an <code>example/*.stack</code> file and run and compare the VM, compiler, and previous output as a way of testing that I didn&rsquo;t change anything as I refactor.</p><p>So, how&rsquo;d I do it?</p><p>It&rsquo;s all down to <a href=https://docs.rs/clap/latest/clap/ target=_blank rel=noopener>clap</a>. I was already using it, but noway near to the level I could.</p><p>Now, instead of a simple struct for parameters, I have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The top-level application
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Parser, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[clap(name = </span><span style=color:#e6db74>&#34;stacklang&#34;</span><span style=color:#75715e>, version = </span><span style=color:#e6db74>&#34;0.1.0&#34;</span><span style=color:#75715e>, author = </span><span style=color:#e6db74>&#34;JP Verkamp&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clap(flatten)]</span>
</span></span><span style=display:flex><span>    globals: <span style=color:#a6e22e>GlobalArgs</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clap(subcommand)]</span>
</span></span><span style=display:flex><span>    command: <span style=color:#a6e22e>Command</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Global arguments that apply to all subcommands
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Args, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GlobalArgs</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clap(long, short = &#39;d&#39;)]</span>
</span></span><span style=display:flex><span>    debug: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// The specific subcommands that can be run
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Subcommand, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Command</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clap(name = </span><span style=color:#e6db74>&#34;vm&#34;</span><span style=color:#75715e>, about = </span><span style=color:#e6db74>&#34;Run a StackLang program using the VM&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    Run {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>/// Input filename
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>        path: <span style=color:#a6e22e>PathBuf</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clap(name = </span><span style=color:#e6db74>&#34;compile&#34;</span><span style=color:#75715e>, about = </span><span style=color:#e6db74>&#34;Compile a StackLang program to C&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    Compile {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>/// Pass to compile (Clang) and automatically run
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>        <span style=color:#75715e>#[clap(long, short = &#39;r&#39;)]</span>
</span></span><span style=display:flex><span>        run: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>/// Output filename, defaults to {path}.c
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>        <span style=color:#75715e>#[clap(long, short = &#39;o&#39;)]</span>
</span></span><span style=display:flex><span>        output: Option<span style=color:#f92672>&lt;</span>PathBuf<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>/// Input filename
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>        path: <span style=color:#a6e22e>PathBuf</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, <code>GlobalArgs</code> will be specified at the top level. So I can pass a <code>--debug</code> flag for either <code>vm</code>, <code>compile</code>, or anything I add. And then after that, <code>Command</code> is an <code>enum</code>. Each subcommand gets it&rsquo;s own data.</p><p>And to use it is just as easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Run specified subcommand
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>match</span> args.command {
</span></span><span style=display:flex><span>    Command::Run { path } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> file <span style=color:#f92672>=</span> std::fs::File::open(path).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tokens <span style=color:#f92672>=</span> lexer::tokenize(BufReader::new(file));
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;Tokens: {:#?}&#34;</span>, tokens);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ast <span style=color:#f92672>=</span> parser::parse(tokens);
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;AST:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{:#?}&#34;</span>, ast);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vm::evaluate(ast);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Command::Compile { run, output, path } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> file <span style=color:#f92672>=</span> std::fs::File::open(path.clone()).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tokens <span style=color:#f92672>=</span> lexer::tokenize(BufReader::new(file));
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;Tokens: {:#?}&#34;</span>, tokens);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ast <span style=color:#f92672>=</span> parser::parse(tokens);
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;AST:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{:#?}&#34;</span>, ast);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c_code <span style=color:#f92672>=</span> compile_c::compile(ast);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Set output path if not specified
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> c_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> output {
</span></span><span style=display:flex><span>            Some(s) <span style=color:#f92672>=&gt;</span> s,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> c_path <span style=color:#f92672>=</span> path.clone();
</span></span><span style=display:flex><span>                c_path.set_extension(<span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>                c_path
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;Writing C code to {}&#34;</span>, c_path.to_str().unwrap());
</span></span><span style=display:flex><span>        std::fs::write(c_path.clone(), c_code).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If run flag is set, compile and run
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> run {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> exe_path <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> exe_path <span style=color:#f92672>=</span> c_path.clone();
</span></span><span style=display:flex><span>                exe_path.set_extension(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>                exe_path
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            log::info!(<span style=color:#e6db74>&#34;Compiling C code to {}&#34;</span>, exe_path.to_str().unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cmd <span style=color:#f92672>=</span> std::process::Command::new(<span style=color:#e6db74>&#34;clang&#34;</span>);
</span></span><span style=display:flex><span>            cmd.arg(c_path).arg(<span style=color:#e6db74>&#34;-o&#34;</span>).arg(exe_path.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> status <span style=color:#f92672>=</span> cmd.status().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>status.success() {
</span></span><span style=display:flex><span>                panic!(<span style=color:#e6db74>&#34;clang failed&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cmd <span style=color:#f92672>=</span> std::process::Command::new(exe_path);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> status <span style=color:#f92672>=</span> cmd.status().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>status.success() {
</span></span><span style=display:flex><span>                panic!(<span style=color:#e6db74>&#34;program failed&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Very cool.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/stacklang vm examples/factorial.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>120</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Compiles to examples/factorial.c</span>
</span></span><span style=display:flex><span>$ ./target/release/stacklang compile examples/factorial.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat examples/factorial.c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &lt;stdbool.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &lt;stdint.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &lt;stdlib.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &lt;string.h&gt;</span>
</span></span><span style=display:flex><span>...%
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/stacklang compile --run examples/factorial.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>120</span>
</span></span></code></pre></div><p>I&rsquo;m going to have to see what I can do about a test harness (as mentioned). Perhaps next time!</p><h2 id=new-datatypes-vm-only-so-far>New datatypes (VM only; so far!)</h2><p>On another note, I keep wanting to do more with StackLang. One thing that will help with that is more powerful datastructures! As a way to see how it&rsquo;s going, I decided to semi-randomly work out the solution to <a href=https://blog.jverkamp.com/2012/11/03/project-euler/>Project Euler</a> <a href="https://projecteuler.net/problem=14" target=_blank rel=noopener>problem 14</a>: Find the number under 1 million with the longest <a href=https://en.wikipedia.org/wiki/Collatz%20Sequence>Collatz Sequence</a>.</p><p>It&rsquo;s not a particularly hard problem to just directly crunch numbers on, but you can save an awful lot of time by caching/<a href=https://en.wikipedia.org/wiki/memoizing>memoizing</a> the results. In a nutshell: the first time you calculate a specific Collatz length, store it in a data structure for later.</p><p>The best options for this storage? A <a href=https://en.wikipedia.org/wiki/hashmap>hashmap</a> or a vector!</p><h3 id=hash>Hash</h3><p>I ended up adding two Hash types: <code>Hash</code> and <code>IntHash</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A value is a literal value that has been evaluated.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Clone, Debug, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(u8)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    Hash(Rc<span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>String, Value<span style=color:#f92672>&gt;&gt;&gt;</span>),
</span></span><span style=display:flex><span>    IntHash(Rc<span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span>, Value<span style=color:#f92672>&gt;&gt;&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This primarily relates to the key. I wrote the <code>String</code> version first, but I don&rsquo;t actually want <code>Strings</code> for this problem, I want an <code>int -> int</code> Hash. Ergo <code>IntHash</code>.</p><p>It&rsquo;s a bit wacky looking with <code>Rc&lt;RefCell&lt;HashMap&lt;...>>></code>, but that&rsquo;s for a reason I&rsquo;ve mentioned before: because I <code>clone</code> values fairly often, if I don&rsquo;t have a <code>Rc</code>, I&rsquo;ll end up to references to new, copied <code>HashMap</code>. Besides being slow to copy values, it&rsquo;s not actually correct. We&rsquo;ll never write anything to somewhere we can read. <code>RefCell</code> then works to actually let us <code>mut</code> the value in the <code>Rc</code>. Fairly standard (if weird looking) Rust.</p><p>With the value written, I need to be able to print them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Display <span style=color:#66d9ef>for</span> Value {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        write!(
</span></span><span style=display:flex><span>            f,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;{}&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>                <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>                Value::Hash(v) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    format!(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Hash&lt;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&gt;&#34;</span>,
</span></span><span style=display:flex><span>                        v.clone()
</span></span><span style=display:flex><span>                            .borrow()
</span></span><span style=display:flex><span>                            .iter()
</span></span><span style=display:flex><span>                            .map(<span style=color:#f92672>|</span>(k, v)<span style=color:#f92672>|</span> format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, k, v))
</span></span><span style=display:flex><span>                            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>                            .join(<span style=color:#e6db74>&#34;, &#34;</span>)
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, some library functions:</p><ul><li><code>make-hash -> {hash}</code>: create a new empty (string) hash</li><li><code>make-int-hash -> {hash}</code>: create an empty integer keyed hash</li><li><code>hash-has? {hash} {key} -> {boolean}</code>: checks if a key is in a hash</li><li><code>hash-ref {hash} {key} -> {value}</code>: read a value from a hash</li><li><code>hash-set! {hash} {key} {value}</code>: update a hash at a specific key (or set the value if not previously defined)</li></ul><p>I&rsquo;m not going to share the entire code here, it&rsquo;s a bit repetitive. But for the most part, it was pretty straight forward to add. I really will want to be adding libraries and import statements (and a standard library?) at some point.</p><p>But you can see the entire code for hashes <a href=https://github.com/jpverkamp/stacklang/blob/ffab86f8a3a3d2b27bca4afd6b4270e2b9ffbadf/src/vm.rs#L466-L554 target=_blank rel=noopener>here</a>.</p><p>It&rsquo;s relying pretty heavily on the Rust <code>HashMap</code> type under the hood, which since C doesn&rsquo;t have one of those in the standard libraries is going to make porting this to the compiler interesting. We&rsquo;ll see how I end up handling this.</p><p>Here&rsquo;s my very very basic <code>example</code> for <code>hash.stack</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>make-hash @h
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>h &#34;x&#34; 5 hash-set!
</span></span><span style=display:flex><span>h &#34;y&#34; 6 hash-set!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>h writeln
</span></span><span style=display:flex><span>h &#34;x&#34; hash-get
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>h &#34;x&#34; 7 hash-set!
</span></span><span style=display:flex><span>h writeln%
</span></span></code></pre></div><p>And running it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/stacklang vm examples/hash.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hash&lt;x:5, y:6&gt;
</span></span><span style=display:flex><span>Hash&lt;x:7, y:6&gt;
</span></span></code></pre></div><h3 id=list-stack><del>List</del> Stack</h3><p>Edit: Turns out&mldr; these are stacks. And the language is named StackLang. ðŸ˜„</p><p>Next up, stacks! Basically, Python style lists / Rust style <code>vec</code>! Basically, a data structure that has a fixed current size, allows for quick <code>push</code> and <code>pop</code> at the end of the list and also <code>get</code> and <code>set</code> at a specific index.</p><p>Something like this:</p><ul><li><code>make-stack -> {stack}</code>: makes an empty stack</li><li><code>stack-length {stack} -> {integer}</code>: gets the length</li><li><code>stack-push! {stack} {value}</code>: pushes to the end of the stack</li><li><code>stack-pop! {stack} -> {value}</code>: pops off the end of the stack</li><li><code>stack-ref {stack} {index} -> {value}</code>: gets the value at a specific index</li><li><code>stack-set! {stack} {index} {value}</code>: sets a value within the stack</li></ul><p>Implementation details <a href=https://github.com/jpverkamp/stacklang/blob/5984da1606757b2f1450396ea90f9d1bf9b1c2bb/src/vm.rs#L243-L302 target=_blank rel=noopener>here</a>.</p><h4 id=liststack-literals>List/Stack literals</h4><p>While I was working on stacks, one thing that I&rsquo;ve been meaning to add to the language is <code>Stack</code> literals:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[ 1 2 3 ] @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l writeln
</span></span></code></pre></div><p>We&rsquo;re already lexing and parsing them, we just need to actually evaluate them when we see them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// List expressions are parsed into Stack values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Expression::List(children) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> values <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> children {
</span></span><span style=display:flex><span>        eval(node, stack);
</span></span><span style=display:flex><span>        values.push(stack.pop().unwrap());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    stack.push(Value::Stack(Rc::new(RefCell::new(values))));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That really is it. And we can put all sorts of interesting things in them&mldr; like blocks! See <a href=#cond-statements>the implementation of cond below</a>.</p><p>One weirdness is that the expression is still a &rsquo;list&rsquo;, but the datatype / value is a Stack. Weirdness, but it works fine.</p><h4 id=examples>Examples</h4><p>Here&rsquo;s my very basic <code>example</code> code for <code>list.stack</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[ 1 2 3 ] @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l writeln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l stack-pop! writeln
</span></span><span style=display:flex><span>l writeln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l 5 stack-push!
</span></span><span style=display:flex><span>l writeln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l 1 stack-ref writeln
</span></span></code></pre></div><p>I know it doesn&rsquo;t actually use <code>make-stack</code>, but it doesn&rsquo;t have to! <code>[]</code> ends up equivalent to that.</p><p>Running it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/stacklang vm examples/list.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2, 5<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>This one is much easier (for me at least) to implement by hand, although there are some neat performance tricks I&rsquo;ll have to be aware of. Basically, allocate some initial amount of memory. If we ever try to <code>push</code> past it, allocate a new, larger chunk, and copy the data over. Other than that, we should be pretty much good to go.</p><p>We&rsquo;ll give it a try, but not just yet.</p><h3 id=cond-statements>Cond statements</h3><p>Speaking of lists/stacks, one thing that I&rsquo;ve been finding annoying is a constant use of nested <code>if</code> statements. They&rsquo;re a bit more verbose than many languages, so nesting them is even more annoying that it should be.</p><p>What if we could make a cleaner syntax for a whole list of <code>cond</code>itionals?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>{
</span></span><span style=display:flex><span>  @n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [
</span></span><span style=display:flex><span>    # Base case
</span></span><span style=display:flex><span>    { @0 !1 n 1 &lt;= } 1
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # If n is even, divide by 2
</span></span><span style=display:flex><span>    { @0 !1 n 2 % 0 = } { @0 !1 n 2 / collatz-length 1 + }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # Default: If n is odd, multiply by 3 and add 1
</span></span><span style=display:flex><span>    { @0 !1 n 3 * 1 + collatz-length 1 +}
</span></span><span style=display:flex><span>  ] cond
</span></span><span style=display:flex><span>  @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  l
</span></span><span style=display:flex><span>} @collatz-length
</span></span></code></pre></div><p>In this case, we have three branches:</p><ul><li><code>n &lt;= 1</code>: return 1</li><li><code>n is even</code>: return <code>1 + collatz-length(n / 2)</code></li><li><code>n is odd</code>: return <code>1 + collatz-length(3 * n + 1)</code></li></ul><p>And that&rsquo;s exactly what the <code>cond</code> statement does. In the specification, it takes exactly an odd number of expressions in a list: some number of pairs of test/value and then a default. Something like this: <code>[test1 value1 test2 value2 ... default]</code>.</p><p>To evaluate it, run <code>test1</code> (this should always be a block). If it&rsquo;s true and <code>value1</code> is a block, evaluate and return it. If <code>value1</code> is a value, just return it. If <code>test1</code> evaluates to false, continue down the line. If no <code>test</code> is true, evaluate/return <code>default</code>.</p><p>The code for it&mldr; well, it&rsquo;s a bit of a thing, mostly to deal with the &lsquo;if it&rsquo;s a block, run it; if not, return it&rsquo; thing. I do need to abstract that.</p><p><a href=https://github.com/jpverkamp/stacklang/blob/0c878415a10879e98be2f0bc8259f88904646a07/src/vm.rs#L243-L321 target=_blank rel=noopener>Here is</a> the full (slightly ugly) code for <code>cond</code>.</p><h3 id=project-euler-problem-14>Project Euler: Problem 14</h3><p>Now that we have all that, let&rsquo;s solve Project Euler Problem 14! As mentioned, we want to find the value up to one million that leads to the longest Collatz sequence.</p><h4 id=with-hashmap>With HashMap</h4><p>First, storing the cached values in an <code>IntHash</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># https://projecteuler.net/problem=14
</span></span><span style=display:flex><span># Which starting number, under one million, produces the longest Collatz chain?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1000000 @bound
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make-int-hash @cache
</span></span><span style=display:flex><span>cache 1 1 hash-set!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  @n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [
</span></span><span style=display:flex><span>    # Already cached
</span></span><span style=display:flex><span>    { @0 !1 cache n hash-has? } { @0 !1 cache n hash-get }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # If n is even, divide by 2
</span></span><span style=display:flex><span>    { @0 !1 n 2 % 0 = } { @0 !1 n 2 / collatz-length 1 + }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # Default: If n is odd, multiply by 3 and add 1
</span></span><span style=display:flex><span>    { @0 !1 n 3 * 1 + collatz-length 1 +}
</span></span><span style=display:flex><span>  ] cond
</span></span><span style=display:flex><span>  @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cache n l hash-set!
</span></span><span style=display:flex><span>  l
</span></span><span style=display:flex><span>} @collatz-length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Store best value so far
</span></span><span style=display:flex><span>make-hash @results
</span></span><span style=display:flex><span>results &#34;best-v&#34; 1 hash-set!
</span></span><span style=display:flex><span>results &#34;best-l&#34; 1 hash-set!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Store best value so far
</span></span><span style=display:flex><span>1 @best-v
</span></span><span style=display:flex><span>1 @best-l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Check each value under 1 million
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  @v !0
</span></span><span style=display:flex><span>  v 1 + !v
</span></span><span style=display:flex><span>  v collatz-length @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    @0 !0
</span></span><span style=display:flex><span>    v !best-v
</span></span><span style=display:flex><span>    l !best-l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    &#34;new best: &#34; write
</span></span><span style=display:flex><span>    v write
</span></span><span style=display:flex><span>    &#34; -&gt; &#34; write
</span></span><span style=display:flex><span>    l writeln
</span></span><span style=display:flex><span>  } 
</span></span><span style=display:flex><span>  { @0 !0 }
</span></span><span style=display:flex><span>  l best-l &gt; if
</span></span><span style=display:flex><span>} bound loop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>best-v writeln
</span></span></code></pre></div><p>Hopefully it&rsquo;s commented fairly well. But essentially what we want to do is define <code>collatz-length</code> to recursively (and with memoization) calculate the length at any arbitrary value and then run a <code>loop</code> from 1 to 1,000,000, tracking the best value seen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/stacklang vm examples/euler-14-cond.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>2</span> -&gt; <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>3</span> -&gt; <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>6</span> -&gt; <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>7</span> -&gt; <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>9</span> -&gt; <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>626331</span> -&gt; <span style=color:#ae81ff>509</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>837799</span> -&gt; <span style=color:#ae81ff>525</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>837799</span>
</span></span></code></pre></div><p>It&rsquo;s not by any stretch of the imagination <em>fast</em>. About 45 seconds on my machine. I can do better! That&rsquo;s what I&rsquo;m hoping to do with compiling&mldr; if I can figure out the hash thing.</p><p>But it <em>is</em> functional. And I think the code isn&rsquo;t actually that bad. One thing I really do need to clean up is the <code>@0 !1</code> and the like I have to currently put everywhere to do the arity checks&mldr; Perhaps when I get proper type checking?</p><h4 id=with-stacks>With Stacks</h4><p>And finally, because it&rsquo;s something that I&rsquo;m more confident in building into the compiler, the same code with a <code>Stack</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># https://projecteuler.net/problem=14
</span></span><span style=display:flex><span># Which starting number, under one million, produces the longest Collatz chain?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1000000 @bound
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make-stack @cache
</span></span><span style=display:flex><span>cache 1 stack-push! 
</span></span><span style=display:flex><span>cache 1 stack-push! 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  @n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  # Extend the cache if needed
</span></span><span style=display:flex><span>  n cache stack-length - 2 + @extension
</span></span><span style=display:flex><span>  { 
</span></span><span style=display:flex><span>    @0 !0
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>      @0 !0
</span></span><span style=display:flex><span>      cache 0 stack-push! 
</span></span><span style=display:flex><span>    } extension loop 
</span></span><span style=display:flex><span>    &#34;extended cache by &#34; write extension writeln
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  { @0 !0 }
</span></span><span style=display:flex><span>  extension 0 &gt; if
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [
</span></span><span style=display:flex><span>    # Already cached
</span></span><span style=display:flex><span>    { @0 !1 cache n stack-ref 0 &gt; } { @0 !1 cache n stack-ref }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    # Base case
</span></span><span style=display:flex><span>    { @0 !1 n 1 &lt;= } 1
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # If n is even, divide by 2
</span></span><span style=display:flex><span>    { @0 !1 n 2 % 0 = } { @0 !1 n 2 / collatz-length 1 + }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    # Default: If n is odd, multiply by 3 and add 1
</span></span><span style=display:flex><span>    { @0 !1 n 3 * 1 + collatz-length 1 +}
</span></span><span style=display:flex><span>  ] cond
</span></span><span style=display:flex><span>  @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cache n l stack-set!
</span></span><span style=display:flex><span>  l
</span></span><span style=display:flex><span>} @collatz-length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Store best value so far
</span></span><span style=display:flex><span>1 @best-v
</span></span><span style=display:flex><span>1 @best-l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Check each value under 1 million
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  @v !0
</span></span><span style=display:flex><span>  v 1 + !v
</span></span><span style=display:flex><span>  v collatz-length @l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    @0 !0
</span></span><span style=display:flex><span>    v !best-v
</span></span><span style=display:flex><span>    l !best-l
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    &#34;new best: &#34; write
</span></span><span style=display:flex><span>    v write
</span></span><span style=display:flex><span>    &#34; -&gt; &#34; write
</span></span><span style=display:flex><span>    l writeln
</span></span><span style=display:flex><span>  } 
</span></span><span style=display:flex><span>  { @0 !0 }
</span></span><span style=display:flex><span>  l best-l &gt; if
</span></span><span style=display:flex><span>} bound loop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>best-v writeln
</span></span></code></pre></div><p>The main difference here is the &lsquo;Extend the cache if needed&rsquo; section. Basically, if the current <code>stack</code> isn&rsquo;t long enough to store the value we&rsquo;re going to add to it, push values until it is. This isn&rsquo;t at all efficient, but for the moment, it at least works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/stacklang vm examples/euler-14-list.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>2</span> -&gt; <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>7</span> to <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>6</span> to <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>3</span> -&gt; <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>6</span> -&gt; <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>6</span> to <span style=color:#ae81ff>22</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>12</span> to <span style=color:#ae81ff>34</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>18</span> to <span style=color:#ae81ff>52</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>7</span> -&gt; <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>9</span> -&gt; <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>18</span> to <span style=color:#ae81ff>70</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>36</span> to <span style=color:#ae81ff>106</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>54</span> to <span style=color:#ae81ff>160</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>18</span> -&gt; <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>25</span> -&gt; <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>54</span> to <span style=color:#ae81ff>214</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>108</span> to <span style=color:#ae81ff>322</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>162</span> to <span style=color:#ae81ff>484</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>216</span> to <span style=color:#ae81ff>700</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>90</span> to <span style=color:#ae81ff>790</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>396</span> to <span style=color:#ae81ff>1186</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>594</span> to <span style=color:#ae81ff>1780</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>378</span> to <span style=color:#ae81ff>2158</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1080</span> to <span style=color:#ae81ff>3238</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1620</span> to <span style=color:#ae81ff>4858</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>2430</span> to <span style=color:#ae81ff>7288</span>
</span></span><span style=display:flex><span>extended cache by <span style=color:#ae81ff>1944</span> to <span style=color:#ae81ff>9232</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>27</span> -&gt; <span style=color:#ae81ff>112</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>54</span> -&gt; <span style=color:#ae81ff>113</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>73</span> -&gt; <span style=color:#ae81ff>116</span>
</span></span><span style=display:flex><span>new best: <span style=color:#ae81ff>97</span> -&gt; <span style=color:#ae81ff>119</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>97</span>
</span></span></code></pre></div><p>For small values of <code>bound</code> ðŸ˜„</p><p>When we get to larger values, the values go way up before they come back down. It may only be 500 or so elements in the chain, but if we have to allocate space for everything?</p><p>You can see it above, even in the first 100 values, we&rsquo;re already maxing out over 9000. (heh)</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>