<!doctype html><html><head><title>StackLang Part V: Compiling to C â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>StackLang Part V: Compiling to C</h1><div class=entry-meta><span class=entry-date>2023-07-12</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/languages/c>C</a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/01/advent-of-code-2023/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/assemblers>Assemblers</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/compilers>Compilers</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memory>Memory</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/stacks>Stacks</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/virtual-machines>Virtual Machines</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link></a><a class=taxonomy-value href=/series/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/07/12/eagle-creek-walks/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/07/12/ultimate-comics-iron-man/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>It&rsquo;s been a bit, but I hope it&rsquo;s worth it. StackLang, part 5: compiling to C!</p><hr><p>Posts in this series:</p><div class=ranking><h3 class=title>Posts in <a href=/series/stacklang/>StackLang</a>:</h3><div class=content><ul><li><a href=https://blog.jverkamp.com/2023/04/14/stacklang-part-i-the-idea/>StackLang Part I: The Idea</a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/>StackLang Part II: The Lexer</a></li><li><a href=https://blog.jverkamp.com/2023/04/24/stacklang-part-iii-the-parser/>StackLang Part III: The Parser</a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/>StackLang Part IV: An Interpreter</a></li><li><a href=https://blog.jverkamp.com/2023/07/12/stacklang-part-v-compiling-to-c/>StackLang Part V: Compiling to C</a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/>StackLang Part VI: Some Examples</a></li><li><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/>StackLang Part VII: New CLI and Datatypes</a></li><li><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/>StackLang Part VIII: Compiler Stacks</a></li><li><a href=https://blog.jverkamp.com/2023/08/12/stacklang-part-ix-better-testing/>StackLang Part IX: Better Testing</a></li></ul></div></div><p>This post:</p><nav id=TableOfContents><ul><li><a href=#the-goal>The goal</a></li><li><a href=#the-target>The target</a></li><li><a href=#code-generation>Code generation</a></li><li><a href=#static-c-code>Static C code</a><ul><li><a href=#headerc><code>header.c</code></a></li><li><a href=#typesc><code>types.c</code></a></li><li><a href=#globalsc><code>globals.c</code></a></li><li><a href=#coercec><code>coerce.c</code></a></li><li><a href=#mainc><code>main.c</code></a></li></ul></li><li><a href=#compile_block><code>compile_block</code></a></li><li><a href=#compile_expr><code>compile_expr</code></a><ul><li><a href=#expressionidentifier>Expression::Identifier</a></li><li><a href=#expressionliteral>Expression::Literal</a></li><li><a href=#expressionblock>Expression::Block</a></li><li><a href=#expressionlist>Expression::List</a></li><li><a href=#expressiongroup>Expression::Group</a></li><li><a href=#expressionat>Expression:At</a></li><li><a href=#expressionbang>Expression::Bang</a></li><li><a href=#expressiondollar>Expression::Dollar</a></li></ul></li><li><a href=#generating-block-code>Generating block code</a></li><li><a href=#named-variables>Named variables</a><ul><li><a href=#collecting-names>Collecting names</a></li><li><a href=#original-idea>Original idea</a></li></ul></li><li><a href=#adding-it-to-the-main-function>Adding it to the <code>main</code> function</a></li><li><a href=#debug-mode>Debug mode</a></li><li><a href=#justfile>Justfile</a></li><li><a href=#mandelbrot-timing>Mandelbrot timing</a></li><li><a href=#next-steps>Next steps</a></li></ul></nav><p>Full source code for StackLang: <a href=https://github.com/jpverkamp/stacklang/ target=_blank rel=noopener>github:jpverkamp/stacklang</a></p><h2 id=the-goal>The goal</h2><p>So previously, I <a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/>wrote an interpreter</a> that can run StackLang programs. It works well enough and is great for hacking on features, but on the other hand:</p><ul><li>It&rsquo;s pretty slow. Generating a 1024x768x8 Mandelbrot image takes ~2m15s even in release mode with the VM vs 2s in the initial compiler. No, that&rsquo;s not a typo.</li><li>It redoes the lex + parse + run on each run, versus building a binary that just runs</li><li>The compiled executable is a bit larger (2.5MB vs 50kB; yes I know that&rsquo;s not much either way)</li><li>I just want to write a compiler!</li></ul><h2 id=the-target>The target</h2><p>So the next question: what do we want to compile to?</p><ul><li>Assembly (x86 / ARM); directly compile without other tools (although an assembler is probably still necessary), best low level control</li><li>A compiler backend (LLVM); something I&rsquo;ve been meaning to learn</li><li>Another language (C / Rust); leverage a lower level compiler for the final compilation steps</li><li>WASM; compiles to the web, it&rsquo;s stack based, so theoretically fits the language well</li></ul><p>All together&mldr; I think that any of those would be interesting, but semi-randomly I think that I&rsquo;m going to try compiling to C and using <a href=https://clang.llvm.org/ target=_blank rel=noopener>Clang</a> behind that (which in turn ends up using LLVM, although not directly).</p><h2 id=code-generation>Code generation</h2><p>Okay, first things first. I want to write a function <code>compile(ast: Expression) -> String</code>. It should generate C code which then can be written to file (or stdout, whichever).</p><p>To start with, something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Compile the AST into C code
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile</span>(ast: <span style=color:#a6e22e>Expression</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/header.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>    lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/types.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>    lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/globals.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>    lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/coerce.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Helper function to compile a specific block to be output later
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile_block</span>(
</span></span><span style=display:flex><span>        arity: (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>        body: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        blocks: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Compile a single expression into strings
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile_expr</span>(
</span></span><span style=display:flex><span>        expr: <span style=color:#a6e22e>Expression</span>,
</span></span><span style=display:flex><span>        blocks: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    ) -&gt; Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Compile the top level expression
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> blocks <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> ast {
</span></span><span style=display:flex><span>        Expression::Group(body) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            compile_block((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#f92672>&amp;</span>body, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> blocks);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unexpected top level expression: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ast),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Forward declare all blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Generate block functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add the main function that setups up the initial stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// and calls the top level block (block_0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/main.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Put it all together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    lines.join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So there are a few things going on here:</p><ul><li>We&rsquo;re generating a <code>vec</code> of <code>lines</code> that will be combined at the end</li><li>The main compile function has two helper functions:<ul><li><code>compile_block</code> will take a block of code (<code>{ ... }</code>) and compile it into a C function, calling <code>compile_expr</code> once for each subexpression</li><li><code>compile_expr</code> will compile a single expression, be it a literal, variable, name, lookup, or whatever (if it&rsquo;s a <code>block</code>, call <code>compile_block</code>)</li></ul></li><li>It&rsquo;s possible to add static C code to <code>lines</code> with <code>include_str!</code>:<ul><li><code>header.c</code> has the includes and a number of <code>#define</code> constants</li><li><code>types.c</code> defines the <code>Value</code> type (a <a href=https://en.wikipedia.org/wiki/tagged%20union>tagged union</a> struct)</li><li><code>globals.c</code> stores global variables (the <code>stack</code> and <code>frame</code>)</li><li><code>coerce.c</code> contains a function to automatically cast numbers when necessary (adding an integer + float should result in a float for example)</li><li><code>main.c</code> defines the <code>int main(int, char*)</code> function; sets up memory</li></ul></li></ul><h2 id=static-c-code>Static C code</h2><p>First, let&rsquo;s talk about all of the static C code that I&rsquo;m including in every program, no matter the content.</p><h3 id=headerc><code>header.c</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_NUMBER 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_NUMBER_INTEGER 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_NUMBER_RATIONAL 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_NUMBER_FLOAT 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_NUMBER_COMPLEX 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_STRING 16
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_BOOLEAN 17
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TAG_BLOCK 18
</span></span></span></code></pre></div><p>Essentially, this is where I pull in headers (for boolean types, converting to/from ints, and doing some string I/O) + define the tags for types (see <a href=#typesc>&lt;code>types.c&lt;/code></a>).</p><h3 id=typesc><code>types.c</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Values on the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> type;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int64_t</span> as_integer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> as_float;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>as_string;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> as_boolean;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>as_block;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>} Value;
</span></span></code></pre></div><p>As mentioned, this is a <a href=https://en.wikipedia.org/wiki/tagged%20union>tagged union</a> for all <code>values</code>. It stores the <code>type</code> (one of the constants from <a href=#headerc>&lt;code>header.c&lt;/code></a>) and the data. But because I&rsquo;m using a union, all of the values are stored in the same memory&ndash;you have to make sure to read it as the right kind of data. It will always take as much memory as the largest of the values (<code>int64_t</code> and <code>double</code> are each 8 bytes), which can be wasteful, but such is life.</p><p>One interesting one in particular is the <code>void *as_block</code>. This is a function pointer to another <code>block_#</code> (we haven&rsquo;t defined them yet) stored as a value.</p><h3 id=globalsc><code>globals.c</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// The stack holding all values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Value <span style=color:#f92672>*</span>stack;
</span></span><span style=display:flex><span>Value <span style=color:#f92672>*</span>stack_ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Frames holding the stack pointer for each block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Value <span style=color:#f92672>**</span>frames;
</span></span><span style=display:flex><span>Value <span style=color:#f92672>**</span>frame_ptr;
</span></span></code></pre></div><p>This stores two arrays which I&rsquo;ll allocate in <a href=#mainc>&lt;code>main.c&lt;/code></a>. They&rsquo;re not dynamic at this point.</p><p>Specifically, <code>stack</code> points to base of the entire stack of values while <code>stack_ptr</code> points to the current top of the <code>stack</code> and will be incremented when pushing and decremented when popping.</p><p><code>frames</code> stores an array of pointers to the <code>stack</code> pointer (yay <code>**</code>) which is updated whenever a new scope is introduced (when invoking a <code>block</code>), so that I know how many values to pop from <code>stack_ptr</code> on return. Likewise, <code>frame_ptr</code> is the current top of that stack.</p><p>It&rsquo;s&mldr; certainly an interesting way to do it, but I think it works well enough.</p><h3 id=coercec><code>coerce.c</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Convert two values to have the same type by upgrading if necessary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>coerce</span>(Value <span style=color:#f92672>*</span>a, Value <span style=color:#f92672>*</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>==</span> b<span style=color:#f92672>-&gt;</span>type)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>==</span> TAG_NUMBER_INTEGER <span style=color:#f92672>&amp;&amp;</span> b<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>==</span> TAG_NUMBER_FLOAT)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        a<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>=</span> TAG_NUMBER_FLOAT;
</span></span><span style=display:flex><span>        a<span style=color:#f92672>-&gt;</span>as_float <span style=color:#f92672>=</span> (<span style=color:#66d9ef>double</span>)a<span style=color:#f92672>-&gt;</span>as_integer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>==</span> TAG_NUMBER_FLOAT <span style=color:#f92672>&amp;&amp;</span> b<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>==</span> TAG_NUMBER_INTEGER)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        b<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>=</span> TAG_NUMBER_FLOAT;
</span></span><span style=display:flex><span>        b<span style=color:#f92672>-&gt;</span>as_float <span style=color:#f92672>=</span> (<span style=color:#66d9ef>double</span>)b<span style=color:#f92672>-&gt;</span>as_integer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As mentioned, this is the function to automatically convert ints/floats when doing math on mixed types. So far, I don&rsquo;t have the rest of the numeric tower I&rsquo;m planning and I may eventually make manual casting required instead of this, but for the moment, this works pretty well.</p><p>I did, for a while, have a rather subtle bug here that did all sorts of interesting things. The last (contentful) line was <code>b->as_float = (double)a->as_integer;</code>. So I ended up copying <code>a</code> over <code>b</code>, but only if <code>a</code> was a float and <code>b</code> an int. That took a while to find&mldr; I need better tests. ðŸ˜„</p><h3 id=mainc><code>main.c</code></h3><p>And finally, the main function!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The stack holding all values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    stack <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#ae81ff>10240</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(Value));
</span></span><span style=display:flex><span>    stack_ptr <span style=color:#f92672>=</span> stack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Frames holding the stack pointer for each block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    frames <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#ae81ff>10240</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(Value <span style=color:#f92672>**</span>));
</span></span><span style=display:flex><span>    frame_ptr <span style=color:#f92672>=</span> frames;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>block_0</span>(NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So right now, I&rsquo;m just allocating two flat arrays of ~90kB each (10240 * (1 byte for the tag and 8 bytes for the value union)). I&rsquo;ll probably make that dynamic at some point, but so far as making this work, it works well.</p><p>Then we call <code>block_0</code> (I&rsquo;ll get to the <code>NULL</code> when talking <a href=#named-variables>names</a>) and finally (if we make it this far) <code>return</code> success. Voila!</p><h2 id=compile_block><code>compile_block</code></h2><p>Okay, let&rsquo;s actually talk about compilation. I&rsquo;m going to start with <code>compile_block</code>. This function call <code>compile_expr</code> to actually compile each expression, but it also has to do a few more things:</p><ul><li>Calculate (or be given) the <code>arity</code> of the expression: how many values it will consume from the stack and how many it will push back on</li><li>Store the frame pointer&ndash;this will be offset by <code>arity_in</code> (which effectively consumes those values)</li><li>Compile the expressions</li><li>Handle popping &rsquo;extra&rsquo; values off the stack so only <code>arity_out</code> values are left after the stored <code>frame_ptr</code> when we&rsquo;re done</li></ul><p>Like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#e6db74>/// Helper function to compile a specific block to be output later
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile_block</span>(
</span></span><span style=display:flex><span>        arity: (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>        body: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        blocks: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        log::debug!(<span style=color:#e6db74>&#34;compile_block({arity:?}, {body:?})&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> blocks.len();
</span></span><span style=display:flex><span>        blocks.push(vec![]); <span style=color:#75715e>// Throwaway vec to hold the index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (arity_in, arity_out) <span style=color:#f92672>=</span> arity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lines.push(format!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;    // block: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>            body.iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>ex<span style=color:#f92672>|</span> ex.to_string())
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>                .join(<span style=color:#e6db74>&#34; &#34;</span>)
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>        lines.push(format!(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>    // Store the current stack pointer with arity_in=</span><span style=color:#e6db74>{arity_in}</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>        lines.push(format!(<span style=color:#e6db74>&#34;    *(++frame_ptr) = (stack_ptr - </span><span style=color:#e6db74>{arity_in}</span><span style=color:#e6db74>);</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Compile the block itself
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> expr <span style=color:#66d9ef>in</span> body {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> compile_expr(expr.clone(), blocks) {
</span></span><span style=display:flex><span>                lines.push(line);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Pop the block off the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        lines.push(format!(<span style=color:#e6db74>&#34;    // Pop the block off the stack, preserving arity_out=</span><span style=color:#e6db74>{arity_out}</span><span style=color:#e6db74> values&#34;</span>));
</span></span><span style=display:flex><span>        lines.push(format!(<span style=color:#e6db74>&#34;    Value* return_ptr = (stack_ptr - </span><span style=color:#e6db74>{arity_out}</span><span style=color:#e6db74>);&#34;</span>));
</span></span><span style=display:flex><span>        lines.push(format!(<span style=color:#e6db74>&#34;    stack_ptr =  *(frame_ptr--);&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>arity_out {
</span></span><span style=display:flex><span>            lines.push(format!(<span style=color:#e6db74>&#34;    *(++stack_ptr) = *(++return_ptr);&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        blocks[index] <span style=color:#f92672>=</span> lines;
</span></span><span style=display:flex><span>        index
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>One thing that I&rsquo;ve been making sure I do is generating comments in the C code. In a perfect world, these are never going to get looked at, since we&rsquo;re going to immediately compile this C code to assembly/machine code. But in a practical world, knowing what code I&rsquo;m generating is kind of important&mldr;</p><p>One thing to note is that all blocks have a single variable: <code>names</code>. This one is a <a href=https://en.wikipedia.org/wiki/linked%20list>linked list</a> of <code>name</code> -> <code>stack_ptr</code> associations that we&rsquo;ve stored. Because it&rsquo;s passed as a parameter to the <code>block_#(...)</code> call, when we return, it &lsquo;forgets&rsquo; all <code>names</code> bound in this block or child blocks. I&rsquo;ll get more into that in <a href=#named-variables>the names section</a>.</p><p>This is also the first time seeing code like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>(<span style=color:#f92672>++</span>frame_ptr) <span style=color:#f92672>=</span> (stack_ptr <span style=color:#f92672>-</span> {arity_in});
</span></span></code></pre></div><p>Essentially, <code>frame_ptr</code> is a pointer to a value in the <code>frames</code> array. <code>++frame_ptr</code> is a pre-increment, so it&rsquo;s saying advance the <code>frame_ptr</code> to the next available value in the array <em>before</em> evaluating the rest of the code. <code>*(++frame_ptr)</code> then unwraps one level (so rather than a frame, it&rsquo;s a <code>stack</code> value), which we then store the current <code>stack_ptr</code> offset by <code>arity_in</code> (essentially saying we&rsquo;re going to pop that many values throughout this function).</p><p>Likewise, at the end:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Value<span style=color:#f92672>*</span> return_ptr <span style=color:#f92672>=</span> (stack_ptr <span style=color:#f92672>-</span> {arity_out});
</span></span><span style=display:flex><span>stack_ptr <span style=color:#f92672>=</span>  <span style=color:#f92672>*</span>(frame_ptr<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>(<span style=color:#f92672>++</span>stack_ptr) <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>++</span>return_ptr); <span style=color:#75715e>// ... repeat arity_out times
</span></span></span></code></pre></div><p>This will use <code>arity_out</code> to determine how many values from the top of the stack (<code>stack_ptr</code>) we want to return. If it&rsquo;s 0, we just won&rsquo;t copy any values. But if it&rsquo;s 3 (for example), we&rsquo;ll start returning from the 3rd from the top of the stack.</p><p>Next, move the <code>stack_ptr</code> to the <code>frame_ptr</code>. Because it&rsquo;s <code>frame_ptr--</code>, we will take the top one and then only after we&rsquo;re done, decrement it to pop this <code>frame</code>. This <code>frame_ptr</code> starts without <code>arity_in</code></p><p>Then <code>*(++stack_ptr) = *(++return_ptr);</code> will be called once for each of arity_in. That says: &lsquo;set the next value on the stack to the next value to return.</p><p>It&mldr; makes sense to me? Perhaps a diagram will help. Let&rsquo;s show a few examples.</p><p>In the first example, let&rsquo;s show what would happen when calling <code>dup</code> function that will pop 1 value and return 2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># Initial state
</span></span><span style=display:flex><span>stack: A B C
</span></span><span style=display:flex><span>           â”” `stack_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Call dup, generate a new frame pointer
</span></span><span style=display:flex><span># The `stack_ptr` contains the value passed to the function
</span></span><span style=display:flex><span># The `frame_ptr` does not, since it&#39;s treating it as those values will be popped
</span></span><span style=display:flex><span>stack: A B C
</span></span><span style=display:flex><span>         â”‚ â”” `stack_ptr`
</span></span><span style=display:flex><span>         â”” `frame_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Dup runs, duplicating the C
</span></span><span style=display:flex><span>stack: A B C C
</span></span><span style=display:flex><span>         â”‚   â”” `stack_ptr`
</span></span><span style=display:flex><span>         â”” `frame_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Preparing for return, 1) `return_ptr` needs to have two values to return
</span></span><span style=display:flex><span>stack: A B C C
</span></span><span style=display:flex><span>         â”‚ â”‚ â”” `stack_ptr`
</span></span><span style=display:flex><span>         â”‚ â”” `return_ptr`
</span></span><span style=display:flex><span>         â”” `frame_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 2) The `stack_ptr` is moved to `frame_ptr - 1` (since we increment before copying)
</span></span><span style=display:flex><span>stack: A B C C
</span></span><span style=display:flex><span>       â”‚ â”‚ â”” `return_ptr`
</span></span><span style=display:flex><span>       â”‚ â”” `frame_ptr`
</span></span><span style=display:flex><span>       â”” `stack_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Now (twice because of `arity_out`), we copy the value at `return_ptr` to `stack_ptr` and increment
</span></span><span style=display:flex><span># After the first copy:
</span></span><span style=display:flex><span>stack: A C C C
</span></span><span style=display:flex><span>         â”‚ â”” `return_ptr`
</span></span><span style=display:flex><span>         â”” `frame_ptr` + `stack_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># After the second copy:
</span></span><span style=display:flex><span>stack: A C C C
</span></span><span style=display:flex><span>         â”‚ â”‚ â”” `return_ptr`
</span></span><span style=display:flex><span>         â”‚ â”” `stack_ptr`
</span></span><span style=display:flex><span>         â”” `frame_ptr`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Finally, we return; because `stack_ptr` is where the stack
</span></span><span style=display:flex><span># will be on returning from the function; the last `C` (`return_ptr`)
</span></span><span style=display:flex><span># is effectively ignored / not able to be referenced any more
</span></span></code></pre></div><p>Hopefully that helps?</p><p>And that&rsquo;s all we have for <code>compile_block</code>. Now the real fun(tm), <code>compile_expr</code>:</p><h2 id=compile_expr><code>compile_expr</code></h2><p>In a nutshell, we have this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#e6db74>/// Compile a single expression into strings
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile_expr</span>(expr: <span style=color:#a6e22e>Expression</span>, blocks: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        log::debug!(<span style=color:#e6db74>&#34;compile_expr({expr})&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>        lines.push(format!(<span style=color:#e6db74>&#34;    // </span><span style=color:#e6db74>{expr}</span><span style=color:#e6db74>&#34;</span>)); <span style=color:#75715e>// TODO: Flag for verbose mode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> expr {
</span></span><span style=display:flex><span>            Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lines
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Where <code>match expr</code> will generate code for each possible expression (see the sections below). Two interesting bits:</p><ul><li><code>blocks: &amp;mut Vec&lt;Vec&lt;String>></code> - this stores the blocks as we compile; since we can have <code>blocks</code> in <code>exprs</code>, we need to thread this through for when we see more blocks</li><li><code>-> Vec&lt;String></code> - we return a <code>Vec</code> so that we can return 0, 1, or more lines; if an expression doesn&rsquo;t generate code, it should return 0. Most will return more than 1: a comment + the actual generated code</li></ul><p>So let&rsquo;s go through the generation!</p><h3 id=expressionidentifier>Expression::Identifier</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> id.as_str() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Built in numeric functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_binop!(lines, <span style=color:#e6db74>&#34;+&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;-&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_binop!(lines, <span style=color:#e6db74>&#34;-&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_binop!(lines, <span style=color:#e6db74>&#34;*&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_binop!(lines, <span style=color:#e6db74>&#34;/&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;%&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_binop!(lines, <span style=color:#e6db74>&#34;%&#34;</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Built in numeric comparisons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;&lt;&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;&lt;&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&lt;=&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;&lt;=&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;==&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;!=&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;!=&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&gt;=&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;&gt;=&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&gt;&#34;</span> <span style=color:#f92672>=&gt;</span> numeric_compare!(lines, <span style=color:#e6db74>&#34;&gt;&#34;</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Built ins
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;read&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/read.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;write&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/write.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;writeln&#34;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/write.c&#34;</span>).to_string());
</span></span><span style=display:flex><span>            lines.push(<span style=color:#e6db74>&#34;printf(</span><span style=color:#ae81ff>\&#34;\\</span><span style=color:#e6db74>n</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>);&#34;</span>.to_string());
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;newline&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(<span style=color:#e6db74>&#34;printf(</span><span style=color:#ae81ff>\&#34;\\</span><span style=color:#e6db74>n</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>);&#34;</span>.to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;loop&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/loop.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;if&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/if.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;to_float&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/to_float.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;to_int&#34;</span> <span style=color:#f92672>=&gt;</span> lines.push(include_str!(<span style=color:#e6db74>&#34;../compile_c_includes/builtins/to_int.c&#34;</span>).to_string()),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Attempt to lookup in names table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        id <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> sanitize_name(id);
</span></span><span style=display:flex><span>            lines.push(format!(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Value* v = lookup(names, NAME_</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>if (v-&gt;type == TAG_BLOCK) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>void *f = v-&gt;as_block;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>((void (*)(Name*))f)(names);
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74> else </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>*(++stack_ptr) = *v;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>
</span></span><span style=display:flex><span>            ));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So there are threeish categories here:</p><ul><li>builtins numeric functions generated by macro</li><li>builtin functions included as C files</li><li>variable lookups</li></ul><p>For numeric functions, we do much like we did in the VM version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A helper macro to generate functions that operate on two integers and floats
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>macro_rules<span style=color:#f92672>!</span> numeric_binop {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$lines</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$op</span>:<span style=color:#a6e22e>literal</span>) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> op <span style=color:#f92672>=</span> stringify!(<span style=color:#75715e>$op</span>).to_string().trim_matches(<span style=color:#e6db74>&#39;&#34;&#39;</span>).to_string();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>$lines</span>.push(format!(<span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Value *b = stack_ptr--;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Value *a = stack_ptr--;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        coerce(a, b);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if (a-&gt;type == TAG_NUMBER_INTEGER) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Value result = </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>.type=TAG_NUMBER_INTEGER, .as_integer=a-&gt;as_integer </span><span style=color:#e6db74>{op}</span><span style=color:#e6db74> b-&gt;as_integer</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            *(++stack_ptr) = result;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74> else if (a-&gt;type == TAG_NUMBER_FLOAT) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Value result = </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>.type=TAG_NUMBER_FLOAT, .as_float=a-&gt;as_float </span><span style=color:#e6db74>{op}</span><span style=color:#e6db74> b-&gt;as_float</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            *(++stack_ptr) = result;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s got fun <code>{{ double brackets }}</code> because otherwise those are template variables (which I do use for <code>op</code>), but other than that, all we do is:</p><ul><li>pop two values with <code>Value *b = stack_ptr--</code> (gets the value and then decrements the pointer)</li><li><a href=#coercec>&lt;code>coerce&lt;/code></a></li><li>perform the function, creating a new value</li><li>push the new value onto the stack with <code>*(++stack_ptr) = result;</code></li></ul><p><code>numeric_compare</code> is much the same, except instead we create a new <code>TAG_BOOLEAN</code> value.</p><p>The next case is the builtins. Those are just including C code, which you can see in the repo <a href=https://github.com/jpverkamp/stacklang/tree/main/compile_c_includes/builtins target=_blank rel=noopener>github:jpverkamp/stacklang:compile_c_includes/builtins</a>.</p><p>For example, <code>if</code> includes <code>builtins/if.c</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Value cond <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(stack_ptr<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>    Value if_false <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(stack_ptr<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>    Value if_true <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(stack_ptr<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cond.<span style=color:#66d9ef>type</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>TAG_BOOLEAN</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Error: if condition must be a boolean</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Value v <span style=color:#f92672>=</span> (cond.as_boolean <span style=color:#f92672>?</span> if_true : <span style=color:#a6e22e>if_false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v.<span style=color:#66d9ef>type</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>TAG_BLOCK</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        void <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> v.as_block;
</span></span><span style=display:flex><span>        ((void (<span style=color:#f92672>*</span>)(Name <span style=color:#f92672>*</span>))f)(names);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(<span style=color:#f92672>++</span>stack_ptr) <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Oh that <code>((void (*)(Name *))f)(names);</code> line&mldr; Essentially, that&rsquo;s taking the <code>as_block</code>, which has to be stored as an arbitrary (<code>void*</code>) pointer and then casts it to a function pointer of the proper type (take a <code>Name*</code> and return nothing), which is then called with the <a href=#named-variables>&lt;code>names&lt;/code> linked list</a>.</p><p>Finally, if the <code>Identifier</code> isn&rsquo;t a builtin function, assume it&rsquo;s a variable and look it up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                    lines.push(format!(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Value* v = lookup(names, NAME_</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if (v-&gt;type == TAG_BLOCK) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        void *f = v-&gt;as_block;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ((void (*)(Name*))f)(names);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74> else </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        *(++stack_ptr) = *v;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#34;</span>
</span></span><span style=display:flex><span>                    ));
</span></span></code></pre></div><p>Then, if it&rsquo;s not a <code>block</code>, push that variable&rsquo;s <code>Value</code> onto the stack as always. But if it is a <code>block</code>, then we need to call it, as we did in <code>if</code> above.</p><p>So that&rsquo;s a lot. ðŸ˜„</p><h3 id=expressionliteral>Expression::Literal</h3><p>Literals are much easier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Literal(value) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (tag, field, value) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: additional numeric tyhpes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Value::Number(Number::Integer(v)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            (<span style=color:#e6db74>&#34;TAG_NUMBER_INTEGER&#34;</span>, <span style=color:#e6db74>&#34;integer&#34;</span>, v.to_string())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Value::Number(Number::Float(v)) <span style=color:#f92672>=&gt;</span> (<span style=color:#e6db74>&#34;TAG_NUMBER_FLOAT&#34;</span>, <span style=color:#e6db74>&#34;float&#34;</span>, v.to_string()),
</span></span><span style=display:flex><span>        Value::String(v) <span style=color:#f92672>=&gt;</span> (<span style=color:#e6db74>&#34;TAG_STRING&#34;</span>, <span style=color:#e6db74>&#34;string&#34;</span>, format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{v:?}</span><span style=color:#e6db74>&#34;</span>)),
</span></span><span style=display:flex><span>        Value::Boolean(v) <span style=color:#f92672>=&gt;</span> (<span style=color:#e6db74>&#34;TAG_BOOLEAN&#34;</span>, <span style=color:#e6db74>&#34;boolean&#34;</span>, format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{v:?}</span><span style=color:#e6db74>&#34;</span>)),
</span></span><span style=display:flex><span>        Value::Block { <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Blocks should be compiled separately&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines.push(format!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Value v = </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>.type=</span><span style=color:#e6db74>{tag}</span><span style=color:#e6db74>, .as_</span><span style=color:#e6db74>{field}</span><span style=color:#e6db74>=</span><span style=color:#e6db74>{value}</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>*(++stack_ptr) = v;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    ));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For each type of literal, determine what the tag should be and generate the necessary code for it. Then push it onto the stack.</p><p>There shouldn&rsquo;t be direct <code>block</code> literals at the moment. <code>panic!</code></p><h3 id=expressionblock>Expression::Block</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Block(<span style=color:#66d9ef>ref</span> body) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arity <span style=color:#f92672>=</span> calculate_arity(<span style=color:#f92672>&amp;</span>expr)
</span></span><span style=display:flex><span>        .expect(format!(<span style=color:#e6db74>&#34;Unable to calculate arity for block: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, expr).as_str());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> compile_block(arity, body, blocks);
</span></span><span style=display:flex><span>    lines.push(format!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Value v = </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>.type=TAG_BLOCK, .as_block=(void*)block_</span><span style=color:#e6db74>{index}</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>*(++stack_ptr) = v;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    ));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This one is straight forward (mostly because the code is in <a href=#compile_block>&lt;code>compile_block&lt;/code></a>). We do calculate the arity ahead of time (I&rsquo;m not sure why anymore&ndash;I think because we have the <code>expr</code> here and only the body in <code>calculate_block</code>?), but then we just compile the block, get the new index for this block, and push a <code>Value::Block</code> onto the stack containing a pointer to the new function.</p><p>Pretty cool how that just works.</p><h3 id=expressionlist>Expression::List</h3><p><code>todo!()</code></p><p>I haven&rsquo;t actually implemented list expressions yet, but I also haven&rsquo;t written any code that needs them yet!</p><h3 id=expressiongroup>Expression::Group</h3><p>Groups are defined with <code>( ... )</code> (or there is an implicit one at the top level). All they are is a sequence of expressions, but this is exactly why we have the function return an arbitrary number of lines:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Group(exprs) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> expr <span style=color:#66d9ef>in</span> exprs {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> compile_expr(expr, blocks) {
</span></span><span style=display:flex><span>            lines.push(line);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=expressionat>Expression:At</h3><p>Here&rsquo;s a more interesting case. At expressions are implicitly tied into <a href=#named-variables>naming</a>, so we&rsquo;ll get into it more there. But for now, assume we have a function <code>bind</code> in our C code that takes <code>names</code>, a <code>NAME_{id}</code> constant, and a pointer to the stack and binds the name to that stack location.</p><p>Then, there are two three cases:</p><ul><li><code>@a</code> for single <code>Identifier</code> binding</li><li><code>@[a b c]</code> for <code>List</code> binding of multiple variables at once</li><li><code>@5</code> for arity clauses, these just shouldn&rsquo;t generate code</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::At(expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> expr.as_ref() {
</span></span><span style=display:flex><span>        Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> sanitize_name(id);
</span></span><span style=display:flex><span>            lines.push(format!(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Value *p = stack_ptr;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    names = bind(names, NAME_</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>, p);
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>            ));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Expression::List(id_exprs) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> id_count <span style=color:#f92672>=</span> id_exprs.len();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (i, id_expr) <span style=color:#66d9ef>in</span> id_exprs.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> id_expr {
</span></span><span style=display:flex><span>                    Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> sanitize_name(id);
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        lines.push(format!(
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74> 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Value *p = (stack_ptr - </span><span style=color:#e6db74>{id_count}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{i}</span><span style=color:#e6db74> + 1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    names = bind(names, NAME_</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>, p);
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>                        ));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unexpected @ expression when compiling: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, expr),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Expression::Literal(Value::Number(Number::Integer(_))) <span style=color:#f92672>=&gt;</span> {} <span style=color:#75715e>// ignore numeric @ expressions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unexpected @ expression when compiling: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, expr),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=expressionbang>Expression::Bang</h3><p>These are eventually going to be for writing to named variables, but I&rsquo;m not currently using them much. What we do have though is <code>arity_out</code> expressions, which have a numeric field, a la <code>!1</code>. We don&rsquo;t want to generate code for them, but do need to handle them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Bang(v) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> v.as_ref() {
</span></span><span style=display:flex><span>        Expression::Literal(Value::Number(Number::Integer(_))) <span style=color:#f92672>=&gt;</span> {}, <span style=color:#75715e>// Used only for arity out expressions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _ <span style=color:#f92672>=&gt;</span> todo!(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=expressiondollar>Expression::Dollar</h3><p><code>$</code> expressions are essentially a simpler form of variable lookups. They always have an <code>Identifier</code> and they always push the value on the stack, even if it&rsquo;s a block. Essentially, this is to allow passing blocks to other blocks. It does make the code simpler though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Expression::Dollar(expr) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> expr.as_ref() {
</span></span><span style=display:flex><span>    Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        lines.push(format!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Value* v = lookup(names, NAME_</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    *(++stack_ptr) = *v;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unexpected $ expression when compiling: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, expr),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=generating-block-code>Generating block code</h2><p>Okay, that&rsquo;s all well and good, but remember back in <a href=#code-generation>the original code</a> when I said I still have to forward declare and generate all blocks? Well, now we have the <code>blocks</code>, so let&rsquo;s do that!</p><p>First:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Forward declare all blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>lines.push(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>// Forward declare all blocks&#34;</span>.to_string());
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, _) <span style=color:#66d9ef>in</span> blocks.iter().enumerate() {
</span></span><span style=display:flex><span>    lines.push(format!(<span style=color:#e6db74>&#34;void block_</span><span style=color:#e6db74>{i}</span><span style=color:#e6db74>(Name *block_names);&#34;</span>, i <span style=color:#f92672>=</span> i).to_string());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This comes up because each <code>block</code> can theoretically call any other block in any order. Because of how C compilers work, you can&rsquo;t call a function defined after you (by default), so what we&rsquo;re doing here is just naming all of the <code>block_#</code> functions we&rsquo;re going to generate to make the compiler happy.</p><p>And then the code gen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Generate block functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>lines.push(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>// Actual block definitions&#34;</span>.to_string());
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, block) <span style=color:#66d9ef>in</span> blocks.iter().enumerate() {
</span></span><span style=display:flex><span>    lines.push(format!(<span style=color:#e6db74>&#34;void block_</span><span style=color:#e6db74>{i}</span><span style=color:#e6db74>(Name *block_names) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>&#34;</span>).to_string());
</span></span><span style=display:flex><span>    lines.push(format!(<span style=color:#e6db74>&#34;    if (block_names != NULL) block_names-&gt;boundary = true;&#34;</span>).to_string());
</span></span><span style=display:flex><span>    lines.push(format!(<span style=color:#e6db74>&#34;    Name* names = block_names;&#34;</span>).to_string());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines.push(block.join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines.push(<span style=color:#e6db74>&#34;    // Free names bound in this block&#34;</span>.to_string());
</span></span><span style=display:flex><span>    lines.push(<span style=color:#e6db74>&#34;    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>while (names != NULL &amp;&amp; block_names != names) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Name *next = names-&gt;prev;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    free(names);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    names = next;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>.to_string());
</span></span><span style=display:flex><span>    lines.push(<span style=color:#e6db74>&#34;}&#34;</span>.to_string());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A lot of that has to do with how we actually deal with <a href=#named-variables>named variables</a>, which we&rsquo;re almost to, I promise. In a nutshell though, we take in <code>block_names</code> as a pointer to where in the <code>names</code> linked list the block started at. We then copy <code>names</code> which will be incremented as we evaluate this block (in <code>At</code> expressions). At the end of the block, if there are any values between (if we bound any names), we free the memory those names used, since the calling function will no longer be able to see them.</p><p>It&rsquo;s not how I originally did it, see the <a href=#original-code>first version of named variables</a>, but it does work!</p><h2 id=named-variables>Named variables</h2><p>Okay, enough is enough. Let&rsquo;s actually talk about <code>names</code>.</p><p>As mentioned in <a href=#generating-block-code>the previous section</a>, we have one more data structure: <code>names</code>. This one, rather than a static array, is actually a linked list. Each name will be added to the end of this list, with the <code>name</code> and <code>stack_ptr</code> it refers to. To lookup, we&rsquo;ll start at the end of this list and iterate backwards until we find <code>name</code>. If we bound a variable multiple times, the last bound (so the closest in scope) will be seen first.</p><p>It&rsquo;s pretty elegant, IMO. Here&rsquo;s the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Names linked list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Name Name;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> Name
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> boundary;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> name;
</span></span><span style=display:flex><span>    Value <span style=color:#f92672>*</span>value;
</span></span><span style=display:flex><span>    Name <span style=color:#f92672>*</span>prev;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name <span style=color:#f92672>*</span><span style=color:#a6e22e>bind</span>(Name <span style=color:#f92672>*</span>names, <span style=color:#66d9ef>uint8_t</span> name, Value <span style=color:#f92672>*</span>value)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Name <span style=color:#f92672>*</span>new_name <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(Name));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (new_name <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Out of memory&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    new_name<span style=color:#f92672>-&gt;</span>boundary <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    new_name<span style=color:#f92672>-&gt;</span>name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    new_name<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    new_name<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> names;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> new_name;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lookup a value on the stack by name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Value <span style=color:#f92672>*</span><span style=color:#a6e22e>lookup</span>(Name <span style=color:#f92672>*</span>names, <span style=color:#66d9ef>uint8_t</span> name)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (names <span style=color:#f92672>!=</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (names<span style=color:#f92672>-&gt;</span>name <span style=color:#f92672>==</span> name)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> names<span style=color:#f92672>-&gt;</span>value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        names <span style=color:#f92672>=</span> names<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Name not found: %d&#34;</span>, name);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, it&rsquo;s a bit weird that we don&rsquo;t store <code>next</code>, but we don&rsquo;t need it. Just <code>prev</code> to look back from the end of the list. And if we ever go all the way back, <code>prev</code> will be <code>NULL</code> and we know the variable isn&rsquo;t defined (so error out).</p><p>One last interesting field is <code>new_name->boundary</code>. This is set when a <code>block</code> is called and essentially all it does is allow us to print a distinction between <code>names</code> in different <code>block_#</code> for <a href=#debug-mode>debug mode</a>.</p><p>With that, <code>bind</code> will <code>malloc</code> the memory for the new node, fill it out, and return the new end of list. <code>lookup</code> (as mentioned) will start at the current end of the list and go back until we either find the <code>name</code> or run out of <code>names</code>.</p><p>I do store all <code>name</code> as <code>uint8_t</code>, which does require collecting all of the names at the start of the <code>compile</code> function:</p><h3 id=collecting-names>Collecting names</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Collect the names used so we can assign each an integer value
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>collect_names</span>(ast: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Expression</span>) -&gt; <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> names <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>collect_names_expr</span>(expr: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Expression</span>, names: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> HashMap<span style=color:#f92672>&lt;</span>String, <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> expr {
</span></span><span style=display:flex><span>            Expression::Identifier(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> Expression::Literal(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> Expression::Bang(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> Expression::Dollar(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Do nothing, no names possible
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>            Expression::List(_) <span style=color:#f92672>=&gt;</span> todo!(),
</span></span><span style=display:flex><span>            Expression::Block(exprs) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> expr <span style=color:#66d9ef>in</span> exprs {
</span></span><span style=display:flex><span>                    collect_names_expr(expr, names);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Expression::Group(exprs) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> expr <span style=color:#66d9ef>in</span> exprs {
</span></span><span style=display:flex><span>                    collect_names_expr(expr, names);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Expression::At(expr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> expr.as_ref() {
</span></span><span style=display:flex><span>                    Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> sanitize_name(id);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>names.contains_key(<span style=color:#f92672>&amp;</span>id) {
</span></span><span style=display:flex><span>                            log::debug!(<span style=color:#e6db74>&#34;Adding name: {} @ {}&#34;</span>, id, names.len());
</span></span><span style=display:flex><span>                            names.insert(id.clone(), names.len());
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Expression::List(id_exprs) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> id_expr <span style=color:#66d9ef>in</span> id_exprs {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>match</span> id_expr {
</span></span><span style=display:flex><span>                                Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> sanitize_name(id);
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>names.contains_key(<span style=color:#f92672>&amp;</span>id) {
</span></span><span style=display:flex><span>                                        log::debug!(<span style=color:#e6db74>&#34;Adding name: {} @ {}&#34;</span>, id, names.len());
</span></span><span style=display:flex><span>                                        names.insert(id.clone(), names.len());
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                _ <span style=color:#f92672>=&gt;</span> panic!(
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;Unexpected @ expression when collecting names: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                                    expr
</span></span><span style=display:flex><span>                                ),
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Expression::Literal(Value::Number(Number::Integer(_))) <span style=color:#f92672>=&gt;</span> {} <span style=color:#75715e>// ignore numeric @ expressions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unexpected @ expression when collecting names: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, expr),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    collect_names_expr(ast, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> names);
</span></span><span style=display:flex><span>    names
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This just iterates through the function, looking for anything that is used in an <code>At</code> expression recursively and makes a unique set of them. It then can generate a define for each:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> names <span style=color:#f92672>=</span> collect_names(<span style=color:#f92672>&amp;</span>ast);
</span></span><span style=display:flex><span>log::debug!(<span style=color:#e6db74>&#34;collected names: {:?}&#34;</span>, names);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (name, index) <span style=color:#66d9ef>in</span> names.iter() {
</span></span><span style=display:flex><span>    lines.push(format!(<span style=color:#e6db74>&#34;#define NAME_</span><span style=color:#e6db74>{name}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{index}</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not so bad.</p><h3 id=original-idea>Original idea</h3><p>As a quick aside, this isn&rsquo;t the first iteration of variable naming I wrote. Originally (and it works in <em>most</em> cases), the <a href=#typesc>&lt;code>types.c&lt;/code></a> definition looked like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Values on the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> type;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int64_t</span> as_integer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> as_float;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>as_string;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> as_boolean;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>as_block;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> name_count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> names[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO: more than 4 names
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Value;
</span></span></code></pre></div><p>In essence, this would store up to 4 <code>names</code> with each value on the stack. This would end up using up that extra memory even if a value was never named, but that&rsquo;s not actually where the bug crept in: because names were always bound on the stack and never removed, when you called a child <code>block</code> that used the same names as a parent <code>block</code>, weird things(tm) could happen.</p><p>This&mldr; took a while to trace down before finally settling on the linked list version above.</p><h2 id=adding-it-to-the-main-function>Adding it to the <code>main</code> function</h2><p>Okay, we have all of the code now! So let&rsquo;s add it to my <code>main.rs</code>. Because we have two possible branches now, along with setting up logging and <a href=#debug-mode>debug mode</a>, it&rsquo;s worth pushing out into a new function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> clap::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> log;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{io::BufReader, env};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> debug;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> numbers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> stack;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> types;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> arity;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> compile_c;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> lexer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> parser;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> vm;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Parser, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[command(author, version, about, long_about = None)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[arg(short, long)]</span>
</span></span><span style=display:flex><span>    file: String,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[arg(short, long)]</span>
</span></span><span style=display:flex><span>    compile: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[arg(short, long)]</span>
</span></span><span style=display:flex><span>    debug: <span style=color:#66d9ef>bool</span>, 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pretty_env_logger::init();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> args <span style=color:#f92672>=</span> Args::parse();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> file <span style=color:#f92672>=</span> std::fs::File::open(args.file).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tokens <span style=color:#f92672>=</span> lexer::tokenize(BufReader::new(file));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    log::info!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Tokens: {}&#34;</span>,
</span></span><span style=display:flex><span>        tokens
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>token<span style=color:#f92672>|</span> token.token.clone())
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>            .join(<span style=color:#e6db74>&#34; &#34;</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ast <span style=color:#f92672>=</span> parser::parse(tokens);
</span></span><span style=display:flex><span>    log::info!(<span style=color:#e6db74>&#34;AST:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{:#?}&#34;</span>, ast);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.compile {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c_code <span style=color:#f92672>=</span> compile_c::compile(ast);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, c_code);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        vm::evaluate(ast);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://docs.rs/clap/latest/clap/ target=_blank rel=noopener>clap</a> is pretty cool!</p><p>Essentially, we read args, load the specified file, always tokenize, always generate an AST, and then based on the <code>compile</code> flag, either run it with the VM or compile it to C.</p><p>That&rsquo;s pretty shiny.</p><h2 id=debug-mode>Debug mode</h2><p>One bit missing though, debug mode!</p><p>There were essentially three options I had here:</p><ul><li>Thread a <code>debug_mode</code> flag through all of the other functions</li><li>Set an environment variable based on the command line flag (if specified)</li><li>Create a crate with <code>debug::ENABLED</code></li></ul><p>The third appealed to me&mldr; with <code>ENABLED</code> being a <code>static mut bool</code>. The only problem with that&mldr; is that it&rsquo;s <code>unsafe</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pretty_env_logger::init();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> args <span style=color:#f92672>=</span> Args::parse();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Debug flag override envs variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> args.debug {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            debug::<span style=color:#66d9ef>ENABLED</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> env::var(<span style=color:#e6db74>&#34;STACKLANG_DEBUG&#34;</span>) {
</span></span><span style=display:flex><span>            Ok(s) <span style=color:#66d9ef>if</span> s.to_lowercase() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>                debug::<span style=color:#66d9ef>ENABLED</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {},
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        env::set_var(<span style=color:#e6db74>&#34;RUST_LOG&#34;</span>, <span style=color:#e6db74>&#34;trace&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> debug::<span style=color:#66d9ef>ENABLED</span> {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Debug mode enabled&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// compile_c.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>/// Compile the AST into C code
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile</span>(ast: <span style=color:#a6e22e>Expression</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> debug::<span style=color:#66d9ef>ENABLED</span> {
</span></span><span style=display:flex><span>            lines.push(<span style=color:#e6db74>&#34;char* get_name(int index) {&#34;</span>.to_string());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (name, index) <span style=color:#66d9ef>in</span> names.iter() {
</span></span><span style=display:flex><span>                lines.push(format!(<span style=color:#e6db74>&#34;    if (index == </span><span style=color:#e6db74>{index}</span><span style=color:#e6db74>) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74> return </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>{name}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>; </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            lines.push(<span style=color:#e6db74>&#34;    return </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&lt;unknown&gt;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>;&#34;</span>.to_string());
</span></span><span style=display:flex><span>            lines.push(<span style=color:#e6db74>&#34;}&#34;</span>.to_string());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m &mldr; not thrilled with that. There has to be a better way to do it, but I&rsquo;ve not found it yet. And it works. For now!</p><h2 id=justfile>Justfile</h2><p>So now I can run with the <code>--file</code> flag to specify file, <code>--compile</code> to enable compilation mode (which actually only generates C code), and <code>--debug</code> to enable <a href=#debug-mode>debug mode</a>. But that&rsquo;s&mldr; a lot. So I made a <a href=https://github.com/casey/just target=_blank rel=noopener>Justfile</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>both name:
</span></span><span style=display:flex><span>    just example {{ name }}
</span></span><span style=display:flex><span>    just example {{ name }} compile=true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>example name compile=&#34;false&#34; debug=&#34;false&#34;:
</span></span><span style=display:flex><span>    just example{{ if compile != &#34;false&#34; { &#34;-compile&#34; } else { &#34;-run&#34; } }}{{ if debug != &#34;false&#34; { &#34;-debug&#34; } else { &#34;&#34; } }} {{name}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>example-run name:
</span></span><span style=display:flex><span>    time cargo run --release -- --file examples/{{name}}.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>example-compile name:
</span></span><span style=display:flex><span>    cargo run --release -- --file examples/{{name}}.stack --compile &gt; output/{{name}}.c
</span></span><span style=display:flex><span>    clang -Ofast output/{{name}}.c -o output/{{name}}
</span></span><span style=display:flex><span>    time output/{{name}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>example-run-debug name:
</span></span><span style=display:flex><span>    cargo run -- --debug --file examples/{{name}}.stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>example-compile-debug name:
</span></span><span style=display:flex><span>    cargo run -- --debug --file examples/{{name}}.stack --compile &gt; output/{{name}}.c
</span></span><span style=display:flex><span>    clang output/{{name}}.c -o output/{{name}}
</span></span><span style=display:flex><span>    output/{{name}}
</span></span></code></pre></div><p>Now I can run my code examples (with timing! and automatic clang!) with <code>just example</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just example fibonacci-acc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>just example-run fibonacci-acc
</span></span><span style=display:flex><span>time cargo run --release -- --file examples/fibonacci-acc.stack
</span></span><span style=display:flex><span>   Compiling stacklang v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/stacklang<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 3.76s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/fibonacci-acc.stack<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>12586269025</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real	0m4.037s
</span></span><span style=display:flex><span>user	0m0.048s
</span></span><span style=display:flex><span>sys	0m0.047s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just example fibonacci-acc compile<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>just example-compile fibonacci-acc
</span></span><span style=display:flex><span>cargo run --release -- --file examples/fibonacci-acc.stack --compile &gt; output/fibonacci-acc.c
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.05s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/fibonacci-acc.stack --compile<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>clang -Ofast output/fibonacci-acc.c -o output/fibonacci-acc
</span></span><span style=display:flex><span>time output/fibonacci-acc
</span></span><span style=display:flex><span><span style=color:#ae81ff>12586269025</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real	0m0.097s
</span></span><span style=display:flex><span>user	0m0.001s
</span></span><span style=display:flex><span>sys	0m0.001s
</span></span></code></pre></div><p>Pretty cool.</p><p>And if I just want to compare VM vs compiler (as I did quite a lot while tracking down bugs):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just both fibonacci-acc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>just example fibonacci-acc
</span></span><span style=display:flex><span>just example-run fibonacci-acc
</span></span><span style=display:flex><span>time cargo run --release -- --file examples/fibonacci-acc.stack
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.08s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/fibonacci-acc.stack<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>12586269025</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real	0m0.327s
</span></span><span style=display:flex><span>user	0m0.044s
</span></span><span style=display:flex><span>sys	0m0.036s
</span></span><span style=display:flex><span>just example fibonacci-acc compile<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>just example-compile fibonacci-acc
</span></span><span style=display:flex><span>cargo run --release -- --file examples/fibonacci-acc.stack --compile &gt; output/fibonacci-acc.c
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.02s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/fibonacci-acc.stack --compile<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>clang -Ofast output/fibonacci-acc.c -o output/fibonacci-acc
</span></span><span style=display:flex><span>time output/fibonacci-acc
</span></span><span style=display:flex><span><span style=color:#ae81ff>12586269025</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real	0m0.035s
</span></span><span style=display:flex><span>user	0m0.000s
</span></span><span style=display:flex><span>sys	0m0.001s
</span></span></code></pre></div><p>Shiny.</p><h2 id=mandelbrot-timing>Mandelbrot timing</h2><p>As mentioned (and shown <a href=#justfile>above</a>), the C compiler is <em>fast</em> compared to the VM. Here&rsquo;s a real example. Generating a 1024x768x8 Mandelbrot image.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo -e <span style=color:#e6db74>&#34;1024\n768\n8\n&#34;</span> | just example mandelbrot-read | convert - output/mandelbrot-vm.png
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>just example-run mandelbrot-read
</span></span><span style=display:flex><span>time cargo run --release -- --file examples/mandelbrot-read.stack
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.15s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/mandelbrot-read.stack<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>                                                                                                                                       real	2m16.413s
</span></span><span style=display:flex><span>user	1m59.204s
</span></span><span style=display:flex><span>sys	0m2.758s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo -e <span style=color:#e6db74>&#34;1024\n768\n8\n&#34;</span> | just example mandelbrot-read compile<span style=color:#f92672>=</span>true | convert - output/mandelbrot-compile.png
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>just example-compile mandelbrot-read
</span></span><span style=display:flex><span>cargo run --release -- --file examples/mandelbrot-read.stack --compile &gt; output/mandelbrot-read.c
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.02s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/stacklang --file examples/mandelbrot-read.stack --compile<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>clang -Ofast output/mandelbrot-read.c -o output/mandelbrot-read
</span></span><span style=display:flex><span>time output/mandelbrot-read
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real	0m2.145s
</span></span><span style=display:flex><span>user	0m2.062s
</span></span></code></pre></div><p>Yes. You read that write. From 2m16s down to 2s. Not too bad! ðŸ˜„</p><h2 id=next-steps>Next steps</h2><p>I know it&rsquo;s been a while, but I hope it was worth it. Like last time, it&rsquo;s so cool just seeing something like this working&mldr;</p><p>So what&rsquo;s next?</p><ul><li>Type checking:<ul><li>Automatically determine specific types of expressions (including blocks)</li><li>Automatically determine the <code>arity</code> of blocks when possible</li></ul></li><li>Numeric tower:<ul><li>Implement rationals/complex numbers at the parser level + in any interpreter / compiler I have at that point</li></ul></li><li>Interpreters:<ul><li>A bytecode interpreter/compiler, evaluating at a lower level (I&rsquo;m not sure how much this would gain, the AST is already fairly low level)</li></ul></li><li>Compilers:<ul><li>Compile to WASM; since it&rsquo;s also stack based, this should be interesting</li><li>Compile to x86/ARM assembly</li></ul></li></ul><p>I think I want to work more on types next, possibly doing away with manual coercion. We&rsquo;ll see.</p><p>Onwards, once again!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>