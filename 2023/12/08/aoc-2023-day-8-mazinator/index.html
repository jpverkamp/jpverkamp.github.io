<!doctype html><html><head><title>AoC 2023 Day 8: Mazinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 8: Mazinator</h1><div class=entry-meta><span class=entry-date>2023-12-08</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/07/aoc-2023-day-7-pokinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/07/aoc-2023-day-7-pokinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/07/aoc-2023-day-7-pokinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/07/aoc-2023-day-7-pokinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/07/aoc-2023-day-7-pokinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-8-haunted-wasteland>Source: <a href=https://adventofcode.com/2023/day/8 target=_blank rel=noopener>Day 8: Haunted Wasteland</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day08 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-8-haunted-wasteland>Source: <a href=https://adventofcode.com/2023/day/8>Day 8: Haunted Wasteland</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#types-and-parsing>Types and Parsing</a></li><li><a href=#solution>Solution</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#brute-force>Brute Force</a></li><li><a href=#detecting-cycles>Detecting Cycles</a></li></ul></li><li><a href=#performance>Performance</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a (repeated) sequence of moves (<code>L</code> for left and <code>R</code> for right) and a directed graph where each node has two neighbors (left and right), count how many total steps it takes to get from the node <code>AAA</code> to the node <code>ZZZ</code>. The sequence of moves can (and will) need to repeat.</p></blockquote><h3 id=types-and-parsing>Types and Parsing</h3><p>I think the only really interesting part in this one was the use of <code>Label</code> as an alias of <code>[char; 3]</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Move</span> {
</span></span><span style=display:flex><span>    Left,
</span></span><span style=display:flex><span>    Right,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Label</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>char</span>; <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Neighbors</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> left: <span style=color:#a6e22e>Label</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> right: <span style=color:#a6e22e>Label</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Simulation</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> moves: Vec<span style=color:#f92672>&lt;</span>Move<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> neighbors: <span style=color:#a6e22e>BTreeMap</span><span style=color:#f92672>&lt;</span>Label, Neighbors<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We probably could have also used <code>&amp;str</code> there, but I figure that copying (always) 3 chars is probably pretty fast? If allocation becomes an issue, we can fix this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>moves</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Vec<span style=color:#f92672>&lt;</span>Move<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, moves) <span style=color:#f92672>=</span> many1(alt((
</span></span><span style=display:flex><span>        map(tag(<span style=color:#e6db74>&#34;L&#34;</span>), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Move::Left),
</span></span><span style=display:flex><span>        map(tag(<span style=color:#e6db74>&#34;R&#34;</span>), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Move::Right),
</span></span><span style=display:flex><span>    )))(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    Ok((s, moves))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>label</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Label<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, label) <span style=color:#f92672>=</span> tuple((anychar, anychar, anychar))(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    Ok((s, label.into()))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>mapping</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, (Label, Neighbors)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, (label, left, right)) <span style=color:#f92672>=</span> tuple((
</span></span><span style=display:flex><span>        label,
</span></span><span style=display:flex><span>        preceded(tag(<span style=color:#e6db74>&#34; = (&#34;</span>), label),
</span></span><span style=display:flex><span>        terminated(preceded(tag(<span style=color:#e6db74>&#34;, &#34;</span>), label), tag(<span style=color:#e6db74>&#34;)&#34;</span>)),
</span></span><span style=display:flex><span>    ))(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok((s, (label, Neighbors { left, right })))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulation</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Simulation<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, moves) <span style=color:#f92672>=</span> moves(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, _) <span style=color:#f92672>=</span> newline(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, _) <span style=color:#f92672>=</span> newline(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, neighbors) <span style=color:#f92672>=</span> separated_list1(newline, mapping)(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    Ok((
</span></span><span style=display:flex><span>        s,
</span></span><span style=display:flex><span>        Simulation {
</span></span><span style=display:flex><span>            moves,
</span></span><span style=display:flex><span>            neighbors: <span style=color:#a6e22e>neighbors</span>.into_iter().collect(),
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    ))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution>Solution</h3><p>Let&rsquo;s start with the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, <span style=color:#66d9ef>ref</span> simulation) <span style=color:#f92672>=</span> parse::simulation(<span style=color:#f92672>&amp;</span>input).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(s.trim(), <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> current: <span style=color:#a6e22e>Label</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> target: <span style=color:#a6e22e>Label</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;Z&#39;</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> m <span style=color:#66d9ef>in</span> simulation.moves.iter().cycle() {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> m {
</span></span><span style=display:flex><span>            Move::Left <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>current].left,
</span></span><span style=display:flex><span>            Move::Right <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>current].right,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current <span style=color:#f92672>==</span> target {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Apparently you can&rsquo;t <code>"AAA".into()</code>. I could have done a <code>from</code> on <code>Label</code>, but this is fine.</p><p>Other than that, start with <code>AAA</code> and then iterate through the <code>simulation.moves</code> until you find <code>ZZZ</code>. The nice part here is <code>.iter().cycle()</code> which gives us an infinitely repeating iterator for more or less free!</p><p>And that&rsquo;s it. 12k steps or so and we&rsquo;re done.</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of starting at just <code>AAA</code>, start at all nodes <code>**A</code> (ending with an <code>A</code>). Simulate all agents in lockstep and end when <em>all</em> agents are at a node <code>**Z</code> (ends with <code>Z</code>).</p></blockquote><h3 id=brute-force>Brute Force</h3><p>Interesting. Well, let&rsquo;s try the brute force solution:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, <span style=color:#66d9ef>ref</span> simulation) <span style=color:#f92672>=</span> parse::simulation(<span style=color:#f92672>&amp;</span>input).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(s.trim(), <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get all nodes that end in A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> current <span style=color:#f92672>=</span> simulation
</span></span><span style=display:flex><span>        .neighbors
</span></span><span style=display:flex><span>        .keys()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> l[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;A&#39;</span>)
</span></span><span style=display:flex><span>        .cloned()
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Count cycles
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> m <span style=color:#66d9ef>in</span> simulation.moves.iter().cycle() {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> result <span style=color:#f92672>%</span> <span style=color:#ae81ff>100_000_000</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update all nodes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        current <span style=color:#f92672>=</span> current
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> m {
</span></span><span style=display:flex><span>                Move::Left <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>l].left,
</span></span><span style=display:flex><span>                Move::Right <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>l].right,
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If all nodes end in Z, we can exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> current.iter().all(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> l[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Z&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code isn&rsquo;t that bad. Instead of a single node, <code>current</code> is now a <code>Vec</code> of nodes (I could actually have used a slice, now that I think about it).</p><p>About now, you&rsquo;re probably realizing that this might be an issue though (especially if you see that <code>result % 100_000_000</code> debug statement in the middle there)&mldr; just how <em>long</em> is it going to take for these all to get in sync?</p><p>Well, I let the code run for a while&mldr; without actually getting an answer. So while I let that run, let&rsquo;s see if we can do any better.</p><h3 id=detecting-cycles>Detecting Cycles</h3><p>So one thing to note: eventually all of the agents <em>have</em> to cycle. The input is repeating and there are only so many nodes in the graph, so eventually you are going to end up at the same node in the graph while on the same step of the input. At that point, you&rsquo;re guaranteed to hit exactly the same sequence of nodes again and again.</p><p>So let&rsquo;s start there.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Get all nodes that end in A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> starts <span style=color:#f92672>=</span> simulation
</span></span><span style=display:flex><span>    .neighbors
</span></span><span style=display:flex><span>    .keys()
</span></span><span style=display:flex><span>    .filter(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> l[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;A&#39;</span>)
</span></span><span style=display:flex><span>    .cloned()
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For each node, determine how long of a cycle it has
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This will be where you see the same node + position in input list twice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> cycles <span style=color:#f92672>=</span> starts
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>each<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> current <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>each;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cycle_length: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Previous states: position in input list + node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> BTreeMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, m) <span style=color:#66d9ef>in</span> simulation.moves.iter().enumerate().cycle() {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re in a final state we&#39;ve seen before, we have a cycle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> current[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Z&#39;</span> <span style=color:#f92672>&amp;&amp;</span> visited.contains_key(<span style=color:#f92672>&amp;</span>(i, current)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> cycle_start: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> visited[<span style=color:#f92672>&amp;</span>(i, current)];
</span></span><span style=display:flex><span>                cycle_length <span style=color:#f92672>=</span> count <span style=color:#f92672>-</span> cycle_start;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, record this state and update
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            visited.insert((i, current), count);
</span></span><span style=display:flex><span>            current <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> m {
</span></span><span style=display:flex><span>                Move::Left <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>current].left,
</span></span><span style=display:flex><span>                Move::Right <span style=color:#f92672>=&gt;</span> simulation.neighbors[<span style=color:#f92672>&amp;</span>current].right,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cycle_length
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span></code></pre></div><p>To solve this, we&rsquo;re going to keep a <code>BTreeMap</code> of all position in input + node we&rsquo;ve seen before and which tick we saw that on. This was a fun trick to find, that <code>.iter().enumerate().cycle()</code> will return <code>(position in cycle, move)</code> as opposed to <code>.iter().cycle().enumerate()</code> which would count on forever.</p><p>Then, as mentioned, when we see an element in the <code>visited</code> map a second time, we&rsquo;ve detected a cycle. The length is the current tick (<code>count</code>) minus when we last saw that state (the value in the <code>Map</code>).</p><p>Originally, I thought that we&rsquo;d need to return both the <code>cycle_start</code> and <code>cycle_length</code> here and then figure out some sort of solver over all <code>start + X * length</code>.</p><p>I also considered &lsquo;what if there are multiple exit points in the cycle&rsquo; (multiple nodes that end in <code>Z</code> that a single agent visits). But again, for this problem, that didn&rsquo;t end up mattering.</p><p>But then I thought a bit mathy: what is the actual mathematical way of determining when two cycles overlap? <a href=https://en.wikipedia.org/wiki/least%20common%20multiple>least common multiple</a>!</p><p>So let&rsquo;s implement that real quick:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>gcd</span>(a: <span style=color:#66d9ef>usize</span>, b: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        a
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        gcd(b, a <span style=color:#f92672>%</span> b)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>lcm</span>(a: <span style=color:#66d9ef>usize</span>, b: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    a <span style=color:#f92672>/</span> gcd(a, b) <span style=color:#f92672>*</span> b
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(That should be in <code>num::integer::lcm</code>, which would have required pulling in <a href=https://crates.io/crates/num target=_blank rel=noopener><code>num</code></a>. It&rsquo;s interesting that&rsquo;s not in the standard library.)</p><p>And then apply the <code>lcm</code> to all of the <code>cycle_lengths</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> cycles.clone().into_iter().reduce(lcm).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>Ok(())
</span></span></code></pre></div><p>I like <code>reduce</code>. It&rsquo;s like <code>fold</code> except takes the first entry as the base case and <code>reduces</code> each number into it. So it turns <code>lcm(a, b)</code> into a function that can take <code>lcm(*ls)</code>.</p><p>In any case&mldr; it turns out that&rsquo;s <em>actually the right answer for the problem</em>.</p><p>I&rsquo;m&mldr; still not actually sure why that worked without considering the offsets of where each cycle starts. The write up on <a href=https://math.stackexchange.com/questions/2218763/how-to-find-lcm-of-two-numbers-when-one-starts-with-an-offset target=_blank rel=noopener>this StackExchange post</a> did give me the hint that it wouldn&rsquo;t matter, but it still feels really weird to me.</p><p>The idea that I didn&rsquo;t have to check multiple possible <code>Z</code> nodes for each cycle though, that&rsquo;s a matter of input. There&rsquo;s only a single <code>Z</code> for each agent&ndash;verified that while solving the problem.</p><p>But&mldr; it worked? And I mostly understand why. So we&rsquo;ll go with it.</p><h2 id=performance>Performance</h2><p>So, let&rsquo;s talk performance. How well do our solutions run?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> just time <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine <span style=color:#f92672>--</span>warmup <span style=color:#ae81ff>3</span> <span style=color:#a6e22e>&#39;just</span> run <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>1</span><span style=color:#a6e22e>&#39;</span>
</span></span><span style=display:flex><span>Benchmark <span style=color:#ae81ff>1</span>: <span style=color:#a6e22e>just</span> run <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time (mean <span style=color:#960050;background-color:#1e0010>±</span> <span style=color:#960050;background-color:#1e0010>σ</span>):      <span style=color:#ae81ff>82.0</span> ms <span style=color:#960050;background-color:#1e0010>±</span>   <span style=color:#ae81ff>4.2</span> ms    [User: <span style=color:#ae81ff>31.0</span> ms, System: <span style=color:#ae81ff>11.6</span> ms]
</span></span><span style=display:flex><span>  Range (min <span style=color:#960050;background-color:#1e0010>…</span> max):    <span style=color:#ae81ff>77.8</span> ms <span style=color:#960050;background-color:#1e0010>…</span>  <span style=color:#ae81ff>90.5</span> ms    <span style=color:#ae81ff>33</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>$</span> just time <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine <span style=color:#f92672>--</span>warmup <span style=color:#ae81ff>3</span> <span style=color:#a6e22e>&#39;just</span> run <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>2</span><span style=color:#a6e22e>&#39;</span>
</span></span><span style=display:flex><span>Benchmark <span style=color:#ae81ff>1</span>: <span style=color:#a6e22e>just</span> run <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time (mean <span style=color:#960050;background-color:#1e0010>±</span> <span style=color:#960050;background-color:#1e0010>σ</span>):     <span style=color:#ae81ff>117.7</span> ms <span style=color:#960050;background-color:#1e0010>±</span>   <span style=color:#ae81ff>7.1</span> ms    [User: <span style=color:#ae81ff>55.8</span> ms, System: <span style=color:#ae81ff>12.4</span> ms]
</span></span><span style=display:flex><span>  Range (min <span style=color:#960050;background-color:#1e0010>…</span> max):   <span style=color:#ae81ff>106.3</span> ms <span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#ae81ff>130.8</span> ms    <span style=color:#ae81ff>23</span> runs
</span></span></code></pre></div><p>Nice! Just about as fast as anything else.</p><p>But&mldr; what about that elephant in the room. The brute force solution. It was still happily chugging away (I tried a few other answers there as well, including <a href=https://crates.io/crates/rayon target=_blank rel=noopener><code>rayon</code></a> and some code optimizations), but none of them finished.</p><p>So&mldr; how long would it take to run?</p><p>Well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ time just run <span style=color:#ae81ff>8</span> 2-brute | ts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat data/<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 8<span style=color:#66d9ef>)</span>.txt | cargo run --release -p day<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 8<span style=color:#66d9ef>)</span> --bin part2-brute
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2023-12-08 01:40:42<span style=color:#f92672>]</span> --- &lt;ts&gt; ---
</span></span><span style=display:flex><span>   Compiling day08 v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/advent-of-code/2023-ws/solutions/day08<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.16s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/part2-brute<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2023-12-08 01:41:08<span style=color:#f92672>]</span> <span style=color:#ae81ff>100000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2023-12-08 01:41:34<span style=color:#f92672>]</span> <span style=color:#ae81ff>200000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2023-12-08 01:42:00<span style=color:#f92672>]</span> <span style=color:#ae81ff>300000000</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><a href=https://blog.jverkamp.com/2015/02/26/ts-timestamping-stdout/>ts</a> is a script I wrote a long time ago that timestamps each line of <code>stdout</code>, so in this case we can get how long the program is running without having to actually do timing in our Rust code.</p><p>As you can see, it&rsquo;s running at (very roughly) 20 seconds per <em>100 million</em> iterations. That&rsquo;s pretty fast. But&mldr; what&rsquo;s the actual answer? Roughly 9 <em>trillion</em>?</p><p>Oy. That&rsquo;s a very big number.</p><p>So big in fact that the estimated time to get to that value is 2.5e6 seconds. That&rsquo;s&mldr; 27 <em>days</em> and change.</p><p>Yeah, I didn&rsquo;t let that keep running.</p><p>I am curious if anyone has a better explanation for why the <code>lcm</code> of just the <code>cycle_lengths</code> works, but for now, it does! Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>