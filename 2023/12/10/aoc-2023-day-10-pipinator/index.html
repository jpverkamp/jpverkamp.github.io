<!doctype html><html><head><title>AoC 2023 Day 10: Pipinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 10: Pipinator</h1><div class=entry-meta><span class=entry-date>2023-12-10</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=previous-link>Prev</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/09/aoc-2023-day-9-stackinator/ class=previous-link>Prev</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-10-pipe-mazehttpsadventofcodecom2023day10>Source: <a href=https://adventofcode.com/2023/day/10 target=_blank rel=noopener>Day 10: Pipe Maze</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day10 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-10-pipe-mazehttpsadventofcodecom2023day10>Source: <a href=https://adventofcode.com/2023/day/10>Day 10: Pipe Maze</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#types-and-parsing>Types and Parsing</a></li><li><a href=#iterating>Iterating</a></li><li><a href=#solution>Solution</a></li></ul></li><li><a href=#part-2>Part 2</a></li><li><a href=#performance>Performance</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>You are given as input an <a href=https://en.wikipedia.org/wiki/ASCII%20art>ASCII art</a> pipe diagram with straight pipes <code>|-</code>, right angle turns <code>LJ7F</code>, ground <code>.</code>, and a start tile <code>S</code>.</p><p>The start tile will be part of a loop of pipes.</p><p>Find the distance to the furthest connected pipe segment from <code>S</code> (or half the length of the loop).</p></blockquote><h3 id=types-and-parsing>Types and Parsing</h3><p>Okay, I feel like this is going to be an interesting one!</p><p>First up, some types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    nodes: Vec<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    start_index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>char</span>,
</span></span><span style=display:flex><span>    neighbor_a_index: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    neighbor_b_index: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We don&rsquo;t actually need to store the <code>x</code> and <code>y</code> for <code>Node</code> (or actually the <code>value</code> either, depending on how we parse things), but I think that they&rsquo;ll be handy to have around.</p><p><code>neighbor_(a|b)_index</code> will store the two neighbors for each node. They&rsquo;re <code>Option</code> because 1) there will be random nodes in the graph that are not part of the loop and 2) the <code>S</code>tart node will need to be filled in when we have the rest of the loop.</p><p>Assuming we have all that, we should be able to write a <code>From&lt;&amp;str></code> for <code>Map</code>. As was the case in <a href=https://blog.jverkamp.com/2023/12/03/aoc-2023-day-3-gearinator/>day 3</a>, <code>nom</code> (so far as I can tell) isn&rsquo;t <em>great</em> when it comes to parsing grids like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Parse a Map from a &amp;str
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> raw_nodes <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>            .lines()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .flat_map(<span style=color:#f92672>|</span>(y, line)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                line.chars()
</span></span><span style=display:flex><span>                    .enumerate()
</span></span><span style=display:flex><span>                    .filter(<span style=color:#f92672>|</span>(_, c)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>                    .map(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>(x, value)<span style=color:#f92672>|</span> (x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>, value))
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> start_index <span style=color:#f92672>=</span> raw_nodes
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .position(<span style=color:#f92672>|</span>(_, _, value)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;S&#39;</span>)
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index_offset</span>(
</span></span><span style=display:flex><span>            raw_nodes: <span style=color:#66d9ef>&amp;</span>[(<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>char</span>)],
</span></span><span style=display:flex><span>            x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            xd: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            yd: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>        ) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            raw_nodes
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .position(<span style=color:#f92672>|</span>(x2, y2, _)<span style=color:#f92672>|</span> x <span style=color:#f92672>+</span> xd <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>x2 <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>+</span> yd <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>y2)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Forward is first clockwise from up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Backwards is second
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nodes <span style=color:#f92672>=</span> raw_nodes
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(x, y, value)<span style=color:#f92672>|</span> Node {
</span></span><span style=display:flex><span>                x: <span style=color:#f92672>*</span>x,
</span></span><span style=display:flex><span>                y: <span style=color:#f92672>*</span>y,
</span></span><span style=display:flex><span>                value: <span style=color:#f92672>*</span>value,
</span></span><span style=display:flex><span>                neighbor_a_index: <span style=color:#a6e22e>match</span> <span style=color:#f92672>*</span>value {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;|&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;L&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;J&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Right (but no up)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;F&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Down (but not right or up)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;7&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Left (can&#39;t have the first one go only left)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Ignore S (we&#39;ll figure this out later)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;S&#39;</span> <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Break on anything else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid value: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, value),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                neighbor_b_index: <span style=color:#a6e22e>match</span> <span style=color:#f92672>*</span>value {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Up (can&#39;t have the second one go up)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Right (first must have gone up)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;L&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Down (first must have gone up or right)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;|&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;F&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Left (anything else really)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;J&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;7&#39;</span> <span style=color:#f92672>=&gt;</span> index_offset(<span style=color:#f92672>&amp;</span>raw_nodes, <span style=color:#f92672>*</span>x, <span style=color:#f92672>*</span>y, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Ignore S (we&#39;ll figure this out later)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;S&#39;</span> <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Break on anything else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid value: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, value),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The start node has exactly two neighbors; find them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> start_neighbors <span style=color:#f92672>=</span> nodes
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>(i, node)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> node.neighbor_a_index.is_some_and(<span style=color:#f92672>|</span>j<span style=color:#f92672>|</span> j <span style=color:#f92672>==</span> start_index)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> node.neighbor_b_index.is_some_and(<span style=color:#f92672>|</span>j<span style=color:#f92672>|</span> j <span style=color:#f92672>==</span> start_index)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Some(i)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        assert_eq!(start_neighbors.len(), <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        nodes[start_index].neighbor_a_index <span style=color:#f92672>=</span> Some(start_neighbors[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        nodes[start_index].neighbor_b_index <span style=color:#f92672>=</span> Some(start_neighbors[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map { nodes, start_index }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay. That&rsquo;s heavy. Hopefully it&rsquo;s well commented. I really should write better tests though. Essentially, we&rsquo;re going to go through a few phases:</p><ol><li>Find all of the <code>raw_nodes</code> - this is just an <code>(x, y, c)</code> for each node, using <code>enumerate()</code> to get the indexes and dropping the ground (<code>.</code>) nodes</li><li>Define a helper <code>index_offset</code> which will take a list of raw nodes, an <code>(x, y)</code> and an <code>(xd, yd)</code> offset and find the index (in <code>raw_nodes</code>) which nodes (if any) is at that position</li><li>Another <code>iter</code> to build the actual <code>Nodes</code>, a lot of the work here is finding the two <code>neighbor_(a|b)_index</code> values and making sure that they don&rsquo;t overlap. As mentioned, to do that, I&rsquo;m specifically defining <code>a</code> as the &lsquo;first&rsquo; point starting up and going clockwise and <code>b</code> the second&ndash;there will be more than two</li><li>The <code>S</code>tart node should now have exactly two neighbors that point to it, fill in index pointers to those two nodes</li></ol><p>And that&rsquo;s <em>it</em> relatively speaking. Step 3 is definitely a bit error prone, since I had to make sure that I was consistent around which was <code>a</code> and which <code>b</code> or you get loops. Ask me how I know ðŸ˜„.</p><h3 id=iterating>Iterating</h3><p>The next useful thing to have will be a way to <code>iter</code> on a <code>Map</code>. Specifically, I want to start at the <code>start_node</code> and return each node along the loop exactly once.</p><p>One funny bit here is that you can&rsquo;t just always take the <code>a</code> (or <code>b</code>) neighbor, because <code>|</code> has <code>a</code> going up no matter if you&rsquo;d be going up or down. So to handle this, you have to keep track of both your current position in the iter and where you just came from (if you have a choice where to go, go to the one that <em>isn&rsquo;t</em> going backwards):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// An iterator over the nodes in Map
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Starts at the start node
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Returns each node (on the loop) once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug, Copy, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MapIterator</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>Map</span>,
</span></span><span style=display:flex><span>    current_index: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    previous_index: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    fresh: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> MapIterator<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we manage to run off a trail, something went wrong, but this will stop iter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.current_index<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The node we&#39;re about to return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>self.map.nodes[self.current_index.unwrap()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Only return the Start node once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.fresh <span style=color:#f92672>&amp;&amp;</span> node.value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;S&#39;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find the next node, if &#39;a&#39; points to the one we were just at, use &#39;b&#39; instead
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_index <span style=color:#f92672>=</span> node.neighbor_a_index;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> next_index <span style=color:#f92672>==</span> self.previous_index {
</span></span><span style=display:flex><span>            next_index <span style=color:#f92672>=</span> node.neighbor_b_index;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        self.previous_index <span style=color:#f92672>=</span> self.current_index;
</span></span><span style=display:flex><span>        self.current_index <span style=color:#f92672>=</span> next_index;
</span></span><span style=display:flex><span>        self.fresh <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(node)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>MapIterator</span> {
</span></span><span style=display:flex><span>        MapIterator {
</span></span><span style=display:flex><span>            map: <span style=color:#a6e22e>self</span>,
</span></span><span style=display:flex><span>            current_index: Some(self.start_index),
</span></span><span style=display:flex><span>            previous_index: None,
</span></span><span style=display:flex><span>            fresh: <span style=color:#a6e22e>true</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution>Solution</h3><p>Okay, that&rsquo;s a lot to get here, but now we should be able to directly calculate the solution using <a href=https://en.wikipedia.org/wiki/Floyd%27s%20tortoise%20and%20hare%20algorithm>Floyd's tortoise and hare algorithm</a>. Essentially, start two <code>iter</code> with one moving twice as fast. Eventually, the fast one will catch up to the slow one; that will be the length of the cycle. Half that is our answer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> map <span style=color:#f92672>=</span> Map::from(input.as_str());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set off two iters, one at double speed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Skip the first nyde for each to avoid the start node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// When they are equal, they have reached the farthest point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> map
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .cycle()
</span></span><span style=display:flex><span>        .skip(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        .zip(map.iter().cycle().skip(<span style=color:#ae81ff>2</span>).step_by(<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>        .position(<span style=color:#f92672>|</span>(n1, n2)<span style=color:#f92672>|</span> n1 <span style=color:#f92672>==</span> n2)
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> (result <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I do enjoy functional Rust sometimes. ðŸ˜„</p><h2 id=part-2>Part 2</h2><blockquote><p>Calculate the area completely enclosed by the loop containing the <code>S</code>tart node. Count extraneous pipe sections, but not those within the main loop. If there are two parallel sections of loop such as <code>.||.</code>, a region North and South of that would still be connected.</p></blockquote><p>This one also took some doing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> map <span style=color:#f92672>=</span> Map::from(input.as_str());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (min_x, min_y, max_x, max_y) <span style=color:#f92672>=</span> map.bounds();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Each region is a hash set of points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> region_cw <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> region_ccw <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> outside_cw <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> outside_ccw <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Determine the main loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> loop_points <span style=color:#f92672>=</span> map
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>node<span style=color:#f92672>|</span> (node.x(), node.y()))
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>HashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Given a specific start point, flood fill all points into the specific region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Do not add points that are:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 1 - Part of the loop (points that are set but not part of the loop are fine)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 2 - Out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 3 - Already added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> flood_fill <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>region: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> HashSet<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>)<span style=color:#f92672>&gt;</span>, start: (<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>)<span style=color:#f92672>|</span> -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stack <span style=color:#f92672>=</span> vec![start];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> is_outside <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some((x, y)) <span style=color:#f92672>=</span> stack.pop() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Never add points on the loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> loop_points.contains(<span style=color:#f92672>&amp;</span>(x, y)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Never add points out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&lt;</span> min_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> x <span style=color:#f92672>&gt;</span> max_x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> y <span style=color:#f92672>&lt;</span> min_y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> y <span style=color:#f92672>&gt;</span> max_y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                is_outside <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Stop if we&#39;ve already added this point to the region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> region.contains(<span style=color:#f92672>&amp;</span>(x, y)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, add it and expand
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            region.insert((x, y));
</span></span><span style=display:flex><span>            stack.push((x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y));
</span></span><span style=display:flex><span>            stack.push((x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y));
</span></span><span style=display:flex><span>            stack.push((x, y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            stack.push((x, y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        is_outside
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Over each pair of points, determine which side is &#39;clockwise&#39; and which &#39;counter-clockwise&#39; from that point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Flood fill the approproiate region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    map.iter()
</span></span><span style=display:flex><span>        .zip(map.iter().cycle().skip(<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        .for_each(<span style=color:#f92672>|</span>(n1, n2)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (x1, y1) <span style=color:#f92672>=</span> (n1.x(), n1.y());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (x2, y2) <span style=color:#f92672>=</span> (n2.x(), n2.y());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> xd <span style=color:#f92672>=</span> x2 <span style=color:#f92672>-</span> x1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> yd <span style=color:#f92672>=</span> y2 <span style=color:#f92672>-</span> y1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> (xd, yd) {
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .2x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .1x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>1</span>).for_each(<span style=color:#f92672>|</span>yd<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        outside_cw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_cw, (x2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y2 <span style=color:#f92672>+</span> yd));
</span></span><span style=display:flex><span>                        outside_ccw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_ccw, (x2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y2 <span style=color:#f92672>+</span> yd));
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .12.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .xx.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>0</span>).for_each(<span style=color:#f92672>|</span>xd<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        outside_cw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_cw, (x2 <span style=color:#f92672>+</span> xd, y2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                        outside_ccw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_ccw, (x2 <span style=color:#f92672>+</span> xd, y2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Down
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// x1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// x2.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>0</span>).for_each(<span style=color:#f92672>|</span>yd<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        outside_cw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_cw, (x2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y2 <span style=color:#f92672>+</span> yd));
</span></span><span style=display:flex><span>                        outside_ccw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_ccw, (x2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y2 <span style=color:#f92672>+</span> yd));
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .xx.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// .21.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>1</span>).for_each(<span style=color:#f92672>|</span>xd<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        outside_cw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_cw, (x2 <span style=color:#f92672>+</span> xd, y2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                        outside_ccw <span style=color:#f92672>|=</span> flood_fill(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> region_ccw, (x2 <span style=color:#f92672>+</span> xd, y2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid direction: (</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, xd, yd),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    assert!(outside_cw <span style=color:#f92672>^</span> outside_ccw);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> outside_ccw { region_cw } <span style=color:#66d9ef>else</span> { region_ccw }.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The basic idea is that there should be exactly two regions in the image, one &lsquo;inside&rsquo; and one &lsquo;outside&rsquo;. But another way to look at it, one will be clockwise (<code>cw</code>) and the other counterclockwise (<code>ccw</code>) with respect to the trail you&rsquo;re taking through the pipes (if you <code>iter</code> in the opposite direction, these will swap).</p><p>So the algorithm is as follows:</p><ol><li>For each point along the loop, use the direction you&rsquo;re moving from the previous point and determine two points <code>clockwise</code> and two <code>counterclockwise</code> along your path; <a href=https://en.wikipedia.org/wiki/flood%20fill>flood fill</a> from each of those points into a calculated region<ol><li>A flood fill will include a point and (recursively) all neighbors so long as each point is <em>not</em>:<ol><li>On the loop</li><li>Out of bounds (this will also mark the region as &lsquo;outside&rsquo;)</li><li>Already included</li></ol></li></ol></li></ol><p>After that all is done, we should have exactly one of the two points that crossed the <code>bounds</code> of the map, this one is outside and we want the other one.</p><p>There was one gotcha that took me a bit to determine; that is the comment about &rsquo;two points <code>clockwise</code>&rsquo;. Without that, it&rsquo;s possible in regions that zigzag a lot to miss a few points that won&rsquo;t otherwise be flood filled. Getting the indexes right for that took a moment as well.</p><p>But once that&rsquo;s all run, we&rsquo;re good to go!</p><p>This was an interesting one. No magic (so far as I&rsquo;m concerned) once you realized that there will always be exactly two regions&ndash;&lsquo;clockwise&rsquo; and &lsquo;counterclockwise&rsquo;.</p><h2 id=performance>Performance</h2><p>Still pretty fast, although we&rsquo;re actually passing (<em>gasp</em>) a quarter second!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 10 1&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     252.3 ms Â±   3.5 ms    <span style=color:#f92672>[</span>User: 177.2 ms, System: 11.3 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   245.3 ms â€¦ 257.9 ms    <span style=color:#ae81ff>11</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 10 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     261.3 ms Â±   3.9 ms    <span style=color:#f92672>[</span>User: 182.7 ms, System: 12.6 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   254.3 ms â€¦ 266.3 ms    <span style=color:#ae81ff>11</span> runs
</span></span></code></pre></div><p>I&rsquo;m okay with this.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>