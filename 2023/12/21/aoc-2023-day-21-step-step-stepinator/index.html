<!doctype html><html><head><title>AoC 2023 Day 21: Step Step Stepinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 21: Step Step Stepinator</h1><div class=entry-meta><span class=entry-date>2023-12-21</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/20/aoc-2023-day-20-flip-flopinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/20/aoc-2023-day-20-flip-flopinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/20/aoc-2023-day-20-flip-flopinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/20/aoc-2023-day-20-flip-flopinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/21/star-wars-vol.-6-out-among-the-stars/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/22/taskmaster-series-11/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-21-step-counterhttpsadventofcodecom2023day21>Source: <a href=https://adventofcode.com/2023/day/21 target=_blank rel=noopener>Day 21: Step Counter</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day21 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-21-step-counterhttpsadventofcodecom2023day21>Source: <a href=https://adventofcode.com/2023/day/21>Day 21: Step Counter</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#parsing>Parsing</a></li><li><a href=#solution>Solution</a></li><li><a href=#re-calculating-bounds>Re-calculating Bounds</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#brute-force>Brute Force</a></li><li><a href=#solution-1>Solution</a></li><li><a href=#another-option>Another option</a></li></ul></li><li><a href=#performance>Performance</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a(n infinite) grid of walls <code>#</code>, count how many points can be reached by exactly 64 steps from a starting point.</p></blockquote><h3 id=parsing>Parsing</h3><p>I&rsquo;m not going to use any more types, but I am going to wrap <code>Grid</code> to just return the points and starting location:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; (FxHashSet<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>, Point) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> walls <span style=color:#f92672>=</span> Grid::read(input, <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span> { Some(<span style=color:#66d9ef>true</span>) } <span style=color:#66d9ef>else</span> { None });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> walls <span style=color:#f92672>=</span> walls.iter().map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p).collect::<span style=color:#f92672>&lt;</span>FxHashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> Grid::read(input, <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;S&#39;</span> { Some(<span style=color:#66d9ef>true</span>) } <span style=color:#66d9ef>else</span> { None });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>start.iter().next().unwrap().<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (walls, start)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution>Solution</h3><p>Okay, let&rsquo;s do it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (walls, start) <span style=color:#f92672>=</span> parse::read(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>    active.insert(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#66d9ef>STEPS</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> pos <span style=color:#66d9ef>in</span> active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> pos.neighbors() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>walls.contains(<span style=color:#f92672>&amp;</span>neighbor) {
</span></span><span style=display:flex><span>                    next_active.insert(neighbor);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        active <span style=color:#f92672>=</span> next_active;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> active.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=re-calculating-bounds>Re-calculating Bounds</h3><p>One problem that doesn&rsquo;t come up in the solution, but did with debug printing is that we lose the <code>Bounds</code> information that a <code>Grid</code> stores. Let&rsquo;s make it possible to recalculate that (hacky, I know) from any <code>Iterator&lt;Item = Point></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Bounds
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: IntoIterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#a6e22e>I</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bounds <span style=color:#f92672>=</span> Bounds::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> value {
</span></span><span style=display:flex><span>            bounds.include(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bounds
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So we can get it back with <code>let wall_bounds = Bounds::from(walls.iter())</code>. Pretty cool that.</p><h2 id=part-2>Part 2</h2><blockquote><p>Repeat the input grid infinitely. How many points can be visited in exactly 26501365 steps.</p></blockquote><p>&mldr; right.</p><h3 id=brute-force>Brute Force</h3><p>Well, we can try it of course:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (walls, start) <span style=color:#f92672>=</span> parse::read(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> wall_bounds <span style=color:#f92672>=</span> Bounds::from(walls.iter());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Note: Assuming min bounds are 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> wall_bounds.max_x <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> wall_bounds.max_y <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A modular wall function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> wall_mod_contains <span style=color:#f92672>=</span> <span style=color:#f92672>|&amp;</span>p: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span><span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> Point::new(p.x <span style=color:#f92672>%</span> width, p.y <span style=color:#f92672>%</span> height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            p.x <span style=color:#f92672>+=</span> width;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            p.y <span style=color:#f92672>+=</span> height;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        walls.contains(<span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>    active.insert(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#66d9ef>STEPS</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> pos <span style=color:#66d9ef>in</span> active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> pos.neighbors() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>wall_mod_contains(<span style=color:#f92672>&amp;</span>neighbor) {
</span></span><span style=display:flex><span>                    next_active.insert(neighbor);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        active <span style=color:#f92672>=</span> next_active;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> active.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that modular wall function, it actually even works pretty well. But <code>active</code> gets really big really quick, which makes everything very slow.</p><p>So&mldr;</p><h3 id=solution-1>Solution</h3><p>One thing to note is that despite all of the walls in the input, if you look carefully, you&rsquo;ll note that the entire horizontal line in the very center of the image is empty&mldr; (the same up and down).</p><p>So in exactly <code>cell_width / 2</code> steps, we&rsquo;ll start the cells to the left and right. Exactly <code>cell_width</code> after that, we&rsquo;ll start the ones after that. Given the 131 wide input, we have a cycle starting at <code>step=65</code> with <code>cycle=131</code>.</p><p>What&rsquo;s more, because of these nice empty rows, we also know that the total area is going to grow <a href=https://en.wikipedia.org/wiki/quadratically>quadratically</a>, out in 2D square instead of on a line.</p><p>So what we want will be to calculate the points at <code>x=0, 1, 2, ...</code> where <code>steps=65, 196, 327</code>. With three of those, we can do some <a href=https://stackoverflow.com/questions/19175037/determine-a-b-c-of-quadratic-equation-using-data-points target=_blank rel=noopener>crazy math</a> to extrapolate to any specific point&mldr; so long as it&rsquo;s of the form <code>131x+65</code>&mldr;</p><div class=latex-block>26501365 = 202300 * 131 + 65</div><p>Huh. Look at that. ðŸ˜„</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (walls, start) <span style=color:#f92672>=</span> parse::read(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> wall_bounds <span style=color:#f92672>=</span> Bounds::from(walls.iter());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Note: Assuming min bounds are 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// The original cell takes cell_width/2 steps to reach the edge
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// And then each cell takes cell_width steps to fill across
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> cell_width <span style=color:#f92672>=</span> wall_bounds.max_x <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cell_height <span style=color:#f92672>=</span> wall_bounds.max_y <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> half_width <span style=color:#f92672>=</span> cell_width <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the number of cycles it would take to get to the target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If this doesn&#39;t evenly divide, messy things happen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> ((<span style=color:#66d9ef>STEPS</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>) <span style=color:#f92672>-</span> half_width) <span style=color:#f92672>/</span> cell_width;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A modular wall function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> wall_mod_contains <span style=color:#f92672>=</span> <span style=color:#f92672>|&amp;</span>p: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span><span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> Point::new(p.x <span style=color:#f92672>%</span> cell_width, p.y <span style=color:#f92672>%</span> cell_height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            p.x <span style=color:#f92672>+=</span> cell_width;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            p.y <span style=color:#f92672>+=</span> cell_height;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        walls.contains(<span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The set of active points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>    active.insert(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We&#39;re not going to have to actually need to iterate this far
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> points <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> step <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#66d9ef>STEPS</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_active <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> pos <span style=color:#66d9ef>in</span> active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> pos.neighbors() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>wall_mod_contains(<span style=color:#f92672>&amp;</span>neighbor) {
</span></span><span style=display:flex><span>                    next_active.insert(neighbor);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        active <span style=color:#f92672>=</span> next_active;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((step <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>) <span style=color:#f92672>-</span> half_width) <span style=color:#f92672>%</span> cell_width <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> i <span style=color:#f92672>=</span> ((step <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>) <span style=color:#f92672>-</span> half_width) <span style=color:#f92672>/</span> cell_width;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::new(i, active.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>);
</span></span><span style=display:flex><span>            points.push(p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{step}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{p}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> points.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Solve the quadratic equation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// https://stackoverflow.com/questions/19175037/determine-a-b-c-of-quadratic-equation-using-data-points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> points[<span style=color:#ae81ff>0</span>].y <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>1</span>].y <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>2</span>].y <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>points[<span style=color:#ae81ff>0</span>].y <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>2</span>].x)
</span></span><span style=display:flex><span>        <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].y <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>2</span>].x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].y <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>1</span>].x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> points[<span style=color:#ae81ff>0</span>].y <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>2</span>].x
</span></span><span style=display:flex><span>        <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>1</span>].y <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>2</span>].x
</span></span><span style=display:flex><span>            <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>1</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>2</span>].x))
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> points[<span style=color:#ae81ff>2</span>].y <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>0</span>].x <span style=color:#f92672>*</span> points[<span style=color:#ae81ff>1</span>].x
</span></span><span style=display:flex><span>            <span style=color:#f92672>/</span> ((points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>0</span>].x) <span style=color:#f92672>*</span> (points[<span style=color:#ae81ff>2</span>].x <span style=color:#f92672>-</span> points[<span style=color:#ae81ff>1</span>].x));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> target <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i128</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> (a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i128</span>) <span style=color:#f92672>*</span> target <span style=color:#f92672>*</span> target <span style=color:#f92672>+</span> (b <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i128</span>) <span style=color:#f92672>*</span> target <span style=color:#f92672>+</span> (c <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i128</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yeah&mldr; it doesn&rsquo;t work at all if you don&rsquo;t have a perfect multiple. But it works well enough for all that.</p><h3 id=another-option>Another option</h3><p>One other option that I was going to look into was to basically implement <a href=https://en.wikipedia.org/wiki/hashlife>hashlife</a>. It takes a <a href=https://en.wikipedia.org/wiki/cellular%20automata>cellular automata</a> on an infinite grid (sound familiar) and hashes it as a <a href=https://en.wikipedia.org/wiki/recursive>recursive</a> <a href=https://en.wikipedia.org/wiki/quadtree>quadtree</a>. I&rsquo;m pretty sure this would work for <em>exactly</em> what we&rsquo;re dealing with. But&mldr; I don&rsquo;t have the time right now.</p><p>Perhaps another day.</p><p>So it goes.</p><h2 id=performance>Performance</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>21</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 21 1&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>21</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     111.7 ms Â±   5.8 ms    <span style=color:#f92672>[</span>User: 44.0 ms, System: 19.9 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    99.6 ms â€¦ 120.9 ms    <span style=color:#ae81ff>28</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>21</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 21 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>21</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     755.3 ms Â±  13.3 ms    <span style=color:#f92672>[</span>User: 636.4 ms, System: 38.2 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   737.5 ms â€¦ 787.2 ms    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Even with that massive skip, it&rsquo;s still almost a second. Goodness we&rsquo;re getting slow there. ðŸ˜„ But it&rsquo;s still under, so onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>