<!doctype html><html><head><title>AoC 2023 Day 23: Looong Mazinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 23: Looong Mazinator</h1><div class=entry-meta><span class=entry-date>2023-12-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/24/aoc-2023-day-24-collisionator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/24/aoc-2023-day-24-collisionator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/24/aoc-2023-day-24-collisionator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/24/aoc-2023-day-24-collisionator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/22/aoc-2023-day-22-block-dropinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/24/aoc-2023-day-24-collisionator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-23-a-long-walkhttpsadventofcodecom2023day23>Source: <a href=https://adventofcode.com/2023/day/23 target=_blank rel=noopener>Day 23: A Long Walk</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day23 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-23-a-long-walkhttpsadventofcodecom2023day23>Source: <a href=https://adventofcode.com/2023/day/23>Day 23: A Long Walk</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#edit-1-petgraph>Edit 1: Petgraph</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#solution-1-brute-force>Solution 1: Brute force</a></li><li><a href=#solution-2-a-better-path>Solution 2: A better <code>Path</code></a></li><li><a href=#solution-3-finding-points-of-interest>Solution 3: Finding points of interest</a></li><li><a href=#edit-1-more-petgraph>Edit 1: More petgraph!</a></li></ul></li><li><a href=#performance>Performance</a><ul><li><a href=#edit-1-petgraph-performance>Edit 1: Petgraph performance</a></li></ul></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Find the longest non-overlapping path through a maze with walls (<code>#</code>) and one way paths (<code>^v&lt;></code>).</p></blockquote><p>Don&rsquo;t even need types or parsing this time, just use <code>Grid</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> grid <span style=color:#f92672>=</span> Grid::read(input.as_str(), <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Object::Wall),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;^&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Object::Slope(Slope::North)),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;v&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Object::Slope(Slope::South)),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&gt;&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Object::Slope(Slope::East)),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&lt;&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Object::Slope(Slope::West)),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>        position: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>        path: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    queue.push(State {
</span></span><span style=display:flex><span>        position: <span style=color:#a6e22e>Point</span>::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        path: Vec::with_capacity(<span style=color:#ae81ff>1024</span>),
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> complete <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(state) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>[
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        ] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next_position <span style=color:#f92672>=</span> state.position <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re at the exit, we&#39;ve found a complete path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> next_position <span style=color:#f92672>==</span> Point::new(grid.bounds.max_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, grid.bounds.max_y) {
</span></span><span style=display:flex><span>                complete.push(state.path.clone());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re out of bounds, we&#39;ve found an invalid path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>grid.bounds.contains(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re on a slope, we can only go in the direction of the slope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Object::Slope(s)) <span style=color:#f92672>=</span> grid.get(<span style=color:#f92672>&amp;</span>state.position) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> direction <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>Point::from(<span style=color:#f92672>*</span>s) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cannot go through walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>match</span> grid.get(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                Some(Object::Wall) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cannot visit the same point more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> state.path.contains(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, queue it up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> new_state <span style=color:#f92672>=</span> State {
</span></span><span style=display:flex><span>                position: <span style=color:#a6e22e>next_position</span>,
</span></span><span style=display:flex><span>                path: {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> path <span style=color:#f92672>=</span> state.path.clone();
</span></span><span style=display:flex><span>                    path.push(next_position);
</span></span><span style=display:flex><span>                    path
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            queue.push(new_state);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the longest path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Add 1 to account for leaving the grid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> complete
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .max_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.len().cmp(<span style=color:#f92672>&amp;</span>b.len()))
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can&rsquo;t really use <a href=https://en.wikipedia.org/wiki/a-star>a-star</a>, since &rsquo;longest&rsquo; path is actually a much harder problem than shortest path&ndash;it&rsquo;s <a href=https://en.wikipedia.org/wiki/NP-hard>NP-hard</a>. You basically have to find all of the paths.</p><p>So that&rsquo;s what we do. Keep a queue of points to examine along with the path we took to get there and explore each valid (non-overlapping + correct direction on slopes) neighboring point.</p><p>Each time we get to the exit, record the path; at the end, record the longest and we&rsquo;re done.</p><p>It&rsquo;s not the fastest solution, but for part 1 it&rsquo;s fine?</p><h3 id=edit-1-petgraph>Edit 1: Petgraph</h3><p>I haven&rsquo;t yet had a chance to look at the <a href=https://docs.rs/petgraph/latest/petgraph/ target=_blank rel=noopener><code>petgraph</code></a> crate. Let&rsquo;s remedy that.</p><p>Essentially, we can represent our map as a graph. To do that, we&rsquo;ll want to generate a list of nodes (each walkable tile, including slopes) and edges (which nodes you can walk to from a given node).</p><p>One interesting thing about <code>petgraph</code> is that everything you do uses <code>NodeIndexes</code>. When you insert a node into a graph, you get the index back. When you add an edge, you add it between 2 <code>NodeIndex</code>. And in the end, when we want to find all paths, we&rsquo;ll need to pass those back.</p><p>So we need to return 3 things: the graph and the <code>NodeIndex</code> for the start and end points.</p><p>Let&rsquo;s do it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> (graph, start, end) <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> g <span style=color:#f92672>=</span> DiGraph::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nodes <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> start <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> end <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>grid.bounds.max_y {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>grid.bounds.max_x {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::new(x, y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Object::Wall) <span style=color:#f92672>=</span> grid.get(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> g.add_node(p);
</span></span><span style=display:flex><span>            nodes.push(node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                start <span style=color:#f92672>=</span> Some(node);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> grid.bounds.max_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>==</span> grid.bounds.max_y {
</span></span><span style=display:flex><span>                end <span style=color:#f92672>=</span> Some(node);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>nodes {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>g.node_weight(<span style=color:#f92672>*</span>node).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>[
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        ] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next_position <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re out of bounds, we&#39;ve found an invalid path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>grid.bounds.contains(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re on a slope, we can only go in the direction of the slope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Object::Slope(s)) <span style=color:#f92672>=</span> grid.get(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> direction <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>Point::from(<span style=color:#f92672>*</span>s) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cannot go through walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>match</span> grid.get(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                Some(Object::Wall) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, queue it up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> next_node <span style=color:#f92672>=</span> nodes
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .find(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>g.node_weight(<span style=color:#f92672>**</span>n).unwrap() <span style=color:#f92672>==</span> next_position)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            g.add_edge(<span style=color:#f92672>*</span>node, <span style=color:#f92672>*</span>next_node, ());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (g, start.unwrap(), end.unwrap())
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Once we have the <code>graph</code>, there&rsquo;s a perfect algorithm for us in <code>petgraph::algo::all_simple_paths</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> all_simple_paths(<span style=color:#f92672>&amp;</span>graph, start, end, <span style=color:#ae81ff>0</span>, None)
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>path: Vec<span style=color:#f92672>&lt;&amp;</span>NodeIndex<span style=color:#f92672>&gt;|</span> path.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    .max()
</span></span><span style=display:flex><span>    .unwrap();
</span></span></code></pre></div><p>A <code>simple_path</code> is exactly what we want: a <code>path</code> that doesn&rsquo;t visit any node in the graph more than once. So we can just go through all of them, find the longest, and get the length of that.</p><p>One gotcha that I had to deal with was that we needed to type the <code>a</code> and <code>b</code> in closure as <code>&amp;Vec&lt;NodeIndex></code>. Alternative, you can <code>turbofish</code> the call itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> all_simple_paths(<span style=color:#f92672>&amp;</span>graph, start, end, <span style=color:#ae81ff>0</span>, None)
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>path: Vec<span style=color:#f92672>&lt;</span>NodeIndex<span style=color:#f92672>&gt;|</span> path.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    .max()
</span></span><span style=display:flex><span>    .unwrap();
</span></span></code></pre></div><p>I think I actually like that one better.</p><p>So how does it actually compare?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 1&#39;</span> <span style=color:#e6db74>&#39;just run 23 1-petgraph&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     412.3 ms Â±  12.5 ms    <span style=color:#f92672>[</span>User: 319.7 ms, System: 20.6 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   392.1 ms â€¦ 442.0 ms    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 2: just run <span style=color:#ae81ff>23</span> 1-petgraph
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     188.4 ms Â±   4.3 ms    <span style=color:#f92672>[</span>User: 98.9 ms, System: 19.8 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   182.5 ms â€¦ 199.4 ms    <span style=color:#ae81ff>15</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Summary
</span></span><span style=display:flex><span>  just run <span style=color:#ae81ff>23</span> 1-petgraph ran
</span></span><span style=display:flex><span>    2.19 Â± 0.08 times faster than just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>That&rsquo;s actually pretty impressive.</p><h2 id=part-2>Part 2</h2><blockquote><p>Ignore slopes.</p></blockquote><h3 id=solution-1-brute-force>Solution 1: Brute force</h3><p>There it is, that makes things far longer. The only real change we need is loading the grid a bit differently:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> grid <span style=color:#f92672>=</span> Grid::read(input.as_str(), <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> Some(<span style=color:#66d9ef>true</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>And then drop the slope code and use <code>grid.get(&amp;p).is_some()</code> to detect walls. That&rsquo;s really it.</p><p>And&mldr; it&rsquo;s pretty slow.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just run <span style=color:#ae81ff>23</span> 2-brute
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat data/<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 23<span style=color:#66d9ef>)</span>.txt | cargo run --release -p day<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 23<span style=color:#66d9ef>)</span> --bin part2-brute
</span></span><span style=display:flex><span>   Compiling day23 v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/advent-of-code/2023/solutions/day23<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.18s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/part2-brute<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100000</span> 710.137333ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>200000</span> 1.426019042s
</span></span><span style=display:flex><span><span style=color:#ae81ff>300000</span> 2.131656583s
</span></span><span style=display:flex><span><span style=color:#ae81ff>400000</span> 2.850222125s
</span></span><span style=display:flex><span><span style=color:#ae81ff>500000</span> 3.651914042s
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>That&rsquo;s the number of states we&rsquo;ve examined. We&rsquo;re doing hundreds of thousands a second, but it&rsquo;s just not long enough.</p><p>We need to go faster!</p><h3 id=solution-2-a-better-path>Solution 2: A better <code>Path</code></h3><p>So one thing that I wanted to try was to avoid all of the <code>clones</code> we&rsquo;re doing for <code>path</code>. What if we had a functional programming style immutable path, where &rsquo;extending&rsquo; a path uses the same memory for any previous steps and only adds a new reference. So branching paths end up far more efficient.</p><p>Let&rsquo;s try it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PathData</span> {
</span></span><span style=display:flex><span>    points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    froms: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Path</span> {
</span></span><span style=display:flex><span>    path: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>PathData<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    length: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Path {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(p: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Path {
</span></span><span style=display:flex><span>            path: <span style=color:#a6e22e>Rc</span>::new(RefCell::new(PathData {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[p],
</span></span><span style=display:flex><span>                froms: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[None],
</span></span><span style=display:flex><span>            })),
</span></span><span style=display:flex><span>            index: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            length: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>extend</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Path</span> {
</span></span><span style=display:flex><span>        self.path.borrow_mut().points.push(p);
</span></span><span style=display:flex><span>        self.path.borrow_mut().froms.push(Some(self.index));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Path {
</span></span><span style=display:flex><span>            path: <span style=color:#a6e22e>self</span>.path.clone(),
</span></span><span style=display:flex><span>            index: <span style=color:#a6e22e>self</span>.path.borrow().points.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            length: <span style=color:#a6e22e>self</span>.length <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        self.length
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contains</span>(<span style=color:#f92672>&amp;</span>self, p: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check the current point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.path.borrow().points[self.index] <span style=color:#f92672>==</span> p {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check previous points until we reach the start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> index <span style=color:#f92672>=</span> self.index;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(from) <span style=color:#f92672>=</span> self.path.borrow().froms[index] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.path.borrow().points[index] <span style=color:#f92672>==</span> p {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            index <span style=color:#f92672>=</span> from;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What we have here is a &lsquo;hidden&rsquo; shared state in <code>PathData</code>, where <code>Path</code> is the actual interface to the data. All that does is store an index into the <code>PathData</code>, which has synchronized lists of Points and indexes (for the previous node). Basically linked lists. <a href=https://rust-unofficial.github.io/too-many-lists/ target=_blank rel=noopener>Entirely too many linked lists</a>.</p><p>All that changes in our solution is extending states:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Otherwise, queue it up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> new_state <span style=color:#f92672>=</span> State {
</span></span><span style=display:flex><span>    position: <span style=color:#a6e22e>next_position</span>,
</span></span><span style=display:flex><span>    path: <span style=color:#a6e22e>state</span>.path.extend(next_position),
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>queue.push(new_state);
</span></span></code></pre></div><p>And&mldr; how&rsquo;s it do?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just run <span style=color:#ae81ff>23</span> 2-path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat data/<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 23<span style=color:#66d9ef>)</span>.txt | cargo run --release -p day<span style=color:#66d9ef>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> 23<span style=color:#66d9ef>)</span> --bin part2-path
</span></span><span style=display:flex><span>   Compiling day23 v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/advent-of-code/2023/solutions/day23<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.20s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/part2-path<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>100000</span> 1.014593291s
</span></span><span style=display:flex><span><span style=color:#ae81ff>200000</span> 1.977192458s
</span></span><span style=display:flex><span><span style=color:#ae81ff>300000</span> 2.961558458s
</span></span><span style=display:flex><span><span style=color:#ae81ff>400000</span> 3.901192916s
</span></span><span style=display:flex><span><span style=color:#ae81ff>500000</span> 4.940979875s
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Unfortunately&mldr; it&rsquo;s about 30% <em>slower</em>.</p><p>What&rsquo;s happening is that we&rsquo;ve fixed the problem with copying lots of memory by&mldr; jumping around a lot in memory. A lot more following references, especially in <code>contains</code> (I already optimized <code>length</code> to just store it in <code>Path</code>.</p><p>So&mldr; a neat idea, but not what we needed.</p><h3 id=solution-3-finding-points-of-interest>Solution 3: Finding points of interest</h3><p>If you actually look at the input (either test or real), you&rsquo;ll notice that the map is almost entirely corridors. There are only a handful of decision points (where you can go 3 or even 4 different directions).</p><p>What if we replace the map with a just a list of those points and distances between them?</p><p>First, find them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Find &#39;points of interest&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>log::info!(<span style=color:#e6db74>&#34;Finding splits&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> splits <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>splits.push(Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>splits.push(Point::new(walls.bounds.max_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, walls.bounds.max_y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>walls.bounds.max_y {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>walls.bounds.max_x {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::new(x, y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> walls.get(<span style=color:#f92672>&amp;</span>p).is_some() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Splits are anything with 3 or 4 non-walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Or alternatively, less than 2 walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>DIRECTIONS</span>
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|</span>d<span style=color:#f92672>|</span> walls.get(<span style=color:#f92672>&amp;</span>(p <span style=color:#f92672>+</span> <span style=color:#f92672>**</span>d)).is_some())
</span></span><span style=display:flex><span>            .count()
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            splits.push(p);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then find the distance between each pair:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Calculate distances between splits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>log::info!(<span style=color:#e6db74>&#34;Calculating split distances&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> split_distances: <span style=color:#a6e22e>FxHashMap</span><span style=color:#f92672>&lt;</span>(Point, Point), <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> FxHashMap::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> split <span style=color:#66d9ef>in</span> splits.iter() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>&#39;found</span>: <span style=color:#a6e22e>for</span> direction <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>DIRECTIONS</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> position <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>split <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// count the first &#39;direction&#39; step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> path <span style=color:#f92672>=</span> vec![<span style=color:#f92672>*</span>split, <span style=color:#f92672>*</span>split <span style=color:#f92672>+</span> direction];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Make sure the initial move is not out of the map or into a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>walls.bounds.contains(<span style=color:#f92672>&amp;</span>position) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> walls.get(<span style=color:#f92672>&amp;</span>position).is_some() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Keep going until we find the next split in that direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>&#39;searching</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we found a split, record the distance and move on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> splits.contains(<span style=color:#f92672>&amp;</span>position) {
</span></span><span style=display:flex><span>                split_distances.insert((<span style=color:#f92672>*</span>split, position), distance);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;found;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            distance <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Find the one direction (should always be one) we haven&#39;t come from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>DIRECTIONS</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> next_position <span style=color:#f92672>=</span> position <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Don&#39;t run into walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> walls.get(<span style=color:#f92672>&amp;</span>next_position).is_some() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// And don&#39;t backtrack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> path.contains(<span style=color:#f92672>&amp;</span>next_position) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                path.push(next_position);
</span></span><span style=display:flex><span>                position <span style=color:#f92672>=</span> next_position;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;searching;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we didn&#39;t find a direction, this is a dead end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>break</span> &#39;found;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, do the same search as part 1, just using these nodes (and the distances between them):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Now search for the longest path using splits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    position: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    path: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    distance: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>queue.push(State {
</span></span><span style=display:flex><span>    position: <span style=color:#a6e22e>Point</span>::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    path: Vec::new(),
</span></span><span style=display:flex><span>    distance: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> complete <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log::info!(<span style=color:#e6db74>&#34;Searching for longest path&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> std::time::Instant::now();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(state) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> count <span style=color:#f92672>%</span> <span style=color:#ae81ff>1_000_000</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        log::info!(<span style=color:#e6db74>&#34;- {:?} paths examined in {:?}&#34;</span>, count, start.elapsed());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Which nodes can we go to next?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> nexts <span style=color:#f92672>=</span> splits.iter().filter_map(<span style=color:#f92672>|</span>dst<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(distance) <span style=color:#f92672>=</span> split_distances.get(<span style=color:#f92672>&amp;</span>(state.position, <span style=color:#f92672>*</span>dst)) {
</span></span><span style=display:flex><span>            Some((<span style=color:#f92672>*</span>dst, <span style=color:#f92672>*</span>distance))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (next, distance) <span style=color:#66d9ef>in</span> nexts {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re at the exit, we&#39;ve found a complete path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> next <span style=color:#f92672>==</span> Point::new(walls.bounds.max_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, walls.bounds.max_y) {
</span></span><span style=display:flex><span>            complete.push((state.path.clone(), state.distance <span style=color:#f92672>+</span> distance));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;ve already hit this split, we&#39;ve found a loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> state.path.contains(<span style=color:#f92672>&amp;</span>next) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, queue it up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> new_state <span style=color:#f92672>=</span> State {
</span></span><span style=display:flex><span>            position: <span style=color:#a6e22e>next</span>,
</span></span><span style=display:flex><span>            path: {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> path <span style=color:#f92672>=</span> state.path.clone();
</span></span><span style=display:flex><span>                path.push(next);
</span></span><span style=display:flex><span>                path
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            distance: <span style=color:#a6e22e>state</span>.distance <span style=color:#f92672>+</span> distance,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        queue.push(new_state);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> complete.iter().map(<span style=color:#f92672>|</span>(_, d)<span style=color:#f92672>|</span> d).max().unwrap();
</span></span></code></pre></div><p>It&rsquo;s a decent bit more code, but &mldr; does it work?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      9.702 s Â±  0.093 s    <span style=color:#f92672>[</span>User: 9.231 s, System: 0.166 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    9.555 s â€¦  9.906 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Victory (of sorts)!</p><p>It&rsquo;s still 10x my worst case goal of 1 second, but at least we actually have a solution.</p><p>And since it&rsquo;s the weekend, that&rsquo;s where I&rsquo;ll leave it for now, but I&rsquo;m probably going to have to come back and try this one again!</p><h3 id=edit-1-more-petgraph>Edit 1: More petgraph!</h3><p>As is the case in <a href=#edit-1-petgraph>part 1</a>, we can speed this up significantly with <code>petgraph</code>. And the conversion is actually even easier once we&rsquo;ve already done <code>splits</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Build a petgraph graph from these splits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> (graph, start, end) <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> g <span style=color:#f92672>=</span> DiGraph::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nodes <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> start <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> end <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add all splits as nodes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> split <span style=color:#66d9ef>in</span> splits.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> g.add_node(<span style=color:#f92672>*</span>split);
</span></span><span style=display:flex><span>        nodes.push(node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>split <span style=color:#f92672>==</span> Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            start <span style=color:#f92672>=</span> Some(node);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>split <span style=color:#f92672>==</span> Point::new(walls.bounds.max_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, walls.bounds.max_y) {
</span></span><span style=display:flex><span>            end <span style=color:#f92672>=</span> Some(node);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add weighted edges between each split that&#39;s connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> ((src, dst), d) <span style=color:#66d9ef>in</span> split_distances.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> nodes
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .find(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>g.node_weight(<span style=color:#f92672>**</span>n).unwrap() <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>src)
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dst <span style=color:#f92672>=</span> nodes
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .find(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>g.node_weight(<span style=color:#f92672>**</span>n).unwrap() <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>dst)
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        g.add_edge(<span style=color:#f92672>*</span>src, <span style=color:#f92672>*</span>dst, <span style=color:#f92672>*</span>d);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (g, start.unwrap(), end.unwrap())
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The <code>result</code> calculation is a bit more complicated this time, since we want to rebuild the lengths of each path:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Get the length of the longest path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> all_simple_paths::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span>, _<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>graph, start, end, <span style=color:#ae81ff>0</span>, None)
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> 
</span></span><span style=display:flex><span>        path
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .tuple_windows()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(a, b)<span style=color:#f92672>|</span> 
</span></span><span style=display:flex><span>                split_distances.get(<span style=color:#f92672>&amp;</span>(
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>graph.node_weight(<span style=color:#f92672>*</span>a).unwrap(),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>graph.node_weight(<span style=color:#f92672>*</span>b).unwrap(),
</span></span><span style=display:flex><span>                )).unwrap())
</span></span><span style=display:flex><span>            .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .max()
</span></span><span style=display:flex><span>    .unwrap();
</span></span></code></pre></div><p>I feel like it&rsquo;s a bit weird that <code>all_simple_paths</code> doesn&rsquo;t return anything about the sum of <code>weights</code> of a path, but perhaps there&rsquo;s another method I&rsquo;m missing? It&rsquo;s not the worst to write though.</p><p>Side note, I did pull in <code>itertools</code> as well, just for <code>tuple_windows</code>.</p><p>And it&rsquo;s faster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 2&#39;</span> <span style=color:#e6db74>&#39;just run 23 2-petgraph&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      9.386 s Â±  0.167 s    <span style=color:#f92672>[</span>User: 8.964 s, System: 0.125 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    9.108 s â€¦  9.607 s    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 2: just run <span style=color:#ae81ff>23</span> 2-petgraph
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      1.859 s Â±  0.145 s    <span style=color:#f92672>[</span>User: 1.641 s, System: 0.024 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    1.741 s â€¦  2.077 s    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Summary
</span></span><span style=display:flex><span>  just run <span style=color:#ae81ff>23</span> 2-petgraph ran
</span></span><span style=display:flex><span>    5.05 Â± 0.40 times faster than just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Still not <em>quite</em> 1 second, but we&rsquo;re getting there!</p><h2 id=performance>Performance</h2><p>Overall (even though it&rsquo;s just above us), this is where we are right now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 1&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     423.8 ms Â±   8.4 ms    <span style=color:#f92672>[</span>User: 337.5 ms, System: 21.9 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   410.7 ms â€¦ 435.2 ms    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      9.702 s Â±  0.093 s    <span style=color:#f92672>[</span>User: 9.231 s, System: 0.166 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    9.555 s â€¦  9.906 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><h3 id=edit-1-petgraph-performance>Edit 1: Petgraph performance</h3><p>Now that we&rsquo;ve updated <a href=#edit-1-petgraph>part 1</a> and <a href=#edit-1-more-petgraph>part 2</a>, we have better overall performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>23</span> 1-petgraph
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 1-petgraph&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> 1-petgraph
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     190.9 ms Â±   7.4 ms    <span style=color:#f92672>[</span>User: 100.6 ms, System: 20.2 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   180.0 ms â€¦ 210.7 ms    <span style=color:#ae81ff>16</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>23</span> 2-petgraph
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 23 2-petgraph&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>23</span> 2-petgraph
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      1.799 s Â±  0.110 s    <span style=color:#f92672>[</span>User: 1.599 s, System: 0.023 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    1.698 s â€¦  1.999 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Not bad!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>