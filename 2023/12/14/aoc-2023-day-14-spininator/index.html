<!doctype html><html><head><title>AoC 2023 Day 14: Spininator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 14: Spininator</h1><div class=entry-meta><span class=entry-date>2023-12-14</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/14/star-wars-vol.-4-last-flight-of-the-harbinger/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-14-parabolic-reflector-dishhttpsadventofcodecom2023day14>Source: <a href=https://adventofcode.com/2023/day/14 target=_blank rel=noopener>Day 14: Parabolic Reflector Dish</a></h2><p><video controls src=/embeds/2023/aoc23-14-direction.mp4></video></p><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day14 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-14-parabolic-reflector-dishhttpsadventofcodecom2023day14>Source: <a href=https://adventofcode.com/2023/day/14>Day 14: Parabolic Reflector Dish</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#types-and-parsing>Types and parsing</a></li><li><a href=#simulation>Simulation</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#solution-spinning-each-way>Solution: Spinning each way</a></li><li><a href=#optimization-1-cycle-detection>Optimization 1: Cycle Detection</a></li><li><a href=#optimization-2-data-structures>Optimization 2: Data Structures</a></li><li><a href=#optimization-3-multislide>Optimization 3: Multislide</a></li></ul></li><li><a href=#performance>Performance</a></li><li><a href=#edit-1-optimization-4--removing-a-debugging-line>Edit 1, Optimization 4: &mldr; removing a debugging line</a></li><li><a href=#edit-2-optimization-5-pre-sorting-the-rocks>Edit 2, Optimization 5: Pre-sorting the rocks</a></li><li><a href=#edit-3-rendering>Edit 3, Rendering</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a grid of <code>#</code> and <code>O</code> (among empty <code>.</code> points) where <code>O</code> can move, slide each <code>O</code> as far north as it can. Score each based on how far north it is.</p></blockquote><p>Cellular automata!</p><p>And an easier one too, it doesn&rsquo;t actually slide side to side, just in one direction.</p><h3 id=types-and-parsing>Types and parsing</h3><p>Okay, let&rsquo;s do it. Start with <code>Point</code> and <code>Bounds</code> from <a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/>yesterday</a> and add today&rsquo;s simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Platform</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> bounds: <span style=color:#a6e22e>Bounds</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> round_rocks: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> cube_rocks: <span style=color:#a6e22e>FxHashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Platform {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bounds <span style=color:#f92672>=</span> Bounds::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> round_rocks <span style=color:#f92672>=</span> Vec::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cube_rocks <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (y, line) <span style=color:#66d9ef>in</span> input.lines().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                bounds.include(Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;O&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        round_rocks.push(Point {
</span></span><span style=display:flex><span>                            x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                            y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        cube_rocks.insert(Point {
</span></span><span style=display:flex><span>                            x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                            y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            bounds,
</span></span><span style=display:flex><span>            round_rocks,
</span></span><span style=display:flex><span>            cube_rocks,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=simulation>Simulation</h3><p>So how does that translate to our problem?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> platform <span style=color:#f92672>=</span> Platform::from(input.as_str());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Let the rocks slide until they stop moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get current point; if we&#39;re at the top already, skip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> platform.round_rocks[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> Point { x: <span style=color:#a6e22e>r</span>.x, y: <span style=color:#a6e22e>r</span>.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check that the next point is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>platform.bounds.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> platform.round_rocks.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> platform.cube_rocks.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we get here, we can move; do it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            platform.round_rocks[i].y <span style=color:#f92672>=</span> next.y;
</span></span><span style=display:flex><span>            changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>changed {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Calculate final score
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> platform
</span></span><span style=display:flex><span>        .round_rocks
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> platform.bounds.max_y <span style=color:#f92672>-</span> r.y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not bad.</p><p>It&rsquo;s not functional style, since if you <code>iter</code> over <code>platform.round_rocks</code>, things get a bit messy.</p><p>One gotcha that I&rsquo;m sure we&rsquo;re going to run into is the <code>platform.(round|cube)_rocks.contains</code>. Since we&rsquo;re storing it as a <code>Vec</code>, this is <span class=latex-inline>O(n)</span>
. But we&rsquo;ll get back to that.</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of just sliding north, slide first north, then east, then south, then west. Repeat this 1 <em>billion</em> times.</p></blockquote><p>Whelp. There it is. Performance is going to matter.</p><h3 id=solution-spinning-each-way>Solution: Spinning each way</h3><p>To make this work, we&rsquo;ll define a few constants and <code>Add</code> and <code>Sub</code> on <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>NORTH</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>SOUTH</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>EAST</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WEST</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::ops::Add<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>+</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>+</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::ops::Sub<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sub</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>-</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>-</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From there, we&rsquo;re going to fairly directly translate. For each cycle + each direction, slide in the right <code>direction</code> until we are stable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> cycle <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#66d9ef>TARGET</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The rocks will slide N, W, S, E
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> [Point::<span style=color:#66d9ef>NORTH</span>, Point::<span style=color:#66d9ef>WEST</span>, Point::<span style=color:#66d9ef>SOUTH</span>, Point::<span style=color:#66d9ef>EAST</span>] {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Let the rocks slide until they stop moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> platform.round_rocks[i];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Check that the next point is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>platform.bounds.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> platform.round_rocks.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> platform.cube_rocks.contains(<span style=color:#f92672>&amp;</span>next)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we get here, we can move; do it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                platform.round_rocks[i].x <span style=color:#f92672>=</span> next.x;
</span></span><span style=display:flex><span>                platform.round_rocks[i].y <span style=color:#f92672>=</span> next.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>changed {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I have no idea how slow this is&mldr; but let&rsquo;s go with <em>very</em>. I&rsquo;m never going to wait a billion cycles for this.</p><h3 id=optimization-1-cycle-detection>Optimization 1: Cycle Detection</h3><p>Luckily, as was the case in [[AoC 2023 Day 8: Mazinator|day 8]], we need to use some cycle detection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> seen <span style=color:#f92672>=</span> FxHashMap::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> cycle <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#66d9ef>TARGET</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check if we&#39;ve seen this platform state before (it&#39;s deterministic, thus cycling)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Keep going until the cycle is in the same phase as the TARGET
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> platform.to_string();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(cycle_start) <span style=color:#f92672>=</span> seen.get(<span style=color:#f92672>&amp;</span>key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> cycle_length <span style=color:#f92672>=</span> cycle <span style=color:#f92672>-</span> cycle_start;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>TARGET</span> <span style=color:#f92672>-</span> cycle_start) <span style=color:#f92672>%</span> cycle_length <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    seen.insert(key, cycle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>As mentioned, we&rsquo;re going to keep a map of the current <code>platform</code> to when we saw it before. If we see the same <code>platform</code> twice, we have a cycle. We don&rsquo;t need to immediately stop then, but rather stop once we&rsquo;re at the same point in that cycle that <code>TARGET</code> is.</p><p>Hashing based on <code>platform.to_string</code> is a bit ugly, but it works well enough. More of the time is spent on updating than <code>to_string</code>, so no worries.</p><p>Still pretty slow.</p><h3 id=optimization-2-data-structures>Optimization 2: Data Structures</h3><p>Okay, the next problem we&rsquo;re having is that <code>contains</code> on a <code>Vec</code> is a bit slow. So let&rsquo;s update our <code>Platform</code> struct a bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PlatformV2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> bounds: <span style=color:#a6e22e>Bounds</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> round_rocks: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> occupied: <span style=color:#a6e22e>FxHashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Platform<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> PlatformV2 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#a6e22e>Platform</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> occupied <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> r <span style=color:#66d9ef>in</span> value.round_rocks.iter() {
</span></span><span style=display:flex><span>            occupied.insert(<span style=color:#f92672>*</span>r);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> value.cube_rocks.iter() {
</span></span><span style=display:flex><span>            occupied.insert(<span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            bounds: <span style=color:#a6e22e>value</span>.bounds,
</span></span><span style=display:flex><span>            round_rocks: <span style=color:#a6e22e>value</span>.round_rocks,
</span></span><span style=display:flex><span>            occupied,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essentially, we&rsquo;re going to store some of the data (the <code>round_rocks</code>) twice in order to get some speedup. <code>occupied</code> will be used specifically for <code>contains</code>, since <code>HashSets</code> are fast for that, but we&rsquo;ll get the <code>Vec&lt;Point></code> for <code>round_rocks</code> so we can loop over it and modify it more easily:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The rocks will slide N, W, S, E
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> [Point::<span style=color:#66d9ef>NORTH</span>, Point::<span style=color:#66d9ef>WEST</span>, Point::<span style=color:#66d9ef>SOUTH</span>, Point::<span style=color:#66d9ef>EAST</span>] {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Let the rocks slide until they stop moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> platform.round_rocks[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check that the next point is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>platform.bounds.contains(<span style=color:#f92672>&amp;</span>next) <span style=color:#f92672>||</span> platform.occupied.contains(<span style=color:#f92672>&amp;</span>next) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we get here, we can move; do it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            platform.round_rocks[i].x <span style=color:#f92672>=</span> next.x;
</span></span><span style=display:flex><span>            platform.round_rocks[i].y <span style=color:#f92672>=</span> next.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            platform.occupied.remove(<span style=color:#f92672>&amp;</span>r);
</span></span><span style=display:flex><span>            platform.occupied.insert(next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>changed {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We do have to update both <code>round_rocks</code> and <code>occupied</code> (which could perhaps be hidden in an <code>impl</code> rather than trusting that I&rsquo;ll get it right), but it works. And for the first time, we actually have a solution!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>14</span> 2-v2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 14 2-v2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>14</span> 2-v2
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:     18.358 s ±  0.172 s    <span style=color:#f92672>[</span>User: 17.818 s, System: 0.025 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:   18.125 s … 18.627 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>We can do better.</p><h3 id=optimization-3-multislide>Optimization 3: Multislide</h3><p>Okay, one thing we&rsquo;ve been doing so far is sliding each rock one tile at a time&ndash;and sometimes not even that. If two rocks are touching and the &lsquo;second&rsquo; tries to slide first, it will have to wait for the first to move. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># sliding right
</span></span><span style=display:flex><span>.OO...
</span></span><span style=display:flex><span>.O.O..
</span></span><span style=display:flex><span>..O.O.
</span></span><span style=display:flex><span>...O.O
</span></span><span style=display:flex><span>....OO
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># versus
</span></span><span style=display:flex><span>.OO...
</span></span><span style=display:flex><span>.O...O
</span></span><span style=display:flex><span>....OO
</span></span></code></pre></div><p>But there&rsquo;s no particular reason we have to do it that way!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> platform.round_rocks[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Move in that direction until we hit something (or a wall)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        next <span style=color:#f92672>=</span> next <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>platform.bounds.contains(<span style=color:#f92672>&amp;</span>next) <span style=color:#f92672>||</span> platform.occupied.contains(<span style=color:#f92672>&amp;</span>next) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Have to step back to the last valid point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            next <span style=color:#f92672>=</span> next <span style=color:#f92672>-</span> direction;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we didn&#39;t actually move, do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> next <span style=color:#f92672>==</span> r {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we get here, we can move; do it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    platform.round_rocks[i].x <span style=color:#f92672>=</span> next.x;
</span></span><span style=display:flex><span>    platform.round_rocks[i].y <span style=color:#f92672>=</span> next.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    platform.occupied.remove(<span style=color:#f92672>&amp;</span>r);
</span></span><span style=display:flex><span>    platform.occupied.insert(next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Does it help?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 14 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:      6.110 s ±  0.215 s    <span style=color:#f92672>[</span>User: 5.781 s, System: 0.021 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:    5.862 s …  6.340 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Absolutely.</p><h2 id=performance>Performance</h2><p>Part 1 is fast&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> just time <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine <span style=color:#f92672>--</span>warmup <span style=color:#ae81ff>3</span> <span style=color:#a6e22e>&#39;just</span> run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>1</span><span style=color:#a6e22e>&#39;</span>
</span></span><span style=display:flex><span>Benchmark <span style=color:#ae81ff>1</span>: <span style=color:#a6e22e>just</span> run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time (mean <span style=color:#960050;background-color:#1e0010>±</span> <span style=color:#960050;background-color:#1e0010>σ</span>):     <span style=color:#ae81ff>308.4</span> ms <span style=color:#960050;background-color:#1e0010>±</span> <span style=color:#ae81ff>162.7</span> ms    [User: <span style=color:#ae81ff>92.8</span> ms, System: <span style=color:#ae81ff>19.5</span> ms]
</span></span><span style=display:flex><span>  Range (min <span style=color:#960050;background-color:#1e0010>…</span> max):   <span style=color:#ae81ff>165.0</span> ms <span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#ae81ff>525.7</span> ms    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>$</span> just time <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine <span style=color:#f92672>--</span>warmup <span style=color:#ae81ff>3</span> <span style=color:#a6e22e>&#39;just</span> run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span><span style=color:#a6e22e>&#39;</span>
</span></span><span style=display:flex><span>Benchmark <span style=color:#ae81ff>1</span>: <span style=color:#a6e22e>just</span> run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time (mean <span style=color:#960050;background-color:#1e0010>±</span> <span style=color:#960050;background-color:#1e0010>σ</span>):      <span style=color:#ae81ff>6.110</span> s <span style=color:#960050;background-color:#1e0010>±</span>  <span style=color:#ae81ff>0.215</span> s    [User: <span style=color:#ae81ff>5.781</span> s, System: <span style=color:#ae81ff>0.021</span> s]
</span></span><span style=display:flex><span>Range (min <span style=color:#960050;background-color:#1e0010>…</span> max):    <span style=color:#ae81ff>5.862</span> s <span style=color:#960050;background-color:#1e0010>…</span>  <span style=color:#ae81ff>6.340</span> s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>&mldr;but part 2 is unfortunately well over the 1 second mark, even with improvements. I really do think that I should be able to do better. But for now, this will have to do. We&rsquo;ll see!</p><h2 id=edit-1-optimization-4--removing-a-debugging-line>Edit 1, Optimization 4: &mldr; removing a debugging line</h2><p>Okay, I kept working on it.</p><p>Fix #1 (and I feel so bad about this)&mldr; I left a debugging line in.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Let the rocks slide until they stop moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> platform.round_rocks[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Move in that direction until we hit something (or a wall)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> next <span style=color:#f92672>+</span> direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>platform.bounds.contains(<span style=color:#f92672>&amp;</span>next) <span style=color:#f92672>||</span> platform.occupied.contains(<span style=color:#f92672>&amp;</span>next) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Have to step back to the last valid point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                next <span style=color:#f92672>=</span> next <span style=color:#f92672>-</span> direction;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we didn&#39;t actually move, do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> next <span style=color:#f92672>==</span> r {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we get here, we can move; do it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        platform.round_rocks[i].x <span style=color:#f92672>=</span> next.x;
</span></span><span style=display:flex><span>        platform.round_rocks[i].y <span style=color:#f92672>=</span> next.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        platform.occupied.remove(<span style=color:#f92672>&amp;</span>r);
</span></span><span style=display:flex><span>        platform.occupied.insert(next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>changed {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That second last break (after <code>changed = true</code>) means that each update will only update a single stone. To update any future stone, it has to at least check each previous one.</p><p>That&rsquo;s &mldr; not helpful.</p><p>Removing that and:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 14 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:      1.776 s ±  0.039 s    <span style=color:#f92672>[</span>User: 1.657 s, System: 0.019 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:    1.715 s …  1.830 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>This does also improve pretty much all of the previous part 2 runtimes, but I&rsquo;m not going to go back and fix them retroactively. Such is life.</p><h2 id=edit-2-optimization-5-pre-sorting-the-rocks>Edit 2, Optimization 5: Pre-sorting the rocks</h2><p>For the first &lsquo;real&rsquo; optimization, I noted previously that we&rsquo;re sliding each stone as far as we can. Well, it turns out that&rsquo;s only partially true. In order to move each stone as far as possible, we have to be moving in the right direction. If we&rsquo;re moving from &rsquo;top to bottom&rsquo;, then moving North is easier than moving South.</p><p>To fix this, let&rsquo;s add a quick sort within the direction loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The rocks will slide N, W, S, E
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (direction_i, direction) <span style=color:#66d9ef>in</span> [Point::<span style=color:#66d9ef>NORTH</span>, Point::<span style=color:#66d9ef>WEST</span>, Point::<span style=color:#66d9ef>SOUTH</span>, Point::<span style=color:#66d9ef>EAST</span>]
</span></span><span style=display:flex><span>    .into_iter()
</span></span><span style=display:flex><span>    .enumerate()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Resort the rocks in the direction we&#39;re moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    platform.round_rocks.sort_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> direction_i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// direction == Point::NORTH
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            a.y.cmp(<span style=color:#f92672>&amp;</span>b.y)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> direction_i <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// direction == Point::WEST
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            a.x.cmp(<span style=color:#f92672>&amp;</span>b.x)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> direction_i <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// direction == Point::SOUTH
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            b.y.cmp(<span style=color:#f92672>&amp;</span>a.y)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> direction_i <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// direction == Point::EAST
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            b.x.cmp(<span style=color:#f92672>&amp;</span>a.x)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            panic!(<span style=color:#e6db74>&#34;Invalid direction_i: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, direction_i)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Slide each rock once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Note: No more `loop` here waiting for them to stop sliding!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>platform.round_rocks.len() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It should sort in place, so no more allocation and I tried to (perhaps prematurely) optimize the comparison about which way we&rsquo;re sorting.</p><p>Downside: we have to spend the extra time each part of each cycle to sort. Upside, we can remove the actual <code>loop</code> and just go directly to updating each rock!</p><p>So, does it help?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 14 2-order&#39;</span> <span style=color:#e6db74>&#39;just run 14 2&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>14</span> 2-order
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:      1.769 s ±  0.183 s    <span style=color:#f92672>[</span>User: 1.550 s, System: 0.020 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:    1.621 s …  2.151 s    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmark 2: just run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:      1.909 s ±  0.152 s    <span style=color:#f92672>[</span>User: 1.651 s, System: 0.019 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:    1.716 s …  2.103 s    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Summary
</span></span><span style=display:flex><span>  just run <span style=color:#ae81ff>14</span> 2-order ran
</span></span><span style=display:flex><span>    1.08 ± 0.14 times faster than just run <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>~8%. So it&rsquo;s progress, but not much.</p><h2 id=edit-3-rendering>Edit 3, Rendering</h2><p>Much as I&rsquo;ve now added to , I have rendering!</p><p>Here is the solution (for <a href=#part-2>part 2</a>) rendering one frame per cycle:</p><p><video controls src=/embeds/2023/aoc23-14-cycle.mp4></video></p><p>And here is rendering one frame per subcycle/direction:</p><p><video controls src=/embeds/2023/aoc23-14-direction.mp4></video></p><p>Not exactly as I expected, but still pretty fun!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>