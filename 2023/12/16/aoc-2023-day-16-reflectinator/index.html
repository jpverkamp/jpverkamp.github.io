<!doctype html><html><head><title>AoC 2023 Day 16: Reflectinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 16: Reflectinator</h1><div class=entry-meta><span class=entry-date>2023-12-16</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/17/aoc-2023-day-17-a-starinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/17/aoc-2023-day-17-a-starinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/17/aoc-2023-day-17-a-starinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/17/aoc-2023-day-17-a-starinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/15/aoc-2023-day-15-hashinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/17/star-wars-vol.-5-yodas-secret-war/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-16-the-floor-will-be-lava>Source: <a href=https://adventofcode.com/2023/day/16 target=_blank rel=noopener>Day 16: The Floor Will Be Lava</a></h2><p><video controls src=/embeds/2023/aoc23-16.mp4></video></p><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day16 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-16-the-floor-will-be-lava>Source: <a href=https://adventofcode.com/2023/day/16>Day 16: The Floor Will Be Lava</a></a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-2>Part 2</a></li><li><a href=#performance>Performance</a></li><li><a href=#grid>Grid</a><ul><li><a href=#implementation>Implementation</a></li><li><a href=#point>Point</a></li><li><a href=#bounds>Bounds</a></li></ul></li><li><a href=#edit-1-adding-to_string-and-to_image-for-grid>Edit 1, Adding to_string and to_image for Grid</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>You are given a grid of mirrors (<code>|-\/</code>) and empty space (<code>.</code>).</p><p>Diagonal mirrors just relect the light.</p><p>The horizontal and vertical mirrors are splitters, light hitting them head on (like <code>>|</code>) will split to go both directions. Light hitting edge on will just go through it.</p><p>Starting in the top left going East, how many total tiles will a light beam illuminate?</p></blockquote><p>Okay, first things first, let&rsquo;s go ahead and extract that <a href=#grid>grid</a> we&rsquo;ve been using. <a href=#grid>See below</a>.</p><p>Other than that, we want some types for <code>Mirrors</code> and <code>Directions</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Mirror</span> {
</span></span><span style=display:flex><span>    VerticalSplitter,
</span></span><span style=display:flex><span>    HorizontalSplitter,
</span></span><span style=display:flex><span>    ForwardReflector,
</span></span><span style=display:flex><span>    BackwardReflector,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>    North,
</span></span><span style=display:flex><span>    South,
</span></span><span style=display:flex><span>    East,
</span></span><span style=display:flex><span>    West,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(d: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> d {
</span></span><span style=display:flex><span>            Direction::North <span style=color:#f92672>=&gt;</span> Point::<span style=color:#66d9ef>NORTH</span>,
</span></span><span style=display:flex><span>            Direction::South <span style=color:#f92672>=&gt;</span> Point::<span style=color:#66d9ef>SOUTH</span>,
</span></span><span style=display:flex><span>            Direction::East <span style=color:#f92672>=&gt;</span> Point::<span style=color:#66d9ef>EAST</span>,
</span></span><span style=display:flex><span>            Direction::West <span style=color:#f92672>=&gt;</span> Point::<span style=color:#66d9ef>WEST</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we should be able to <code>illuminate</code>. Because we can split, I&rsquo;ll keep a <a href=https://en.wikipedia.org/wiki/queue>queue</a> of current points to check. Each iteration, I&rsquo;ll advance the light by one (possibly splitting). One caveat is to make sure that we don&rsquo;t get into possible loops. As before, keeping a <code>HashSet</code> of <code>visited</code> <code>(Point, Direction)</code> should be sufficient as we can visit the same point with different directions and get different outputs, but the same point and direction will always add the same points to the <code>illumanation</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>illuminate</span>(mirrors: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Mirror<span style=color:#f92672>&gt;</span>, start: (Point, Direction)) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> Direction::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> Mirror::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    queue.push(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> fxhash::FxHashSet::default();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> illuminated <span style=color:#f92672>=</span> Grid::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some((p, d)) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Ignore points that have gone out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>mirrors.bounds.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Don&#39;t evaluate the same point + direction more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> visited.contains(<span style=color:#f92672>&amp;</span>(p, d)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        visited.insert((p, d));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        illuminated.insert(p, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> (mirrors.get(<span style=color:#f92672>&amp;</span>p), d) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If you hit a splitter side on (ex &gt;-), you continue in the same direction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            (Some(VerticalSplitter), North) <span style=color:#f92672>|</span> (Some(VerticalSplitter), South) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> d.into(), d));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            (Some(HorizontalSplitter), East) <span style=color:#f92672>|</span> (Some(HorizontalSplitter), West) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> d.into(), d));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise (ex &gt;|), split to the two directions it points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            (Some(VerticalSplitter), _) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> North.into(), North));
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> South.into(), South));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            (Some(HorizontalSplitter), _) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> East.into(), East));
</span></span><span style=display:flex><span>                queue.push((p <span style=color:#f92672>+</span> West.into(), West));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Diagonal reflectors just change, so &gt;\ goes South, &gt;/ goes North etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            (Some(ForwardReflector), North) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> East.into(), East)),
</span></span><span style=display:flex><span>            (Some(ForwardReflector), East) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> North.into(), North)),
</span></span><span style=display:flex><span>            (Some(ForwardReflector), South) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> West.into(), West)),
</span></span><span style=display:flex><span>            (Some(ForwardReflector), West) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> South.into(), South)),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            (Some(BackwardReflector), North) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> West.into(), West)),
</span></span><span style=display:flex><span>            (Some(BackwardReflector), East) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> South.into(), South)),
</span></span><span style=display:flex><span>            (Some(BackwardReflector), South) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> East.into(), East)),
</span></span><span style=display:flex><span>            (Some(BackwardReflector), West) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> North.into(), North)),
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If there&#39;s nothing there, keep going
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            (None, _) <span style=color:#f92672>=&gt;</span> queue.push((p <span style=color:#f92672>+</span> d.into(), d)),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    illuminated
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bit of a big <code>match</code> there, but I think that it&rsquo;s pretty straight forward? One thing that I like is that because of how <code>match</code> statements work in Rust, if I miss any cases, it will yell at me!</p><p>Okay, let&rsquo;s plug it in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirrors <span style=color:#f92672>=</span> Grid::read(<span style=color:#f92672>&amp;</span>input, <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;|&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::VerticalSplitter),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::HorizontalSplitter),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::ForwardReflector),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;\\&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::BackwardReflector),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> illuminated <span style=color:#f92672>=</span> illuminate(<span style=color:#f92672>&amp;</span>mirrors, (Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), Direction::East));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> illuminated.iter().count();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sweet.</p><p>I like the new <a href=#grid>grid</a> interface. &#x1f604;</p><h2 id=part-2>Part 2</h2><blockquote><p>Assuming the light could start on any of the 4 edges, what is the maximum illumination?</p></blockquote><p>Well, we already have the function. Let&rsquo;s just try them all!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>mod</span> part1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> part1::illuminate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> Direction::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mirrors <span style=color:#f92672>=</span> Grid::read(<span style=color:#f92672>&amp;</span>input, <span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;|&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::VerticalSplitter),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::HorizontalSplitter),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::ForwardReflector),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;\\&#39;</span> <span style=color:#f92672>=&gt;</span> Some(Mirror::BackwardReflector),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> starts <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> mirrors.bounds.min_x<span style=color:#f92672>..=</span>mirrors.bounds.max_x {
</span></span><span style=display:flex><span>        starts.push((Point::new(x, mirrors.bounds.min_y), South));
</span></span><span style=display:flex><span>        starts.push((Point::new(x, mirrors.bounds.max_y), North));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> mirrors.bounds.min_y<span style=color:#f92672>..=</span>mirrors.bounds.max_y {
</span></span><span style=display:flex><span>        starts.push((Point::new(mirrors.bounds.min_x, y), East));
</span></span><span style=display:flex><span>        starts.push((Point::new(mirrors.bounds.max_x, y), West));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> starts
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>start<span style=color:#f92672>|</span> illuminate(<span style=color:#f92672>&amp;</span>mirrors, <span style=color:#f92672>*</span>start).iter().count())
</span></span><span style=display:flex><span>        .max()
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pulling <code>illuminate</code> from the other <code>bin</code> is a bit weird&mldr; but it works fine! Just need to generate all of the <code>starts</code> and try them.</p><h2 id=performance>Performance</h2><p>Plenty quick:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 16 1&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:      83.3 ms ±   3.3 ms    <span style=color:#f92672>[</span>User: 32.3 ms, System: 12.6 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:    78.8 ms …  92.2 ms    <span style=color:#ae81ff>32</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 16 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean ± σ<span style=color:#f92672>)</span>:     206.9 ms ±   3.7 ms    <span style=color:#f92672>[</span>User: 129.8 ms, System: 15.5 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min … max<span style=color:#f92672>)</span>:   200.5 ms … 214.2 ms    <span style=color:#ae81ff>14</span> runs
</span></span></code></pre></div><p>It&rsquo;s mostly disk I/O. You can tell that especially in part 2. Despite doing more than 400 as much work, it&rsquo;s only ~2.5x slower&ndash;because we only have to load the data once.</p><h2 id=grid>Grid</h2><p>As a side note, the implementation of Grid!</p><h3 id=implementation>Implementation</h3><p>The goal of <code>Grid</code> was to create a <a href=https://en.wikipedia.org/wiki/sparse%20grid>sparse grid</a> of points (where most are empty).</p><p>So rather than allocating memory for each possible point, we only keep a <code>HashMap</code> from <a href=#point><code>Point</code></a> to some generic type <code>T</code>.</p><p>What I think is particularly cool is that (like most of Rust), you generally don&rsquo;t have to specify the generic type <code>T</code>. If you provide a conversion function to <code>read</code> (as we did in <a href=#part-1>loading the mirrors</a>) or just <code>insert</code> values yourself (as we do in <a href=#part-1>illuminate</a>) it will just figure it out. That&rsquo;s pretty cool. &#x1f604;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> bounds: <span style=color:#a6e22e>Bounds</span>,
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>FxHashMap</span><span style=color:#f92672>&lt;</span>Point, T<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: Default<span style=color:#f92672>&gt;</span> Default <span style=color:#66d9ef>for</span> Grid<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>default</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self::new()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Grid<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            bounds: <span style=color:#a6e22e>Bounds</span>::default(),
</span></span><span style=display:flex><span>            data: <span style=color:#a6e22e>FxHashMap</span>::default(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, from_c: <span style=color:#a6e22e>impl</span> Fn(<span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> grid <span style=color:#f92672>=</span> Self::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (y, line) <span style=color:#66d9ef>in</span> s.lines().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(c) <span style=color:#f92672>=</span> from_c(c) {
</span></span><span style=display:flex><span>                    grid.insert(Point { x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>, y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> }, c);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        grid
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, point: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.get(point)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_mut</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, point: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.get_mut(point)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, point: <span style=color:#a6e22e>Point</span>, value: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>        self.bounds.include(point);
</span></span><span style=display:flex><span>        self.data.insert(point, value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>remove</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, point: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span>) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.remove(point)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> (<span style=color:#f92672>&amp;</span>Point, <span style=color:#f92672>&amp;</span>T)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.iter()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter_mut</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> (<span style=color:#f92672>&amp;</span>Point, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> T)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.iter_mut()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter_points</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>Point<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.keys()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter_values</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.values()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter_values_mut</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.values_mut()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In addition, to make this work, we also have extracted <a href=#point><code>Point</code></a> and <a href=#bounds><code>Bounds</code></a> into their own packages as well. I feel like we might want these all in one&mldr; but for now it works.</p><h3 id=point>Point</h3><p>As before, a point is <code>isize</code>. This allows us to add/subtract points without worrying about underflow!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, Ord, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>NORTH</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>SOUTH</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>EAST</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WEST</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#66d9ef>isize</span>, y: <span style=color:#66d9ef>isize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>manhattan_distance</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>        (self.x <span style=color:#f92672>-</span> other.x).abs() <span style=color:#f92672>+</span> (self.y <span style=color:#f92672>-</span> other.y).abs()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::ops::Add<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>+</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>+</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::ops::Sub<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sub</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>-</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>-</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::fmt::Display <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;({}, {})&#34;</span>, self.x, self.y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bounds>Bounds</h3><p>And finally <code>Bounds</code>. This represents a bounding box. The neat part to me is that you can extend it with <code>include</code>. I feel like that needs a better name. Anyways:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> point::Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Eq, PartialEq, Default, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bounds</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> min_x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> max_x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> min_y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> max_y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Bounds {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contains</span>(<span style=color:#f92672>&amp;</span>self, point: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        point.x <span style=color:#f92672>&gt;=</span> self.min_x
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> point.x <span style=color:#f92672>&lt;=</span> self.max_x
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> point.y <span style=color:#f92672>&gt;=</span> self.min_y
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> point.y <span style=color:#f92672>&lt;=</span> self.max_y
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>include</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>        self.min_x <span style=color:#f92672>=</span> self.min_x.min(p.x);
</span></span><span style=display:flex><span>        self.max_x <span style=color:#f92672>=</span> self.max_x.max(p.x);
</span></span><span style=display:flex><span>        self.min_y <span style=color:#f92672>=</span> self.min_y.min(p.y);
</span></span><span style=display:flex><span>        self.max_y <span style=color:#f92672>=</span> self.max_y.max(p.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=edit-1-adding-to_string-and-to_image-for-grid>Edit 1, Adding to_string and to_image for Grid</h2><p>It&rsquo;s nice to be able to debug and we can basically reverse the <code>from_c</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Grid<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>to_string</span>(<span style=color:#f92672>&amp;</span>self, empty_c: <span style=color:#66d9ef>char</span>, to_c: <span style=color:#a6e22e>impl</span> Fn(<span style=color:#f92672>&amp;</span>T) -&gt; <span style=color:#66d9ef>char</span>) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> self.bounds.min_y<span style=color:#f92672>..=</span>self.bounds.max_y {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> self.bounds.min_x<span style=color:#f92672>..=</span>self.bounds.max_x {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(c) <span style=color:#f92672>=</span> self.get(<span style=color:#f92672>&amp;</span>p).map(<span style=color:#f92672>&amp;</span>to_c) {
</span></span><span style=display:flex><span>                    s.push(c);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    s.push(empty_c);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            s.push(<span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        s
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>to_image</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self,
</span></span><span style=display:flex><span>        empty_c: <span style=color:#a6e22e>image</span>::Rgba<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        to_c: <span style=color:#a6e22e>impl</span> Fn(<span style=color:#f92672>&amp;</span>T) -&gt; <span style=color:#a6e22e>image</span>::Rgba<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#a6e22e>image</span>::RgbaImage {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> self.bounds.max_x <span style=color:#f92672>-</span> self.bounds.min_x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> self.bounds.max_y <span style=color:#f92672>-</span> self.bounds.min_y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> image <span style=color:#f92672>=</span> image::RgbaImage::new(width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>, height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> self.bounds.min_y<span style=color:#f92672>..=</span>self.bounds.max_y {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> self.bounds.min_x<span style=color:#f92672>..=</span>self.bounds.max_x {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(c) <span style=color:#f92672>=</span> self.get(<span style=color:#f92672>&amp;</span>p).map(<span style=color:#f92672>&amp;</span>to_c) {
</span></span><span style=display:flex><span>                    image.put_pixel(
</span></span><span style=display:flex><span>                        (x <span style=color:#f92672>-</span> self.bounds.min_x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>                        (y <span style=color:#f92672>-</span> self.bounds.min_y) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>                        c,
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    image.put_pixel(
</span></span><span style=display:flex><span>                        (x <span style=color:#f92672>-</span> self.bounds.min_x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>                        (y <span style=color:#f92672>-</span> self.bounds.min_y) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>                        empty_c,
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        image
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we can make a nice <code>part2-render.rs</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> background <span style=color:#f92672>=</span> mirrors.to_image(image::Rgba([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>    image::Rgba([<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>])
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> barely_black <span style=color:#f92672>=</span> image::RgbaImage::from_pixel(
</span></span><span style=display:flex><span>    background.width(),
</span></span><span style=display:flex><span>    background.height(),
</span></span><span style=display:flex><span>    image::Rgba([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>8</span>]),
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> foreground <span style=color:#f92672>=</span> image::RgbaImage::new(background.width(), background.height());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> frame <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(points) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> frame <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>RENDER_FRAMES</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Render the current frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        frame <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> filename <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;frames/</span><span style=color:#e6db74>{:04}</span><span style=color:#e6db74>.png&#34;</span>, frame);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Rendering </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, filename);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        create_dir_all(<span style=color:#e6db74>&#34;frames&#34;</span>).ok();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> frame <span style=color:#f92672>=</span> image::RgbaImage::new(background.width(), background.height());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Darken the previous foreground frames slightly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        image::imageops::overlay(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> foreground, <span style=color:#f92672>&amp;</span>barely_black, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (p, _) <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>points {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> mirrors.bounds.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                foreground.put_pixel(p.x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>, p.y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>, image::Rgba([<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>]));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        image::imageops::overlay(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> frame, <span style=color:#f92672>&amp;</span>foreground, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        image::imageops::overlay(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> frame, <span style=color:#f92672>&amp;</span>background, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        frame.save(filename).unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>I did tweak it to 1) not check <code>visited</code> points, so that we get full effect and 2) keep an ever growing list of the current points, rather than the more efficient queue. I think the results are pretty cool!</p><p><video controls src=/embeds/2023/aoc23-16.mp4></video></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>