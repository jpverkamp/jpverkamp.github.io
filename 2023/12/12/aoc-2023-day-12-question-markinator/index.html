<!doctype html><html><head><title>AoC 2023 Day 12: Question Markinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.34a34d86b8aae11b989d80a1626629c053029d012419a1993cfb6c12ea175737.css integrity="sha256-NKNNhriq4RuYnYChYmYpwFMCnQEkGaGZPPtsEuoXVzc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2023 Day 12: Question Markinator</h1><div class=entry-meta><span class=entry-date>2023-12-12</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/11/aoc-2023-day-11-big-banginator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/11/aoc-2023-day-11-big-banginator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/11/aoc-2023-day-11-big-banginator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2023>Advent of Code 2023</a><a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/12/11/aoc-2023-day-11-big-banginator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/12/11/aoc-2023-day-11-big-banginator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/12/13/aoc-2023-day-13-reflectinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-12-hot-springs>Source: <a href=https://adventofcode.com/2023/day/12 target=_blank rel=noopener>Day 12: Hot Springs</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/tree/master/2023/solutions/day12 target=_blank rel=noopener>Full solution</a> for today (spoilers!)</p><nav id=TableOfContents><ul><li><a href=#source-day-12-hot-springs>Source: <a href=https://adventofcode.com/2023/day/12>Day 12: Hot Springs</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#types-and-parsing>Types and Parsing</a></li><li><a href=#solution>Solution</a></li><li><a href=#cleaning-up>Cleaning up</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#almost-brute-force>(Almost) Brute Force</a></li><li><a href=#caching>Caching</a></li><li><a href=#a-choice-of-map>A choice of map</a></li><li><a href=#rewriting-it-with-types>Rewriting it with types</a></li></ul></li><li><a href=#performance>Performance</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a sequence of <code>#.?</code> as on, off, and unknown and a sequence of group sizes, determine how many possible arrangements there are that match the given groups.</p><p>More specifically, if you have <code>???.## 1,2</code> you need a single <code>#</code> and a set of two <code>##</code>, there are three possibilities: <code>#...###</code>, <code>.#..###</code>, and <code>..#.###</code>.</p></blockquote><h3 id=types-and-parsing>Types and Parsing</h3><p>Okay, let&rsquo;s represent this thing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Condition</span> {
</span></span><span style=display:flex><span>    Operational,
</span></span><span style=display:flex><span>    Damaged,
</span></span><span style=display:flex><span>    Unknown,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Condition {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_known</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span><span style=color:#a6e22e>matches!</span>(self, Condition::Unknown)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Spring</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> conditions: Vec<span style=color:#f92672>&lt;</span>Condition<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> groups: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>condition</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Condition<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    alt((
</span></span><span style=display:flex><span>        map(tag(<span style=color:#e6db74>&#34;#&#34;</span>), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Condition::Operational),
</span></span><span style=display:flex><span>        map(tag(<span style=color:#e6db74>&#34;.&#34;</span>), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Condition::Damaged),
</span></span><span style=display:flex><span>        map(tag(<span style=color:#e6db74>&#34;?&#34;</span>), <span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Condition::Unknown),
</span></span><span style=display:flex><span>    ))(s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>spring</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Spring<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, conditions) <span style=color:#f92672>=</span> many1(condition)(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, _) <span style=color:#f92672>=</span> space1(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, groups) <span style=color:#f92672>=</span> separated_list1(<span style=color:#66d9ef>char</span>(<span style=color:#e6db74>&#39;,&#39;</span>), complete::<span style=color:#66d9ef>u64</span>)(s)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok((s, Spring { conditions, groups }))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>springs</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>IResult</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Vec<span style=color:#f92672>&lt;</span>Spring<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    separated_list1(line_ending, spring)(s)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pretty straight forward.</p><p>Originally, I had just <code>Operational</code> and <code>Damaged</code> with <code>Option</code> (<code>None</code>) to represent unknown parts, but really, it just the made the code more confusing, so I changed that before even version 1.</p><h3 id=solution>Solution</h3><p>But the really interesting part is the solution:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, springs) <span style=color:#f92672>=</span> parse::springs(<span style=color:#f92672>&amp;</span>input).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(s.trim(), <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> springs
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>use</span> Condition::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> possibles <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>            queue.push(s.conditions.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(current) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If there are no unknown components, score it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> current.iter().all(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.is_known()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> groups <span style=color:#f92672>=</span> current
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .chain(std::iter::once(<span style=color:#f92672>&amp;</span>Damaged))
</span></span><span style=display:flex><span>                        .fold(
</span></span><span style=display:flex><span>                            (Damaged, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>vec!</span>[]),
</span></span><span style=display:flex><span>                            <span style=color:#f92672>|</span>(previous, current_length, <span style=color:#66d9ef>mut</span> lengths), current<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> (
</span></span><span style=display:flex><span>                                previous, current,
</span></span><span style=display:flex><span>                            ) {
</span></span><span style=display:flex><span>                                (Operational, Operational) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    (Operational, current_length <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, lengths)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                (Operational, Damaged) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    lengths.push(current_length);
</span></span><span style=display:flex><span>                                    (Damaged, <span style=color:#ae81ff>0</span>, lengths)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                (Damaged, Operational) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    (Operational, <span style=color:#ae81ff>1</span>, lengths)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                (Damaged, Damaged) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    (Damaged, <span style=color:#ae81ff>0</span>, lengths)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Invalid state, previous: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>, current: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, previous, current)
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                        )
</span></span><span style=display:flex><span>                        .<span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> groups <span style=color:#f92672>==</span> s.groups {
</span></span><span style=display:flex><span>                        possibles <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Otherwise, queue one in with each possibility
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>for</span> (i, condition) <span style=color:#66d9ef>in</span> current.iter().enumerate() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>condition.is_known() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> current.clone();
</span></span><span style=display:flex><span>                            next[i] <span style=color:#f92672>=</span> Operational;
</span></span><span style=display:flex><span>                            queue.push(next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> current.clone();
</span></span><span style=display:flex><span>                            next[i] <span style=color:#f92672>=</span> Damaged;
</span></span><span style=display:flex><span>                            queue.push(next);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            possibles
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yeah, okay. That&rsquo;s a bit ugly. Essentially, we&rsquo;re going to solve the problem by:</p><ol><li>Initialize a stack of potential solutions with the initial state</li><li>For each solution:<ol><li>If it has at least one <code>?</code> left, push a two new copies with it set to either <code>.</code> or <code>#</code></li><li>If it has no <code>?</code> left, score it (it either matches the target groups or not)</li></ol></li></ol><p>The most interesting part is probably the <code>fold</code>. That&rsquo;s calculating sequential groups by keeping track of the previous character (so you know if you change from <code>.#</code> or vice versa) and the current count and <code>match (previous, current)</code> against them.</p><p>It&rsquo;s not terrible code&mldr; but I can already guess that this is going to blow up in part 2.</p><h3 id=cleaning-up>Cleaning up</h3><p>Speaking of terrible, we can move some of this functionality to <code>impl Spring</code> and make things I think a little cleaner.</p><p>First, a helper method that will wrap up that <code>fold</code> from before (although it&rsquo;s a <code>for</code> now) into a single method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Spring {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>current_groups</span>(<span style=color:#f92672>&amp;</span>self) -&gt; (Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>u64</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Condition::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> groups <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> group: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> previous <span style=color:#f92672>=</span> Condition::Damaged;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> current <span style=color:#66d9ef>in</span> self.conditions.iter().chain(std::iter::once(<span style=color:#f92672>&amp;</span>Damaged)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> (previous, current) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Continuing this group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                (Operational, Operational) <span style=color:#f92672>=&gt;</span> group <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Ending a group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                (Operational, Damaged) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    groups.push(group);
</span></span><span style=display:flex><span>                    group <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Starting a new group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                (Damaged, Operational) <span style=color:#f92672>=&gt;</span> group <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Currently not in a group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                (Damaged, Damaged) <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we hit an unknown, bail early with the current groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                (_, Unknown) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Invalid state&#34;</span>),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            previous <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>current;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (groups, group)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This one is slightly different. Rather than matching the entire sequence only, this one will handle partial sequences, up until you get to the first <code>?</code>. It will then also return two things: any groups completed + the length of the last currently incomplete group.</p><p>This then lets us write some more helpers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Spring {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (groups, next_group) <span style=color:#f92672>=</span> self.current_groups();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.groups.starts_with(<span style=color:#f92672>&amp;</span>groups) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>&lt;</span> self.groups.len()
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> next_group <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self.groups[groups.len()] <span style=color:#f92672>&lt;</span> next_group
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_known</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.conditions.iter().all(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.is_known())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_correct</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.is_known() <span style=color:#f92672>&amp;&amp;</span> self.groups <span style=color:#f92672>==</span> self.current_groups().<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this case, <code>is_valid</code> will tell us if it&rsquo;s <em>possible</em> that the current solution is still valid, based only on the section up to the first <code>?</code> (using <code>current_groups</code>). The second <code>if</code> with three clauses makes sure that you don&rsquo;t have to generate all lengths of final groups with a terminating <code>.</code> before bailing out. As soon as you&rsquo;ve counted up more than the <code>next_group</code>, you&rsquo;re already invalid.</p><p>After that, <code>is_known</code> defines the end case (all values set) and <code>is_correct</code> verifies that you have exactly the correct solution.</p><p>With all these, we can have a cleaner (if not that much shorter) part 1:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, springs) <span style=color:#f92672>=</span> parse::springs(<span style=color:#f92672>&amp;</span>input).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(s.trim(), <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> springs
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>use</span> Condition::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> possibles <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> VecDeque::new();
</span></span><span style=display:flex><span>            queue.push_back(s.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(current) <span style=color:#f92672>=</span> queue.pop_front() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If the current state is impossible, skip it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>current.is_valid() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// println!(&#34;{current} is invalid&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If it is possible and completely known, score it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> current.is_correct() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// println!(&#34;{current} is scoring&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    possibles <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Otherwise, queue one in with each possibility
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (i, condition) <span style=color:#66d9ef>in</span> current.conditions.iter().enumerate() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>condition.is_known() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> current.clone();
</span></span><span style=display:flex><span>                        next.conditions[i] <span style=color:#f92672>=</span> Operational;
</span></span><span style=display:flex><span>                        queue.push_back(next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> current.clone();
</span></span><span style=display:flex><span>                        next.conditions[i] <span style=color:#f92672>=</span> Damaged;
</span></span><span style=display:flex><span>                        queue.push_back(next);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            possibles
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s significantly faster too (roughly ~15x), although that&rsquo;s more due to the <code>is_valid</code> bailing out early than the cleaner code.</p><p>Okay. Let&rsquo;s see what tricks they have for us.</p><h2 id=part-2>Part 2</h2><blockquote><p>Repeat each input sequence 5x. Delimit the first inputs by an extra <code>?</code> and the second by the necessary <code>,</code>. So <code>#.? 1,1</code> becomes <code>#.??#.??#.??#.??#.? 1,1,1,1,1,1,1,1,1,1</code>.</p></blockquote><p>Well. That certainly makes things longer.</p><p>Rewriting the input isn&rsquo;t too bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drep</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, d: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; String {
</span></span><span style=display:flex><span>    std::iter::repeat(s).take(n).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>().join(d)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> input
</span></span><span style=display:flex><span>    .lines()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> parts <span style=color:#f92672>=</span> line.split_once(<span style=color:#e6db74>&#39; &#39;</span>).unwrap();
</span></span><span style=display:flex><span>        drep(parts.<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;?&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>&amp;</span>drep(parts.<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>    .join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{input}</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><h3 id=almost-brute-force>(Almost) Brute Force</h3><p>But&mldr; there&rsquo;s no way this is going to run in anyway at all fast.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>-</span>brute
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat data<span style=color:#f92672>/</span><span style=color:#75715e>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> <span style=color:#ae81ff>12</span>).txt <span style=color:#f92672>|</span> cargo run <span style=color:#f92672>--</span>release <span style=color:#f92672>-</span>p day<span style=color:#75715e>$(</span>printf <span style=color:#e6db74>&#34;%02d&#34;</span> <span style=color:#ae81ff>12</span>) <span style=color:#f92672>--</span>bin part2<span style=color:#f92672>-</span>brute
</span></span><span style=display:flex><span>   Compiling day12 v0.<span style=color:#ae81ff>1.0</span> (<span style=color:#f92672>/</span>Users<span style=color:#f92672>/</span>jp<span style=color:#f92672>/</span>Projects<span style=color:#f92672>/</span>advent<span style=color:#f92672>-</span>of<span style=color:#f92672>-</span>code<span style=color:#f92672>/</span><span style=color:#ae81ff>2023</span><span style=color:#f92672>/</span>solutions<span style=color:#f92672>/</span>day12)
</span></span><span style=display:flex><span>    Finished release [optimized] target(s) <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.18</span>s
</span></span><span style=display:flex><span>     Running <span style=color:#960050;background-color:#1e0010>`</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>part2<span style=color:#f92672>-</span>brute<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>: <span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>##.#<span style=color:#f92672>???????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>##.#<span style=color:#f92672>???????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>##.#<span style=color:#f92672>???????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>##.#<span style=color:#f92672>???????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>##.#<span style=color:#f92672>????</span>
</span></span><span style=display:flex><span>[solutions<span style=color:#f92672>/</span>day12<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>part2<span style=color:#f92672>-</span>brute.rs:<span style=color:#ae81ff>72</span>] possibles <span style=color:#f92672>=</span> <span style=color:#ae81ff>512</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>: .#<span style=color:#f92672>?</span>#.<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>???</span>.#<span style=color:#f92672>?</span>#.<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>???</span>.#<span style=color:#f92672>?</span>#.<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>???</span>.#<span style=color:#f92672>?</span>#.<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>???</span>.#<span style=color:#f92672>?</span>#.<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>
</span></span><span style=display:flex><span>[solutions<span style=color:#f92672>/</span>day12<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>part2<span style=color:#f92672>-</span>brute.rs:<span style=color:#ae81ff>72</span>] possibles <span style=color:#f92672>=</span> <span style=color:#ae81ff>5184</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>: #<span style=color:#f92672>???</span>.#<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>.<span style=color:#f92672>??</span>#<span style=color:#f92672>???</span>.#<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>.<span style=color:#f92672>??</span>#<span style=color:#f92672>???</span>.#<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>.<span style=color:#f92672>??</span>#<span style=color:#f92672>???</span>.#<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>.<span style=color:#f92672>??</span>#<span style=color:#f92672>???</span>.#<span style=color:#f92672>???</span>#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>.<span style=color:#f92672>??</span>.<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>29160</span>: ##.#.#####<span style=color:#f92672>..</span>#.#<span style=color:#f92672>..</span>.##.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#<span style=color:#f92672>..</span>.#<span style=color:#f92672>....</span>##<span style=color:#f92672>..</span>#<span style=color:#f92672>......</span>.#####<span style=color:#f92672>..</span>#.#.##<span style=color:#f92672>........</span>#<span style=color:#f92672>....</span>#####<span style=color:#f92672>..</span>#.#<span style=color:#f92672>?</span>.<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>[solutions<span style=color:#f92672>/</span>day12<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>part2<span style=color:#f92672>-</span>brute.rs:<span style=color:#ae81ff>72</span>] possibles <span style=color:#f92672>=</span> <span style=color:#ae81ff>32805</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>: <span style=color:#f92672>??</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>???????????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>???????????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>???????????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>???????????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>????????</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>44</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>3853</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>......</span>.#<span style=color:#f92672>..</span>#<span style=color:#f92672>....</span>#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#<span style=color:#f92672>..........</span>.#####<span style=color:#f92672>....</span>#.#<span style=color:#f92672>..</span>.#####.#<span style=color:#f92672>..</span>#.<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>66884</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>......</span>.#<span style=color:#f92672>..</span>#.#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#.#####.#<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####.#<span style=color:#f92672>........</span>.##<span style=color:#f92672>?</span>#<span style=color:#f92672>????????</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>38</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>132766</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>.#.#.#####<span style=color:#f92672>....</span>#<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>#<span style=color:#f92672>....</span>.#.#####.#<span style=color:#f92672>....?</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>40</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>198154</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>#.#.#####<span style=color:#f92672>..</span>#<span style=color:#f92672>....</span>.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>.#####<span style=color:#f92672>........</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>263202</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#<span style=color:#f92672>..</span>#####.#<span style=color:#f92672>..</span>#.#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#<span style=color:#f92672>....</span>#####<span style=color:#f92672>....</span>#<span style=color:#f92672>..</span>#.#.#<span style=color:#f92672>??</span>#<span style=color:#f92672>????????</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>36</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>327133</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#.#####<span style=color:#f92672>....</span>.#<span style=color:#f92672>..</span>#.#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#.#####<span style=color:#f92672>..</span>.#<span style=color:#f92672>....</span>#.#####.#<span style=color:#f92672>..</span>###.
</span></span><span style=display:flex><span><span style=color:#ae81ff>7000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>34</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>393297</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#.#####<span style=color:#f92672>..</span>.#.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#.#####.#<span style=color:#f92672>......</span>#<span style=color:#f92672>....</span>#####.#<span style=color:#f92672>?????</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>36</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>458305</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#.#####<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####.#<span style=color:#f92672>....</span>#<span style=color:#f92672>..</span>.#####<span style=color:#f92672>..</span>.#.#<span style=color:#f92672>..</span>.#####<span style=color:#f92672>....</span>##<span style=color:#f92672>??</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>9000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>38</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>522607</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#.#####.#<span style=color:#f92672>......</span>#<span style=color:#f92672>..</span>#####.#.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>..</span>.#<span style=color:#f92672>..</span>.#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#
</span></span><span style=display:flex><span><span style=color:#ae81ff>10000000</span>, q<span style=color:#f92672>=</span><span style=color:#ae81ff>28</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>587737</span>: <span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>#####<span style=color:#f92672>....</span>.#.#.#####.#<span style=color:#f92672>..</span>#<span style=color:#f92672>..</span>.#####<span style=color:#f92672>..</span>.#.#<span style=color:#f92672>..</span>.#####<span style=color:#f92672>....</span>#<span style=color:#f92672>??????</span>#<span style=color:#f92672>??</span>#<span style=color:#f92672>????????</span>
</span></span></code></pre></div><p>That&rsquo;s a whole mess of output. The import part is that each of those lines at the bottom is going through 1 million possible cases and we already have a roughly 6% success rate.</p><p>And that&rsquo;s <em>with</em> the <code>is_valid</code> optimization.</p><p>We&rsquo;re going to need something better.</p><h3 id=caching>Caching</h3><p>Okay, what I expect we&rsquo;re going to want is <a href=https://en.wikipedia.org/wiki/dynamic%20programming>dynamic programming</a> / <a href=https://en.wikipedia.org/wiki/caching>caching</a> / <a href=https://en.wikipedia.org/wiki/memoization>memoization</a>.</p><p>We want to take the original problem and somehow break it down to one or more smaller problems. For each of those smaller problems, continue to break it down. And then whenever (for a smaller problem), we get an answer, assume that another of those very very very many branches is going to ask the same (sub)question, so write it down.</p><p>In essence, this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drep</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, d: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; String {
</span></span><span style=display:flex><span>        std::iter::repeat(s).take(n).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>().join(d)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> parts <span style=color:#f92672>=</span> line.split_once(<span style=color:#e6db74>&#39; &#39;</span>).unwrap();
</span></span><span style=display:flex><span>            drep(parts.<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;?&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>&amp;</span>drep(parts.<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> parts <span style=color:#f92672>=</span> line.split_once(<span style=color:#e6db74>&#39; &#39;</span>).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> conditions <span style=color:#f92672>=</span> parts.<span style=color:#ae81ff>0.</span>as_bytes();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> groups <span style=color:#f92672>=</span> parts
</span></span><span style=display:flex><span>                .<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                .split(<span style=color:#e6db74>&#39;,&#39;</span>)
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.parse().unwrap())
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Solver::new().check(conditions, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span>, <span style=color:#f92672>&amp;</span>groups, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yeah, yeah, that&rsquo;s definitely a <a href=https://knowyourmeme.com/memes/how-to-draw-an-owl target=_blank rel=noopener>how to draw an owl</a> moment, but hang with me. The <code>Solver::new().check</code> is going to recursively do the work.</p><p>I&rsquo;m not messing with types here, since I want to only use pointers into that original string slice of input (I could make a single processed slice of my own types, we&rsquo;ll <a href=#rewriting-it-with-types>come back to that</a>).</p><p>But for now, what in the world does <code>Solver</code> look like?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Key</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u8</span>], <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u64</span>], <span style=color:#66d9ef>u64</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Solver</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    cache: <span style=color:#a6e22e>FxHashMap</span><span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> Solver<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>FxHashMap</span>::default(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>check</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        s: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u8</span>],       <span style=color:#75715e>// The remaining input string after current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr: <span style=color:#66d9ef>u8</span>,          <span style=color:#75715e>// The current character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        prev: <span style=color:#66d9ef>u8</span>,          <span style=color:#75715e>// The previous character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        groups: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u64</span>], <span style=color:#75715e>// The remaining groups to match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        count: <span style=color:#66d9ef>u64</span>,        <span style=color:#75715e>// The size of the current group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> (s, curr, prev, groups, count);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(value) <span style=color:#f92672>=</span> self.cache.get(<span style=color:#f92672>&amp;</span>key) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> groups.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Base case, we have no more groups to go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Everything else must not be #
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>||</span> s.iter().any(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>c <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// From here on out, we know groups is not empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;?&#39;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is unknown, try both cases (without advancing s!)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> if_d <span style=color:#f92672>=</span> self.check(s, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span>, prev, groups, count);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> if_o <span style=color:#f92672>=</span> self.check(s, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span>, prev, groups, count);
</span></span><span style=display:flex><span>                if_d <span style=color:#f92672>+</span> if_o
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> s.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// This block seems wrong, but I need it to have curr and prev work with ?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// We have no more input, check the last current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// We have at least one group at this point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If the last current is operational, we need to match the last group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we came from operational check the last group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> count <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got something weird on empty input: </span><span style=color:#e6db74>{curr}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is operational
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After damaged, start a new group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After another operational, continue group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got # after something weird: </span><span style=color:#e6db74>{prev}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is damaged
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After another damaged, nothing happens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;#&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After operational, finish the current group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// If the size doesn&#39;t match, this branch is immediately invalid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> count <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, <span style=color:#f92672>&amp;</span>groups[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got . after something weird: </span><span style=color:#e6db74>{prev}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got something weird: </span><span style=color:#e6db74>{curr}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dbg!(result);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        self.cache.insert(key, result);
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It could certainly be longer&mldr; and it&rsquo;s at least well documented?</p><p>The main thing to start with is the signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>check</span>(
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>    s: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u8</span>],       <span style=color:#75715e>// The remaining input string after current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    curr: <span style=color:#66d9ef>u8</span>,          <span style=color:#75715e>// The current character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    prev: <span style=color:#66d9ef>u8</span>,          <span style=color:#75715e>// The previous character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    groups: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u64</span>], <span style=color:#75715e>// The remaining groups to match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    count: <span style=color:#66d9ef>u64</span>,        <span style=color:#75715e>// The size of the current group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>) 
</span></span></code></pre></div><p>As mentioned, <code>s</code> is future input. <code>curr</code> is the current input&ndash;roughly <code>s[-1]</code> if that worked&ndash;and <code>prev</code> is the previous one&ndash;<code>s[-2]</code>&ndash;as we dealt with before. <code>groups</code> is the groups we haven&rsquo;t matched yet and <code>count</code> is the length of the current group.</p><p>So we end up with a whole bunch of cases:</p><ul><li>If we go from (<code>prev</code>) a damaged <code>.</code> section&mldr;<ul><li>to a operational <code>#</code> section: start counting a new group</li><li>to another damaged section: nothing changes (group count is 0)</li></ul></li><li>If we go from a operational section&mldr;<ul><li>to another operational section: increment the current group</li><li>to a damaged section: end the current group<ul><li>If it matches the next (first) value of <code>groups</code>: we&rsquo;re done with that group, move on</li><li>Otherwise, this solution is not possibly valid and we can bail out early!</li></ul></li></ul></li></ul><p>But there are also a bunch of extra cases:</p><ul><li>If we hit an unknown <code>?</code> section: try both. This changes <code>curr</code> but does <em>not</em> change <code>s</code> or anything else. This is actually the exact reason why we have <code>curr</code>: because we don&rsquo;t want to (and can&rsquo;t) mutate <code>s[0]</code></li><li>If we run out of groups: If the rest of the input has only <code>.</code> or <code>?</code> (which can be <code>.</code>), this is fine. Count it as a solution. But even one <code>#</code> and we&rsquo;re completely invalid.</li><li>If we run out of input, we still have to deal with the last <code>curr</code> character.</li></ul><p>It took a little while to finagle that all out, but when I did:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      1.196 s Â±  0.053 s    <span style=color:#f92672>[</span>User: 1.052 s, System: 0.046 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    1.160 s â€¦  1.337 s    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Oh, that&rsquo;s not bad at all! I think we can do a bit better though&mldr;</p><h3 id=a-choice-of-map>A choice of map</h3><p>You might have noticed that &mldr; I&rsquo;m not actually using <code>HashMap</code>. Instead, I&rsquo;m using <a href=https://docs.rs/fxhash/latest/fxhash/ target=_blank rel=noopener><code>fxhash::HashMap</code></a>. The built in hashing function in Rust is designed to be cryptographically secure, but that comes at a performance cost. Granted, it&rsquo;s still far faster in many cases than <em>not</em> using a map, but let&rsquo;s try the other options:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># BTreeMap</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:      1.460 s Â±  0.260 s    <span style=color:#f92672>[</span>User: 1.322 s, System: 0.037 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:    1.155 s â€¦  1.761 s    <span style=color:#ae81ff>10</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># fxhash::HashMap</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     607.8 ms Â±   5.6 ms    <span style=color:#f92672>[</span>User: 492.9 ms, System: 40.5 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   595.6 ms â€¦ 615.1 ms    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p><code>BTreeMap</code> works by sorting the data rather than hashing it, but often has <code>log(n)</code> runtimes rather than <code>n</code> that we want. <code>fxhash</code> instead uses a much faster hashing algorithm that doesn&rsquo;t worry about attacks. It&rsquo;s &mldr; pretty impressive. Roughly a 2x speedup and we&rsquo;re under a second!</p><h3 id=rewriting-it-with-types>Rewriting it with types</h3><p>Okay, we got it working&mldr; but it does bother me a bit that we&rsquo;re not using those types. We should be able to use <code>&[Condition]</code> instead of <code>&[u8]</code> without much problem, right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Key</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [Condition], Condition, Condition, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u64</span>], <span style=color:#66d9ef>u64</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Solver</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    cache: <span style=color:#a6e22e>FxHashMap</span><span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> Solver<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>FxHashMap</span>::default(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>check</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        s: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [Condition], <span style=color:#75715e>// The remaining input string after current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr: <span style=color:#a6e22e>Condition</span>,    <span style=color:#75715e>// The current character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        prev: <span style=color:#a6e22e>Condition</span>,    <span style=color:#75715e>// The previous character to check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        groups: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>u64</span>],  <span style=color:#75715e>// The remaining groups to match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        count: <span style=color:#66d9ef>u64</span>,         <span style=color:#75715e>// The size of the current group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Condition::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> (s, curr, prev, groups, count);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(value) <span style=color:#f92672>=</span> self.cache.get(<span style=color:#f92672>&amp;</span>key) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> groups.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Base case, we have no more groups to go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Everything else must not be #
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Operational <span style=color:#f92672>||</span> s.iter().any(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>c <span style=color:#f92672>==</span> Operational) {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// From here on out, we know groups is not empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Unknown {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is unknown, try both cases (without advancing s!)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> if_d <span style=color:#f92672>=</span> self.check(s, Damaged, prev, groups, count);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> if_o <span style=color:#f92672>=</span> self.check(s, Operational, prev, groups, count);
</span></span><span style=display:flex><span>                if_d <span style=color:#f92672>+</span> if_o
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> s.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// This block seems wrong, but I need it to have curr and prev work with ?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// We have no more input, check the last current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// We have at least one group at this point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Operational {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If the last current is operational, we need to match the last group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Damaged {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we came from operational check the last group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> count <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got something weird on empty input: </span><span style=color:#e6db74>{curr:?}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Operational {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is operational
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> Damaged {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After damaged, start a new group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> Operational {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After another operational, continue group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got # after something weird: </span><span style=color:#e6db74>{prev:?}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> curr <span style=color:#f92672>==</span> Damaged {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current is damaged
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> Damaged {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After another damaged, nothing happens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, groups, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>==</span> Operational {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// After operational, finish the current group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// If the size doesn&#39;t match, this branch is immediately invalid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> count <span style=color:#f92672>==</span> groups[<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>                        self.check(<span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], s[<span style=color:#ae81ff>0</span>], curr, <span style=color:#f92672>&amp;</span>groups[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got . after something weird: </span><span style=color:#e6db74>{prev:?}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;got something weird: </span><span style=color:#e6db74>{curr:?}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dbg!(result);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        self.cache.insert(key, result);
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// #[aoc_test(&#34;data/test/12.txt&#34;, &#34;21&#34;)]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// #[aoc_test(&#34;data/12.txt&#34;, &#34;7025&#34;)]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> Condition::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(stdin.lock())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (s, springs) <span style=color:#f92672>=</span> parse::springs(<span style=color:#f92672>&amp;</span>input).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(s.trim(), <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> springs
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>spring<span style=color:#f92672>|</span> Spring {
</span></span><span style=display:flex><span>            conditions: (spring
</span></span><span style=display:flex><span>                .conditions
</span></span><span style=display:flex><span>                .clone()
</span></span><span style=display:flex><span>                .into_iter()
</span></span><span style=display:flex><span>                .chain(std::iter::once(Unknown))
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>())
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .cycle()
</span></span><span style=display:flex><span>            .take(spring.conditions.len() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>            groups: <span style=color:#a6e22e>spring</span>
</span></span><span style=display:flex><span>                .groups
</span></span><span style=display:flex><span>                .clone()
</span></span><span style=display:flex><span>                .into_iter()
</span></span><span style=display:flex><span>                .cycle()
</span></span><span style=display:flex><span>                .take(spring.groups.len() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>spring<span style=color:#f92672>|</span> Solver::new().check(<span style=color:#f92672>&amp;</span>spring.conditions, Damaged, Damaged, <span style=color:#f92672>&amp;</span>spring.groups, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes actually.</p><p>And it&rsquo;s not that much longer code and (I could argue), it&rsquo;s a bit easier to read.</p><p>The new 5x codes are a bit weird. I orignally had <code>.into_iter().chain(...).cycle()</code>, but that actually doesn&rsquo;t do at all what you want, it cycles the chained iterator (many unknowns), not the whole thing. This the extra parens.</p><p>So&mldr; does it perform well?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> 2-typed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 2-typed&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> 2-typed
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     893.5 ms Â±   8.5 ms    <span style=color:#f92672>[</span>User: 764.8 ms, System: 51.5 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   878.1 ms â€¦ 909.4 ms    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>That&rsquo;s actually really close (and still under a second!).</p><p>I&rsquo;m curious what the difference is&mldr; but not enough to mess with it right now. Perhaps I&rsquo;ll come back to this later in the month. We shall see!</p><h2 id=performance>Performance</h2><p>We&rsquo;ve already seen these, but&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 1&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     120.3 ms Â±   5.2 ms    <span style=color:#f92672>[</span>User: 56.9 ms, System: 13.4 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   112.1 ms â€¦ 136.6 ms    <span style=color:#ae81ff>24</span> runs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just time <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hyperfine --warmup <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;just run 12 2&#39;</span>
</span></span><span style=display:flex><span>Benchmark 1: just run <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  Time <span style=color:#f92672>(</span>mean Â± Ïƒ<span style=color:#f92672>)</span>:     654.8 ms Â±   6.2 ms    <span style=color:#f92672>[</span>User: 531.8 ms, System: 51.0 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#f92672>(</span>min â€¦ max<span style=color:#f92672>)</span>:   648.3 ms â€¦ 667.6 ms    <span style=color:#ae81ff>10</span> runs
</span></span></code></pre></div><p>Not bad. Especially given the who knows how much longer we had it running for before.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>