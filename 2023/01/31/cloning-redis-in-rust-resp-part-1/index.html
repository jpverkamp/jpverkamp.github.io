<!doctype html><html><head><title>Cloning Redis in Rust: RESP [Part 1] â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js defer></script>
<script src=/custom.min.9bb1a6d1e0b58ced38df246e4479317e4561461cfabab31b36fbc36035186214.js defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css><link rel=stylesheet href=/custom.min.3bcba67844fc4a76aa7c1947a1fcf14cddaf8e9e0f1e734fde0fa219416f058d.css></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Cloning Redis in Rust: RESP [Part 1]</h1><div class=entry-meta><span class=entry-date>2023-01-31</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/01/17/proc-macro-workshop-derivebuilder-part-2/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/02/04/redis-in-rust-an-echo-server-part-2/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/21/aoc-2022-day-21-yellinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a></li><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/parsing>Parsing</a></li><li><a href=https://blog.jverkamp.com/2020/07/14/directly-monitoring-sidekiq-in-redis/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/redis>Redis</a><a href=https://blog.jverkamp.com/2023/02/04/redis-in-rust-an-echo-server-part-2/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/series/cloning-redis-in-rust>Cloning Redis in Rust</a><a href=https://blog.jverkamp.com/2023/02/04/redis-in-rust-an-echo-server-part-2/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/01/30/next/previous-space-in-hammerspoon/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/02/01/genuary-2023.01-perfect-loop/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/01/31/hawkeye-volume-2-little-hits/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/01/31/build-your-own-redis-with-c/c-/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Recently, I read through <a href=https://blog.jverkamp.com/2023/01/31/build-your-own-redis-with-c/c-/>Build Your Own Redis with C/C++</a>. C/C++ are ugly, so let&rsquo;s run through it in Rust!</p><p>My goal: implement some large subset of <a href=https://redis.io/>Redis</a> (both server and client) in Rust. For any features I implement, it should be compatible with Redis off the shelf. I should be able to use their client with my server and their server with my client and it should just work.</p><p>No idea if this is going to work out, but it sounds like an interesting problem!</p><p>First task: <a href=https://redis.io/docs/reference/protocol-spec/>the REdis Serialization Protocol (RESP)</a>.</p><nav id=TableOfContents><ul><li><a href=#the-struct-and-errors>The struct (and errors)</a></li><li><a href=#from-for-a-few-basic-types><code>From</code> for a few basic types</a></li><li><a href=#display-turning-structs-into-strings><code>Display</code>: Turning structs into strings</a></li><li><a href=#fromstr-turning-strings-into-structs><code>FromStr</code>: Turning strings into structs</a></li><li><a href=#tests-all-around>Tests all around</a></li><li><a href=#whats-next>What&rsquo;s next?</a></li></ul></nav><h2 id=the-struct-and-errors>The struct (and errors)</h2><p>First step, let&rsquo;s make a basic struct for what we&rsquo;ll be storing. There are 4 basic data types in the Redis protocol:</p><ul><li>Strings</li><li>Errors (really just strings under the hood)</li><li>Integers (signed, 64 bit)</li><li>Arrays (contain the other types, can be mixed and/or nested)</li></ul><p>On top of that, we actually have two different null types: <code>NullString</code> and <code>NullArray</code>. For historical reasons, Redis can return either of these for different functions, so we&rsquo;ll have to deal with them. In a nutshell, they are represented by a string/array with a negative length.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug, Eq, PartialEq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>RedisType</span> {
</span></span><span style=display:flex><span>    NullString,
</span></span><span style=display:flex><span>    NullArray,
</span></span><span style=display:flex><span>    String { value: String },
</span></span><span style=display:flex><span>    Error { value: String },
</span></span><span style=display:flex><span>    Integer { value: <span style=color:#66d9ef>i64</span> },
</span></span><span style=display:flex><span>    Array { value: Vec<span style=color:#f92672>&lt;</span>RedisType<span style=color:#f92672>&gt;</span> },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next up, we have a few different errors that can come up. Since I&rsquo;m experimenting with <code>Result</code> types, let&rsquo;s make an <code>Error</code> type to go with it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>RedisTypeParseError</span> {
</span></span><span style=display:flex><span>    MissingPrefix,
</span></span><span style=display:flex><span>    InvalidPrefix,
</span></span><span style=display:flex><span>    InvalidSuffix,
</span></span><span style=display:flex><span>    InvalidArrayLength,
</span></span><span style=display:flex><span>    LeftOverData,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=from-for-a-few-basic-types><code>From</code> for a few basic types</h2><p>Okay, now that we have that, we can just directly implement <code>From</code> for a few basic types, which will give us <code>Into</code> for &lsquo;free&rsquo;. Basically, if a type is already a string, i64, or array of the same, we can coerce it. I&rsquo;ll add <code>Option&lt;String></code> for those <code>NullString</code> types (to distinguish between <code>""</code> and <code>None</code>). Not sure if it&rsquo;s necessary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            Some(value) <span style=color:#f92672>=&gt;</span> RedisType::String {
</span></span><span style=display:flex><span>                value: <span style=color:#a6e22e>value</span>.to_owned(),
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> RedisType::NullString,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        RedisType::String {
</span></span><span style=display:flex><span>            value: <span style=color:#a6e22e>value</span>.to_owned(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>i64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        RedisType::Integer { value }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>RedisType<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: Vec<span style=color:#f92672>&lt;</span>RedisType<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        RedisType::Array { value }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=display-turning-structs-into-strings><code>Display</code>: Turning structs into strings</h2><p>Now we&rsquo;re getting into the meat of the algorithm. Basically, each of the <code>Redis</code> types starts with a single key character and ends with <code>\r\n</code>:</p><ul><li><code>+</code> - basic (non-binary) strings, cannot contain newlines or binary data</li><li><code>-</code> - errors, no newlines, the same as <code>+</code></li><li><code>:</code> - integers, represented as the digits in text (not directly as binary)</li></ul><p>Then we have the two &rsquo;length&rsquo; types:</p><ul><li><code>$</code> - represents a bulk string / binary data; the first line has the length of remaining data, then the data itself; example: <code>$11\r\nHello world\r\n</code> represents the string <code>Hello world</code> as a bulk string&ndash;&ldquo;11&rdquo; characters, a <code>\r\n</code>, then those 11 characters, then another <code>\r\n</code> (unnecessary, since we know the length; but there anyways)</li><li><code>*</code> - an array, encoded the same way; so the list <code>[1, 2, 3]</code> would be <code>*3\r\n:1\r\n:2\r\n:3\r\n</code>&ndash;array of 3 then each of the values</li></ul><p>There are also (as I mentioned) the two special cases:</p><ul><li><code>$-1\r\n</code> is a null bulk string (not an empty bulk string, that is <code>$0\r\n\r\n</code>&ndash;note the &rsquo;extra&rsquo; <code>\r\n</code> even with no actual items, or an empty simple string would be <code>+\r\n</code>)</li><li><code>*-1\r\n</code> is a null bulk array (empty array: <code>*0\r\n\r\n</code>)</li></ul><p>And that&rsquo;s it. So if we want to print those things out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Display <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;&#39;</span>_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> crlf <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;\r\n&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            RedisType::NullString <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;$-1{}&#34;</span>, crlf),
</span></span><span style=display:flex><span>            RedisType::NullArray <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;*-1{}&#34;</span>, crlf),
</span></span><span style=display:flex><span>            RedisType::String { value } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> value.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Empty strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    write!(f, <span style=color:#e6db74>&#34;$0{}{}&#34;</span>, crlf, crlf)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> value
</span></span><span style=display:flex><span>                    .chars()
</span></span><span style=display:flex><span>                    .any(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.is_control() <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\r&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Bulk strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: Are there any other interesting cases?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    write!(f, <span style=color:#e6db74>&#34;${}{}{}{}&#34;</span>, value.len(), crlf, value, crlf)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Simple strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    write!(f, <span style=color:#e6db74>&#34;+{}{}&#34;</span>, value, crlf)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            RedisType::Error { value } <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;-{}{}&#34;</span>, value, crlf),
</span></span><span style=display:flex><span>            RedisType::Integer { value } <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;:{}{}&#34;</span>, value, crlf),
</span></span><span style=display:flex><span>            RedisType::Array { value } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;*{}{}&#34;</span>, value.len(), crlf)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> el <span style=color:#66d9ef>in</span> value {
</span></span><span style=display:flex><span>                    write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, el)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Ok(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I think it&rsquo;s pretty straight forward. It&rsquo;s pretty cool that <code>Display</code> is the same as <code>to_string</code>. Makes sense really.</p><h2 id=fromstr-turning-strings-into-structs><code>FromStr</code>: Turning strings into structs</h2><p>Okay, now the other way around. We want to turn strings into structs. To do that for more of the types is pretty easy, just read a line (until <code>\r\n</code>). But unfortunately, arrays really mess with that.</p><p>To make those work, we need a very simple recursive descent parser. Basically, the <code>parse</code> inner function below that takes a string, parses one object and then returns what&rsquo;s left of the string + the resulting type. So when parsing an array, you can call this function and once you&rsquo;ve parsed enough, continue on where you where.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FromStr <span style=color:#66d9ef>for</span> RedisType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> Err <span style=color:#f92672>=</span> RedisTypeParseError;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_str</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Err<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>, RedisType), RedisTypeParseError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> s.as_bytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> s.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Err(RedisTypeParseError::MissingPrefix);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>s.contains(<span style=color:#e6db74>&#34;\r\n&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Err(RedisTypeParseError::InvalidSuffix);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> crlf <span style=color:#f92672>=</span> s.find(<span style=color:#e6db74>&#34;\r\n&#34;</span>).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> payload <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>crlf];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rest <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[crlf <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> bytes[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>char</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;+&#39;</span> <span style=color:#f92672>=&gt;</span> Ok((
</span></span><span style=display:flex><span>                    rest,
</span></span><span style=display:flex><span>                    RedisType::String {
</span></span><span style=display:flex><span>                        value: String::from(payload),
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                )),
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>=&gt;</span> Ok((
</span></span><span style=display:flex><span>                    rest,
</span></span><span style=display:flex><span>                    RedisType::Error {
</span></span><span style=display:flex><span>                        value: String::from(payload),
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                )),
</span></span><span style=display:flex><span>                <span style=color:#75715e>// TODO: Better error handling for failing to parse
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#e6db74>&#39;:&#39;</span> <span style=color:#f92672>=&gt;</span> Ok((
</span></span><span style=display:flex><span>                    rest,
</span></span><span style=display:flex><span>                    RedisType::Integer {
</span></span><span style=display:flex><span>                        value: String::from(payload).parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>().unwrap(),
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                )), 
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;*&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// TODO: Validate that array length parsed correctly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> String::from(payload).parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>().unwrap(); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Special case: bulk string with -1 length is actually a &#39;null&#39; array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// This is historical
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> len <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        Ok((rest, RedisType::NullArray))
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> value <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>len {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> (next, el) <span style=color:#f92672>=</span> parse(rest)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                            value.push(el);
</span></span><span style=display:flex><span>                            rest <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        Ok((rest, RedisType::Array { value }))
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;$&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> String::from(payload).parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>().unwrap(); <span style=color:#75715e>// TODO: Validate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Special case: bulk string with -1 length is actually a &#39;null&#39; value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// I&#39;m just treating any negative as this case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> len <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        Ok((rest, RedisType::NullString))
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> len <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> String::from(<span style=color:#f92672>&amp;</span>rest[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>len]);
</span></span><span style=display:flex><span>                        rest <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>rest[len <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        Ok((rest, RedisType::String { value }))
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> Err(RedisTypeParseError::InvalidPrefix),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> parse(s) {
</span></span><span style=display:flex><span>            Ok((rest, result)) <span style=color:#66d9ef>if</span> rest.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> Ok(result),
</span></span><span style=display:flex><span>            Ok(_) <span style=color:#f92672>=&gt;</span> Err(RedisTypeParseError::LeftOverData),
</span></span><span style=display:flex><span>            Err(e) <span style=color:#f92672>=&gt;</span> Err(e),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pretty cool I think. And it even handles extra data pretty well.</p><p>I don&rsquo;t think I&rsquo;m using errors quite right&mldr; but for the moment, it does work.</p><h2 id=tests-all-around>Tests all around</h2><p>So I started writing some tests. As one does.</p><p>And I realized that they were <em>super</em> repetitive.</p><p>And how do fix repetitive things in programming?</p><p>MACROS!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules! make_tests {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>tt</span>, <span style=color:#75715e>$string</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$redis</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        paste::item<span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span> test_ <span style=color:#75715e>$name</span> _from_str <span style=color:#f92672>&gt;</span>]() {
</span></span><span style=display:flex><span>                assert_eq!(RedisType::from_str(<span style=color:#75715e>$string</span>).unwrap(), <span style=color:#75715e>$redis</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span> test_ <span style=color:#75715e>$name</span> _to_string <span style=color:#f92672>&gt;</span>]() {
</span></span><span style=display:flex><span>                assert_eq!(<span style=color:#75715e>$redis</span>.to_string(), <span style=color:#75715e>$string</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span> test_ <span style=color:#75715e>$name</span> _inverse_to_from  <span style=color:#f92672>&gt;</span>]() {
</span></span><span style=display:flex><span>                assert_eq!(RedisType::from_str(<span style=color:#f92672>&amp;</span><span style=color:#75715e>$redis</span>.to_string()).unwrap(), <span style=color:#75715e>$redis</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span> test_ <span style=color:#75715e>$name</span> _inverse_from_to <span style=color:#f92672>&gt;</span>]() {
</span></span><span style=display:flex><span>                assert_eq!(RedisType::from_str(<span style=color:#75715e>$string</span>).unwrap().to_string(), <span style=color:#75715e>$string</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This uses the <a href=https://docs.rs/paste/1.0.11/paste/><code>paste</code> crate</a> to build identifiers for each of four test functions that we&rsquo;ll output:</p><ul><li>Using <code>from_str</code> to parse a string into a <code>RedisType</code></li><li>Using <code>to_string</code> / <code>Display</code> to go back to a string</li><li>Round tripping with <code>to_string</code> first</li><li>Round tripping the other way</li></ul><p>I absolutely did not need those last two, but ðŸ¤·</p><p>Actual test cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(null, <span style=color:#e6db74>&#34;$-1\r\n&#34;</span>, RedisType::NullString);
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(null_array, <span style=color:#e6db74>&#34;*-1\r\n&#34;</span>, RedisType::NullArray);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    simple_string,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;+Hello world\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::String {
</span></span><span style=display:flex><span>        value: <span style=color:#e6db74>&#34;Hello world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    empty_string,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;$0\r\n\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::String {
</span></span><span style=display:flex><span>        value: <span style=color:#e6db74>&#34;&#34;</span>.to_owned()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    bulk_string,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;$5\r\nYo\0\r\n\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::String {
</span></span><span style=display:flex><span>        value: <span style=color:#e6db74>&#34;Yo\0\r\n&#34;</span>.to_owned()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    err,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;-ERR Goodbye world\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Error {
</span></span><span style=display:flex><span>        value: <span style=color:#e6db74>&#34;ERR Goodbye world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    positive_integer,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;:42\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Integer { value: <span style=color:#ae81ff>42</span> }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    negative_integer,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;:-1337\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Integer { value: <span style=color:#f92672>-</span><span style=color:#ae81ff>1337</span> }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    array,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;*3\r\n+Hello world\r\n:42\r\n-ERR Goodbye world\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Array {
</span></span><span style=display:flex><span>        value: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>            RedisType::String {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;Hello world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            RedisType::Integer { value: <span style=color:#ae81ff>42</span> },
</span></span><span style=display:flex><span>            RedisType::Error {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;ERR Goodbye world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    null_in_array,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;*3\r\n$3\r\nYo\0\r\n$-1\r\n-ERR Goodbye world\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Array {
</span></span><span style=display:flex><span>        value: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>            RedisType::String {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;Yo\0&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            RedisType::NullString,
</span></span><span style=display:flex><span>            RedisType::Error {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;ERR Goodbye world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make_tests<span style=color:#f92672>!</span>(
</span></span><span style=display:flex><span>    nested_array,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;*4\r\n+Hello world\r\n:42\r\n-ERR Goodbye world\r\n*3\r\n+Hello world\r\n:42\r\n-ERR Goodbye world\r\n&#34;</span>,
</span></span><span style=display:flex><span>    RedisType::Array {
</span></span><span style=display:flex><span>        value: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>            RedisType::String {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;Hello world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            RedisType::Integer { value: <span style=color:#ae81ff>42</span> },
</span></span><span style=display:flex><span>            RedisType::Error {
</span></span><span style=display:flex><span>                value: <span style=color:#e6db74>&#34;ERR Goodbye world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            RedisType::Array {
</span></span><span style=display:flex><span>                value: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    RedisType::String {
</span></span><span style=display:flex><span>                        value: <span style=color:#e6db74>&#34;Hello world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    RedisType::Integer { value: <span style=color:#ae81ff>42</span> },
</span></span><span style=display:flex><span>                    RedisType::Error {
</span></span><span style=display:flex><span>                        value: <span style=color:#e6db74>&#34;ERR Goodbye world&#34;</span>.to_owned()
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                ]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>I think that&rsquo;s a pretty good list. We test each of the main types, both kinds of nulls, positive and negative integers, and both un-nested and nested arrays. I&rsquo;m sure I&rsquo;m missing some cases, but it&rsquo;s pretty good for now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.08s
</span></span><span style=display:flex><span>     Running unittests src/lib.rs <span style=color:#f92672>(</span>target/debug/deps/redis_rs-f3cfbacec8e60619<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>44</span> tests
</span></span><span style=display:flex><span>test tests::test_bulk_string_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_array_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_array_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_bulk_string_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_array_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_empty_string_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_bulk_string_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_bulk_string_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_array_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_empty_string_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_empty_string_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_empty_string_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_err_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_err_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_err_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_err_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_negative_integer_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_negative_integer_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_negative_integer_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_negative_integer_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_nested_array_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_nested_array_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_nested_array_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_null_array_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_null_array_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_null_array_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_null_array_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_null_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_null_in_array_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_nested_array_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_null_in_array_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_null_in_array_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_null_in_array_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_null_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_null_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_positive_integer_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_positive_integer_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_null_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_positive_integer_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_positive_integer_to_string ... ok
</span></span><span style=display:flex><span>test tests::test_simple_string_from_str ... ok
</span></span><span style=display:flex><span>test tests::test_simple_string_inverse_from_to ... ok
</span></span><span style=display:flex><span>test tests::test_simple_string_inverse_to_from ... ok
</span></span><span style=display:flex><span>test tests::test_simple_string_to_string ... ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>44</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/client.rs <span style=color:#f92672>(</span>target/debug/deps/client-a8942fb79fdb150b<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/server.rs <span style=color:#f92672>(</span>target/debug/deps/server-0d5859cce044e451<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   Doc-tests redis-rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span></code></pre></div><p>Yeah, okay. That&rsquo;s a lot</p><h2 id=whats-next>What&rsquo;s next?</h2><p>Well, that handles how clients and servers talk to one another&mldr; so I think next we should write a very simple server (we can talk to it with <a href=https://en.wikipedia.org/wiki/telnet>telnet</a> / <a href=https://en.wikipedia.org/wiki/netcat>netcat</a>). A simple hash map for just keys/values and maybe number of keys should be good.</p><p>Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>