<!doctype html><html><head><title>StackLang Part III: The Parser â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>StackLang Part III: The Parser</h1><div class=entry-meta><span class=entry-date>2023-04-24</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/assemblers>Assemblers</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/compilers>Compilers</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memory>Memory</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/stacks>Stacks</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/virtual-machines>Virtual Machines</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link></a><a class=taxonomy-value href=/series/stacklang>StackLang</a><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2023/04/24/ultimate-annuals-volume-1/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2023/04/24/good-omens-the-nice-and-accurate-prophecies-of-agnes-nutter-witch/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>StackLang, part 3: parsing. This is going to be the most complicated one thus far! Onward.</p><hr><p>Posts in this series:</p><div class=ranking><h3 class=title>Posts in <a href=/series/stacklang/>StackLang</a>:</h3><div class=content><ul><li><a href=https://blog.jverkamp.com/2023/08/12/stacklang-part-ix-better-testing/>StackLang Part IX: Better Testing</a></li><li><a href=https://blog.jverkamp.com/2023/08/11/stacklang-part-viii-compiler-stacks/>StackLang Part VIII: Compiler Stacks</a></li><li><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/>StackLang Part VII: New CLI and Datatypes</a></li><li><a href=https://blog.jverkamp.com/2023/07/16/stacklang-part-vi-some-examples/>StackLang Part VI: Some Examples</a></li><li><a href=https://blog.jverkamp.com/2023/07/12/stacklang-part-v-compiling-to-c/>StackLang Part V: Compiling to C</a></li><li><a href=https://blog.jverkamp.com/2023/05/01/stacklang-part-iv-an-interpreter/>StackLang Part IV: An Interpreter</a></li><li><a href=https://blog.jverkamp.com/2023/04/24/stacklang-part-iii-the-parser/>StackLang Part III: The Parser</a></li><li><a href=https://blog.jverkamp.com/2023/04/16/stacklang-part-ii-the-lexer/>StackLang Part II: The Lexer</a></li><li><a href=https://blog.jverkamp.com/2023/04/14/stacklang-part-i-the-idea/>StackLang Part I: The Idea</a></li></ul></div></div><p>This post:</p><nav id=TableOfContents><ul><li><a href=#types>Types</a><ul><li><a href=#expression---the-ast-itself><code>Expression</code> - the AST itself</a></li><li><a href=#value---values-on-the-stack--literals><code>Value</code> - values on the stack + literals</a></li><li><a href=#number---the-numeric-tower><code>Number</code> - the numeric tower</a></li><li><a href=#future-work-type-constructors--macros>Future work: type constructors / macros</a></li></ul></li><li><a href=#parsing>Parsing</a><ul><li><a href=#parse_until---for-blocks-of-code><code>parse_until</code> - for blocks of code</a></li><li><a href=#parse_one---for-single-expressions><code>parse_one</code> - for single expressions</a></li><li><a href=#starting-the-parser>Starting the parser</a></li></ul></li><li><a href=#testing>Testing</a></li><li><a href=#whats-next>What&rsquo;s next?</a></li></ul></nav><p>Full source code for StackLang: <a href=https://github.com/jpverkamp/stacklang/ target=_blank rel=noopener>github:jpverkamp/stacklang</a></p><h2 id=types>Types</h2><p>Okay, things are getting more interesting. Let&rsquo;s start where I generally do, with the types. In this case, I&rsquo;m going to split things to a few levels.</p><h3 id=expression---the-ast-itself><code>Expression</code> - the AST itself</h3><p>Starting at the top level, we have expressions. These are the actual AST and represent one level of the eventual parse tree:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// An expression is a single unit of a program, part of the AST
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Clone, Debug, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Expression</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// An identifier/variable, used to lookup a named value or global
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Identifier(String),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A literal value
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Literal(Value),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A function definition, generally delimited with {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Block(Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A list of values, generally delimited with []
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    List(Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A group of values, generally delimited with (), currently used only for clean code
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Group(Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// An @ prefixed expression, used to name values on the stack
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// If followed by [], an @list is multiple names
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    At(Box<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A ! prefixed expression, used to set values by name
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Bang(Box<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// A $ prefixed expression, used to pass to the stack (only really needed for blocks)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Dollar(Box<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s actually for the most part simpler than a lot of ASTs, since (like S-Expression based languages) we really don&rsquo;t have much complicated syntax. In this case, there are broadly three groups:</p><ul><li>Single tokens: literal values (like <code>42</code>, <code>"Hello world"</code>, etc; <a href=#values>we&rsquo;ll get there</a>) and identifiers (anything else)</li><li>Groups of subexpressions (these could probably have been one expression with a node that stores which type it is but I found this better since they work differently):<ul><li>Blocks, defined with <code>{}</code>, essentially function definitions, important since these will have their own arity</li><li>Lists, defined with <code>[]</code>, currently only used in list naming <code>@[a b c]</code></li><li>Groups, defined with <code>()</code>, implicitly used for the &lsquo;main&rsquo; block, but can be used to group code mostly for visual appeal, because of the stack nature, doesn&rsquo;t actually modify control flow or introduce scopes</li></ul></li><li>Prefixed expressions:<ul><li><code>@</code> expressions, for naming values; the expression should be a single identifier, a list of identifiers, or an integer (arity in), but that isn&rsquo;t a parse time check yet</li><li><code>!</code> expressions, for setting values by name or setting arity out; should be a single identifier or integer (arity)</li><li><code>$</code> expressions, for passing blocks as a parameter rather than applying them</li></ul></li></ul><p>One interesting bit is the implementation of <code>Display</code> for <code>Expression</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> write_children {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$f</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$prefix</span>:<span style=color:#a6e22e>literal</span> <span style=color:#75715e>$children</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$suffix</span>:<span style=color:#a6e22e>literal</span>) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>        s.push(<span style=color:#75715e>$prefix</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, child) <span style=color:#66d9ef>in</span> <span style=color:#75715e>$children</span>.iter().enumerate() {
</span></span><span style=display:flex><span>            s.push_str(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, child));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>!=</span> <span style=color:#75715e>$children</span>.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                s.push(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        s.push(<span style=color:#75715e>$suffix</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write!</span>(<span style=color:#75715e>$f</span>, <span style=color:#e6db74>&#34;{}&#34;</span>, s)
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Display <span style=color:#66d9ef>for</span> Expression {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Expression::Identifier(id) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;{}&#34;</span>, id),
</span></span><span style=display:flex><span>            Expression::Literal(value) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;{}&#34;</span>, value),
</span></span><span style=display:flex><span>            Expression::Block(children) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write_children!</span> {f <span style=color:#e6db74>&#39;{&#39;</span> children <span style=color:#e6db74>&#39;}&#39;</span>},
</span></span><span style=display:flex><span>            Expression::List(children) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write_children!</span> {f <span style=color:#e6db74>&#39;[&#39;</span> children <span style=color:#e6db74>&#39;]&#39;</span>},
</span></span><span style=display:flex><span>            Expression::Group(children) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write_children!</span> {f <span style=color:#e6db74>&#39;(&#39;</span> children <span style=color:#e6db74>&#39;)&#39;</span>},
</span></span><span style=display:flex><span>            Expression::At(expr) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;@{}&#34;</span>, expr),
</span></span><span style=display:flex><span>            Expression::Bang(expr) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;!{}&#34;</span>, expr),
</span></span><span style=display:flex><span>            Expression::Dollar(expr) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>write!</span>(f, <span style=color:#e6db74>&#34;${}&#34;</span>, expr),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It should be possible to round trip this: <code>Display</code>ed code should be readable. Mostly the goal is to display expressions without using up quite so much screen real estate. Don&rsquo;t have tests for that though.</p><h3 id=value---values-on-the-stack--literals><code>Value</code> - values on the stack + literals</h3><p>Okay, we have expressions, but we&rsquo;re missing <code>Value</code>. That&rsquo;s any <code>Value</code> that can actually be stored on the stack, but is also used for literals.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A value is a literal value that has been evaluated.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Clone, Debug, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(u8)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>    Number(Number),
</span></span><span style=display:flex><span>    String(String),
</span></span><span style=display:flex><span>    Boolean(<span style=color:#66d9ef>bool</span>),
</span></span><span style=display:flex><span>    Block {
</span></span><span style=display:flex><span>        arity_in: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        arity_out: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        expression: Box<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Display <span style=color:#66d9ef>for</span> Value {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> std::fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>std</span>::fmt::Result {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write!</span>(
</span></span><span style=display:flex><span>            f,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;{}&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>                Value::Number(v) <span style=color:#f92672>=&gt;</span> v.to_string(),
</span></span><span style=display:flex><span>                Value::String(v) <span style=color:#f92672>=&gt;</span> v.to_string().trim_matches(<span style=color:#e6db74>&#39;&#34;&#39;</span>).to_string(),
</span></span><span style=display:flex><span>                Value::Boolean(v) <span style=color:#f92672>=&gt;</span> v.to_string(),
</span></span><span style=display:flex><span>                Value::Block {
</span></span><span style=display:flex><span>                    arity_in,
</span></span><span style=display:flex><span>                    arity_out,
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                } <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>-&gt;</span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>&#34;</span>, arity_in, arity_out),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Numbers are further distinguished (<a href=#numbers>see below</a>). Otherwise, it&rsquo;s strings, booleans, or blocks. Blocks shouldn&rsquo;t show up in the parser, they&rsquo;re when Values are used as values on the stack, but they&rsquo;re defined here anyways.</p><h3 id=number---the-numeric-tower><code>Number</code> - the numeric tower</h3><p>The <a href=https://en.wikipedia.org/wiki/numeric%20tower>numeric tower</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// The numeric tower
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Copy, Clone, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Number</span> {
</span></span><span style=display:flex><span>    Integer(<span style=color:#66d9ef>i64</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Rational(i64, i64),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Float(<span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Complex(f64, f64),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>So&mldr; I haven&rsquo;t actually written <code>Rational</code> or <code>Complex</code> values yet! But I&rsquo;m getting there.</p><p>I do want to implement the various mathematical traits for numbers on these values though, so let&rsquo;s give that a try:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> do_op {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$trait</span>:<span style=color:#a6e22e>ty</span>, <span style=color:#75715e>$f</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$op</span>:<span style=color:#a6e22e>tt</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>impl</span> <span style=color:#75715e>$trait</span> <span style=color:#66d9ef>for</span> Number {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#75715e>$f</span>(self, rhs: <span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (a, b) <span style=color:#f92672>=</span> Number::coerce(self, rhs);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> (a, b) {
</span></span><span style=display:flex><span>                    (Number::Integer(av), Number::Integer(bv)) <span style=color:#f92672>=&gt;</span> Number::Integer(av <span style=color:#75715e>$op</span> bv),
</span></span><span style=display:flex><span>                    (Number::Float(av), Number::Float(bv)) <span style=color:#f92672>=&gt;</span> Number::Float(av <span style=color:#75715e>$op</span> bv),
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>unreachable!</span>(),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>do_op!</span>(Add, add, <span style=color:#f92672>+</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>do_op!</span>(Sub, sub, <span style=color:#f92672>-</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>do_op!</span>(Mul, mul, <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>do_op!</span>(Div, div, <span style=color:#f92672>/</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>do_op!</span>(Rem, rem, <span style=color:#f92672>%</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> PartialEq <span style=color:#66d9ef>for</span> Number {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>eq</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (a, b) <span style=color:#f92672>=</span> Number::coerce(<span style=color:#f92672>*</span>self, <span style=color:#f92672>*</span>other);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> (a, b) {
</span></span><span style=display:flex><span>            (Number::Integer(av), Number::Integer(bv)) <span style=color:#f92672>=&gt;</span> av <span style=color:#f92672>==</span> bv,
</span></span><span style=display:flex><span>            (Number::Float(av), Number::Float(bv)) <span style=color:#f92672>=&gt;</span> av <span style=color:#f92672>==</span> bv,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>unreachable!</span>(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Eq <span style=color:#66d9ef>for</span> Number {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> PartialOrd <span style=color:#66d9ef>for</span> Number {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>partial_cmp</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>) -&gt; Option<span style=color:#f92672>&lt;</span>std::cmp::Ordering<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (a, b) <span style=color:#f92672>=</span> Number::coerce(<span style=color:#f92672>*</span>self, <span style=color:#f92672>*</span>other);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> (a, b) {
</span></span><span style=display:flex><span>            (Number::Integer(av), Number::Integer(bv)) <span style=color:#f92672>=&gt;</span> av.partial_cmp(<span style=color:#f92672>&amp;</span>bv),
</span></span><span style=display:flex><span>            (Number::Float(av), Number::Float(bv)) <span style=color:#f92672>=&gt;</span> av.partial_cmp(<span style=color:#f92672>&amp;</span>bv),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>unreachable!</span>(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I don&rsquo;t know if this will actually work for <code>Rational</code> / <code>Complex</code>. We&rsquo;ll figure that out.</p><p>I think that what I&rsquo;m going to have to do is to create a new <code>Rational</code> struct and then implement <code>Number::Rational</code> as <code>Rational(Rational)</code> (or something less confusing). That way, I can implement <code>Add</code> etc manually on that type and everything else will just work (tm).</p><p>We&rsquo;ll see.</p><h3 id=future-work-type-constructors--macros>Future work: type constructors / macros</h3><p>One problem that I&rsquo;ve been running into a bit is code like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_integer</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> tokenize(<span style=color:#e6db74>&#34;123&#34;</span>.as_bytes());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> parse(input);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(
</span></span><span style=display:flex><span>        output,
</span></span><span style=display:flex><span>        Expression::Group(<span style=color:#a6e22e>vec!</span>[Expression::Literal(Value::Number(Number::Integer(
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>        )))])
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Having a <code>Group</code> of one <code>Literal</code>, which is a <code>Number</code>, specifically an <code>Integer</code> is&mldr; annoying. At the very least, being able to write <code>Literal::make_integer(123)</code> would be nice.</p><p>Or alternatively, with macros: <code>group!{integer!(123)}</code>.</p><p>Or perhaps a single macro: <code>expr!{ group(integer(123)) }</code>. But at that point, we&rsquo;re re-writing the parser. We&rsquo;ll see.</p><h2 id=parsing>Parsing</h2><p>Okay. That&rsquo;s fun, but a worthwhile framework. Now that we have that, I&rsquo;m going to have to start actually parsing things, probably with a <code>pub fn parse(tokens: Vec&lt;Token>) -> Expression</code> function. But to do that, I think that I want to split it into two helper functions:</p><ul><li><pre tabindex=0><code>fn parse_one(tokens: &amp;[Token]) -&gt; (Expression, &amp;[Token])
</code></pre><p>given a slice of <code>Token</code>, consume enough to parse one expression and return the remaining slice of <code>Token</code></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_until</span>(tokens: <span style=color:#66d9ef>&amp;</span>[Token], ending: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; (Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>[Token])
</span></span></code></pre></div><p>given a slice of <code>Token</code> and an <code>ending</code>, parse until we see the <code>ending</code> character; this is for parsing block etc expressions until you reach the <code>}</code> / <code>]</code> / <code>)</code></p><p><code>ending</code> is <code>Option</code> for the <code>main</code> block (that doesn&rsquo;t have a delimiter); in that case, parse until the end of the <code>Token</code> slice</p></li></ul><h3 id=parse_until---for-blocks-of-code><code>parse_until</code> - for blocks of code</h3><p>Since the latter is actually easier (and depends on <code>parse_one</code>), let&rsquo;s start with that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// A helper to parse a list of expressions until a given ending token
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If ending is not set, parse until end of stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_until</span>(tokens: <span style=color:#66d9ef>&amp;</span>[Token], ending: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; (Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>[Token]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> tokens <span style=color:#f92672>=</span> tokens;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> expressions <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>tokens.is_empty() <span style=color:#f92672>&amp;&amp;</span> Some(tokens[<span style=color:#ae81ff>0</span>].token.clone()) <span style=color:#f92672>!=</span> ending {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (expression, next_tokens) <span style=color:#f92672>=</span> parse_one(tokens);
</span></span><span style=display:flex><span>        expressions.push(expression);
</span></span><span style=display:flex><span>        tokens <span style=color:#f92672>=</span> next_tokens;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>tokens.is_empty() <span style=color:#f92672>&amp;&amp;</span> Some(tokens[<span style=color:#ae81ff>0</span>].token.clone()) <span style=color:#f92672>==</span> ending {
</span></span><span style=display:flex><span>        (expressions, <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        (expressions, tokens)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That really is it. For each token (until we hit the ending), <code>parse_one</code> and collect them. If we hit the ending (or end of slice), we&rsquo;re done.</p><p>Return the sub slice&ndash;this advances the tokens that we&rsquo;ve already consumed, so we can start from where we left off. This is something I really like about Rust. Slices are a window (+ reference) into a section of memory, so it&rsquo;s cheap to get a sub slice, rather than copying <code>Vec</code> around.</p><h3 id=parse_one---for-single-expressions><code>parse_one</code> - for single expressions</h3><p>This is the much more interesting one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// A helper to parse a single expression from the current position in the token stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_one</span>(tokens: <span style=color:#66d9ef>&amp;</span>[Token]) -&gt; (Expression, <span style=color:#f92672>&amp;</span>[Token]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;@&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// @ expressions prefix the next value (naming)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (next, tokens) <span style=color:#f92672>=</span> parse_one(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]);
</span></span><span style=display:flex><span>        (Expression::At(Box::new(next)), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;!&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ! expressions prefix the next value (assignment)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (next, tokens) <span style=color:#f92672>=</span> parse_one(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]);
</span></span><span style=display:flex><span>        (Expression::Bang(Box::new(next)), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;$&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// $ expressions allow pushing a block to the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (next, tokens) <span style=color:#f92672>=</span> parse_one(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]);
</span></span><span style=display:flex><span>        (Expression::Dollar(Box::new(next)), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;{&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// { expressions are blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (children, tokens) <span style=color:#f92672>=</span> parse_until(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], Some(String::from(<span style=color:#e6db74>&#34;}&#34;</span>)));
</span></span><span style=display:flex><span>        (Expression::Block(children), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;[&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [ expressions are lists
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (children, tokens) <span style=color:#f92672>=</span> parse_until(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], Some(String::from(<span style=color:#e6db74>&#34;]&#34;</span>)));
</span></span><span style=display:flex><span>        (Expression::List(children), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;(&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ( expressions are groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> (children, tokens) <span style=color:#f92672>=</span> parse_until(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], Some(String::from(<span style=color:#e6db74>&#34;)&#34;</span>)));
</span></span><span style=display:flex><span>        (Expression::Group(children), tokens)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to parse each literal value, if none match assume it&#39;s an identifier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(v) <span style=color:#f92672>=</span> tokens[<span style=color:#ae81ff>0</span>].token.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>().ok() {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                Expression::Literal(Value::Number(Number::Integer(v))),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(v) <span style=color:#f92672>=</span> tokens[<span style=color:#ae81ff>0</span>].token.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>().ok() {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                Expression::Literal(Value::Number(Number::Float(v))),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token.starts_with(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>) {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                Expression::Literal(Value::String(
</span></span><span style=display:flex><span>                    tokens[<span style=color:#ae81ff>0</span>].token.trim_matches(<span style=color:#e6db74>&#39;&#34;&#39;</span>).to_string(),
</span></span><span style=display:flex><span>                )),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>||</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;false&#34;</span> {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                Expression::Literal(Value::Boolean(tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;true&#34;</span>)),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                Expression::Identifier(tokens[<span style=color:#ae81ff>0</span>].token.clone()),
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A bit more complicated. Similar to the same breakdown of the <a href=#values><code>Value</code> struct</a>, we have three parts (albeit in reverse order): prefixed expressions, nested expressions, and literals.</p><p>For prefixed expressions, they&rsquo;re all the same:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;@&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// @ expressions prefix the next value (naming)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> (next, tokens) <span style=color:#f92672>=</span> parse_one(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]);
</span></span><span style=display:flex><span>    (Expression::At(Box::new(next)), tokens)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Take and consume the <code>@</code>, <code>parse_one</code> the expression it&rsquo;s prefixing, and return the new <code>Expression:At</code> plus the next <code>tokens</code> (from the subexpression).</p><p>For subexpressions, likewise, we&rsquo;re the same (and this is why we have <code>parse_until</code> as a separate function):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> tokens[<span style=color:#ae81ff>0</span>].token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;{&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// { expressions are blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> (children, tokens) <span style=color:#f92672>=</span> parse_until(<span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>], Some(String::from(<span style=color:#e6db74>&#34;}&#34;</span>)));
</span></span><span style=display:flex><span>    (Expression::Block(children), tokens)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>parse_until</code> the matching delimiter and return the new <code>Expression::Block</code> and the point in <code>tokens</code> after that.</p><p>And finally, literals. These are a bit more interesting, but another reason that I&rsquo;m really liking Rust. The <code>parse</code> function will try to parse the given token into whatever type we give it (using that type&rsquo;s <code>FromStr</code> trait). If it can, use <code>if let Some(v)</code> to unpack it and return. If not, fall through to the next case.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(v) <span style=color:#f92672>=</span> tokens[<span style=color:#ae81ff>0</span>].token.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>().ok() {
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        Expression::Literal(Value::Number(Number::Integer(v))),
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>tokens[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>],
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All without exceptions! I like it.</p><h3 id=starting-the-parser>Starting the parser</h3><p>And that&rsquo;s it. Now just tie it together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Parses a vector of tokens into a vector of expressions.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(tokens: Vec<span style=color:#f92672>&lt;</span>Token<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Expression</span> {
</span></span><span style=display:flex><span>    log::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;parse({:?})&#34;</span>, tokens);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A helper to parse a single expression from the current position in the token stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_one</span>(tokens: <span style=color:#66d9ef>&amp;</span>[Token]) -&gt; (Expression, <span style=color:#f92672>&amp;</span>[Token]) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A helper to parse a list of expressions until a given ending token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If ending is not set, parse until end of stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_until</span>(tokens: <span style=color:#66d9ef>&amp;</span>[Token], ending: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; (Vec<span style=color:#f92672>&lt;</span>Expression<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&amp;</span>[Token]) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Parse the entire stream
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: This should be an exception if the stream is not empty after this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Expression::Group(parse_until(tokens.as_slice(), None).<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=testing>Testing</h2><p>As before, I&rsquo;m actually writing some unit tests! Thank you Github Co-Pilot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> test {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::lexer::tokenize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::numbers::Number;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::parser::parse;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::types::{Expression, Value};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_integer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> tokenize(<span style=color:#e6db74>&#34;123&#34;</span>.as_bytes());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> parse(input);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>assert_eq!</span>(
</span></span><span style=display:flex><span>            output,
</span></span><span style=display:flex><span>            Expression::Group(<span style=color:#a6e22e>vec!</span>[Expression::Literal(Value::Number(Number::Integer(
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>            )))])
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_factorial</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> tokenize(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  @[n fact]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  { @0 n 1 - $fact fact n * }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  n 1 &lt; if
</span></span></span><span style=display:flex><span><span style=color:#e6db74>} @fact
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>5 $fact fact writeln&#34;</span>
</span></span><span style=display:flex><span>                .as_bytes(),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> parse(input);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>assert_eq!</span>(
</span></span><span style=display:flex><span>            output,
</span></span><span style=display:flex><span>            Expression::Group(<span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>                Expression::Block(<span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>                    Expression::At(Box::new(Expression::List(<span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;n&#34;</span>)),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)),
</span></span><span style=display:flex><span>                    ]))),
</span></span><span style=display:flex><span>                    Expression::Literal(Value::Number(Number::Integer(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>                    Expression::Block(<span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>                        Expression::At(Box::new(Expression::Literal(Value::Number(
</span></span><span style=display:flex><span>                            Number::Integer(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                        )),)),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;n&#34;</span>)),
</span></span><span style=display:flex><span>                        Expression::Literal(Value::Number(Number::Integer(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;-&#34;</span>)),
</span></span><span style=display:flex><span>                        Expression::Dollar(Box::new(Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)))),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;n&#34;</span>)),
</span></span><span style=display:flex><span>                        Expression::Identifier(String::from(<span style=color:#e6db74>&#34;*&#34;</span>)),
</span></span><span style=display:flex><span>                    ]),
</span></span><span style=display:flex><span>                    Expression::Identifier(String::from(<span style=color:#e6db74>&#34;n&#34;</span>)),
</span></span><span style=display:flex><span>                    Expression::Literal(Value::Number(Number::Integer(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>                    Expression::Identifier(String::from(<span style=color:#e6db74>&#34;&lt;&#34;</span>)),
</span></span><span style=display:flex><span>                    Expression::Identifier(String::from(<span style=color:#e6db74>&#34;if&#34;</span>)),
</span></span><span style=display:flex><span>                ]),
</span></span><span style=display:flex><span>                Expression::At(Box::new(Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)))),
</span></span><span style=display:flex><span>                Expression::Literal(Value::Number(Number::Integer(<span style=color:#ae81ff>5</span>))),
</span></span><span style=display:flex><span>                Expression::Dollar(Box::new(Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)))),
</span></span><span style=display:flex><span>                Expression::Identifier(String::from(<span style=color:#e6db74>&#34;fact&#34;</span>)),
</span></span><span style=display:flex><span>                Expression::Identifier(String::from(<span style=color:#e6db74>&#34;writeln&#34;</span>)),
</span></span><span style=display:flex><span>            ])
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Writing that by hand would be a <em>pain</em>. But Co-Pilot doesn&rsquo;t mind!</p><h2 id=whats-next>What&rsquo;s next?</h2><p>Onward!</p><p>Next up, I&rsquo;m planning to:</p><ul><li>Type checking:<ul><li>Automatically determine the <code>arity</code> of blocks when possible</li><li>Automatically determine specific types of expressions (including blocks)</li></ul></li><li>Numeric tower:<ul><li>Implement rationals/complex numbers at the parser level + in any interpreter / compiler I have at that point</li><li>Implement automatic numeric coercion&ndash;if you try to add an integer to a complex number, the result should be a complex number</li></ul></li><li>Interpreters:<ul><li>An AST-walking interpreter, directly evaluating the AST</li><li>A bytecode interpreter/compiler, evaluating at a lower level (I&rsquo;m not sure how much this would gain, the AST is already fairly low level)</li></ul></li><li>Compilers:<ul><li>Compile to C (and then pass to GCC/Clang) to compile that</li><li>Compile to WASM; since it&rsquo;s also stack based, this should be interesting</li><li>Compile to x86/ARM assembly</li></ul></li></ul></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>