<!doctype html><html><head><title>CodeCrafters: Build Myself a Grep â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>CodeCrafters: Build Myself a Grep</h1><div class=entry-meta><span class=entry-date>2024-08-28</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/grep>Grep</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/interpreters>Interpreters</a><a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/lexers>Lexers</a><a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/programming-languages>Programming Languages</a><a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/regex>Regex</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2017/12/04/aoc-2017-day-4-password-validator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/regular-expressions>Regular Expressions</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/series/codecrafters>CodeCrafters</a><a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/08/24/the-night-masquerade/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/09/01/the-sea-of-trolls/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>I recently stumbled across <a href=https://codecrafters.io/ target=_blank rel=noopener>CodeCrafters</a> again<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. In a nutshell, they give a number of &lsquo;Build Your Own&mldr;&rsquo; courses, each of which will automatically create a repo for you, guide you through solving the program step by step, and provide some feedback on the way.</p><p>On one hand, it&rsquo;s a freemium (one problem a month is free) / paid service. I wish they had tiers. I really think their monthly fee is a bit steep for what they offer (we&rsquo;ll come back to that). But on the other hand, it&rsquo;s a neat tool and I&rsquo;ve been wanting some more larger programming projects to learn more Rust on, so away we go!</p><p>First up, <a href=https://en.wikipedia.org/wiki/grep>grep</a>!</p><p>In a nutshell, the project on CodeCrafters (as of this writing), takes you through building a very basic regex (<a href=https://en.wikipedia.org/wiki/regular%20expression>regular expression</a>) engine, including:</p><ul><li>Literal characters: <code>abc</code></li><li>Character classes: <code>\d</code> and <code>\w</code></li><li>Character groups: <code>[abc]</code> and negative groups: <code>^[abc]</code></li><li>Basic anchors: <code>^</code> and <code>$</code></li><li>Repeated matches: <code>+</code> and <code>?</code></li><li>Wildcards: <code>.</code></li><li>Alternatives: <code>|</code></li></ul><p>There&rsquo;s also currently one advanced module: backreferences. This includes single, multiple, and nested backreferences.</p><p>It&rsquo;s a pretty interesting (if not at all complete) selection. Here&rsquo;s what I ended up with as a solution for the first parts: <a href=https://github.com/jpverkamp/jp-grep target=_blank rel=noopener>jp-grep</a>. I&rsquo;m just going to go through the most recent version of the code, but you can go through the repo <a href=https://github.com/jpverkamp/jp-grep/commits/main/ target=_blank rel=noopener>history</a> to see it at previous points.</p><nav id=TableOfContents><ul><li><a href=#representing-a-regex>Representing a regex</a></li><li><a href=#parsing-a-regex>Parsing a regex</a></li><li><a href=#matching-a-string>Matching a string</a><ul><li><a href=#match_recur><code>match_recur</code></a></li><li><a href=#returning-multiple-options>Returning multiple options</a></li><li><a href=#backreferences>Backreferences</a></li></ul></li><li><a href=#optimization-memoization>Optimization: Memoization</a></li><li><a href=#future-work-returning-groups>Future work: Returning groups</a></li><li><a href=#other-future-work>Other future work</a><ul><li><a href=#regex-features>regex features</a></li><li><a href=#grep-features>grep features</a></li><li><a href=#performance>Performance</a></li></ul></li><li><a href=#summary-and-thoughts-on-codecrafters>Summary and thoughts on CodeCrafters</a></li></ul></nav><h2 id=representing-a-regex>Representing a regex</h2><p>First, a data structure that represents a regex:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Regex</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Single characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Char(CharType),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A sequence of regexes that each must match in order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Sequence(Vec<span style=color:#f92672>&lt;</span>Regex<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A character group, may be negated
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// True if inverted, (eg [^abc])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CharacterGroup(Vec<span style=color:#f92672>&lt;</span>CharType<span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>bool</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A capturing group used for backreferences
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CapturingGroup(Box<span style=color:#f92672>&lt;</span>Regex<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Backref(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Repeat a pattern (e.g. +, *, ?)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Repeated(RepeatType, Box<span style=color:#f92672>&lt;</span>Regex<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Anchors for teh start and end of a line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Start,
</span></span><span style=display:flex><span>    End,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Used for parsing |, will be expanded into a Choice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Choice(Vec<span style=color:#f92672>&lt;</span>Regex<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    ChoicePlaceholder,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CharType</span> {
</span></span><span style=display:flex><span>    Any,
</span></span><span style=display:flex><span>    Single(<span style=color:#66d9ef>char</span>),
</span></span><span style=display:flex><span>    Range(<span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>char</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>RepeatType</span> {
</span></span><span style=display:flex><span>    OneOrMore,
</span></span><span style=display:flex><span>    ZeroOrMore,
</span></span><span style=display:flex><span>    ZeroOrOne,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This handles all of the cases above, each as mentioned in comments for that group. A few more that might be less clear:</p><ul><li><code>CharacterGroup</code> includes <code>\d</code> and <code>\w</code>, since those are just multiple <code>CharType::Ranges</code>.</li><li>Alternatives, I called <code>Choice</code>; the <code>ChoicePlaceholder</code> is used for parsing and should no longer exist when evaluating (I could probably have done this as an <code>Option</code> instead, but this works)</li></ul><p>It is a recursive type, since a <code>CapturingGroup</code>, <code>Repeated</code>, or <code>Choice</code> can contain more <code>Regex</code>. In the first two cases, we just <code>Box</code> that, to make sure that the structure isn&rsquo;t infinitely large (because of recursion), but for the last, <code>Vec</code> does the same.</p><h2 id=parsing-a-regex>Parsing a regex</h2><p>Okay, we have the regex, how do we turn a string like <code>"(([abc]+)-([def]+)) is \1, not ([^xyz]+), \2, or \3"</code> into a regex like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Sequence([
</span></span><span style=display:flex><span>    CapturingGroup(
</span></span><span style=display:flex><span>        Sequence([
</span></span><span style=display:flex><span>            CapturingGroup(Sequence([
</span></span><span style=display:flex><span>                Repeated(OneOrMore, CharacterGroup([
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;a&#39;</span>),
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;b&#39;</span>),
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;c&#39;</span>)
</span></span><span style=display:flex><span>                ], <span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>            ])),
</span></span><span style=display:flex><span>            Char(Single(<span style=color:#e6db74>&#39;-&#39;</span>)),
</span></span><span style=display:flex><span>            CapturingGroup(Sequence([
</span></span><span style=display:flex><span>                Repeated(OneOrMore, CharacterGroup([
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;d&#39;</span>),
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;e&#39;</span>),
</span></span><span style=display:flex><span>                    Single(<span style=color:#e6db74>&#39;f&#39;</span>)
</span></span><span style=display:flex><span>                ], <span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>            ]))
</span></span><span style=display:flex><span>        ])),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;i&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;s&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        Backref(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;,&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;n&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;o&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;t&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        CapturingGroup(Sequence([
</span></span><span style=display:flex><span>            Repeated(OneOrMore, CharacterGroup([
</span></span><span style=display:flex><span>                Single(<span style=color:#e6db74>&#39;x&#39;</span>),
</span></span><span style=display:flex><span>                Single(<span style=color:#e6db74>&#39;y&#39;</span>),
</span></span><span style=display:flex><span>                Single(<span style=color:#e6db74>&#39;z&#39;</span>)
</span></span><span style=display:flex><span>            ], <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        ])),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;,&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        Backref(<span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;,&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;o&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39;r&#39;</span>)),
</span></span><span style=display:flex><span>        Char(Single(<span style=color:#e6db74>&#39; &#39;</span>)), 
</span></span><span style=display:flex><span>        Backref(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><p>Yeah, I know that&rsquo;s a lot. So&mldr; how do we do it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Regex {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read until the &#39;until&#39; char, or end of string if None
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_until</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>char</span>], until: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>) -&gt; (Regex, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>char</span>]) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sequence <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> input;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Read until end of input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#f92672>&amp;</span>c) <span style=color:#f92672>=</span> input.first() {
</span></span><span style=display:flex><span>                input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Break if we have and hit the until character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> until <span style=color:#f92672>==</span> Some(c) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Predefined character groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;\\&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> group <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> input.first() {
</span></span><span style=display:flex><span>                            Some(<span style=color:#e6db74>&#39;d&#39;</span>) <span style=color:#f92672>=&gt;</span> Regex::Char(CharType::Range(<span style=color:#e6db74>&#39;0&#39;</span>, <span style=color:#e6db74>&#39;9&#39;</span>)),
</span></span><span style=display:flex><span>                            Some(<span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#f92672>=&gt;</span> Regex::Choice(vec![
</span></span><span style=display:flex><span>                                Regex::Char(CharType::Range(<span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;z&#39;</span>)),
</span></span><span style=display:flex><span>                                Regex::Char(CharType::Range(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;Z&#39;</span>)),
</span></span><span style=display:flex><span>                                Regex::Char(CharType::Range(<span style=color:#e6db74>&#39;0&#39;</span>, <span style=color:#e6db74>&#39;9&#39;</span>)),
</span></span><span style=display:flex><span>                                Regex::Char(CharType::Single(<span style=color:#e6db74>&#39;_&#39;</span>)),
</span></span><span style=display:flex><span>                            ]),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Backreference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            Some(<span style=color:#f92672>&amp;</span>c) <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                                Regex::Backref(index)
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Escaped control characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            Some(<span style=color:#f92672>&amp;</span>c) <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>()[]|&#34;</span>.contains(c) <span style=color:#f92672>=&gt;</span> Regex::Char(CharType::Single(c)),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// A group we don&#39;t know about
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            _ <span style=color:#f92672>=&gt;</span> unimplemented!()
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>                        group
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Custom defined character groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: Implement ranges
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: Implement escaping in character groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;[&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Handle negation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> negated <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#e6db74>&#39;^&#39;</span>) <span style=color:#f92672>=</span> input.first() {
</span></span><span style=display:flex><span>                            input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> choices <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#f92672>&amp;</span>c) <span style=color:#f92672>=</span> input.first() {
</span></span><span style=display:flex><span>                            input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;]&#39;</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            choices.push(CharType::Single(c));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        Regex::CharacterGroup(choices, negated)
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Capture groups
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;(&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> (group, remaining) <span style=color:#f92672>=</span> read_until(input, Some(<span style=color:#e6db74>&#39;)&#39;</span>));
</span></span><span style=display:flex><span>                        input <span style=color:#f92672>=</span> remaining;
</span></span><span style=display:flex><span>                        Regex::CapturingGroup(Box::new(group))
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;)&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// This should have been consumed by the parent group
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        unreachable!(<span style=color:#e6db74>&#34;Unmatched &#39;)&#39;&#34;</span>);
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Anchors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;^&#39;</span> <span style=color:#f92672>=&gt;</span> Regex::Start,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;$&#39;</span> <span style=color:#f92672>=&gt;</span> Regex::End,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Hit the any key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>=&gt;</span> Regex::Char(CharType::Any),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// An alternate choice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// This will insert a placeholder we will deal with later
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#e6db74>&#39;|&#39;</span> <span style=color:#f92672>=&gt;</span> Regex::ChoicePlaceholder,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Single characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    c <span style=color:#f92672>=&gt;</span> Regex::Char(CharType::Single(c)),
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Check for modifiers (+*)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> input.first() {
</span></span><span style=display:flex><span>                    Some(<span style=color:#e6db74>&#39;+&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>                        Regex::Repeated(RepeatType::OneOrMore, Box::new(node))
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    Some(<span style=color:#e6db74>&#39;*&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>                        Regex::Repeated(RepeatType::ZeroOrMore, Box::new(node))
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    Some(<span style=color:#e6db74>&#39;?&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>                        Regex::Repeated(RepeatType::ZeroOrOne, Box::new(node))
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> node,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                sequence.push(node);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we have any choice placeholders, we need to split the sequence into choices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> sequence.contains(<span style=color:#f92672>&amp;</span>Regex::ChoicePlaceholder) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> choices <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> current_choice <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> sequence {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> node <span style=color:#f92672>==</span> Regex::ChoicePlaceholder {
</span></span><span style=display:flex><span>                        choices.push(Regex::Sequence(current_choice));
</span></span><span style=display:flex><span>                        current_choice <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        current_choice.push(node);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                choices.push(Regex::Sequence(current_choice));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (Regex::Choice(choices), input);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            (Regex::Sequence(sequence), input)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> value.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (result, remaining_chars) <span style=color:#f92672>=</span> read_until(<span style=color:#f92672>&amp;</span>chars, None);
</span></span><span style=display:flex><span>        assert_eq!(remaining_chars.len(), <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Remaining input: {:?}&#34;</span>, remaining_chars);
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That should probably be <code>From&lt;&amp;str></code>. But otherwise, we parse it recursively. Most of the work is <code>read_until</code> that (as it says) reads until it sees either a specific character (<code>Some(c)</code>) or the end of the strong (<code>None</code>) and returns a <code>Sequence</code>.</p><p>If we see a <code>\</code>, check for character groups. If we see <code>[</code>, parse a custom character group. If we see a <code>(</code>, parse until the matching <code>)</code> (recursion comes for free!). And if we see <code>|</code>, remember this as a <code>ChoicePlaceholder</code>.</p><p>Then, at the end, if we ever saw a <code>ChoicePlaceholder</code> in this <code>sequence</code>, turn it into a <code>Choice</code> element.</p><p>Tada!</p><h2 id=matching-a-string>Matching a string</h2><p>Okay, this is by far the more interesting part.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Regex {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>matches</span>(<span style=color:#f92672>&amp;</span>self, input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> input.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Pattern can apply at any starting point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>chars.len() {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;matches({:?}) against {:?}, start={}&#34;</span>, chars[i<span style=color:#f92672>..</span>].iter().collect::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>(), <span style=color:#f92672>&amp;</span>self, i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> groups <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> results <span style=color:#f92672>=</span> self.match_recur(<span style=color:#f92672>&amp;</span>chars[i<span style=color:#f92672>..</span>], i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> groups);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>results.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As noted, the pattern could match anywhere in the string (without anchors), so for each possible starting point, we&rsquo;re going to call our helper <code>match_recur</code> function. We do have a flag as well, that will signify if we&rsquo;re at start of string for anchors.</p><p>This is not very efficient if you have an anchor (since it will still try every other anchor point), but not as bad as you might think. Because it will always match and immediately fail on the <code>^</code> / <code>Regex::Start</code>, each point after the first will fail fast. So it just works.</p><p>The other interesting part is that we create a <code>groups: Vec&lt;char></code> for each match. This is entirely to match backreferences. When we match a backreference in the string, we&rsquo;ll record it in the <code>groups</code> as a <code>Vec&lt;char></code>, that way we can directly match against it.</p><p>This could also be used to <a href=#future-work-returning-groups>directly implement returning the matched groups</a>, but that wasn&rsquo;t part of the exercise just yet!</p><h3 id=match_recur><code>match_recur</code></h3><p>So what about <code>match_recur</code>? This one is quite a bit more!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>match_recur</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>self,
</span></span><span style=display:flex><span>    input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>char</span>],
</span></span><span style=display:flex><span>    at_start: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    groups: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>char</span>]<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>) -&gt; Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> [<span style=color:#66d9ef>char</span>]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    log::debug!(<span style=color:#e6db74>&#34;match_recur({self:?}, {}, {at_start})&#34;</span>, input.iter().collect::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> input.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.allow_none() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![input];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Hit the any key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Char(CharType::Any) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]];
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Single character matches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Char(CharType::Single(c)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>c {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        Regex::Char(CharType::Range(start, end)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>*</span>start <span style=color:#f92672>&amp;&amp;</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>*</span>end {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Character groups, match any of the characters (or none if negated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::CharacterGroup(chars, negated) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> matched <span style=color:#f92672>=</span> chars.iter().any(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                    CharType::Single(c) <span style=color:#f92672>=&gt;</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>c,
</span></span><span style=display:flex><span>                    CharType::Range(start, end) <span style=color:#f92672>=&gt;</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>*</span>start <span style=color:#f92672>&amp;&amp;</span> input[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>*</span>end,
</span></span><span style=display:flex><span>                    CharType::Any <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> negated <span style=color:#f92672>^</span> matched {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>&amp;</span>input[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Anchors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Start <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> at_start {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![input];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        Regex::End <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![input];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Multi-match modifiers (?+*)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// NOTE: These should match the longest group they can and still work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Repeated(mode, node) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> mode {
</span></span><span style=display:flex><span>                RepeatType::ZeroOrMore <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Return all possible matches at this level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Base case: match nothing and return input as is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results <span style=color:#f92672>=</span> vec![input];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remaining <span style=color:#f92672>=</span> input;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> recur <span style=color:#f92672>=</span> node.match_recur(remaining, at_start, groups);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> recur.is_empty() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> new_remaining <span style=color:#66d9ef>in</span> recur {
</span></span><span style=display:flex><span>                            results.push(new_remaining);
</span></span><span style=display:flex><span>                            remaining <span style=color:#f92672>=</span> new_remaining;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    results.reverse();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> results;
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                RepeatType::OneOrMore <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Return all possible matches at this level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// No base case: must match at least once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remaining <span style=color:#f92672>=</span> input;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> recur <span style=color:#f92672>=</span> node.match_recur(remaining, at_start, groups);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> recur.is_empty() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> new_remaining <span style=color:#66d9ef>in</span> recur {
</span></span><span style=display:flex><span>                            results.push(new_remaining);
</span></span><span style=display:flex><span>                            remaining <span style=color:#f92672>=</span> new_remaining;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    results.reverse();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> results;
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                RepeatType::ZeroOrOne <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If zero match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results <span style=color:#f92672>=</span> vec![input];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If one match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> recur <span style=color:#f92672>=</span> node.match_recur(input, at_start, groups);
</span></span><span style=display:flex><span>                    results.append(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> recur);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    results.reverse();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> results;
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// A sequence of matches, all of which must match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If any fails, abort the entire sequence and advance to try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Sequence(seq) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Keep a list of the possible branching values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// TODO: This is hugely memory intensive :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remainings <span style=color:#f92672>=</span> vec![input];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> seq_at_start <span style=color:#f92672>=</span> at_start;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> seq {
</span></span><span style=display:flex><span>                remainings <span style=color:#f92672>=</span> remainings.into_iter().flat_map(<span style=color:#f92672>|</span>input<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    node.match_recur(input, seq_at_start, groups)
</span></span><span style=display:flex><span>                }).collect();
</span></span><span style=display:flex><span>                seq_at_start <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> remainings;
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// A choice of matches, any of which much match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If none match, abort the entire choice and advance to try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Choice(seq) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> seq {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> recur <span style=color:#f92672>=</span> node.match_recur(input, at_start, groups);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>recur.is_empty() {
</span></span><span style=display:flex><span>                    results.append(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> recur);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> results;
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Capturing groups wrap another node and then store what was captured
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::CapturingGroup(node) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Add a placeholder to get order correct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> groups.len();
</span></span><span style=display:flex><span>            groups.push(None);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> recur <span style=color:#f92672>=</span> node.match_recur(input, at_start, groups);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> recur.is_empty() {
</span></span><span style=display:flex><span>                groups.remove(index);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                groups[index] <span style=color:#f92672>=</span> Some(<span style=color:#f92672>&amp;</span>input[<span style=color:#f92672>..</span>(input.len() <span style=color:#f92672>-</span> recur[<span style=color:#ae81ff>0</span>].len())]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> recur;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Backreferences
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::Backref(index) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 1-indexed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we haven&#39;t captured that group, this is a problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> groups.len() <span style=color:#f92672>&lt;=</span> index <span style=color:#f92672>||</span> groups[index].is_none() {
</span></span><span style=display:flex><span>                unimplemented!(<span style=color:#e6db74>&#34;Backreference to group </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> that hasn&#39;t been captured&#34;</span>, index);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> captured <span style=color:#f92672>=</span> groups[index].unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.starts_with(captured) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>&amp;</span>input[captured.len()<span style=color:#f92672>..</span>]];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vec![];
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This should have been expanded by the time we get here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Regex::ChoicePlaceholder <span style=color:#f92672>=&gt;</span> unreachable!(<span style=color:#e6db74>&#34;ChoicePlaceholder should have been expanded&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For the most part, it&rsquo;s just a matter of applying the given patternr(whatever type that is) to the given index in the <code>&[char]</code> and returning where we got to, mostly as <code>vec![...one thing...]</code> (see <a href=#returning-multiple-options>here</a> for the case where we return more than one).</p><p>That&rsquo;s&mldr; pretty cool IMO.</p><h3 id=returning-multiple-options>Returning multiple options</h3><p>Okay, first up. Why does it return <code>Vec&lt;&'[char]></code>?</p><p>Originally, I just returned <code>Option&lt;&'[char]></code>, which was either <code>None</code> if we didn&rsquo;t have a match or <code>&'[char]</code> which was a pointer to where in the <code>[char]</code> we have advanced to (and where any future matches would start).</p><p>But as soon as we got to <code>+</code> and <code>?</code>, that got a lot more complicated. For each match in those cases (above), we need to match as greedily as possible. So if we have <code>a+ab</code> against <code>"aaaab"</code>, we want to match <code>"aaa"</code> for <code>a+</code>, not just a single <code>a</code> (or two). But conversely, the greedy match might not work. In this case, the greediest match would be <code>"aaaa"</code>, but that doesn&rsquo;t leave another <code>a</code> for the <code>ab</code>.</p><p>So <code>Vec&lt;&'[char]></code>? All of the possible next matches (where they will next match from) at a given position, from most to least greedy! (<code>results.reverse();</code>)</p><p>So when we match a <code>Sequence</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> seq {
</span></span><span style=display:flex><span>    remainings <span style=color:#f92672>=</span> remainings.into_iter().flat_map(<span style=color:#f92672>|</span>input<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        node.match_recur(input, seq_at_start, groups)
</span></span><span style=display:flex><span>    }).collect();
</span></span><span style=display:flex><span>    seq_at_start <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will take each current match (<code>remainings</code>) and apply it to the input recursively, getting one or more results in turn. If that branch isn&rsquo;t possible, return <code>vec![]</code>, so the <code>flat_map</code> will remove those as possible matches.</p><p>It ends up calculating <em>every</em> match at a specific point. We could probably return an <code>impl Iterator&lt;&'[char]></code> that lazily returns the next possibility, but that&rsquo;s <a href=#optimization-memoization>future work</a>!</p><h3 id=backreferences>Backreferences</h3><p>The other interesting implementation is how I did capturing groups and backreferences. That&rsquo;s why we&rsquo;re passing the <code>groups: &amp;mut Vec&lt;Option&lt;&'a [char]>></code> around. At each index, it will contain the substring (subchars?) that the capturing group actually matched.</p><p>Why <code>Option</code>? That&rsquo;s to deal with ordering. If you have something like <code>((a)(b))</code>, the <code>ab</code> should be <code>\1</code>, but <code>a</code> will be the first group matched. So instead, I <code>push(None)</code> when the group is created and update that to <code>Some(...)</code> when the match is completed.</p><p>Then, when you get a <code>Backreference</code>, we match the literal string stored in <code>groups</code> and we&rsquo;re good to go!</p><h2 id=optimization-memoization>Optimization: Memoization</h2><p>So, what can we do better?</p><p>One problem that we&rsquo;re seeing is that it&rsquo;s possible that we&rsquo;ll match the same subset of the string a couple different ways. For example, if we have <code>(a+)(a+)b</code> against <code>"aaaab"</code>, we could theoretically match <code>"a" / "aaa"</code>, <code>"aa" / "aa"</code>, or <code>"aaa" / "a"</code> and all will be matching <code>b</code> against <code>"b"</code>.</p><p>This is perhaps a silly example, but as matches and/or input get far far larger, this is exactly the sort of issue that will cause a regex denial of service sort of attack.</p><p>But there&rsquo;s hope! It&rsquo;s also exactly the sort of thing <a href=https://en.wikipedia.org/wiki/memoization>memoization</a> solves! If you get exactly the same arguments, return the same answer. The <code>groups</code> is a problem here, but perhaps not an insurmountable one. Worth trying! Perhaps as an optional flag?</p><h2 id=future-work-returning-groups>Future work: Returning groups</h2><p>Another group, as mentioned is returning the actual matches from <code>matches</code>. This is actually really easy! We just have to insert a <code>\0</code> element that matches the entire thing and then change <code>matches(...) -> bool</code> to <code>Vec&lt;String></code>! We&rsquo;ll get there.</p><h2 id=other-future-work>Other future work</h2><h3 id=regex-features>regex features</h3><p>There are a number of things in regexes that I don&rsquo;t support yet:</p><ul><li>ranges in groups - this is mostly a parsing problem</li><li>negated groups - such as <code>\D</code> for &rsquo;not a digit&rsquo;, again mostly a parsing problem</li><li>more classes - whitespace</li><li>escape characters - tabs, carriage returns, etc</li><li>unicode character class escapes - we already support unicode, but escapes would be handy</li><li>more anchors - <code>\b</code> for boundaries</li><li>lookahead/lookbehind - match but don&rsquo;t consume the text, shouldn&rsquo;t be hard?</li><li>named capture groups / named backreferences - mostly a syntax thing + a <code>HashMap</code> instead of <code>Vec</code></li><li>non-capturing groups - just a flag</li><li>flags - <code>(?ims:...)</code> - will probably need a new parameter for the <code>match_recur</code> function to track which flags are on</li><li>exactly <code>n</code> repeats - <code>*</code>, <code>+</code>, and <code>?</code> are really just subcases of this</li><li>non-greedy matches - <code>x+?</code>, this will just (not) reverse the order of the match</li></ul><p>But&mldr; I don&rsquo;t think any of those are insurmountable. It&rsquo;s not part of the CodeCrafters tests (yet), but still I think worth doing.</p><h3 id=grep-features>grep features</h3><p>In addition, we currently only support the <code>-E</code> flag to <code>grep</code>. There are &mldr; a whole bunch more that are probably worth supporting! In particular:</p><ul><li><code>-A</code> / <code>-B</code> - print the context before/after matches</li><li>multiple patterns + <code>--exclude</code> - match several patterns both positive and negative</li><li>handling directories, <code>-R</code> etc</li></ul><p>Not actually that much, but it would be fun to have an alternative.</p><h3 id=performance>Performance</h3><p>Finally, it would be interesting to test against some really complicated expressions / large files. The current solution (as mentioned <a href=#returning-multiple-options>here</a>) returns every possible solution as it&rsquo;s working, eating up a potentially crazy amount of RAM and calculating a bunch of cases we don&rsquo;t need. It would be nice not to do that.</p><p>Furthermore, we could do the theoretical computer science and turn this into a <a href=https://en.wikipedia.org/wiki/non-deterministic%20finite%20automata>non-deterministic finite automata</a>. Performant? Not sure. But interesting.</p><h2 id=summary-and-thoughts-on-codecrafters>Summary and thoughts on CodeCrafters</h2><p>Overall, it was an interesting problem and I think that the CodeCrafters interface is well done. You push to a git repo and it runs a bunch of test cases against it, showing you what failed.</p><p>Conversely, it&rsquo;s &mldr; incomplete? I feel like a number of the additional <a href=#regex-features>regex cases</a> could have been included. Perhaps future modules? But still, incomplete.</p><p>Still, for the month, it&rsquo;s free and it was an interesting problem to solve. So, worth doing. For the moment, I probably won&rsquo;t pay for CodeCrafters, but I will continue to solve the free problems! ðŸ˜„</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>One bit of unfortunate history was <a href=https://github.com/rust-lang/rustlings/pull/1768 target=_blank rel=noopener>here</a> where CodeCrafters added themselves (as a paid service) to &lsquo;what to do next&rsquo; without disclosing it. I still think that wasn&rsquo;t a great move, but time passes. And it&rsquo;s an interesting enough service.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>