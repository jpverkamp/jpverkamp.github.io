<!doctype html><html><head><title>The Golf (Peaks) of Solving â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>The Golf (Peaks) of Solving</h1><div class=entry-meta><span class=entry-date>2024-06-17</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/06/15/things-in-the-basement/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/07/02/spider-man-2099-classic-vol.-1/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another day (week? month?), another puzzle game.</p><p>This time around, we&rsquo;re going to solve <a href=https://store.steampowered.com/app/923260/Golf_Peaks/ target=_blank rel=noopener>Golf Peaks</a>. I picked this up a while ago on iOS, but only recently on Steam. It&rsquo;s a cute little puzzle game themed around minigolf.</p><p><img src=1.7-slopes.png alt></p><p>Basically, you&rsquo;re on a grid and you have to get the ball (in the bottom in that screenshot above) to the flag (currently at the top). You have a set list of moves you can take, styled as cards&ndash;all of which either move a certain number of tiles in a specific direction or possibly jump into the air (and fly over obstacles).</p><p>It gets more complicated from there, but hopefully you have the basic idea. ðŸ˜„</p><nav id=TableOfContents><ul><li><a href=#the-initialbasic-model>The initial/basic model</a></li><li><a href=#generating-states>Generating states</a><ul><li><a href=#try_move><code>try_move</code></a></li><li><a href=#try_jump><code>try_jump</code></a></li></ul></li><li><a href=#sloped-tiles>Sloped tiles</a></li><li><a href=#multiple-step-moves>Multiple step moves</a></li><li><a href=#bouncing-off-angled-walls>Bouncing off angled walls</a></li><li><a href=#sand>Sand</a></li><li><a href=#quicksand>Quicksand</a></li><li><a href=#water>Water</a></li><li><a href=#springs>Springs</a></li><li><a href=#warps--teleporters>Warps / Teleporters</a><ul><li><a href=#the-worst-warp-level>The worst warp level</a></li></ul></li><li><a href=#belts>Belts</a></li><li><a href=#edge-case-falling-sideways-onto-slopes>Edge case: Falling sideways onto slopes</a></li><li><a href=#sideways-slope-fix>Sideways slope fix</a></li><li><a href=#loops>Loops</a></li><li><a href=#the-final-level>The final level</a></li><li><a href=#fin>Fin.</a></li></ul></nav><h2 id=the-initialbasic-model>The initial/basic model</h2><p><img src=1.3-introduction.png alt></p><p>Okay, to start out with, we&rsquo;re going to represent <code>Tiles</code> as an <code>enum</code> (since I&rsquo;m writing this after finishing the game, I know we&rsquo;ll have a bunch ðŸ˜„).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The map (our <code>Global</code> state) will then hold all of the tiles, the location of the flag, and any solutions (for test cases later):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Global</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    tiles: Vec<span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    flag: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    solutions: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then the <code>Local</code> state should store any <code>Cards</code> remaining (they look like cards, so that&rsquo;s what I&rsquo;ve called them throughout) plus the current location of the <code>ball</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Card</span> {
</span></span><span style=display:flex><span>    Move(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Jump(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Hash, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    ball: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    cards: Vec<span style=color:#f92672>&lt;</span>Card<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is eventually going to have to change (<a href=#multiple-step-moves>eventually</a> we&rsquo;ll add moves that <code>Jump</code> and then <code>Move</code>), but for the first good number of puzzles this will work.</p><p>And finally, our <code>Step</code> will be a <code>Card</code> in a <code>Direction</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Step</span> {
</span></span><span style=display:flex><span>    card: <span style=color:#a6e22e>Card</span>,
</span></span><span style=display:flex><span>    direction: <span style=color:#a6e22e>Direction</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We do also need a function to <code>read</code> in the initial <code>Global</code> + <code>Local</code> state, but I&rsquo;m not going to get into that much detail here. Suffice it to say&mldr; it <a href=https://github.com/jpverkamp/rust-solvers/blob/5268b3ed21c72f7e9cd263fa460cda5fa929fed0/src/bin/golf-peaks.rs#L249-L482 target=_blank rel=noopener>got complicated</a>&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>9x9
</span></span><span style=display:flex><span>0,flag  5,left  3       2,*e    0       1,left  2,left  3,warp0 x
</span></span><span style=display:flex><span>5,up    4,warp0 3       2,*e    0,ice   1,left  2,left  3,/bl   3,warp1
</span></span><span style=display:flex><span>3       3       3,ice   2,*e    0       1,left  1,icetr 2,down  2,down
</span></span><span style=display:flex><span>2,*s    2,*s    2,*s    2,ice   2,*e    2,*s    1,down  1,down  1,down
</span></span><span style=display:flex><span>0       0,ice   0       2,*s    1,ball  2,*e    0       0,ice   0,ice
</span></span><span style=display:flex><span>1,up    1,up    1,up    2,*e    2,*s    2       1,up    1,up    1,up
</span></span><span style=display:flex><span>2,up    2,up    1,icebl 1,right 0       1,left  1       2,*w    2,*n
</span></span><span style=display:flex><span>2       3,warp2 2,right 1,right 0,ice   1,left  2,*n    3,/tl   3,warp1
</span></span><span style=display:flex><span>x       2       2,right 1       0,ice   1       2,*w    3,warp2 x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1- 1- 2- 2- 1/ 1/ 1/1- 1/1- 1/2-
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1/â†— 2-â†™ 1/1-â†™ 1-â†– 1/2-â†– 1/1-â†— 1-â†— 2-â†– 1/â†—
</span></span></code></pre></div><p>(We&rsquo;ll get to all of those different kinds of tiles later.)</p><p>ðŸ˜„</p><h2 id=generating-states>Generating states</h2><p>Okay, the next step for a solver is to impelement <code>State::next_states</code>. At first, it&rsquo;s relatively clean:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, Step, Self)<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        Self: Sized {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_states <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, card) <span style=color:#66d9ef>in</span> self.cards.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                next_state.cards.remove(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>match</span> card {
</span></span><span style=display:flex><span>                    Card::Move(strength) <span style=color:#f92672>=&gt;</span> next_state.try_move(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                    Card::Jump(strength) <span style=color:#f92672>=&gt;</span> next_state.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                } {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Invalid state, try next direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                next_states.push((<span style=color:#ae81ff>1</span>, Step { card: <span style=color:#f92672>*</span>card, direction }, next_state));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> next_states.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Some(next_states)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we&rsquo;ve done in <a href=https://blog.jverkamp.com/series/rust-solvers/>several of these posts now</a>, we go through each possible move (each <code>Card</code> in each <code>Direction</code>) and queue up each of those as a state. Currently, we just handle everything in a <code>try_move</code> and <code>try_jump</code> function on the <code>Local</code>. Each of those is designed to return <code>bool</code> if the move/jump &lsquo;worked&rsquo;. If it returns <code>false</code> (currently, if the ball falls off the map), then that state isn&rsquo;t considered as part of a solution.</p><h3 id=try_move><code>try_move</code></h3><p>So how do we <code>try_move</code>?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// No more moving to do, we&#39;re done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> strength <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_height <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            Tile::Empty <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>            Tile::Flat(height) <span style=color:#f92672>=&gt;</span> height,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next_point <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> Point::from(direction);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next_tile <span style=color:#f92672>=</span> global.tile_at(next_point);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Trying to move into empty space/out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Empty <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normal flat tile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Flat(height) <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// On the same level, just move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> height <span style=color:#f92672>==</span> current_height {
</span></span><span style=display:flex><span>                self.ball <span style=color:#f92672>=</span> next_point;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// New tile is higher, bounce
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This effectively reverses direction and moves &#39;back&#39; to the same tile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> height <span style=color:#f92672>&gt;</span> current_height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> self.try_move(global, direction.flip(), strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// New tile is lower, fall?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> height <span style=color:#f92672>&lt;</span> current_height {
</span></span><span style=display:flex><span>                todo!()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            unreachable!();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normal flat tile, recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.ball <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> direction.into();
</span></span><span style=display:flex><span>        self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We certainly have some room for expansion, since I knew even then we&rsquo;d be adding in a bunch of different kinds of tiles.</p><h3 id=try_jump><code>try_jump</code></h3><p><img src=2.1-jumps.png alt></p><p>Jumping&mldr; is much easier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_jump</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next_point <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> Point::from(direction) <span style=color:#f92672>*</span> strength <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next_tile <span style=color:#f92672>=</span> global.tile_at(next_point);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Trying to jump into empty space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Empty <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, it always works
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.ball <span style=color:#f92672>=</span> next_point;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Jumping explicitly just ignores any intervening terrain (there&rsquo;s not a &lsquo;jump height&rsquo;), so we just teleport. Whee!</p><p>And that&rsquo;s all we need to solve all of the levels up until ~1.7 when slopes are introduced!</p><h2 id=sloped-tiles>Sloped tiles</h2><p><img src=1.7-slopes.png alt></p><p>Okay, first addition will be sloped tiles. These will come back a number of times as we interact with other kinds of tiles, but the basic idea is this:</p><ul><li>If you are moving &lsquo;with&rsquo; the slope (either up or down), <code>try_move</code> will treat it as flat and end up going up/down a level</li><li>If you end a move or jump on a slope, you will slide down the slope (possibly in a chain)</li></ul><p>There&rsquo;s one (major) edge case here that actually doesn&rsquo;t come up until 9-6 (<a href=#edge-case-falling-sideways-onto-slopes>falling sideways onto slopes</a>).</p><p>Slopes will be handled as <code>Tile::Slope(usize, Direction)</code> where the first is the height of the top of the slope and the <code>Direction</code> is &lsquo;down&rsquo; the slope.</p><p><code>try_move</code> has a few updates. First, we calculate the current height a bit differently for slopes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> current_height <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>    Tile::Empty <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>    Tile::Flat(height) <span style=color:#f92672>=&gt;</span> height,
</span></span><span style=display:flex><span>    Tile::Slope(height, slope_direction) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>if</span> direction <span style=color:#f92672>==</span> slope_direction {
</span></span><span style=display:flex><span>        height
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> direction <span style=color:#f92672>==</span> slope_direction.flip() {
</span></span><span style=display:flex><span>        height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// TODO: Support this? 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>That <code>TODO: Support this?</code> is the side on case I mentioned earlier. It doesn&rsquo;t come up for a surprisingly long time. Other than that, the <code>height</code> of the slope is as specified in the map at the top and one less at the bottom.</p><p>Then, later moving onto a slope:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Slope(height, slope_direction) <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sliding down at the proper height
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> height <span style=color:#f92672>==</span> current_height <span style=color:#f92672>&amp;&amp;</span> (slope_direction <span style=color:#f92672>==</span> direction <span style=color:#f92672>||</span> slope_direction <span style=color:#f92672>==</span> direction.flip()) {
</span></span><span style=display:flex><span>        self.ball <span style=color:#f92672>=</span> next_point;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Dropping down onto a slope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> height <span style=color:#f92672>&lt;</span> current_height {
</span></span><span style=display:flex><span>        self.ball <span style=color:#f92672>=</span> next_point;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Anything else we don&#39;t support for now
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: Support this?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it for <code>try_move</code>, <em>but</em> we do need to add on a <code>try_slopes</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slopes</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> current_tile <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Slopes apply a single tile move than recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Slope(_, slope_direction) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, slope_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self.try_slopes(global);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What this is going to do is, after each move, if you&rsquo;re currently on a <code>Slope</code>, use <code>try_move</code> to move once on that slope (which will check bouncing into something or falling off the level) and then <code>try_slope</code> again in case there are multiple ones in a chain.</p><p>To implement this, our <code>next_states</code> becomes this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, card) <span style=color:#66d9ef>in</span> self.cards.iter().enumerate() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>        next_state.cards.remove(i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>match</span> card {
</span></span><span style=display:flex><span>            Card::Move(strength) <span style=color:#f92672>=&gt;</span> next_state.try_move(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>            Card::Jump(strength) <span style=color:#f92672>=&gt;</span> next_state.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>        } {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Invalid state, try next direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Apply slopes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        next_state.try_slopes(global);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        next_states.push((<span style=color:#ae81ff>1</span>, Step { card: <span style=color:#f92672>*</span>card, direction }, next_state));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>Pretty good for now!</p><h2 id=multiple-step-moves>Multiple step moves</h2><p><img src=2.4-jump-and-slide.png alt></p><p>Whelp. It was good while it lasted. It turns out that our current implementation of <code>Cards</code> isn&rsquo;t sufficient, we need to be able play a single card that can <code>Jump</code> and <code>Move</code> in the same direction (and there are a number of things that end up applying in between those two states).</p><p>Now, instead of a single card, we&rsquo;re going to implement a <code>Card</code> that can have 1 or more <code>CardSteps</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CardStep</span> {
</span></span><span style=display:flex><span>    Move(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Jump(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>CARD_MAX_STEPS</span>: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Card</span>([CardStep;<span style=color:#66d9ef>CARD_MAX_STEPS</span>]);
</span></span></code></pre></div><p>I use a constant array with size 10 here (I eventually drop this to 3) because you can&rsquo;t get <code>Copy</code> if you&rsquo;re going to store them in a <code>Vec&lt;CardStep></code>. <code>Copy</code> has to be constant size and inline (no pointers). Technically, I <em>really</em> didn&rsquo;t have to do this. I expected that we might end up with even more interesting moves or cards as we want (perhaps ones that turn in midair? or 3+ steps?) but&mldr; this is as complicated as we get. We&rsquo;ll never do anything other than <code>Move(usize)</code>, <code>Jump(usize)</code>, or <code>JumpAndMove(usize, usize)</code>.</p><p>But it was still fun to implement! ðŸ˜„</p><p>And the actual implementation is not at <em>all</em> that bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, card) <span style=color:#66d9ef>in</span> self.cards.iter().enumerate() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> direction <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>        next_state.cards.remove(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> step_success <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> card_step {
</span></span><span style=display:flex><span>                CardStep::Move(strength) <span style=color:#f92672>=&gt;</span> next_state.try_move(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::Jump(strength) <span style=color:#f92672>=&gt;</span> next_state.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>step_success {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Invalid state, try next direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Apply slopes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            next_state.try_slopes(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        next_states.push((<span style=color:#ae81ff>1</span>, Step { card: <span style=color:#f92672>*</span>card, direction }, next_state));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We still loop over each <code>Card</code> in each <code>Direction</code>, but now when actually implementing the move, we apply each step in turn, failing if after any one of them we end up off the board.</p><p>One interesting bug I did have in the initial implementation was that I only applied slopes at the end. But apparently, you can apply them in between the <code>Jump</code> and the <code>Move</code> (already fixed above).</p><p>While I was working on this, I did end up pulling in the &lsquo;solution checker&rsquo; that I wrote about in <a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/>Solving Sokobond</a>. Each level file will also include any possible solutions I&rsquo;ve found for that level. That lets me write a single test case that will try all solved levels and make sure we still generate a valid solution even after I change things. Go go gadget integration tests!</p><h2 id=bouncing-off-angled-walls>Bouncing off angled walls</h2><p><img src=2.8-angles.png alt></p><p>Okay, still in world 2, we do have one more trick. This time we have angled walls. If a ball comes in from either of the sides with the angled wall, it will change direction. The other two basically act as walls one step higher.</p><p>To implement this, first I&rsquo;m going to define an <code>enum</code> to store the four possible <code>AngleTypes</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>AngleType</span> {
</span></span><span style=display:flex><span>    TopLeft,
</span></span><span style=display:flex><span>    TopRight,
</span></span><span style=display:flex><span>    BottomLeft,
</span></span><span style=display:flex><span>    BottomRight,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> AngleType {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_reflect</span>(<span style=color:#f92672>&amp;</span>self, direction: <span style=color:#a6e22e>Direction</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            AngleType::TopLeft <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> direction {
</span></span><span style=display:flex><span>                Direction::Up <span style=color:#f92672>=&gt;</span> Some(Direction::Right),
</span></span><span style=display:flex><span>                Direction::Left <span style=color:#f92672>=&gt;</span> Some(Direction::Down),
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            AngleType::TopRight <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> direction {
</span></span><span style=display:flex><span>                Direction::Up <span style=color:#f92672>=&gt;</span> Some(Direction::Left),
</span></span><span style=display:flex><span>                Direction::Right <span style=color:#f92672>=&gt;</span> Some(Direction::Down),
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            AngleType::BottomLeft <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> direction {
</span></span><span style=display:flex><span>                Direction::Down <span style=color:#f92672>=&gt;</span> Some(Direction::Right),
</span></span><span style=display:flex><span>                Direction::Left <span style=color:#f92672>=&gt;</span> Some(Direction::Up),
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            AngleType::BottomRight <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> direction {
</span></span><span style=display:flex><span>                Direction::Down <span style=color:#f92672>=&gt;</span> Some(Direction::Left),
</span></span><span style=display:flex><span>                Direction::Right <span style=color:#f92672>=&gt;</span> Some(Direction::Up),
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I originally had these stored using a pair of <code>Direction</code>, but &mldr; it got confusing, mostly because I didn&rsquo;t have the two ordered. This is much better.</p><p>To handle this in <code>try_move</code>, we end up adding a new block after <code>Tile::Slope</code> but before the base &lsquo;flat&rsquo; case:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Angled tiles
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// On either of their angled sides, reflect to the other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// On the other two, treat them as a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Angle(height, a_type) <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re on the same height and reflect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> height <span style=color:#f92672>==</span> current_height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(new_direction) <span style=color:#f92672>=</span> a_type.try_reflect(direction) {
</span></span><span style=display:flex><span>                    self.ball <span style=color:#f92672>=</span> next_point;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> self.try_move(global, new_direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, always treat this as a wall one height (fall through)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            next_tile <span style=color:#f92672>=</span> Tile::Flat(height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we bounce off the angle, we&rsquo;ll recur on <code>try_move</code> in the new direction and immediately return it&rsquo;s response, this will handle the bounce. But the interesting part is that we can modify <code>next_tile</code> here (which doesn&rsquo;t modify the <code>Global</code> map, since it&rsquo;s intentionally immutable) and fall through to treat it as a flat tile if you bounce into the &lsquo;back&rsquo; of it.</p><p>And that&rsquo;s it. Angles!</p><h2 id=sand>Sand</h2><p><img src=3.8-sand.png alt></p><p>World 3&rsquo;s trick? Sand! Also quicksand. This is 3-8, which has both of them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>    Sand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Cannot slide out of sand, just stop moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// But return true, this isn&#39;t an error, just stopping
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Sand(_) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Instead of recurring <code>try_move</code> with <code>strength - 1</code>&mldr; we just immediately return <code>true</code>. And that&rsquo;s enough to stop the ball in it&rsquo;s tracks when it <code>try_moves</code> across sand.</p><p>I like the easy ones.</p><h2 id=quicksand>Quicksand</h2><p>Quicksand though, that one is slightly more sneaky.</p><ul><li>As long as you are moving, <code>Quicksand</code> is treated as a normal flat tile</li><li>If you finish a card on quicksand, the ball slowly sinks (which should return <code>false</code> from <code>try_move</code>)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>    Sand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Quicksand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To actually implement this properly, I did do a bit of refactoring. Rather than <code>next_states</code> handling the different kinds of cards itself, I instead created a new <code>try_card</code> function on <code>Local</code> which will properly handle a single <code>Card</code> in a single <code>Direction</code>:</p><ul><li>For each step of the <code>Card</code><ul><li><code>Move</code>/<code>Jump</code> as specified</li><li>Check for slopes</li></ul></li><li>After each step is done, check <code>Quicksand</code></li></ul><p>Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> card_step {
</span></span><span style=display:flex><span>                CardStep::Move(strength) <span style=color:#f92672>=&gt;</span> self.try_move(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::Jump(strength) <span style=color:#f92672>=&gt;</span> self.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>success {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_slopes(global) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// On quicksand, we fail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Quicksand(_) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the <code>next_states</code> loop just becomes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, card) <span style=color:#66d9ef>in</span> self.cards.iter().enumerate() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>&#39;next_direction</span>: <span style=color:#a6e22e>for</span> direction <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>        next_state.cards.remove(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>next_state.try_card(global, <span style=color:#f92672>*</span>card, direction) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Invalid state, try next direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>continue</span> &#39;next_direction;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        next_states.push((<span style=color:#ae81ff>1</span>, Step { card: <span style=color:#f92672>*</span>card, direction }, next_state));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If I had this in more than one file, this would be <code>pub fn try_card</code> and <code>try_move</code> / <code>try_jump</code> / etc would all be private so I can force myself only to call this one. As it is though&mldr; well I just have to be careful, now don&rsquo;t I? ðŸ˜„</p><h2 id=water>Water</h2><p>Next up, world 4 and water traps!</p><p><img src=4.2-water.png alt></p><p>Water is interesting, since it wouldn&rsquo;t make any sense to immediately lose the level (you could just leave it open). Instead, if a ball ever falls into water, it will respawn&ndash;not where you hit the ball from, but rather on the last &lsquo;safe&rsquo; tile that the ball moved across. So you can respawn on <code>Flat</code> or <code>Sand</code>, but not <code>Slope</code> or <code>Quicksand</code>. (Technically <code>Angle</code> is allowed as well.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>    Sand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Quicksand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Water(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Hash, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    ball: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    cards: Vec<span style=color:#f92672>&lt;</span>Card<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    last_safe: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This requires a few changes. In <code>try_card</code>, if we end a move on water (this can be between steps as well), revert to the <code>last_safe</code> point:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> card_step {
</span></span><span style=display:flex><span>                CardStep::Move(strength) <span style=color:#f92672>=&gt;</span> self.try_move(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::Jump(strength) <span style=color:#f92672>=&gt;</span> self.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>success {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If after any step, we&#39;re on water, reset to last safe tile and stop move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This shouldn&#39;t apply after move (it&#39;s handled in try_move), but might after jump or slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Water(_) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>                self.ball <span style=color:#f92672>=</span> self.last_safe;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, when we <code>try_move</code>, if we&rsquo;re moving <em>from</em> a safe tile, we can mark it + handle falling into water during a move (<code>jump</code> and <code>slide</code> are handled above):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re on a flat/safe tile, mark this as the last safe spot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Flat(_) <span style=color:#f92672>|</span> Tile::Angle(_, _) <span style=color:#f92672>|</span> Tile::Sand(_) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>            self.last_safe <span style=color:#f92672>=</span> self.ball;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Trying to move onto water, fall back to last safe tile and end move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Water(_) <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            self.ball <span style=color:#f92672>=</span> self.last_safe;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normal flat tile, recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.ball <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> direction.into();
</span></span><span style=display:flex><span>        self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s interesting that <code>try_move</code> <em>succeeds</em> if the ball falls in water, but that&rsquo;s actually what a lot of levels in this section are built around, which is kind of cool.</p><h2 id=springs>Springs</h2><p><img src=5.2-boing.png alt></p><p>Next up, world 5 is built around springs. Basically if you hit a spring part of the way through a <code>Move</code>, treat it as a <code>Jump</code> for the rest of the move.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>    Sand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Quicksand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Water(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Spring(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bouncing <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> card_step {
</span></span><span style=display:flex><span>                CardStep::Move(strength) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>if</span> bouncing {
</span></span><span style=display:flex><span>                    self.try_jump(global, direction, <span style=color:#f92672>*</span>strength)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    self.try_move(global, direction, <span style=color:#f92672>*</span>strength)
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                CardStep::Jump(strength) <span style=color:#f92672>=&gt;</span> self.try_jump(global, direction, <span style=color:#f92672>*</span>strength),
</span></span><span style=display:flex><span>                CardStep::None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>success {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we end part of a card on a spring, the next move counts as a jump
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Spring(_) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>                bouncing <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, direction: <span style=color:#a6e22e>Direction</span>, strength: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we move onto a spring, treat the rest of the move as a jump
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Spring(_) <span style=color:#f92672>=</span> next_tile {
</span></span><span style=display:flex><span>            self.ball <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> direction.into();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_jump(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normal flat tile, recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.ball <span style=color:#f92672>=</span> self.ball <span style=color:#f92672>+</span> direction.into();
</span></span><span style=display:flex><span>        self.try_move(global, direction, strength <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For <code>try_move</code>, the change is easy enough. If we see a <code>Spring</code>, call to <code>try_jump</code> for the next part of the move instead of <code>try_move</code>. But we also need to handle an interesting edge case. If you have a <code>Jump(1) + Move(1)</code> card and after the jump you end up on a <code>Spring</code>, then the <code>Move</code> part needs to be handled as a <code>Jump</code> instead. Which of course comes up in levels in this section. Whee!</p><h2 id=warps--teleporters>Warps / Teleporters</h2><p><img src=6.3-warps.png alt></p><p>Up next, warps! Or teleporters. Or holes, although in golf that would be the flag, so I had to rename them. ðŸ˜„</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Flat(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Slope(<span style=color:#66d9ef>usize</span>, Direction),
</span></span><span style=display:flex><span>    Angle(<span style=color:#66d9ef>usize</span>, AngleType),
</span></span><span style=display:flex><span>    Sand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Quicksand(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Water(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Spring(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Warp(<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The extra second parameter here is the <code>id</code> of the <code>Warp</code> since (as you can see in the above picture), it&rsquo;s possible to have multiple pairs of <code>Warps</code> per level&ndash;although you&rsquo;ll always have exactly a pair of each kind (no non-determinism here thankfully).</p><p>I originally had this inline with the <code>try_card</code> functionality, but you can also actually see it in the middle of a <code>try_slope</code>, so I had to refactor again.</p><p>On thing that&rsquo;s interesting is this one does not at all touch <code>try_move</code> or <code>try_jump</code>, since you cannot warp in the middle of a <code>CardStep</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we end on the flag, we don&#39;t have to finish this card
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.ball <span style=color:#f92672>==</span> global.flag {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slopes</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_tile <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Slopes apply a single tile move than recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Slope(_, slope_direction) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, slope_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_slopes(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_warp</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re on a warp after any card part, transport to the other half
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Warp(_, warp_index) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> ball_index <span style=color:#f92672>=</span> self.ball.y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> self.ball.x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> other_warp_map_index <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>                .tiles
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .enumerate()
</span></span><span style=display:flex><span>                .find_map(<span style=color:#f92672>|</span>(other_index, tile)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> other_index <span style=color:#f92672>==</span> ball_index {
</span></span><span style=display:flex><span>                        None
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Warp(_, other_warp_index) <span style=color:#f92672>=</span> tile {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>other_warp_index <span style=color:#f92672>==</span> warp_index {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Some(other_index);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            None
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        None
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;No other warp in map&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.ball <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                x: (other_warp_map_index <span style=color:#f92672>%</span> global.width) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                y: (other_warp_map_index <span style=color:#f92672>/</span> global.width) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I probably could have directly stored the &lsquo;warp to&rsquo; point in the <code>Tile::Warp</code> on load (which I&rsquo;m just thinking about now), but I didn&rsquo;t really have any performance problems with this as is, so it&rsquo;s fine to leave for now.</p><h3 id=the-worst-warp-level>The worst warp level</h3><p>So remember how I said that we only ever have pairs of warps?</p><p><img src=7.10-all-the-warps.png alt></p><p>Yeah&mldr; that was a surprising level to see ðŸ˜„</p><p>Technically, each one is <em>still</em> only part of a single pair, but there&rsquo;s no visual indicator. You instead have to manually go through each to figure out where they all go.</p><span class=spoiler><code><pre>
6x4
0,flag  0,warp7 0,warp6 0,warp4 0,warp7 x
x       0,warp1 0,warp0 0,warp5 0,warp3 x
x       0,warp2 0,warp1 0,warp6 0,warp2 x
x       0,warp4 0,warp3 0,warp5 0,warp0 0,ball

1- 1- 1- 1- 1- 1- 1- 1-

1-â†– 1-â†˜ 1-â†– 1-â†— 1-
1-â†– 1-â†˜ 1-â†– 1-â†— 1-â†–
</pre></code></span><p>Interesting. Annoying to code for the solver. But interesting.</p><h2 id=belts>Belts</h2><p><img src=8.2-belts.png alt></p><p>So&mldr; these are a bit weird. They really are <code>slopes</code> that are flat. There&rsquo;s not actually an edge case that I ever found where they&rsquo;d be treated differently. Which makes them (implementation wise) easier than slopes, since you don&rsquo;t have to deal with falling onto them from the sides or the high/low side.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slopes</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_tile <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Slopes apply a single tile move than recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Slope(_, slope_direction) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, slope_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_slopes(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Same for belts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Belt(_, belt_direction) <span style=color:#f92672>=</span> current_tile {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, belt_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_slopes(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s&mldr; really it. I could actually have rewritten this in arguably a more compact syntax:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slopes</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_tile <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Slopes and belts apply a single tile move than recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> current_tile {
</span></span><span style=display:flex><span>            Tile::Slope(_, direction) <span style=color:#f92672>|</span> Tile::Belt(_, direction) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                self.try_warp(global);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> self.try_slopes(global);
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I just &mldr; didn&rsquo;t think about it until I saw the code when writing this post. Oops. ðŸ˜„</p><h2 id=edge-case-falling-sideways-onto-slopes>Edge case: Falling sideways onto slopes</h2><p><img src=9.2-ice.png alt></p><p>Ooh ice. Ice is nice.</p><p>So this is an interesting one. <code>Ice</code> will basically work in that if you finish a <code>Card</code> on ice, you will continue to move in the same direction until either:</p><ul><li>You move off the <code>Ice</code> onto some other kind of <code>Tile</code></li><li>You &lsquo;bounce&rsquo; into a wall, staying on the same <code>Ice</code> block</li></ul><p>This ended up being a bit tricky to implement though, since the direction you&rsquo;re moving can change mid-move (<code>Angles</code>), but the <code>Ice</code> won&rsquo;t be implemented until <code>try_card</code>. So we either need to return the last direction &mldr; or store it in the <code>Local</code> state. Let&rsquo;s go with the latter:</p><p>It gets even more complicated (but also even more fun) when you introduce <code>Ice</code> + <code>Angles</code>:</p><p><img src=9.3-ice-angles.png alt></p><p>I could have implemented this as a single spot on the map having multiple <code>Tile</code> attributes, but instead, I just made this <code>IceAngle</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Hash, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    ball: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    cards: Vec<span style=color:#f92672>&lt;</span>Card<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    last_safe: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    last_move: <span style=color:#a6e22e>Direction</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now unlike <code>last_safe</code>, we do need to set <code>last_move</code> on things like <code>Slope</code>, so we end up setting it a bunch of different places. This was by far the most interesting single addition (pair of additions?) to the game.</p><p>I ended up implementing this with <code>last_move</code> as above (should that have been <code>slide_direction</code>?) + refactoring the <code>try_slope</code> method into <code>try_slide</code> instead, which will handle <code>Slopes</code>, <code>Belts</code>, and now <code>Ice</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> direction <span style=color:#f92672>=</span> direction;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bouncing <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> card_step <span style=color:#66d9ef>in</span> card.<span style=color:#ae81ff>0.</span>iter() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_slide(global) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// On quicksand, we fail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Quicksand(_) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slide</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_tile <span style=color:#f92672>=</span> global.tile_at(self.ball);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_tile <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re on ice, continue to slide in that direction until it changes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>                Tile::Ice(_) <span style=color:#f92672>|</span> Tile::IceAngle(_, _) <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start_position <span style=color:#f92672>=</span> self.ball;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> success <span style=color:#f92672>=</span> self.try_move(global, self.last_move, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Fell off the map (most likely)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>success {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Didn&#39;t actually slide, probably bounced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.ball <span style=color:#f92672>==</span> start_position {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=sideways-slope-fix>Sideways slope fix</h2><p>This&mldr; was not the end of these levels though. We also ended up having to fix a <em>really</em> old bug.</p><p><img src=9.6-sideways-slope-fix.png alt></p><p>It turns out that if you fall onto a <code>Slope</code> from above, it immediately cancels your momentum and you slide down it. This is really the only difference between <code>Belts</code> and <code>Slopes</code> (other than the height difference).</p><p>It took a while to find this one&mldr;</p><h2 id=loops>Loops</h2><p>And finally, we&rsquo;re on to the last levels.</p><p>For the most part, there was nothing new here, just a culmination of all of the tricks of the other 9 worlds. We did finally (in 10.5) come across our first loop though:</p><p><img src=10.5-loop-fix.png alt></p><p>See it yet?</p><p>It&rsquo;s down in the bottom left, with the two <code>IceAngles</code> forming one end of a rectangle with the <code>Belts</code> along one side.</p><p>This was interesting to fix. Essentially, I added a loop detection cache to <code>Local</code> (which has to be <code>Clone</code>, but not <code>Copy</code>, so we can use a <code>Vec</code>!)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Hash, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    ball: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    cards: Vec<span style=color:#f92672>&lt;</span>Card<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    last_safe: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    last_move: <span style=color:#a6e22e>Direction</span>,
</span></span><span style=display:flex><span>    slide_loop_cache: Vec<span style=color:#f92672>&lt;</span>(Point, Direction)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is reset in <code>try_card</code> and then only used in <code>try_slide</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_card</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, card: <span style=color:#a6e22e>Card</span>, direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> direction <span style=color:#f92672>=</span> direction;
</span></span><span style=display:flex><span>        log::debug!(<span style=color:#e6db74>&#34;try_card({:?}, {card:?}, {direction:?})&#34;</span>, self.ball);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Keep a cache of moves we&#39;ve seen on the same card while sliding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we see the same move again, we&#39;re in a loop and should stop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.slide_loop_cache.clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_slide(global) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_slide</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> global.tile_at(self.ball) <span style=color:#f92672>==</span> Tile::Empty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_ice</span>(tile: <span style=color:#a6e22e>Tile</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> tile {
</span></span><span style=display:flex><span>                Tile::Ice(_) <span style=color:#f92672>|</span> Tile::IceAngle(_, _) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re on ice, continue to slide in that direction until it changes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This is if + while to deal with the warp at the end of ice case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> is_ice(global.tile_at(self.ball)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Keep sliding until we hit something that isn&#39;t ice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> is_ice(global.tile_at(self.ball)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update/check slide loop check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> self.slide_loop_cache.contains(<span style=color:#f92672>&amp;</span>(self.ball, self.last_move)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                self.slide_loop_cache.push((self.ball, self.last_move));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> start_position <span style=color:#f92672>=</span> self.ball;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> success <span style=color:#f92672>=</span> self.try_move(global, self.last_move, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Fell off the map (most likely)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>success {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Didn&#39;t actually slide, probably bounced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> self.ball <span style=color:#f92672>==</span> start_position {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Slopes apply a single tile move than recur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Slope(_, slope_direction) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Update/check slide loop check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.slide_loop_cache.contains(<span style=color:#f92672>&amp;</span>(self.ball, slope_direction)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.slide_loop_cache.push((self.ball, slope_direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try to slide down the slope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, slope_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_slide(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Same for belts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Belt(_, belt_direction) <span style=color:#f92672>=</span> global.tile_at(self.ball) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Update/check slide loop check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.slide_loop_cache.contains(<span style=color:#f92672>&amp;</span>(self.ball, belt_direction)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.slide_loop_cache.push((self.ball, belt_direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try to get pushed by the belt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.try_move(global, belt_direction, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.try_warp(global);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.try_slide(global);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-slopes just don&#39;t slide
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, I know, I still have both <code>Tile::Slope</code> and <code>Tile::Belt</code> with identical code. But otherwise, it&rsquo;s easy. Each time we slide, store the ball location and direction in the cache. If we ever see the same as something in the cache, we have a loop, so this isn&rsquo;t a valid solution.</p><p>Oops!</p><p>It works well though.</p><h2 id=the-final-level>The final level</h2><p>And so we come to the end.</p><p><img src=10.12-finale.png alt></p><p>This is a fun one. Except&mldr; where in the world is the flag?!</p><h2 id=fin>Fin.</h2><p><img src=0-achievements.png alt></p><p>And that&rsquo;s it! There&rsquo;s a hidden 19th Hole <span class=spoiler>in the credits</span>
, but that&rsquo;s it.</p><p>That was a fun game. It was kind of nice to work on a solver for something with such a ridiculously smaller exploration space. In this case, there&rsquo;s a maximum of <span class=latex-inline>(4n)!</span>
(where <code>n</code> is the number of cards) possible moves.</p><p>The most cards is 9 in <a href=#the-final-level>10-12 (the last level!)</a>. Which&mldr; is technically 3.71e41 states&mldr; but a <em>vast</em> majority of those are invalid (jumping off the level or not doing anything interesting). To find the solution, I only ended up having to evaluate 6831 of those states, which was the most states of any of the puzzles here (there wasn&rsquo;t one with fewer cards but a higher branching factor).</p><p>Even that took less about half a second on my laptop <em>in debug mode</em>. In release mode, it took 0.05 seconds. So I really wasn&rsquo;t worried about optimization for this one. ðŸ˜„</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>