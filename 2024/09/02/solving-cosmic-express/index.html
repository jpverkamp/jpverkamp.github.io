<!doctype html><html><head><title>Solving Cosmic Express – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Solving Cosmic Express</h1><div class=entry-meta><span class=entry-date>2024-09-02</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/pathfinding>Pathfinding</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/09/01/the-sea-of-trolls/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another <a href=https://blog.jverkamp.com/series/rust-solvers/>Rust Solvers</a> puzzle: <a href=https://store.steampowered.com/app/583270/Cosmic_Express/ target=_blank rel=noopener>Cosmic Express</a>. Basically, it&rsquo;s a routefinding puzzle. You have a train that needs a track from entrance to exit, picking up and dropping off cargo on the way.</p><p>It&rsquo;s actual a relatively simple puzzle, so far as things go, but one thing that&rsquo;s interesting from a solving perspective is that branching paths <em>really</em> don&rsquo;t work great with my solver code. Paths just have a crazy branching factor when compared to (for example) <a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/>playing one of a handful of cards</a>.</p><p>But it&rsquo;s still an interesting puzzle!</p><hr><nav id=TableOfContents><ul><li><a href=#representing-the-simulation>Representing the simulation</a></li><li><a href=#solving-cosmic-express>Solving Cosmic Express</a></li><li><a href=#loading-level-data>Loading level data</a></li><li><a href=#parameterizing-the-solver>Parameterizing the solver</a><ul><li><a href=#a-simple-heuristic>A simple heuristic</a></li><li><a href=#floodfill-validator>Floodfill validator</a></li><li><a href=#a-custom-hash-function>A custom hash function</a></li></ul></li><li><a href=#current-progress>Current progress</a></li></ul></nav><h2 id=representing-the-simulation>Representing the simulation</h2><p>Okay, first as always, what structs do we have to represent the puzzle in our solver? For the global state, we have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CosmicExpressGlobal</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    length: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    entrance: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    exit: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    walls: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a standard grid with a few non-changing elements, such as the <code>entrance</code> and <code>exit</code> into the level and the non-passable <code>walls</code> that you can&rsquo;t path through. One interesting aspect here is that the aliens/houses (the cargo you pick up and where you drop it off) are also treated as <code>walls</code>, so I just also include them in this map.</p><p>Also, I could definitely use a <code>HashSet</code> for <code>walls</code>, it would fit, but this is one of those interesting cases where that&rsquo;s actually slower than just searching through a <code>Vec</code> (I benchmarked it). There are just so few walls (&lt;10) on most levels, it&rsquo;s not worth the cost to calculate the hash of <code>Point</code> over and over again.</p><p>Next up, the local state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Hash, Ord, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {
</span></span><span style=display:flex><span>    Purple,
</span></span><span style=display:flex><span>    Orange,
</span></span><span style=display:flex><span>    Green,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, PartialEq, Eq, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CosmicExpressLocal</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The path the train has taken so far
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    path: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The current seats of the train
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Seats contains the color of the alien in the seat
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Goop is a flag on if a seat has been &#39;gooped&#39; by a green alien
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    seats: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Color<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    seat_goop: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Remaining aliens that haven&#39;t been picked up / houses that haven&#39;t been delivered to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    aliens: Vec<span style=color:#f92672>&lt;</span>(Point, Color)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    houses: Vec<span style=color:#f92672>&lt;</span>(Point, Color)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this case, we have an ordered list of all the points visited on this <code>path</code> first. Next up, we have <code>seats</code>. The train has nultiple seats that follow along the engine, which are basically at <code>1..=seats.len()</code> in <code>path</code>.</p><p>What <code>seats</code> actually holds is an <code>Option&lt;Color></code> representing which color alien is in the seat (<code>Some</code>) or if it&rsquo;s empty <code>None</code>. Then <code>seat_goop</code> is another array representing if a <code>Green</code> alien has sat in the seat at any point&ndash;no non-green alien will sit in a seat after a green has. Both of these <code>Vec</code> are always exactly the same length as the number of seats on the train.</p><p>I could have implemented this as <code>seats: Vec&lt;(bool, Option&lt;Color>)></code>, but honestly, I added the <code>seat_goop</code> once the seat color was already implemented, so this seemed find.</p><p>Finally, <code>aliens</code> and <code>houses</code> represent remaining <code>aliens</code> to pick up (this <code>Vec</code> will shrink over time) and <code>houses</code> to take them to, if the colors matches.</p><h2 id=solving-cosmic-express>Solving Cosmic Express</h2><p>Okay, so what&rsquo;s the basic model for solving this?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>CosmicExpressGlobal, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> CosmicExpressLocal {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, g: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CosmicExpressGlobal</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check goop, if we have no un-gooped seats and there are non-Green aliens left, it&#39;s invalid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.seat_goop.iter().all(<span style=color:#f92672>|&amp;</span>b<span style=color:#f92672>|</span> b)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self
</span></span><span style=display:flex><span>                .aliens
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>(_, c)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>c <span style=color:#f92672>!=</span> Color::Green)
</span></span><span style=display:flex><span>                .count()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// All validators passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solved</span>(<span style=color:#f92672>&amp;</span>self, g: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CosmicExpressGlobal</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.aliens.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> 
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self.houses.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self.path.last().unwrap() <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>g.exit
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, g: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CosmicExpressGlobal</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, (), Self)<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> Vec::with_capacity(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>&#39;neighbor</span>: <span style=color:#a6e22e>for</span> p <span style=color:#66d9ef>in</span> self.path.last().unwrap().neighbors() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Validate that the next point is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Cannot leave the bounds unless on entrance or exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>(g.entrance <span style=color:#f92672>==</span> p <span style=color:#f92672>||</span> g.exit <span style=color:#f92672>==</span> p)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> (p.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> p.x <span style=color:#f92672>&gt;</span> g.width <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&gt;</span> g.height)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;neighbor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cannot move onto walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> g.walls.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;neighbor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cannot visit the same tile more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> p2 <span style=color:#66d9ef>in</span> self.path.iter() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>&amp;</span>p <span style=color:#f92672>==</span> p2 {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span> &#39;neighbor;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Assume we can move, create the new state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_local <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>            new_local.path.push(p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Update each seat
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (seat_index, seat_point) <span style=color:#66d9ef>in</span> self.path.iter().rev().skip(<span style=color:#ae81ff>1</span>).enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we&#39;re over the end of the seats, we&#39;re done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> seat_index <span style=color:#f92672>&gt;=</span> new_local.seats.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> seat_contents <span style=color:#f92672>=</span> new_local.seats[seat_index];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Full seats next to the correct house; drop it off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(seat_color) <span style=color:#f92672>=</span> seat_contents {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (house_index, (house_point, house_color)) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                        new_local.houses.iter().enumerate()
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> seat_point.manhattan_distance(<span style=color:#f92672>*</span>house_point) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> seat_color <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>house_color
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            new_local.houses.remove(house_index);
</span></span><span style=display:flex><span>                            new_local.seats[seat_index] <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                            seat_contents <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Empty seats next to an alien; pick it up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> seat_contents.is_none() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Find all viable aliens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// This has to be done this way because if two try to load at once, none get to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> viable_aliens <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (alien_index, (alien_point, alien_color)) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                        new_local.aliens.iter().enumerate()
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> seat_point.manhattan_distance(<span style=color:#f92672>*</span>alien_point) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Non-green aliens will not try to sit in gooped seats
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#66d9ef>if</span> alien_color <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>Color::Green <span style=color:#f92672>&amp;&amp;</span> new_local.seat_goop[seat_index] {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Record that this alien can be loaded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            viable_aliens.push((alien_index, <span style=color:#f92672>*</span>alien_color));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we found exactly one, load it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> viable_aliens.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> (alien_index, alien_color) <span style=color:#f92672>=</span> viable_aliens[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        new_local.aliens.remove(alien_index);
</span></span><span style=display:flex><span>                        new_local.seats[seat_index] <span style=color:#f92672>=</span> Some(alien_color);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> alien_color <span style=color:#f92672>==</span> Color::Green {
</span></span><span style=display:flex><span>                            new_local.seat_goop[seat_index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            result.push((<span style=color:#ae81ff>1</span>, (), new_local));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ll always have nodes, so always return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// We&#39;re relying on is_valid to filter impossible states this time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Some(result)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>heuristic</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CosmicExpressGlobal</span>) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> heuristic <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Very basic heuristic; just how many entities are left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>HEURISTIC_COUNT_ENTITIES</span> {
</span></span><span style=display:flex><span>            heuristic <span style=color:#f92672>+=</span> ((self.aliens.len() <span style=color:#f92672>+</span> self.houses.len()) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span> global.width.max(global.height)) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Custom heuristic to hug walls (hopefully cuts down on path segments)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>HEURISTIC_HUG_WALLS</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self
</span></span><span style=display:flex><span>                .path
</span></span><span style=display:flex><span>                .last()
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .neighbors()
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> 
</span></span><span style=display:flex><span>                    global.walls.contains(n) 
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> self.path.contains(n)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> n.x <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> n.y <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> n.x <span style=color:#f92672>&gt;=</span> global.width
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> n.y <span style=color:#f92672>&gt;=</span> global.height
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .count()
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                heuristic <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Custom heuristic to actually guess the possible path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>HEURISTIC_NEAREST_HOUSE</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... explained later ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        heuristic
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>is_valid</code> doesn&rsquo;t actually do much, although it does bail out if we&rsquo;ve picked up too many green aliens to solve the puzzle. But for most of my runs, I did use a <a href=#floodfill-validator>much better validator</a>, which I&rsquo;ll talk about later.</p><p>Likewise, the <code>is_solved</code> is just: all aliens and houses are cleared + at the exit.</p><p>The <code>heuristic</code> also has a slightly more complicated section <a href=#a-simple-heuristic>later</a></p><p><code>next_states</code>, as always, contains the simulation itself, so is a bit more complicated.</p><p>Basically:</p><ul><li>Find the end of current path; for each neighbor:<ul><li>If it tries to exit the level, skip</li><li>If it tries to walk into a wall (including aliens and houses), skip</li><li>Paths cannot cross (yet)</li><li>Otherwise:<ul><li>Update each seat<ul><li>If an empty seat is next to a alien, pick it up (complication: not if there are two to pick up at once)<ul><li>Green aliens goop their seats</li></ul></li><li>If an alien is in a seat next to a matching (empty) house, drop it off</li></ul></li></ul></li></ul></li></ul><p>That&rsquo;s&mldr; actually it. It&rsquo;s interesting how relatively simple generating states can be. It does branch rather much though&mldr;</p><p>But for basic levels, that&rsquo;s enough to solve the problem!</p><h2 id=loading-level-data>Loading level data</h2><p>This is actually my second time through solving this puzzle. For the first time around, I had a slightly more complicated model with multiple <code>entrances</code> / <code>exits</code> and <code>entities</code> for <code>Wall</code>/<code>Alien</code>/<code>House</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Used only for loading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Copy, Clone, Debug, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Entity</span> {
</span></span><span style=display:flex><span>    Wall,
</span></span><span style=display:flex><span>    Alien { color: <span style=color:#a6e22e>Color</span> },
</span></span><span style=display:flex><span>    House { color: <span style=color:#a6e22e>Color</span> },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CosmicExpressDefinition</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    length: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    entrances: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    exits: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    entities: Vec<span style=color:#f92672>&lt;</span>(Point, Entity)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>One thing that&rsquo;s interesting here though (and you might already see it with the <code>#[derive(Serialize, Deserialize)]</code>): I can write out the levels as JSON and use <a href=https://serde.rs/ target=_blank rel=noopener>serde</a> + <a href=https://github.com/serde-rs/json target=_blank rel=noopener>serde_json</a> to automagically parse them!</p><p>So something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;width&#34;</span>: <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;height&#34;</span>: <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;length&#34;</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;entrances&#34;</span>: [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>4</span> }],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;exits&#34;</span>: [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>8</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>4</span> }],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;entities&#34;</span>: [
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>1</span> }, <span style=color:#e6db74>&#34;Wall&#34;</span>],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>7</span> }, <span style=color:#e6db74>&#34;Wall&#34;</span>],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>6</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>4</span> }, <span style=color:#e6db74>&#34;Wall&#34;</span>],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>5</span> }, { <span style=color:#f92672>&#34;Alien&#34;</span>: { <span style=color:#f92672>&#34;color&#34;</span>: <span style=color:#e6db74>&#34;Purple&#34;</span> } }],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>3</span> }, { <span style=color:#f92672>&#34;Alien&#34;</span>: { <span style=color:#f92672>&#34;color&#34;</span>: <span style=color:#e6db74>&#34;Orange&#34;</span> } }],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>7</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>1</span> }, { <span style=color:#f92672>&#34;House&#34;</span>: { <span style=color:#f92672>&#34;color&#34;</span>: <span style=color:#e6db74>&#34;Purple&#34;</span> } }],
</span></span><span style=display:flex><span>    [{ <span style=color:#f92672>&#34;x&#34;</span>: <span style=color:#ae81ff>7</span>, <span style=color:#f92672>&#34;y&#34;</span>: <span style=color:#ae81ff>7</span> }, { <span style=color:#f92672>&#34;House&#34;</span>: { <span style=color:#f92672>&#34;color&#34;</span>: <span style=color:#e6db74>&#34;Orange&#34;</span> } }]
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Can be loaded with just this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> stdin <span style=color:#f92672>=</span> io::stdin().lock();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> definition: <span style=color:#a6e22e>CosmicExpressDefinition</span> <span style=color:#f92672>=</span> serde_json::from_reader(stdin).unwrap();
</span></span></code></pre></div><p>But&mldr; I did change the model slightly between version 1 and here, so I had to also convert a bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Convert to a global and local
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// There is a hidden wall under all aliens and houses
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO: Entities should have an is_wall property or something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> walls <span style=color:#f92672>=</span> definition.entities.iter().map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p).collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert!(definition.entrances.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>assert!(definition.exits.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> global <span style=color:#f92672>=</span> CosmicExpressGlobal {
</span></span><span style=display:flex><span>    width: <span style=color:#a6e22e>definition</span>.width,
</span></span><span style=display:flex><span>    height: <span style=color:#a6e22e>definition</span>.height,
</span></span><span style=display:flex><span>    length: <span style=color:#a6e22e>definition</span>.length,
</span></span><span style=display:flex><span>    entrance: <span style=color:#f92672>*</span>definition.entrances.first().unwrap(),
</span></span><span style=display:flex><span>    exit: <span style=color:#f92672>*</span>definition.exits.first().unwrap(),
</span></span><span style=display:flex><span>    walls,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> seats <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>definition.length).map(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> None).collect();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> seat_goop <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>definition.length).map(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> <span style=color:#66d9ef>false</span>).collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> aliens: Vec<span style=color:#f92672>&lt;</span>(Point, Color)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> definition
</span></span><span style=display:flex><span>    .entities
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .filter_map(<span style=color:#f92672>|</span>(p, e)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Entity::Alien { color } <span style=color:#f92672>=</span> e {
</span></span><span style=display:flex><span>            Some((<span style=color:#f92672>*</span>p, <span style=color:#f92672>*</span>color))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> houses: Vec<span style=color:#f92672>&lt;</span>(Point, Color)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> definition
</span></span><span style=display:flex><span>    .entities
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .filter_map(<span style=color:#f92672>|</span>(p, e)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Entity::House { color } <span style=color:#f92672>=</span> e {
</span></span><span style=display:flex><span>            Some((<span style=color:#f92672>*</span>p, <span style=color:#f92672>*</span>color))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Validity checks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Counts of each color alien and house match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> alien_colors <span style=color:#f92672>=</span> aliens.iter().map(<span style=color:#f92672>|</span>(_, c)<span style=color:#f92672>|</span> c).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    alien_colors.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> house_colors <span style=color:#f92672>=</span> houses.iter().map(<span style=color:#f92672>|</span>(_, c)<span style=color:#f92672>|</span> c).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    house_colors.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert_eq!(
</span></span><span style=display:flex><span>        alien_colors, house_colors,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Alien and house counts don&#39;t match: {alien_colors:?} {house_colors:?}&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// No entities (from the original definition) overlap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> points <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (p, _) <span style=color:#66d9ef>in</span> definition.entities.iter() {
</span></span><span style=display:flex><span>        assert!(points.insert(<span style=color:#f92672>*</span>p), <span style=color:#e6db74>&#34;Entities overlap at {p:?}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The entrances and exits are all unique
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> points <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> definition.entrances.iter().chain(definition.exits.iter()) {
</span></span><span style=display:flex><span>        assert!(points.insert(<span style=color:#f92672>*</span>p), <span style=color:#e6db74>&#34;Entrance/exit overlap {p:?}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> local <span style=color:#f92672>=</span> CosmicExpressLocal {
</span></span><span style=display:flex><span>    path: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[global.entrance],
</span></span><span style=display:flex><span>    seats,
</span></span><span style=display:flex><span>    seat_goop,
</span></span><span style=display:flex><span>    aliens,
</span></span><span style=display:flex><span>    houses,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Not bad though!</p><h2 id=parameterizing-the-solver>Parameterizing the solver</h2><p>One thing I did for this puzzle that I hadn&rsquo;t otherwise done was to use <a href=https://docs.rs/lazy_static/latest/lazy_static/ target=_blank rel=noopener>lazy_static</a> to load several possible <code>env</code> variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>lazy_static! {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>DEBUG_PRINT</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_DEBUG_PRINT&#34;</span>).is_ok();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>FLOODFILL_VALIDATOR</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_FLOODFILL_VALIDATOR&#34;</span>).is_ok();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>HEURISTIC_COUNT_ENTITIES</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_HEURISTIC_COUNT_ENTITIES&#34;</span>).is_ok();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>HEURISTIC_NEAREST_HOUSE</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_HEURISTIC_NEAREST_HOUSE&#34;</span>).is_ok();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>HEURISTIC_HUG_WALLS</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_HEURISTIC_HUG_WALLS&#34;</span>).is_ok();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>ref</span> <span style=color:#66d9ef>USE_CUSTOM_HASH</span>: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;COSMIC_EXPRESS_CUSTOM_HASH&#34;</span>).is_ok();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order:</p><ul><li><code>DEBUG_PRINT</code> - prints out debug information, I could have just used env_logger, but this also avoids calculating the thing to print<ul><li>TODO: Can logger take in a closure?</li></ul></li><li><code>FLOODFILL_VALIDATOR</code> - see <a href=#floodfill-validator>floodfill validator</a>; I almost always use this one</li><li><code>HEURISTIC_COUNT_ENTITIES</code> - my simple original heuristic; doesn&rsquo;t work very well</li><li><code>HEURISTIC_NEAREST_HOUSE</code> - see <a href=#a-simple-heuristic>a simple heuristic</a></li><li><code>HEURISTIC_HUG_WALLS</code> - an experimental heuristic that attempted to solve the puzzle as I would; didn&rsquo;t really work</li><li><code>USE_CUSTOM_HASH</code> - see <a href=#a-custom-hash-function>a custom hash</a></li></ul><h3 id=a-simple-heuristic>A simple heuristic</h3><p>So how were these each implemented? Well, first, I want a heuristic that will make A* behave better:</p><ul><li>Guess at the following distances:<ul><li>Add the distance to the nearest alien</li><li>Add the distance between each alien and the closest house</li><li>Add the distance to the exit once we&rsquo;re out of aliens</li></ul></li></ul><p>It&rsquo;s a bit more than free to calculate, but it does make the program behave much better, so I almost always have it on.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> current_point <span style=color:#f92672>=</span> self.path.last().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Distance from the path to the nearest remaining alien
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(distance) <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>    .aliens
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>(alien_point, _)<span style=color:#f92672>|</span> alien_point.manhattan_distance(<span style=color:#f92672>*</span>current_point))
</span></span><span style=display:flex><span>    .min()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    heuristic <span style=color:#f92672>+=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Distance from each alien to the closest matching house
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (alien_point, alien_color) <span style=color:#66d9ef>in</span> self.aliens.iter() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nearest_house <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>        .houses
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, house_color)<span style=color:#f92672>|</span> house_color <span style=color:#f92672>==</span> alien_color)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(house_point, _)<span style=color:#f92672>|</span> alien_point.manhattan_distance(<span style=color:#f92672>*</span>house_point))
</span></span><span style=display:flex><span>        .min();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(distance) <span style=color:#f92672>=</span> nearest_house {
</span></span><span style=display:flex><span>        heuristic <span style=color:#f92672>+=</span> distance <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Also, distance to the exit if we&#39;re out of aliens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>heuristic <span style=color:#f92672>+=</span> current_point.manhattan_distance(global.exit) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span></code></pre></div><h3 id=floodfill-validator>Floodfill validator</h3><p>Next up, vastly improve the <code>is_valid</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>CosmicExpressGlobal, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> CosmicExpressLocal {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, g: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>CosmicExpressGlobal</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Flood fill from the current head, stopping at all walls and current path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we can&#39;t reach all remaining aliens, houses, and the exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>FLOODFILL_VALIDATOR</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> max_size <span style=color:#f92672>=</span> (g.width <span style=color:#f92672>*</span> g.height) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> reachable <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>            reachable.reserve(max_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> to_check <span style=color:#f92672>=</span> Vec::with_capacity(max_size);
</span></span><span style=display:flex><span>            to_check.push(<span style=color:#f92672>*</span>self.path.last().unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// All points current under a seat are reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This took a while to track down
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            self.path
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .rev()
</span></span><span style=display:flex><span>                .take(<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> self.seats.len())
</span></span><span style=display:flex><span>                .for_each(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    reachable.insert(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Flood fill from the head of the current path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(p) <span style=color:#f92672>=</span> to_check.pop() {
</span></span><span style=display:flex><span>                reachable.insert(p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Flood fill all empty points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> p.neighbors().into_iter() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Only check each point once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> reachable.contains(<span style=color:#f92672>&amp;</span>neighbor) <span style=color:#f92672>||</span> to_check.contains(<span style=color:#f92672>&amp;</span>neighbor) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Don&#39;t add points out of bounds (remember there&#39;s a border)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> neighbor.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> neighbor.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> neighbor.x <span style=color:#f92672>&gt;</span> g.width
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> neighbor.y <span style=color:#f92672>&gt;</span> g.height
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Keep expanding empty points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>(g.walls.contains(<span style=color:#f92672>&amp;</span>neighbor) <span style=color:#f92672>||</span> self.path.contains(<span style=color:#f92672>&amp;</span>neighbor)) {
</span></span><span style=display:flex><span>                        to_check.push(neighbor);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Expand all points by one: any alien or house *adjacent* to a reachable point is also reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> expanded <span style=color:#f92672>=</span> FxHashSet::default();
</span></span><span style=display:flex><span>            expanded.reserve(max_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> reachable.iter() {
</span></span><span style=display:flex><span>                expanded.insert(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> p.neighbors().into_iter() {
</span></span><span style=display:flex><span>                    expanded.insert(neighbor);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> reachable <span style=color:#f92672>=</span> expanded;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// All aliens and houses must be reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.aliens.iter().any(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>reachable.contains(p)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.houses.iter().any(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>reachable.contains(p)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// At least one exit must be reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>reachable.contains(<span style=color:#f92672>&amp;</span>g.exit) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// All validators passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is fairly expensive to calculate. To the point that you can actually see it generating and checking solutions noticeably slower. But conversely, it <em>really</em> cuts down on the number of states to check.</p><p>Basically, if the current path cuts off part of the level with an alien or house (since you can&rsquo;t cross over the path), you can no longer solve the puzzle. To calculate that, flood fill out from the head of the path and find all neighboring aliens/houses.</p><p>Pretty neat and made some levels much more solvable!</p><h3 id=a-custom-hash-function>A custom hash function</h3><p>Finally, an attempt that I was working on (but that didn&rsquo;t <em>really</em> go anywhere): a custom hashing function for <code>CosmicExpressLocal</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Hash <span style=color:#66d9ef>for</span> CosmicExpressLocal {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>&lt;</span>H: <span style=color:#a6e22e>std</span>:#<span style=color:#960050;background-color:#1e0010>️⃣</span>:<span style=color:#a6e22e>Hasher</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>self, state: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> H) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>USE_CUSTOM_HASH</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Getting to exactly the same points a different way counts as equal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// So long as the last step (where we&#39;ll expand from) is the same
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> path <span style=color:#f92672>=</span> self.path.clone();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> last <span style=color:#f92672>=</span> path.pop().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            path.sort();
</span></span><span style=display:flex><span>            path.push(last);
</span></span><span style=display:flex><span>            path.hash(state);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We don&#39;t care about which aliens since they don&#39;t move, just the list of remaining points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Sort so order is preserved
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> entities <span style=color:#f92672>=</span> Vec::with_capacity(self.aliens.len() <span style=color:#f92672>+</span> self.houses.len());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (p, _) <span style=color:#66d9ef>in</span> self.aliens.iter() {
</span></span><span style=display:flex><span>                entities.push(p);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (p, _) <span style=color:#66d9ef>in</span> self.houses.iter() {
</span></span><span style=display:flex><span>                entities.push(p);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            entities.sort();
</span></span><span style=display:flex><span>            entities.hash(state);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.seats.hash(state);
</span></span><span style=display:flex><span>            self.seat_goop.hash(state);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Default hashing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            self.path.hash(state);
</span></span><span style=display:flex><span>            self.seats.hash(state);
</span></span><span style=display:flex><span>            self.seat_goop.hash(state);
</span></span><span style=display:flex><span>            self.aliens.hash(state);
</span></span><span style=display:flex><span>            self.houses.hash(state);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically (as it says in the comments), the idea here is I don&rsquo;t actually care how we get to a specific path, so long as we&rsquo;ve covered the same elements in the path. So instead of hashing the path in order, we sort it then hash. Same with entities (since they don&rsquo;t move, just get removed).</p><p>This&mldr; didn&rsquo;t actually help that much. But it was a neat idea, so I thought I&rsquo;d include it!</p><h2 id=current-progress>Current progress</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo build --release --bin cosmic-express; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>testit <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --command <span style=color:#e6db74>&#34;./target/release/cosmic-express&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --env COSMIC_EXPRESS_FLOODFILL_VALIDATOR<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --env COSMIC_EXPRESS_HEURISTIC_NEAREST_HOUSE<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --files <span style=color:#e6db74>&#34;data/cosmic-express/*/*.json&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --timeout <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Finished <span style=color:#e6db74>`</span>release<span style=color:#e6db74>`</span> profile <span style=color:#f92672>[</span>optimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.03s
</span></span><span style=display:flex><span>data/cosmic-express/Andromeda/Andromeda 1.json: New success:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> ........
</span></span><span style=display:flex><span> ........
</span></span><span style=display:flex><span> .#......
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>────────<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span> ......#.
</span></span><span style=display:flex><span> ........
</span></span><span style=display:flex><span> ........
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... rest of levels here ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data/cosmic-express/Vela/Vela 5.json: New success:
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>     <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span> .│┌───┐│.
</span></span><span style=display:flex><span> .└┘.┌─┘│.
</span></span><span style=display:flex><span> ..##│##│.
</span></span><span style=display:flex><span> ..#.└┐#│.
</span></span><span style=display:flex><span> .┌──┐│┌┘.
</span></span><span style=display:flex><span> <span style=color:#75715e>#│#.└┘│.#</span>
</span></span><span style=display:flex><span> <span style=color:#75715e>#│##.#│#.</span>
</span></span><span style=display:flex><span> .│#...└┐.
</span></span><span style=display:flex><span> .└─────┘.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data/cosmic-express/Vela/Vela 6.json: Timeout
</span></span><span style=display:flex><span>data/cosmic-express/Vela/Vela 7.json: Timeout
</span></span><span style=display:flex><span>data/cosmic-express/Vela/Vela 8.json: Timeout
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Summary:
</span></span><span style=display:flex><span>	Successes: <span style=color:#ae81ff>26</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>26</span> new<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>	Failures: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	Timeouts: <span style=color:#ae81ff>27</span>
</span></span></code></pre></div><p>Well, I&rsquo;ve solved 26 levels so far! Actually 30 if I increase the timeout somewhat. But there are still dozens of levels that even with a significant timeout, I can&rsquo;t solve. It really comes down to the branching factor. The larger the level (and to a lesser extent, the more aliens I have to find), the worse it is and the longer it takes.</p><p>Plus, this is only solutions for Andromeda, Delphinus, Ursa Minor, Vela, and a start on Cassiopeia. There are at least 5 constellations left!</p><p>So far, I&rsquo;ve implemented:</p><ul><li>Simple trains</li><li>Multiple cars (only up to 2 so far)</li><li>Three alien species:<ul><li>Orange/Purple are normal</li><li>After a Green sits in a seat no other can ()</li></ul></li></ul><p>But at a quick look, I still need to deal with:</p><ul><li>&lsquo;Any&rsquo; hoses (which can take any color alien)</li><li>Warp portals (go in one, come out the other)</li><li>Even bigger levels!</li><li>Cross tracks (built in to the level)</li><li>Completion requirements</li></ul><p>Looks like fun!</p><p>But for now, we have some progress. I&rsquo;ll probably keep working on this. Perhaps a part 2!</p><p>Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>