<!doctype html><html><head><title>CodeCrafters: Build Myself an Interpreter â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>CodeCrafters: Build Myself an Interpreter</h1><div class=entry-meta><span class=entry-date>2024-09-04</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/08/12/stacklang-part-ix-better-testing/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/compilers>Compilers</a></li><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/interpreters>Interpreters</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/lexers>Lexers</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/lux>Lux</a></li><li><a class=taxonomy-value href=/programming/topics/parsering>Parsering</a></li><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/programming-languages>Programming Languages</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/tokenizers>Tokenizers</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/ class=previous-link></a><a class=taxonomy-value href=/series/codecrafters>CodeCrafters</a><a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/09/05/kitty-friends/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Didn&rsquo;t I <a href=https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/>just do one of these</a>? Well, yes. Yes I did. But I love building <a href=/programming/topics/compilers/>compilers and interpreters</a>, so when I saw this one was in beta (and thus free ðŸ˜‰), I had to try it!</p><p>It&rsquo;s directly an implemention of the Lox languages from the <a href=https://craftinginterpreters.com/ target=_blank rel=noopener>Crafting Interpreters</a> website / book (<a href=https://blog.jverkamp.com/2021/06/12/crafting-interpreters/>my review</a>), if incomplete. By the end of the lesson, we&rsquo;ll have:</p><ul><li>A <a href=https://en.wikipedia.org/wiki/tokenizer>tokenizer</a> that handles parentheses, braces, operators (single and multiple character), whitespace, identifiers, string literals, numeric literals, and keywords</li><li>A <a href=https://en.wikipedia.org/wiki/parser>parser</a> that can take those tokens and build an <a href=https://en.wikipedia.org/wiki/abstract%20syntax%20tree>abstract syntax tree</a> using <a href=https://en.wikipedia.org/wiki/recursive%20descent%20parsing>recursive descent parsing</a></li><li>A simple <a href=https://en.wikipedia.org/wiki/tree%20walking%20interpreter>tree walking interpreter</a> for some subset of the language</li></ul><p>It doesn&rsquo;t handle all of the syntax (yet). In particular, we don&rsquo;t have functions, control statements like <code>if</code> or <code>while</code> or custom <code>class</code>es. These seem&mldr; kind of important! But it&rsquo;s a start and something I can definitely see myself building more on it.</p><p>Let&rsquo;s do it!</p><nav id=TableOfContents><ul><li><a href=#quick-note>Quick note</a></li><li><a href=#command-line-interface>Command line interface</a></li><li><a href=#tokenizer>Tokenizer</a><ul><li><a href=#keywords-and-the-const_enum-macro>Keywords and the <code>const_enum!</code> macro</a></li><li><a href=#the-tokenizer-struct>The <code>Tokenizer</code> struct</a></li><li><a href=#impl-iteratoritem--token><code>impl Iterator&lt;Item = Token></code></a></li></ul></li><li><a href=#parser>Parser</a><ul><li><a href=#astnode-struct><code>AstNode</code> struct</a></li><li><a href=#parse_x-functions><code>parse_X</code> functions</a></li><li><a href=#peeking-into-the-tokenizer>Peeking into the tokenizer</a></li></ul></li><li><a href=#evaluator>Evaluator</a><ul><li><a href=#an-evaluate-trait>An <code>Evaluate</code> trait</a></li><li><a href=#adding-the-environment>Adding the environment</a></li><li><a href=#builtins>Builtins</a></li></ul></li><li><a href=#future-work>Future work</a><ul><li><a href=#finish-parsing>Finish parsing</a></li><li><a href=#spanned>Spanned</a></li><li><a href=#better-error-output>Better error output</a></li><li><a href=#typed>Typed</a></li><li><a href=#wasm-compiler>WASM Compiler</a></li></ul></li><li><a href=#thoughts>Thoughts</a></li><li><a href=#code-crafters-output-format>Code crafters output format</a></li></ul></nav><h2 id=quick-note>Quick note</h2><p>This represents the current state of my code as of the writing of this post: <a href=https://github.com/jpverkamp/jp-lox target=_blank rel=noopener>repo</a>. To see how it changed over time, you can of course look at the <a href=https://github.com/jpverkamp/jp-lox/commits/main/ target=_blank rel=noopener>git history</a>.</p><p>I expect I&rsquo;ll be working on this one a bit more, I&rsquo;ve already done a few things after finishing the current state of CodeCrafters.</p><h2 id=command-line-interface>Command line interface</h2><p>As I have several times before, I used <a href=https://docs.rs/clap/latest/clap/ target=_blank rel=noopener>clap</a> to write my CLI.</p><p>The original command line interface of the program was supposed to be: <code>jp-lox (tokenize|parse|evaluate) &lt;filename></code>, which works well enough as a clap <code>Subcommand</code>, but the problem was that it required duplicating the <code>input</code> file for each subcommand. Not my favorite. So instead, I ended up with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Implementation of the lox programming language for code crafters
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, ClapParser)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[clap(name = </span><span style=color:#e6db74>&#34;jp-lox&#34;</span><span style=color:#75715e>, version)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Debug mode
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[clap(short, long)]</span>
</span></span><span style=display:flex><span>    debug: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Subcommand to run
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[clap(subcommand)]</span>
</span></span><span style=display:flex><span>    command: <span style=color:#a6e22e>Command</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// The input file (or - for stdin)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(global=true)]</span>
</span></span><span style=display:flex><span>    input: Option<span style=color:#f92672>&lt;</span>FileOrStdin<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Subcommand)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Command</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Tokenize and print all tokens.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Tokenize,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Parse and print the AST.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Parse,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Evaluate the source expression.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Evaluate,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Run the source program.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Run,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This does (for better or for worse) allows the <code>input</code> file to be either before or after the command. Since the test cases expect it to be after, that&rsquo;s perfectly fine. It ends up generating this help file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Main help</span>
</span></span><span style=display:flex><span>$ cargo run -- --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Finished <span style=color:#e6db74>`</span>dev<span style=color:#e6db74>`</span> profile <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.01s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/debug/jp-lox --help<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>Implementation of the lox programming language <span style=color:#66d9ef>for</span> code crafters
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: jp-lox <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span> &lt;COMMAND&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  tokenize  Tokenize and print all tokens
</span></span><span style=display:flex><span>  parse     Parse and print the AST
</span></span><span style=display:flex><span>  evaluate  Evaluate the source expression
</span></span><span style=display:flex><span>  run       Run the source program
</span></span><span style=display:flex><span>  help      Print this message or the help of the given subcommand<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arguments:
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span>  The input file <span style=color:#f92672>(</span>or - <span style=color:#66d9ef>for</span> stdin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -d, --debug    Debug mode
</span></span><span style=display:flex><span>  -h, --help     Print help
</span></span><span style=display:flex><span>  -V, --version  Print version
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># For the tokenize subcommand, basically the same for the others</span>
</span></span><span style=display:flex><span>$ cargo run -- tokenize --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Finished <span style=color:#e6db74>`</span>dev<span style=color:#e6db74>`</span> profile <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.01s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/debug/jp-lox tokenize --help<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>Tokenize and print all tokens
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: jp-lox tokenize <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arguments:
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span>  The input file <span style=color:#f92672>(</span>or - <span style=color:#66d9ef>for</span> stdin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -h, --help  Print help
</span></span></code></pre></div><p>That&rsquo;s not bad!</p><p>The for the rest of <code>main.rs</code>, we basically load the input file (handling <code>-</code> as stdin as well, to better match <a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/>testit</a>) and then run through each step in turn. If that&rsquo;s the step we stop at, print it&rsquo;s output and exit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> args <span style=color:#f92672>=</span> Args::parse();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.debug {
</span></span><span style=display:flex><span>        env_logger::Builder::new()
</span></span><span style=display:flex><span>            .filter_level(log::LevelFilter::Debug)
</span></span><span style=display:flex><span>            .init();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        env_logger::init();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ----- Shared filename / contents loading -----
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> source <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> args.input.is_none() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>.to_string();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> contents <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>        std::io::stdin().read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> contents)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        NamedSource::new(name, contents)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> args.input.unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.is_file() {
</span></span><span style=display:flex><span>            input.filename().to_string()
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>.to_string()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> contents <span style=color:#f92672>=</span> input.contents()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        NamedSource::new(name, contents)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ----- Tokenizing -----
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    log::debug!(<span style=color:#e6db74>&#34;Tokenizing...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> tokenizer <span style=color:#f92672>=</span> Tokenizer::new(<span style=color:#f92672>&amp;</span>source.bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Command::Tokenize <span style=color:#f92672>=</span> args.command {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> token <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> tokenizer {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, token.code_crafters_format());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> tokenizer.had_errors() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> error <span style=color:#66d9ef>in</span> tokenizer.iter_errors() {
</span></span><span style=display:flex><span>                eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, error);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            std::process::exit(<span style=color:#ae81ff>65</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ----- Parsing -----
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    log::debug!(<span style=color:#e6db74>&#34;Parsing...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> parser <span style=color:#f92672>=</span> Parser::from(tokenizer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ast <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> parser.parse() {
</span></span><span style=display:flex><span>        Ok(ast) <span style=color:#f92672>=&gt;</span> ast,
</span></span><span style=display:flex><span>        Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e);
</span></span><span style=display:flex><span>            std::process::exit(<span style=color:#ae81ff>65</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> parser.tokenizer_had_errors() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> error <span style=color:#66d9ef>in</span> parser.tokenizer_iter_errors() {
</span></span><span style=display:flex><span>            eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, error);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std::process::exit(<span style=color:#ae81ff>65</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Command::Parse <span style=color:#f92672>=</span> args.command {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, ast);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ----- Evaluating -----
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> args.command {
</span></span><span style=display:flex><span>        Command::Evaluate <span style=color:#f92672>|</span> Command::Run <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> env <span style=color:#f92672>=</span> EnvironmentStack::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> ast.evaluate(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> env) {
</span></span><span style=display:flex><span>                Ok(value) <span style=color:#f92672>=&gt;</span> value,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e);
</span></span><span style=display:flex><span>                    std::process::exit(<span style=color:#ae81ff>70</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Eval prints the last command, run doesn&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// For *reasons* numbers should&#39;t print .0 here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Command::Evaluate <span style=color:#f92672>=</span> args.command {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> output {
</span></span><span style=display:flex><span>                    values::Value::Number(n) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{n}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, output),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Command::Run <span style=color:#f92672>=</span> args.command {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Success (so far)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That seems pretty decent to me!</p><h2 id=tokenizer>Tokenizer</h2><p>Next up, <code>mod tokenizer</code>. I used a few crates here to make my life a bit cleaner:</p><ul><li><a href=https://crates.io/crates/convert_case target=_blank rel=noopener><code>convert_case</code></a> - The test cases require output like <code>LEFT_PAREN</code> instead of <code>LeftParen</code>, this did that for free (<a href=#thoughts>comments</a>)</li><li><a href=https://crates.io/crates/derive_more target=_blank rel=noopener><code>derive_more</code></a> - Adds the ability to <code>#[derive(Display)]</code>, which is nice</li><li><a href=https://crates.io/crates/thiserror target=_blank rel=noopener><code>thiserror</code></a> - Simplifies error handling, I started a conversion to this from only <code>anyhow!</code>. I&rsquo;m not sure what to think about this.</li></ul><p>After that, we have a <code>Token</code>. This ends up being fairly simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// span.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Span</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> line: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> start: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> end: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// tokenizer.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug, Display, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Token</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>EOF</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[display(</span><span style=color:#e6db74>&#34;{}&#34;</span><span style=color:#75715e>, _1)]</span>
</span></span><span style=display:flex><span>    Keyword(Span, Keyword),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[display(</span><span style=color:#e6db74>&#34;{}&#34;</span><span style=color:#75715e>, _2)]</span>
</span></span><span style=display:flex><span>    Literal(Span, String, Value),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[display(</span><span style=color:#e6db74>&#34;{}&#34;</span><span style=color:#75715e>, _1)]</span>
</span></span><span style=display:flex><span>    Identifier(Span, String),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <code>Keyword</code> is any reserved <code>Identifier</code> and also includes symbolic operators. So things like <code>print</code> but also things like <code>+</code> and <code>==</code>.</p><h3 id=keywords-and-the-const_enum-macro>Keywords and the <code>const_enum!</code> macro</h3><p>So to write the keywords, I originally had code like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Keyword</span> {
</span></span><span style=display:flex><span>    LeftParen,
</span></span><span style=display:flex><span>    RightParen,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Keyword {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> s {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>=&gt;</span> Keyword::LeftParen,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>=&gt;</span> Keyword::RightParen,
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Unknown keyword: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Into<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Keyword {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into</span>(self) -&gt; <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Keyword::LeftParen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;(&#34;</span>,
</span></span><span style=display:flex><span>            Keyword::RightParen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;)&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This got kind of annoying. So I wrote a macro that let me do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Define keywords which are based on strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>const_enum! {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> Keyword <span style=color:#66d9ef>as</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Match these first to avoid partial matches (ex == vs =)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        EqualEqual <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;==&#34;</span>,
</span></span><span style=display:flex><span>        BangEqual <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;!=&#34;</span>,
</span></span><span style=display:flex><span>        LessEqual <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;&lt;=&#34;</span>,
</span></span><span style=display:flex><span>        GreaterEqual <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;&gt;=&#34;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        And <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;and&#34;</span>,
</span></span><span style=display:flex><span>        Class <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;class&#34;</span>,
</span></span><span style=display:flex><span>        Else <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;else&#34;</span>,
</span></span><span style=display:flex><span>        False <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;false&#34;</span>,
</span></span><span style=display:flex><span>        For <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;for&#34;</span>,
</span></span><span style=display:flex><span>        Fun <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;fun&#34;</span>,
</span></span><span style=display:flex><span>        If <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;if&#34;</span>,
</span></span><span style=display:flex><span>        Nil <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;nil&#34;</span>,
</span></span><span style=display:flex><span>        Or <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;or&#34;</span>,
</span></span><span style=display:flex><span>        Print <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;print&#34;</span>,
</span></span><span style=display:flex><span>        Return <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;return&#34;</span>,
</span></span><span style=display:flex><span>        Super <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;super&#34;</span>,
</span></span><span style=display:flex><span>        This <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;this&#34;</span>,
</span></span><span style=display:flex><span>        True <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;true&#34;</span>,
</span></span><span style=display:flex><span>        Var <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;var&#34;</span>,
</span></span><span style=display:flex><span>        While <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;while&#34;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        LeftParen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;(&#34;</span>,
</span></span><span style=display:flex><span>        RightParen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;)&#34;</span>,
</span></span><span style=display:flex><span>        LeftBrace <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;{&#34;</span>,
</span></span><span style=display:flex><span>        RightBrace <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;}&#34;</span>,
</span></span><span style=display:flex><span>        Comma <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;,&#34;</span>,
</span></span><span style=display:flex><span>        Dot <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;.&#34;</span>,
</span></span><span style=display:flex><span>        Semicolon <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;;&#34;</span>,
</span></span><span style=display:flex><span>        Plus <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;+&#34;</span>,
</span></span><span style=display:flex><span>        Minus <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;-&#34;</span>,
</span></span><span style=display:flex><span>        Star <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;*&#34;</span>,
</span></span><span style=display:flex><span>        Slash <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;/&#34;</span>,
</span></span><span style=display:flex><span>        Equal <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;=&#34;</span>,
</span></span><span style=display:flex><span>        Bang <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;!&#34;</span>,
</span></span><span style=display:flex><span>        Less <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;&lt;&#34;</span>,
</span></span><span style=display:flex><span>        Greater <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;&gt;&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This defines the enum, implements <code>TryFrom</code>, implements <code>to_value</code> (rather than <code>Into</code> for no particular reason), and implements <code>values()</code> which returns a <code>Vec</code> of all options in a map.</p><p>Just like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[macro_export]</span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> const_enum {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$vis</span>:<span style=color:#a6e22e>vis</span> <span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span> <span style=color:#66d9ef>as</span> <span style=color:#75715e>$type</span>:<span style=color:#a6e22e>ty</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>$($value</span>:<span style=color:#a6e22e>ident</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$char</span>:<span style=color:#a6e22e>expr</span>),<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>    }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Debug, Display, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>$vis</span> <span style=color:#66d9ef>enum</span> <span style=color:#75715e>$name</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>$($value</span>),<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>impl</span> <span style=color:#75715e>$name</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>to_value</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#75715e>$type</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> <span style=color:#f92672>*</span>self {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>$name</span>::<span style=color:#75715e>$value</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$char</span>,
</span></span><span style=display:flex><span>                    )<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>values</span>() -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#75715e>$name</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                vec![<span style=color:#75715e>$($name</span>::<span style=color:#75715e>$value</span>),<span style=color:#f92672>+</span>]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span><span style=color:#75715e>$type</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> <span style=color:#75715e>$name</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(value: <span style=color:#75715e>$type</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>$char</span> <span style=color:#f92672>=&gt;</span> Ok(<span style=color:#75715e>$name</span>::<span style=color:#75715e>$value</span>),
</span></span><span style=display:flex><span>                    )<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> Err(()),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s pretty clean!</p><h3 id=the-tokenizer-struct>The <code>Tokenizer</code> struct</h3><p>Next up, the <code>Tokenizer</code> struct itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The current state of the tokenizer, use it as an iterator (in general)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Tokenizer</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Internal state stored as raw bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) source: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    byte_pos: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Internal state stored as utf8 characters, processed once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    chars: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    char_pos: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The current position of the iterator in the source code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    line: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flag that the iterator has already emitted EOF, so should not iterate any more
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    emitted_eof: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Collect tokenizer errors this tokenizer has encountered.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    errors: Vec<span style=color:#f92672>&lt;</span>TokenizerError<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The currently peeked token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    peeked: Option<span style=color:#f92672>&lt;</span>Token<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This takes in the source code and keeps track of where in the token steam it is. Basically, we&rsquo;re going to <code>impl Iterator&lt;Item = Token></code> (technically with <code>Peekable</code> inlined as well, see <a href=#peeking-into-the-tokenizer>Peeking into the tokenizer</a>).</p><h3 id=impl-iteratoritem--token><code>impl Iterator&lt;Item = Token></code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> Tokenizer<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> Token;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ve already consumed the iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.emitted_eof {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we have a peeked token, clear and return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(token) <span style=color:#f92672>=</span> self.peeked.take() {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Clearing peeked token: {}&#34;</span>, token);
</span></span><span style=display:flex><span>            self.peeked <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(token);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ve reached the end of the source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.char_pos <span style=color:#f92672>&gt;=</span> self.chars.len() {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Reached EOF&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.emitted_eof <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(Token::<span style=color:#66d9ef>EOF</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to match comments, from // to EOL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.char_pos <span style=color:#f92672>&lt;</span> self.chars.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self.chars[self.char_pos] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> self.chars[self.char_pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Matching comment&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> self.char_pos <span style=color:#f92672>&lt;</span> self.chars.len() <span style=color:#f92672>&amp;&amp;</span> self.chars[self.char_pos] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\n&#39;</span> {
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.next();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read strings, currently there is no escaping, so read until a matching &#34; or EOL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we reach EOL, report an error and continue on the next line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.chars[self.char_pos] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#34;&#39;</span> {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Matching string&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> value <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>            self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            self.byte_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.char_pos <span style=color:#f92672>&gt;=</span> self.chars.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> error_span <span style=color:#f92672>=</span> Span {
</span></span><span style=display:flex><span>                        line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                        start,
</span></span><span style=display:flex><span>                        end: <span style=color:#a6e22e>self</span>.char_pos,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>                    self.errors
</span></span><span style=display:flex><span>                        .push(TokenizerError::UnterminatedString(error_span));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> self.next();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.chars[self.char_pos] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#34;&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.chars[self.char_pos] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span> {
</span></span><span style=display:flex><span>                    self.line <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> self.chars[self.char_pos];
</span></span><span style=display:flex><span>                value.push(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> c.len_utf8();
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Consume closing &#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            self.byte_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(Token::Literal(
</span></span><span style=display:flex><span>                Span {
</span></span><span style=display:flex><span>                    line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                    start,
</span></span><span style=display:flex><span>                    end,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                format!(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>{value}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>                Value::String(value),
</span></span><span style=display:flex><span>            ));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read numbers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Numbers must start with a digit (cannot do .1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Numbers can contain a single . (cannot do 1.2.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Numbers must have a digit after the . (cannot do 1. That&#39;s two tokens)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.chars[self.char_pos].is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Matching number&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lexeme <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> has_dot <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> last_dot <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> self.char_pos <span style=color:#f92672>&lt;</span> self.chars.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> self.chars[self.char_pos];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>                    lexeme.push(c);
</span></span><span style=display:flex><span>                    last_dot <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>has_dot {
</span></span><span style=display:flex><span>                    lexeme.push(c);
</span></span><span style=display:flex><span>                    has_dot <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    last_dot <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If the last character was a dot, we need to back up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> last_dot {
</span></span><span style=display:flex><span>                lexeme.pop();
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> value: <span style=color:#66d9ef>f64</span> <span style=color:#f92672>=</span> lexeme.parse().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(Token::Literal(
</span></span><span style=display:flex><span>                Span {
</span></span><span style=display:flex><span>                    line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                    start,
</span></span><span style=display:flex><span>                    end,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                lexeme,
</span></span><span style=display:flex><span>                Value::Number(value),
</span></span><span style=display:flex><span>            ));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read constant values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (lexeme, value) <span style=color:#66d9ef>in</span> Value::<span style=color:#66d9ef>CONSTANT_VALUES</span>.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> lexeme_chars <span style=color:#f92672>=</span> lexeme.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.chars[self.char_pos<span style=color:#f92672>..</span>].starts_with(<span style=color:#f92672>&amp;</span>lexeme_chars) {
</span></span><span style=display:flex><span>                log::debug!(<span style=color:#e6db74>&#34;Matching constant: {}&#34;</span>, lexeme);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> lexeme.len();
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> lexeme.len();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(Token::Literal(
</span></span><span style=display:flex><span>                    Span {
</span></span><span style=display:flex><span>                        line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                        start,
</span></span><span style=display:flex><span>                        end,
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    lexeme.to_string(),
</span></span><span style=display:flex><span>                    value.clone(),
</span></span><span style=display:flex><span>                ));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Match identifiers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Identifiers start with a letter or _
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Identifiers can contain letters, numbers, and _
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.chars[self.char_pos].is_alphabetic() <span style=color:#f92672>||</span> self.chars[self.char_pos] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;_&#39;</span> {
</span></span><span style=display:flex><span>            log::debug!(<span style=color:#e6db74>&#34;Matching identifier&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> value <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> self.char_pos <span style=color:#f92672>&lt;</span> self.chars.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> self.chars[self.char_pos];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> c.is_alphanumeric() <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;_&#39;</span> {
</span></span><span style=display:flex><span>                    value.push(c);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check if it&#39;s actually a keyword
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This is called &#39;maximal munch&#39;, so superduper doesn&#39;t get parsed as &lt;super&gt;&lt;duper&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(keyword) <span style=color:#f92672>=</span> Keyword::try_from(value.as_str()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(Token::Keyword(
</span></span><span style=display:flex><span>                    Span {
</span></span><span style=display:flex><span>                        line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                        start,
</span></span><span style=display:flex><span>                        end,
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    keyword,
</span></span><span style=display:flex><span>                ));
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(Token::Identifier(
</span></span><span style=display:flex><span>                    Span {
</span></span><span style=display:flex><span>                        line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                        start,
</span></span><span style=display:flex><span>                        end,
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    value,
</span></span><span style=display:flex><span>                ));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Match remaining keywords, this will include ones that are symbolic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> keyword <span style=color:#66d9ef>in</span> Keyword::values() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> pattern <span style=color:#f92672>=</span> keyword.to_value();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> pattern_chars <span style=color:#f92672>=</span> pattern.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.chars[self.char_pos<span style=color:#f92672>..</span>].starts_with(<span style=color:#f92672>&amp;</span>pattern_chars) {
</span></span><span style=display:flex><span>                log::debug!(<span style=color:#e6db74>&#34;Matching keyword: {}&#34;</span>, keyword);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>                self.byte_pos <span style=color:#f92672>+=</span> pattern.len();
</span></span><span style=display:flex><span>                self.char_pos <span style=color:#f92672>+=</span> pattern_chars.len();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> self.char_pos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(Token::Keyword(
</span></span><span style=display:flex><span>                    Span {
</span></span><span style=display:flex><span>                        line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                        start,
</span></span><span style=display:flex><span>                        end,
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                    keyword,
</span></span><span style=display:flex><span>                ));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The only things that should be left are whitespace
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Anything else is an error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> self.chars[self.char_pos];
</span></span><span style=display:flex><span>        self.char_pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        self.byte_pos <span style=color:#f92672>+=</span> c.len_utf8();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Newlines don&#39;t emit a token, but &#39;\n&#39; does increment the line number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> c.is_whitespace() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span> {
</span></span><span style=display:flex><span>                self.line <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self.next();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Anything else should emit an error and continue as best we can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.errors.push(TokenizerError::UnexpectedCharacter(
</span></span><span style=display:flex><span>            Span {
</span></span><span style=display:flex><span>                line: <span style=color:#a6e22e>self</span>.line,
</span></span><span style=display:flex><span>                start: <span style=color:#a6e22e>self</span>.char_pos,
</span></span><span style=display:flex><span>                end: <span style=color:#a6e22e>self</span>.char_pos,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            c,
</span></span><span style=display:flex><span>        ));
</span></span><span style=display:flex><span>        self.next()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I actually think this turned out fairly clean. We&rsquo;re using <code>self</code> to keep track of the current state, so basically we consume as much of that as we need to for whatever the next token is.</p><p>Along that time, we also need to track a <code>Span</code> for where each token came from. Eventually, I want to put that in a <a href=#spanned>wrapper type <code>Spanned</code></a>, but not for now.</p><p>And that&rsquo;s it, we have a working <code>tokenizer</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;print &#34;Hello&#34; + &#34; World!&#34;;&#39;</span> | jp-lox tokenize -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PRINT print null
</span></span><span style=display:flex><span>STRING <span style=color:#e6db74>&#34;Hello&#34;</span> Hello
</span></span><span style=display:flex><span>PLUS + null
</span></span><span style=display:flex><span>STRING <span style=color:#e6db74>&#34; World!&#34;</span>  World!
</span></span><span style=display:flex><span>SEMICOLON ; null
</span></span><span style=display:flex><span>EOF  null
</span></span></code></pre></div><p>Pretty cool.</p><h2 id=parser>Parser</h2><p>Okay, next up, we want to take that stream of tokens and turn it in an <a href=https://en.wikipedia.org/wiki/abstract%20syntax%20tree>abstract syntax tree</a>. There are a few different algorithms for this, but we&rsquo;ll go ahead and implement the <a href=https://en.wikipedia.org/wiki/recursive%20descent%20parser>recursive descent parser</a> from the book (and recommended by CodeCrafters). For that, we have a series of nested <code>parse_X</code> functions.</p><h3 id=astnode-struct><code>AstNode</code> struct</h3><p>But first, the struct, constructor, and a <code>Display</code> function that outputs <a href=https://en.wikipedia.org/wiki/s-expressions>s-expressions</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Parser</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    tokenizer: <span style=color:#a6e22e>Tokenizer</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>AstNode</span> {
</span></span><span style=display:flex><span>    Literal(Span, Value),
</span></span><span style=display:flex><span>    Symbol(Span, String),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Group(Span, Vec<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>), <span style=color:#75715e>// No new scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Block(Span, Vec<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>), <span style=color:#75715e>// New scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Application(Span, Box<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>, Vec<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Declaration(Span, String, Box<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>), <span style=color:#75715e>// Creates new variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Assignment(Span, String, Box<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>),  <span style=color:#75715e>// Sets values, error on undeclared
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Program(Span, Vec<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;</span>Tokenizer<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>for</span> Parser<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#a6e22e>Tokenizer</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Parser { tokenizer: <span style=color:#a6e22e>value</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Display <span style=color:#66d9ef>for</span> AstNode {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            AstNode::Literal(_, value) <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, value),
</span></span><span style=display:flex><span>            AstNode::Symbol(_, name) <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, name),
</span></span><span style=display:flex><span>            AstNode::Declaration(_, name, value) <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;(var {} {})&#34;</span>, name, value),
</span></span><span style=display:flex><span>            AstNode::Assignment(_, name, value) <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;(= {} {})&#34;</span>, name, value),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Group(_, nodes) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;(group&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> nodes {
</span></span><span style=display:flex><span>                    write!(f, <span style=color:#e6db74>&#34; {}&#34;</span>, node)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;)&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                std::fmt::Result::Ok(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Block(_, nodes) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;{{&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> first <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> nodes {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> first {
</span></span><span style=display:flex><span>                        write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, node)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                        first <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        write!(f, <span style=color:#e6db74>&#34; {}&#34;</span>, node)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;}}&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                std::fmt::Result::Ok(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Application(_, func, args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;({}&#34;</span>, func)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> arg <span style=color:#66d9ef>in</span> args {
</span></span><span style=display:flex><span>                    write!(f, <span style=color:#e6db74>&#34; {}&#34;</span>, arg)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                write!(f, <span style=color:#e6db74>&#34;)&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                std::fmt::Result::Ok(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Program(_, nodes) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> nodes {
</span></span><span style=display:flex><span>                    write!(f, <span style=color:#e6db74>&#34;{}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, node)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                std::fmt::Result::Ok(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=parse_x-functions><code>parse_X</code> functions</h3><p>First, at the &rsquo;top&rsquo; of the parse tree, the <code>parse</code> function itself. Takes the (internal) tokenizer and repeatedly <code>parse_declaration</code> until we have a <code>Program</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Parser<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nodes <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> span <span style=color:#f92672>=</span> Span::<span style=color:#66d9ef>ZERO</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(token) <span style=color:#f92672>=</span> self.tokenizer.peek() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> token <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>Token::<span style=color:#66d9ef>EOF</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> self.parse_declaration()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            span <span style=color:#f92672>=</span> span.merge(<span style=color:#f92672>&amp;</span>node.span());
</span></span><span style=display:flex><span>            nodes.push(node);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(AstNode::Program(span, nodes))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Why <code>parse_declaration</code>? That&rsquo;s the highest level of binding, a statement that is either <code>var x;</code> or <code>var y = 5;</code> or a <code>parse_statement</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_declaration</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    log::debug!(<span style=color:#e6db74>&#34;parse_declaration&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> self.tokenizer.peek() {
</span></span><span style=display:flex><span>        Some(Token::Keyword(_, Keyword::Var)) <span style=color:#f92672>=&gt;</span> self.parse_var_statement(),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> self.parse_statement(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Likewise, <code>parse_statement</code> is a block (if the next token is <code>{</code>), a <code>print</code> statement, or falls through to an <code>expression_statement</code>.</p><p><code>parse_block</code> is an interesting one, since it parses until it sees a <code>}</code> but otherwise &rsquo;escapes&rsquo; all the way back up to <code>parse_declaration</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_block</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> left_brace <span style=color:#f92672>=</span> self.tokenizer.next().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> span <span style=color:#f92672>=</span> left_brace.span();
</span></span><span style=display:flex><span>    log::debug!(<span style=color:#e6db74>&#34;parse_block @ {span:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nodes <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(token) <span style=color:#f92672>=</span> self.tokenizer.peek() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Token::Keyword(_, Keyword::RightBrace) <span style=color:#f92672>=</span> token {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> node <span style=color:#f92672>=</span> self.parse_declaration()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        nodes.push(node);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> right_brace <span style=color:#f92672>=</span> self.tokenizer.next().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> span <span style=color:#f92672>=</span> span.merge(<span style=color:#f92672>&amp;</span>right_brace.span());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(AstNode::Block(span, nodes))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next down the tree, we have <code>parse_expression_statement</code>. This one I diverged a bit from the expected code, since I want to be able to parse either single expressions (<code>2 + 3</code>) or statements (ending with <code>;</code>). So I have to have each end with either a <code>;</code> or the end of file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_expression_statement</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>AstNode<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expression <span style=color:#f92672>=</span> self.parse_expression()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO: Should the span include this ;?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Currently I can&#39;t, since I can&#39;t set the expresion&#39;s span
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    self.consume_semicolon_or_eof()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(expression)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And so on we continue down the tree, parsing each expression in descending order of precedence. This is how <a href=https://en.wikipedia.org/wiki/recursive%20descent%20parsers>recursive descent parsers</a> handle correctly building a tree for something like <code>2 + 3 * 4</code> with <code>3 * 4</code> evaluated first.</p><p>But in the end, that&rsquo;s all we need to make a parser!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#e6db74>&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var x = &#34;Hello&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var y = &#34; World!&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>print x + y;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;</span> | jp-lox parse -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>var x <span style=color:#e6db74>&#34;Hello&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>var y <span style=color:#e6db74>&#34; World!&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>print <span style=color:#f92672>(</span>+ x y<span style=color:#f92672>))</span>
</span></span></code></pre></div><p>Not bad, eh?</p><h3 id=peeking-into-the-tokenizer>Peeking into the tokenizer</h3><p>One thing that we did use a few times in various <code>parse_X</code> functions was <code>Tokenizer::peek</code>. Originally I stored the <code>Parser</code> as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Parser</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    tokenizer: <span style=color:#a6e22e>Peekable</span><span style=color:#f92672>&lt;</span>Tokenizer<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which worked for that, but meant that I couldn&rsquo;t get direct access to any of the methods on <code>Tokenizer</code> (since they&rsquo;re not on <code>Peekable</code> and you can&rsquo;t get a reference). So instead, I just implemented <code>.peek()</code> myself on <code>Tokenizer</code>. If we call <code>.peek()</code>, get the <code>.next()</code> value, cache it, and return it. If we have a cached value when we <code>.next()</code>, clear the cache, and return it. It&rsquo;s just that east! (I expect that&rsquo;s how <code>Peekable</code> is implemented.)</p><h2 id=evaluator>Evaluator</h2><p>Okay, we&rsquo;ve got an AST, so we should be able to evaluate it, yes? Well, there are actually two different commands that we might want to do here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;2 + 3&#39;</span> | jp-lox evaluate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;2 + 3&#39;</span> | jp-lox run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;print(2 + 3);&#39;</span> | jp-lox evaluate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>nil
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;print(2 + 3);&#39;</span> | jp-lox run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>Essentially, <code>evaluate</code> will run a single expression (or a sequence of expressions) and print out the result of the last expression (thus the extra <code>nil</code> in the third example).</p><p><code>run</code> on the other hand is designed for entire programs and will not print out anything that isn&rsquo;t <code>print</code>ed.</p><p>Weird distinction? A bit. But it works.</p><h3 id=an-evaluate-trait>An <code>Evaluate</code> trait</h3><p>So I wanted to leave myself the option of being able to <code>Evaluate</code> other things than <code>AstNode</code>, so I made <code>Evaluate</code> a <code>trait</code> instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Evaluate {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#f92672>&amp;</span>self, env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>impl</span> Environment<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Originally, I didn&rsquo;t have that <code>Environment</code>, we&rsquo;ll cover that <a href=#adding-the-environment>in a bit</a>.</p><p>Evaluation (at this level), is actually surprisingly straight forward. If we have a leaf node (like a <code>Literal</code>), return it&rsquo;s value. Otherwise, evaluate any child nodes (like for a <code>Program</code> or the <code>args</code> to a <code>Builtin</code>) recursively then evaluate me.</p><p>Here, we use the <code>env</code> in <code>Symbol</code> (if we&rsquo;re getting an <code>Identifier</code> that we defined with a <code>var</code> earlier) or in <code>var</code> / assignment. We also introduce scopes with <code>Block</code>, again we&rsquo;ll <a href=#adding-the-environment>come back to that</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Evaluate <span style=color:#66d9ef>for</span> AstNode {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#f92672>&amp;</span>self, env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>impl</span> Environment<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            AstNode::Literal(_, value) <span style=color:#f92672>=&gt;</span> Ok(value.clone()),
</span></span><span style=display:flex><span>            AstNode::Symbol(span, name) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Keywords become builtins; fall back to env; then error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> Keyword::try_from(name.as_str()).is_ok() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Ok(Value::Builtin(name.clone()));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> env.get(name) {
</span></span><span style=display:flex><span>                    Some(value) <span style=color:#f92672>=&gt;</span> Ok(value),
</span></span><span style=display:flex><span>                    None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> span.line;
</span></span><span style=display:flex><span>                        Err(anyhow!(<span style=color:#e6db74>&#34;[line {line}] Undefined variable &#39;{name}&#39;&#34;</span>))
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Program(_, nodes) <span style=color:#f92672>|</span> AstNode::Group(_, nodes) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> last <span style=color:#f92672>=</span> Value::Nil;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> nodes {
</span></span><span style=display:flex><span>                    last <span style=color:#f92672>=</span> node.evaluate(env)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Ok(last)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Block(_, nodes) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                env.enter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> last <span style=color:#f92672>=</span> Value::Nil;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> nodes {
</span></span><span style=display:flex><span>                    last <span style=color:#f92672>=</span> node.evaluate(env)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                env.exit();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Ok(last)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Application(_span, func, args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> arg_values <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> arg <span style=color:#66d9ef>in</span> args {
</span></span><span style=display:flex><span>                    arg_values.push(arg.evaluate(env)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> func.evaluate(env)<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>                    Value::Builtin(name) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> callable <span style=color:#f92672>=</span> BuiltIn::try_from(name.as_str())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                        callable.call(arg_values)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> unimplemented!(<span style=color:#e6db74>&#34;Only built ins are implemented&#34;</span>),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Declaration(_, name, body) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> body.evaluate(env)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                env.set(name, value.clone());
</span></span><span style=display:flex><span>                Ok(value)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            AstNode::Assignment(span, name, body) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> env.get(name).is_none() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> span.line;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(anyhow!(<span style=color:#e6db74>&#34;[line {line}] Undefined variable &#39;{name}&#39;&#34;</span>));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> body.evaluate(env)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                env.set(name, value.clone());
</span></span><span style=display:flex><span>                Ok(value)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s enough to evaluate a program!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#e6db74>&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var x = &#34;Hello&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var y = &#34; World!&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>print x + y;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;</span> | jp-lox run -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hello World!
</span></span></code></pre></div><p>Not bad!</p><h3 id=adding-the-environment>Adding the environment</h3><p>The first missing piece that you might be wondering about is the <code>Environment</code>. For that, we want to implement another trait:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Environment<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, key: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, key: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, value: <span style=color:#a6e22e>T</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>enter</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>exit</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are a few different ways that we can implement an <code>Environment</code>, but we always need to be able to <code>get</code>/<code>set</code> values and <code>enter</code>/<code>exit</code> scopes introduced by blocks.</p><p>For this specific implementation, I made an <code>EnvironmentStack&lt;T></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EnvironmentStack</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    stack: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(String, T)<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> EnvironmentStack<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            stack: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[vec![]],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: Clone<span style=color:#f92672>&gt;</span> Environment<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> EnvironmentStack<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, key: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> frame <span style=color:#66d9ef>in</span> self.stack.iter().rev() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (k, v) <span style=color:#66d9ef>in</span> frame.iter().rev() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> k <span style=color:#f92672>==</span> key {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(v.clone());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, key: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, value: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>        self.stack
</span></span><span style=display:flex><span>            .last_mut()
</span></span><span style=display:flex><span>            .unwrap()
</span></span><span style=display:flex><span>            .push((key.to_string(), value));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>enter</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        self.stack.push(vec![]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>exit</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        self.stack.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This stores each value as an <a href=https://en.wikipedia.org/wiki/association%20list>association list</a> with another list of those as scopes. When we <code>enter</code> a scope, add a new association list. <code>exit</code> pops the most recent. <code>get</code> starts at the end and down the stack until we either find the value or run out. <code>set</code> always writes to the top level&mldr; which may be an error now that I think about it.</p><p>What should this output?</p><pre tabindex=0><code class=language-lox data-lang=lox>var x = 5;
{
  x = 6;
  {
    var x = 7;
    print x;
  }
  print x;
}
print x;
</code></pre><p>I think that the <code>x = 6</code> should actually mutate the value assigned at the outer scope (with the <code>var x = 5;</code>), resulting in <code>7 5 5</code>. But because of how I implemented <code>set</code>, it outputs <code>7 6 5</code>. Oops!</p><p>The current interface doesn&rsquo;t actually work with this. We&rsquo;d need another <code>define</code> method. Or a <code>get_mut</code> method.</p><p>In any case, you might be wondering, why <code>EnvironmentStack&lt;T></code>? Especially when I&rsquo;m always going to be storing <code>Values</code>?</p><p>Well, I&rsquo;m not!</p><p>I haven&rsquo;t done it yet (<a href=#typed>future work</a>), but my goal is to be able to typecheck programs (so we can tell if you&rsquo;re trying to <code>5 + "strings"</code>). When doing that, I&rsquo;ll actually pseudo-evaulate the program, but instead of storing the actual values, I&rsquo;ll store <code>EnvironmentStack&lt;Type></code>. Or that&rsquo;s the plan. We&rsquo;ll see!</p><h3 id=builtins>Builtins</h3><p>Another thing you might have noticed is this block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>AstNode::Application(_span, func, args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> arg_values <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> arg <span style=color:#66d9ef>in</span> args {
</span></span><span style=display:flex><span>        arg_values.push(arg.evaluate(env)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> func.evaluate(env)<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>        Value::Builtin(name) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> callable <span style=color:#f92672>=</span> BuiltIn::try_from(name.as_str())<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            callable.call(arg_values)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> unimplemented!(<span style=color:#e6db74>&#34;Only built ins are implemented&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What is <code>let callable = BuiltIn::try_from(name.as_str())?;</code> and how does that work?</p><p>I went through a few different iterations of this, but again with the <a href=#typed>future typechecking</a> work, I wanted a central way to define builtins. So I ended up with this lovely macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> define_builtins {
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>$variant</span>:<span style=color:#a6e22e>ident</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>$token</span>:<span style=color:#a6e22e>literal</span> 
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>$args_pat</span>:<span style=color:#a6e22e>pat</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$body</span>:<span style=color:#a6e22e>tt</span>
</span></span><span style=display:flex><span>                ),<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        ),<span style=color:#f92672>+</span> 
</span></span><span style=display:flex><span>        <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>BuiltIn</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>$($variant</span>),<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> BuiltIn {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> anyhow::Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> s {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>$($token</span> <span style=color:#f92672>=&gt;</span> Ok(BuiltIn::<span style=color:#75715e>$variant</span>),)<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> Err(anyhow!(<span style=color:#e6db74>&#34;Unknown builtin: {}&#34;</span>, s)),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>impl</span> BuiltIn {
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[allow(unused_braces)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, args: Vec<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>$(</span>BuiltIn::<span style=color:#75715e>$variant</span> <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// Each builtin by symbol, eg +
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>match</span> args.as_slice() {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>$(</span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e>$args_pat</span> <span style=color:#f92672>=&gt;</span> { Ok(<span style=color:#75715e>$body</span>) },
</span></span><span style=display:flex><span>                            )<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                            _ <span style=color:#f92672>=&gt;</span> Err(anyhow!(<span style=color:#e6db74>&#34;Invalid arguments {args:?} for builtin: {}&#34;</span>, stringify!(<span style=color:#75715e>$variant</span>))),
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    },)<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&mldr; is a crazy looking thing. But what it ends up doing is it lets me define builtins (with overloading!) like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>define_builtins!{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Arithmetic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Plus <span style=color:#e6db74>&#34;+&#34;</span> {
</span></span><span style=display:flex><span>       [Number(a), Number(b)] <span style=color:#f92672>=&gt;</span> { Number(a <span style=color:#f92672>+</span> b) },
</span></span><span style=display:flex><span>       [String(a), String(b)] <span style=color:#f92672>=&gt;</span> { 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> std::string::String::new();
</span></span><span style=display:flex><span>            result.push_str(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>            result.push_str(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>            String(result)
</span></span><span style=display:flex><span>       },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    Minus <span style=color:#e6db74>&#34;-&#34;</span> {
</span></span><span style=display:flex><span>        [Number(a), Number(b)] <span style=color:#f92672>=&gt;</span> { Number(a <span style=color:#f92672>-</span> b) },
</span></span><span style=display:flex><span>        [Number(v)] <span style=color:#f92672>=&gt;</span> { Number(<span style=color:#f92672>-</span>v) },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    Times <span style=color:#e6db74>&#34;*&#34;</span> {
</span></span><span style=display:flex><span>        [Number(a), Number(b)] <span style=color:#f92672>=&gt;</span> { Number(a <span style=color:#f92672>*</span> b) },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    Divide <span style=color:#e6db74>&#34;/&#34;</span> {
</span></span><span style=display:flex><span>        [Number(a), Number(b)] <span style=color:#f92672>=&gt;</span> { Number(a <span style=color:#f92672>/</span> b) },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// I/O
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Print <span style=color:#e6db74>&#34;print&#34;</span> {
</span></span><span style=display:flex><span>        [Number(n)] <span style=color:#f92672>=&gt;</span> { println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, n); Nil },
</span></span><span style=display:flex><span>        [a] <span style=color:#f92672>=&gt;</span> { println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, a); Nil },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have the <code>$variant</code> that ends up stored directly in the <code>enum</code>, a <code>&amp;str</code> that we can look up which function we want by (I could have and probably will combine(d) this with my <code>Keywords</code>, but haven&rsquo;t yet), and a <code>match</code> like syntax that lets us unpack the <code>args</code> and match directly against them.</p><p>Pretty cool. Not going to lie.</p><p>It&rsquo;s even better, because it basically gives us syntax errors inline + lets us overload based on types.</p><p>This was pretty fun to write.</p><h2 id=future-work>Future work</h2><p>So. We have a very (very) basic lox program that can tokenize, parse, and evaluate simple lox programs. That&rsquo;s enough to implement everything CodeCrafters has as of now&mldr; but what else can I do with this?</p><h3 id=finish-parsing>Finish parsing</h3><p>Well, for one I can finish parsing/evaluating the rest of the language. At the very least (based on our keywords), we need to implement:</p><ul><li>control flow like <code>if</code> and <code>while</code></li><li>functions with <code>fun</code> and <code>return</code></li><li><a href=https://en.wikipedia.org/wiki/object%20oriented>object oriented</a> goodness with <code>class</code>, <code>this</code>, <code>.</code> (dot), and <code>super</code></li></ul><p>At the very least, I want to do the first two. We need control flow to make useful programs. And functions allow us to actually write pretty much everything. I&rsquo;ll probably do OO as well though.</p><h3 id=spanned>Spanned</h3><p>Another thing I want to do is rewrite how I handle spans. Currently, I have the <code>Span</code> as a field on <code>Token</code> and <code>AstNode</code>, but I don&rsquo;t like it. Instead, I&rsquo;d rather wrap them both in <code>Spanned&lt;T></code>. I think I might end up with issues like <code>Peekable</code> had, but we&rsquo;ll see.</p><h3 id=better-error-output>Better error output</h3><p>Most of the output format was required by CodeCrafters. I&rsquo;d really like to pull in something like the <a href=https://docs.rs/miette/latest/miette/ target=_blank rel=noopener>miette</a> crate to be able to point to the specific location in the source code where the errors are.</p><h3 id=typed>Typed</h3><p>Like <code>Spanned</code> <a href=#spanned>above</a>, I&rsquo;d also like to be able to add another level to the program (before <code>evaluate</code>) that handles <a href=https://en.wikipedia.org/wiki/type%20checking>type checking</a>. Specifically, I&rsquo;m thinking of making it return <code>Typed&lt;AstNode></code> with a type assigned to every node recursively. We&rsquo;ll see if that works with the recursive nature of <code>AstNode</code>, it might not!</p><h3 id=wasm-compiler>WASM Compiler</h3><p>I want to be able to compile the code. What better than compiling to WASM. It would give me a reason to learn about how <code>SharedMemory</code> works (for strings).</p><p>On the other hand, I never did quite get to it (yet) for <a href=https://blog.jverkamp.com/series/stacklang/>StackLang</a> so&mldr; we shall see!</p><h2 id=thoughts>Thoughts</h2><p>This was a fun prompt. I&rsquo;ve been meaning to do it since I <a href=https://blog.jverkamp.com/2021/06/12/crafting-interpreters/>read the book</a> and this was a good excuse. I think the CodeCrafters implementation needs some work (at least <code>if</code> and <code>while</code>, if not the rest, along with output weirdness (see below)), but it&rsquo;s a good start and I&rsquo;m glad to have done it!</p><p>Onward!</p><h2 id=code-crafters-output-format>Code crafters output format</h2><p>The tokenizer test cases required a very specific format to match what was in the original Crafting Interpreters book. For example, a number that came from the token <code>10.40</code> should be output as <code>NUMBER 10.40 10.4</code> (the type, <a href=https://en.wikipedia.org/wiki/lexeme>lexeme</a>, and value).</p><p>Not a huge fan, but I did write a function <code>Token::code_crafters_format</code> to handle this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Code crafters requires a very specific output format, implement it here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> Token {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>code_crafters_format</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Token::<span style=color:#66d9ef>EOF</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;EOF  null&#34;</span>.to_string(),
</span></span><span style=display:flex><span>            Token::Keyword(_, keyword) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> keyword.to_string().to_case(Case::ScreamingSnake);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> lexeme <span style=color:#f92672>=</span> keyword.to_value();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{name}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{lexeme}</span><span style=color:#e6db74> null&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Token::Literal(_, lexeme, value) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>                    Value::Nil <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;NIL nil null&#34;</span>.to_string();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Value::Bool(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> value.to_string().to_case(Case::ScreamingSnake);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{name}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{value}</span><span style=color:#e6db74> null&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Value::Number(_) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;NUMBER&#34;</span>,
</span></span><span style=display:flex><span>                    Value::String(_) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;STRING&#34;</span>,
</span></span><span style=display:flex><span>                    Value::Builtin(_) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;BUILTIN&#34;</span>,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{name}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{lexeme}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{value}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Token::Identifier(_, name) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                format!(<span style=color:#e6db74>&#34;IDENTIFIER </span><span style=color:#e6db74>{name}</span><span style=color:#e6db74> null&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>