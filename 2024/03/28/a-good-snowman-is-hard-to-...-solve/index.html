<!doctype html><html><head><title>A Good Snowman Is Hard To ... Solve? â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>A Good Snowman Is Hard To ... Solve?</h1><div class=entry-meta><span class=entry-date>2024-03-28</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2023/12/28/advent-of-code-2023-testing-and-timing/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/03/14/infinite-craft-bot/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/24/aoc-2022-day-24-blizzinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/sokoban>Sokoban</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a><a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/03/14/infinite-craft-bot/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/04/06/solving-sokobond/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/03/28/ms.-marvel-vol.-6-civil-war-ii/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/03/29/black-mirror-season-3/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>I enjoy puzzle games. I especially enjoy letting computers solve them for me ðŸ˜„. Once upon a time, I set up a <a href=https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/>framework for solving random things</a>. Let&rsquo;s solve some more.</p><p>Today: <a href=https://store.steampowered.com/app/316610/A_Good_Snowman_Is_Hard_To_Build/ target=_blank rel=noopener>A Good Snowman Is Hard To Build</a></p><p>It&rsquo;s a <a href=https://en.wikipedia.org/wiki/Sokoban>Sokoban</a> about making snowmen! You can push snowballs of three sizes around, collecting snow if you roll over it. You can push smaller snowballs onto bigger ones, stacking them. Or back off, in order to get around one another.</p><p>And that&rsquo;s really it.</p><p>There are some interesting twists (multiple snowmen, the ability to leave and re-enter levels, and even a whole second &lsquo;hard mode&rsquo;), but at a basic level, it&rsquo;s just pushing.</p><h2 id=representing-the-board>Representing the board</h2><p>So, how do we represent the board? Well, the map is made of walls, empty space, and snowy spaces. Snow can become empty when you roll over it, otherwise, these don&rsquo;t change. Which would mean that they could be good parts of <code>GlobalState</code> (the shared state that doesn&rsquo;t have to be <code>cloned</code>). Meanwhile, the snowballs and player move all the time, thus being part of <code>LocalState</code>.</p><p>But&mldr; that&rsquo;s not how I did it, despite the optimization. We&rsquo;ll just put it all in <code>LocalState</code>:</p><p>First, snowball stacks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    Small <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    Medium <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    MediumSmall <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    Large <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>    LargeSmall <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>    LargeMedium <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>    LargeMediumSmall <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Stack {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> Stack::Small,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> Stack::Medium,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> Stack::MediumSmall,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span> <span style=color:#f92672>=&gt;</span> Stack::Large,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>5</span> <span style=color:#f92672>=&gt;</span> Stack::LargeSmall,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>6</span> <span style=color:#f92672>=&gt;</span> Stack::LargeMedium,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>7</span> <span style=color:#f92672>=&gt;</span> Stack::LargeMediumSmall,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid stack size&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This could easily be a <code>struct Stack(bool, bool, bool)</code> or something like that, but this worked out well enough. And it&rsquo;s a nice binary representation. First bit is large, second medium, third small.</p><p>So now, building the map:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Location</span> {
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Snow,
</span></span><span style=display:flex><span>    Wall,
</span></span><span style=display:flex><span>    Snowman(Stack),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    player: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span>Location<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=loading-the-puzzles>Loading the puzzles</h2><p>Previously, I&rsquo;d created puzzles like this by loading JSON files. It&rsquo;s a fair bit trickier to load, so instead, we&rsquo;ll just go with a text format:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>XXXX***XXXX
</span></span><span style=display:flex><span>***X*1*X***
</span></span><span style=display:flex><span>*1*******1*
</span></span><span style=display:flex><span>***X***X***
</span></span><span style=display:flex><span>XXXX***XXXX
</span></span><span style=display:flex><span>XXXXX#XXXXX
</span></span></code></pre></div><ul><li><code>X</code> is a wall (could be anything unwalkable)</li><li><code>*</code> is snow on the ground</li><li><code>-</code> (none in this one) is empty space</li><li><code>#</code> is the player</li><li><code>1</code> - <code>7</code> are snowballs (see <code>Stack</code> above)</li></ul><p>We can load that easily from a string:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Location::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> lines <span style=color:#f92672>=</span> value.lines().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> lines.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> lines[<span style=color:#ae81ff>0</span>].len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> player <span style=color:#f92672>=</span> Point(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (y, line) <span style=color:#66d9ef>in</span> lines.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>=&gt;</span> data.push(Empty),
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;*&#39;</span> <span style=color:#f92672>=&gt;</span> data.push(Snow),
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;X&#39;</span> <span style=color:#f92672>=&gt;</span> data.push(Wall),
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        data.push(Empty);
</span></span><span style=display:flex><span>                        player <span style=color:#f92672>=</span> Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>                        data.push(Snowman(value.into()));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map {
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            height,
</span></span><span style=display:flex><span>            player,
</span></span><span style=display:flex><span>            data,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=checking-for-solvedness>Checking for solvedness</h2><p>Okay, we have the basic data structure in place, so now we need the solver functions: <code>is_valid</code>, <code>is_solved</code>, <code>next_states</code>, and <code>heuristic</code>.</p><p>Let&rsquo;s start with <code>is_solved</code>, that&rsquo;s easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>G<span style=color:#f92672>&gt;</span> State<span style=color:#f92672>&lt;</span>G, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solved</span>(<span style=color:#f92672>&amp;</span>self, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>G</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Location::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Stack::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// All snowmen are completely formed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    Some(Snowman(LargeMediumSmall)) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                    Some(Snowman(_)) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yup, that&rsquo;s it.</p><h2 id=checking-for-invalid-states>Checking for invalid states</h2><p>Okay, next let&rsquo;s validate!</p><p>This is an implementation choice. If you never generate an invalid state, this function can just <code>return true</code>. But conversely, you can use this to check for technically &lsquo;valid&rsquo; states that you could move into, but that can <em>never</em> lead to a solved state, which is what I did here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>G<span style=color:#f92672>&gt;</span> State<span style=color:#f92672>&lt;</span>G, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, g: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>G</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Location::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Stack::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re solved, we&#39;re valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.is_solved(g) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check that we have or can build the proper number of snowmen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> small_balls <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> medium_balls <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> large_balls <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> snow_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    Some(Snowman(any)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        small_balls <span style=color:#f92672>+=</span> <span style=color:#66d9ef>if</span> (any <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>                        medium_balls <span style=color:#f92672>+=</span> <span style=color:#66d9ef>if</span> (any <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>                        large_balls <span style=color:#f92672>+=</span> <span style=color:#66d9ef>if</span> (any <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Some(Snow) <span style=color:#f92672>=&gt;</span> snow_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> small_balls <span style=color:#f92672>&lt;</span> large_balls {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> small_balls <span style=color:#f92672>+</span> medium_balls <span style=color:#f92672>&lt;</span> large_balls {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We have to have enough snow left to transform so that we have N L/M/S
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> target_snowmen <span style=color:#f92672>=</span> (small_balls <span style=color:#f92672>+</span> medium_balls <span style=color:#f92672>+</span> large_balls) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Not enough remaining heads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> small_balls <span style=color:#f92672>&lt;</span> target_snowmen {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Not enough heads to match bellies (even if we used all remaining snow)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> medium_balls <span style=color:#f92672>+</span> small_balls.min(snow_count) <span style=color:#f92672>&lt;</span> target_snowmen {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Not enough butts, even if we use bellies and heads with remaining snow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This is imperfect, but should help
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> large_balls <span style=color:#f92672>+</span> medium_balls.min(snow_count) <span style=color:#f92672>+</span> small_balls.min(snow_count) <span style=color:#f92672>&lt;</span> target_snowmen
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We have too many bottoms; can&#39;t downgrade them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> large_balls <span style=color:#f92672>&gt;</span> target_snowmen {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This overestimates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Technically a snowman is &#39;moveable&#39; if you can either stack them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Or the target snowman is itself moveable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Which we can calculate, but I haven&#39;t yet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> is_moveable <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>l: <span style=color:#a6e22e>Location</span><span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> l {
</span></span><span style=display:flex><span>            Empty <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            Snow <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            Snowman(_) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-large in a corner is trapped (and thus invalid)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Larges in a non-target corner are also bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (is_snowman, is_large) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    Some(Snowman(LargeMediumSmall <span style=color:#f92672>|</span> LargeMedium <span style=color:#f92672>|</span> Large)) <span style=color:#f92672>=&gt;</span> (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>),
</span></span><span style=display:flex><span>                    Some(Snowman(_)) <span style=color:#f92672>=&gt;</span> (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>),
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> (<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>),
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_snowman {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> north <span style=color:#f92672>=</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)).unwrap_or(Wall);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> south <span style=color:#f92672>=</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)).unwrap_or(Wall);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> east <span style=color:#f92672>=</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)).unwrap_or(Wall);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> west <span style=color:#f92672>=</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)).unwrap_or(Wall);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_moveable(north) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>is_moveable(west) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_moveable(north) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>is_moveable(east) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_moveable(south) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>is_moveable(west) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_moveable(south) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>is_moveable(east) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, assume valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are a few cases here that I added as I kept solving more levels and I think they should all be commented fairly well. For example, if you start with 6 snowballs (in various states), then you know that you will need to build 2 snowmen. So you will need 2 small balls / heads. And you can never make a snowball smaller, so if you ever end up with less than 2&mldr; we&rsquo;ll <code>!is_valid</code>.</p><p>Likewise, if you get small balls stuck in corners. You can&rsquo;t push them out and you can&rsquo;t put a larger ball on a smaller one. <code>!is_valid</code>.</p><p>This one, I really do need to work on. It&rsquo;s not perfect right now, as this state is technically invalid, but I can&rsquo;t catch it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>XXXX
</span></span><span style=display:flex><span>X-1-
</span></span><span style=display:flex><span>X1--
</span></span><span style=display:flex><span>X---
</span></span></code></pre></div><p>Because if you would push either ball into the corner, it&rsquo;s invalidated. Now, that branch of the solver will be pruned as soon as either is pushed there, but because each step of the player is a separate &lsquo;state&rsquo;, it&rsquo;s still not efficient. But that&rsquo;s a problem for another day.</p><h2 id=generating-next-states>Generating next states</h2><p>Okay, here&rsquo;s the meat of the problem. How do we take a state and generate the <code>next_states</code> from it?</p><p>Well, like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>G<span style=color:#f92672>&gt;</span> State<span style=color:#f92672>&lt;</span>G, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, _: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>G</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, Step, Map)<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Location::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Stack::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Step::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> states <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> moves <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>            (North, Point(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)),
</span></span><span style=display:flex><span>            (South, Point(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)),
</span></span><span style=display:flex><span>            (East, Point(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>            (West, Point(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (step, delta) <span style=color:#66d9ef>in</span> moves.into_iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> self.player <span style=color:#f92672>+</span> delta;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next_2 <span style=color:#f92672>=</span> next <span style=color:#f92672>+</span> delta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> self.get(next);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> target_2 <span style=color:#f92672>=</span> self.get(next_2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can&#39;t move out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> target.is_none() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can&#39;t move into a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Wall <span style=color:#f92672>=</span> target.unwrap() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The target is empty, just move into it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Empty <span style=color:#f92672>=</span> target.unwrap() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                new_state.player <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                states.push((<span style=color:#66d9ef>MOVE_EMPTY_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Likewise onto snow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Snow <span style=color:#f92672>=</span> target.unwrap() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                new_state.player <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                states.push((<span style=color:#66d9ef>MOVE_SNOW_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try to push a snowman together or apart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Snowman(any) <span style=color:#f92672>=</span> target.unwrap() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Single balls can be pushed into empty spaces, snow (growing), and valid snowmen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> target_2.is_some() <span style=color:#f92672>&amp;&amp;</span> (any <span style=color:#f92672>==</span> Small <span style=color:#f92672>||</span> any <span style=color:#f92672>==</span> Medium <span style=color:#f92672>||</span> any <span style=color:#f92672>==</span> Large) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Empty spaces always work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Empty <span style=color:#f92672>=</span> target_2.unwrap() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                        new_state.player <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                        new_state.set(next, Empty);
</span></span><span style=display:flex><span>                        new_state.set(next_2, Snowman(any));
</span></span><span style=display:flex><span>                        states.push((<span style=color:#66d9ef>PUSH_EMPTY_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Snow works and grows the ball
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Large stays large
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Snow is always removed (even if large -&gt; large)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Snow <span style=color:#f92672>=</span> target_2.unwrap() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> any {
</span></span><span style=display:flex><span>                            Small <span style=color:#f92672>=&gt;</span> Medium,
</span></span><span style=display:flex><span>                            Medium <span style=color:#f92672>=&gt;</span> Large,
</span></span><span style=display:flex><span>                            Large <span style=color:#f92672>=&gt;</span> Large,
</span></span><span style=display:flex><span>                            _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                        new_state.player <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                        new_state.set(next, Empty);
</span></span><span style=display:flex><span>                        new_state.set(next_2, Snowman(new_size));
</span></span><span style=display:flex><span>                        states.push((<span style=color:#66d9ef>PUSH_SNOW_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Single balls can be pushed onto other smaller balls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Snowman(other) <span style=color:#f92672>=</span> target_2.unwrap() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> combined <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> (any, other) {
</span></span><span style=display:flex><span>                            (Small, Medium) <span style=color:#f92672>=&gt;</span> Some(MediumSmall),
</span></span><span style=display:flex><span>                            (Small, Large) <span style=color:#f92672>=&gt;</span> Some(LargeSmall),
</span></span><span style=display:flex><span>                            (Medium, Large) <span style=color:#f92672>=&gt;</span> Some(LargeMedium),
</span></span><span style=display:flex><span>                            (Small, LargeMedium) <span style=color:#f92672>=&gt;</span> Some(LargeMediumSmall),
</span></span><span style=display:flex><span>                            _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(combined) <span style=color:#f92672>=</span> combined {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                            new_state.player <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                            new_state.set(next, Empty);
</span></span><span style=display:flex><span>                            new_state.set(next_2, Snowman(combined));
</span></span><span style=display:flex><span>                            states.push((<span style=color:#66d9ef>STACK_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Stacks can be broken apart if the target is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Note: In these cases, the player *does not move*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> target_2.is_some()
</span></span><span style=display:flex><span>                    <span style=color:#f92672>&amp;&amp;</span> (any <span style=color:#f92672>==</span> MediumSmall <span style=color:#f92672>||</span> any <span style=color:#f92672>==</span> LargeSmall <span style=color:#f92672>||</span> any <span style=color:#f92672>==</span> LargeMedium)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Pushing into empty space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Empty <span style=color:#f92672>=</span> target_2.unwrap() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> (a, b) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> any {
</span></span><span style=display:flex><span>                            MediumSmall <span style=color:#f92672>=&gt;</span> (Medium, Small),
</span></span><span style=display:flex><span>                            LargeSmall <span style=color:#f92672>=&gt;</span> (Large, Small),
</span></span><span style=display:flex><span>                            LargeMedium <span style=color:#f92672>=&gt;</span> (Large, Medium),
</span></span><span style=display:flex><span>                            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid stack size&#34;</span>),
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                        new_state.set(next, Snowman(a));
</span></span><span style=display:flex><span>                        new_state.set(next_2, Snowman(b));
</span></span><span style=display:flex><span>                        states.push((<span style=color:#66d9ef>UNSTACK_EMPTY_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Pushing onto snow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Snow <span style=color:#f92672>=</span> target_2.unwrap() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> (a, b) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> any {
</span></span><span style=display:flex><span>                            MediumSmall <span style=color:#f92672>=&gt;</span> (Medium, Medium),
</span></span><span style=display:flex><span>                            LargeSmall <span style=color:#f92672>=&gt;</span> (Large, Medium),
</span></span><span style=display:flex><span>                            LargeMedium <span style=color:#f92672>=&gt;</span> (Large, Large),
</span></span><span style=display:flex><span>                            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid stack size&#34;</span>),
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                        new_state.set(next, Snowman(a));
</span></span><span style=display:flex><span>                        new_state.set(next_2, Snowman(b));
</span></span><span style=display:flex><span>                        states.push((<span style=color:#66d9ef>UNSTACK_SNOW_COST</span>, step, new_state));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we made it this far, the state is invalid for some other reason
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// println!(&#34;Invalid state: {:?}&#34;, self);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// println!(&#34;Moving: {:?}&#34;, delta);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we have states, return them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>states.is_empty() {
</span></span><span style=display:flex><span>            Some(states)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, first the signature. If you don&rsquo;t recall from previous posts (actually, you won&rsquo;t, I changed it ðŸ˜„), the <code>next_states</code> function should return a <code>Vec</code> of possible states from the one we&rsquo;re in. For each, it should return a tuple of <code>(i64, StepType, LocalStateType)</code> where <code>StepType</code> represents taking one step (to rebuild the path) and <code>LocalStateType</code> is the state that changes with each step through the puzzle. In this case, <code>StepType</code> is a <code>Step</code>, <code>North</code>, <code>South</code>, <code>East</code>, <code>West</code> and <code>LocalStateType</code> is the <code>Map</code> above (a grid of <code>Location</code> and <code>Stack</code>).</p><p>From there, we have always exactly 4 moves:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> moves <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    (North, Point(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)),
</span></span><span style=display:flex><span>    (South, Point(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)),
</span></span><span style=display:flex><span>    (East, Point(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>    (West, Point(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>For each of those, we&rsquo;ll do a few things in sequence (matching the code above):</p><ul><li>Generate what point we&rsquo;d move on to (<code>next</code>) and the spot after that (<code>next_2</code>); the latter is used if we push a snowball onto (or off of) an existing snowman</li><li>If either of those is out of bounds <code>None</code> or solid <code>Some(Wall)</code>, we can&rsquo;t move, so do nothing.</li><li>If the <code>next</code> space is <code>Empty</code> (or <code>Snow</code>), we just walk onto it, ignore <code>next_2</code></li><li>If <code>next</code> is a <code>Snowman</code>, then <code>next_2</code> has to be <code>Empty</code> or <code>Snow</code>, otherwise, ignore this state; otherwise:<ul><li>If it&rsquo;s a single small/medium ball and <code>next_2</code> is medium/large, we can stack them</li><li>If it&rsquo;s incomplete snowman and <code>next_2</code> is <code>Empty</code> or <code>Snow</code>, we can push it off</li></ul></li></ul><p>Turn all of that to code&mldr; and we have our next states!</p><p>This was a lot of trial and error and&mldr; I really should have written more tests. But it was fun to write!</p><h2 id=trying-the-solver>Trying the solver</h2><p>Don&rsquo;t worry, we&rsquo;ll come back to the heuristics. ðŸ˜„</p><p>For now though, that&rsquo;s all we need to write the solver:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    env_logger::init();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> io::read_to_string(io::stdin()).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> initial_state <span style=color:#f92672>=</span> Map::from(input.as_str());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;initial: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, initial_state);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> solver <span style=color:#f92672>=</span> Solver::new((), initial_state.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(state) <span style=color:#f92672>=</span> solver.next() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> solver.states_checked() <span style=color:#f92672>%</span> <span style=color:#ae81ff>100000</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;===== ===== ===== ===== =====&#34;</span>);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;state: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, state);
</span></span><span style=display:flex><span>        println!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> states checked, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> in queue, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> invalidated, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> seconds, heuristic: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>            solver.states_checked(),
</span></span><span style=display:flex><span>            solver.in_queue(),
</span></span><span style=display:flex><span>            solver.states_invalidated(),
</span></span><span style=display:flex><span>            solver.time_spent(),
</span></span><span style=display:flex><span>            state.heuristic(<span style=color:#f92672>&amp;</span>()),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solver.get_solution();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> solution.is_none() {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;no solution found&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solution.unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;solution: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, solution);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> steps <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> step <span style=color:#66d9ef>in</span> solver.path(<span style=color:#f92672>&amp;</span>initial_state, <span style=color:#f92672>&amp;</span>solution).unwrap() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> step {
</span></span><span style=display:flex><span>            Step::North <span style=color:#f92672>=&gt;</span> steps <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;W&#34;</span>,
</span></span><span style=display:flex><span>            Step::South <span style=color:#f92672>=&gt;</span> steps <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;S&#34;</span>,
</span></span><span style=display:flex><span>            Step::East <span style=color:#f92672>=&gt;</span> steps <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;D&#34;</span>,
</span></span><span style=display:flex><span>            Step::West <span style=color:#f92672>=&gt;</span> steps <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;A&#34;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;path: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, steps);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> states, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> seconds&#34;</span>,
</span></span><span style=display:flex><span>        solver.states_checked(),
</span></span><span style=display:flex><span>        solver.time_spent()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Load it up, have a lot of debugging in there and&mldr; that&rsquo;s it. For a lot of the simpler puzzles, it just works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat data/good-snowman/Mary.txt | ./target/release/good-snowman
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>initial: map:
</span></span><span style=display:flex><span>  *****
</span></span><span style=display:flex><span>  *4X3*
</span></span><span style=display:flex><span>  *****
</span></span><span style=display:flex><span>  X#XXX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>solution: map:
</span></span><span style=display:flex><span>  *#7-*
</span></span><span style=display:flex><span>  *-X-*
</span></span><span style=display:flex><span>  *****
</span></span><span style=display:flex><span>  X-XXX
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path: WWAWDDAASSDDDDWWADSSAWDWWAADSSAWDWASSAAAWWD
</span></span><span style=display:flex><span><span style=color:#ae81ff>116</span> states, 0.00035992003 seconds
</span></span></code></pre></div><p>Some of them take a fair bit longer than that. And the solutions are <em>not</em> optimal at the moment, which really feels like a bug, shouldn&rsquo;t it be doing a breadth first search?</p><p>But, for the purposes of running through these puzzles, it works pretty well!</p><h2 id=back-to-heuristics>Back to heuristics</h2><p>Okay, so back a step to those heuristics I was talking about.</p><p>We&rsquo;re running basically <a href=https://en.wikipedia.org/wiki/A%20star>A star</a> to solve these problems, over the puzzle state space. In this case, we&rsquo;re always returning <code>1</code> for the step cost, because each move is the same number of key presses in the final solution. If we wanted to push snowmen as little as possible, we could change this.</p><p>But failing that, a heuristic should help order which states we look at in which order.</p><p>So here we go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>G<span style=color:#f92672>&gt;</span> State<span style=color:#f92672>&lt;</span>G, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>heuristic</span>(<span style=color:#f92672>&amp;</span>self, _global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>G</span>) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Location::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> Stack::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> score <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// // Add the sum of distances between each pair of incomplete snowmen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// for y in 0..self.height {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     for x in 0..self.width {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         match self.get(Point(x as i8, y as i8)) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             Some(Snowman(LargeMediumSmall)) =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             Some(Snowman(_)) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                 for y2 in 0..self.height {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                     for x2 in 0..self.width {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                         match self.get(Point(x2 as i8, y2 as i8)) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                             Some(Snowman(LargeMediumSmall)) =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                             Some(Snowman(_)) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                                 let dx = x as i64 - x2 as i64;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                                 let dy = y as i64 - y2 as i64;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                                 score += dx.abs() + dy.abs();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                             },
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                             _ =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                         }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//                 }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             },
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             _ =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add the distance from the player to the nearest incomplete snowman
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distance <span style=color:#f92672>=</span> (self.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> self.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    Some(Snowman(LargeMediumSmall)) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                    Some(Snowman(_)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> dx <span style=color:#f92672>=</span> (self.player.<span style=color:#ae81ff>0</span> <span style=color:#f92672>-</span> (x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> dy <span style=color:#f92672>=</span> (self.player.<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> (y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                        distance <span style=color:#f92672>=</span> distance.min(dx <span style=color:#f92672>+</span> dy);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        score <span style=color:#f92672>+=</span> distance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add the distance from each small/medium to the nearest available medium/large
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    Some(Snowman(Small)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distance <span style=color:#f92672>=</span> (self.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> self.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> y2 <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> x2 <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>match</span> self.get(Point(x2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                                    Some(Snowman(Medium)) <span style=color:#f92672>|</span> Some(Snowman(LargeMedium)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>let</span> dx <span style=color:#f92672>=</span> (x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> x2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>let</span> dy <span style=color:#f92672>=</span> (y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> y2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                                        distance <span style=color:#f92672>=</span> distance.min(dx <span style=color:#f92672>+</span> dy);
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        score <span style=color:#f92672>+=</span> distance;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Some(Snowman(Medium)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distance <span style=color:#f92672>=</span> (self.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> self.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> y2 <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> x2 <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>match</span> self.get(Point(x2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                                    Some(Snowman(Large)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>let</span> dx <span style=color:#f92672>=</span> (x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> x2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>let</span> dy <span style=color:#f92672>=</span> (y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span> <span style=color:#f92672>-</span> y2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>).abs() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span>                                        distance <span style=color:#f92672>=</span> distance.min(dx <span style=color:#f92672>+</span> dy);
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        score <span style=color:#f92672>+=</span> distance;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// // Add various points per incomplete snowman
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// for y in 0..self.height {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     for x in 0..self.width {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         match self.get(Point(x as i8, y as i8)) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             Some(Snowman(LargeMediumSmall)) =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             Some(Snowman(any)) =&gt; score += 10 * (any as i64),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             _ =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// // Add points for snow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// for y in 0..self.height {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     for x in 0..self.width {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         match self.get(Point(x as i8, y as i8)) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             Some(Snow) =&gt; score += 1,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             _ =&gt; continue,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, it&rsquo;s not perfect. In <code>A Star</code>, you are guaranteed a solution, but if your heuristic is less than the actual number of steps, you&rsquo;re not guaranteed an optimal solution. So I mostly messed with a bunch of different values to see what we could actually get. And this does help the solver significantly, although we could do better.</p><p>At this point though, this is more than enough to solve the basic game. All 30 puzzles. A few didn&rsquo;t solve quickly (at all), but they all do eventually finish. So&mldr; what&rsquo;s next?</p><h2 id=extra-credit-targetted-solutions>Extra credit: Targetted solutions</h2><p>Well, it turns out there&rsquo;s a second &lsquo;hard mode&rsquo;, where you dream about where you build the snowmen and then take those locations and build metasnowmen? It gets weird. Anyways, to solve this, we want to be able to set a specific location for the snowman to be built at.</p><p>This actually isn&rsquo;t that much of a change.</p><p>First, in <code>Map</code>, add <code>targets: Option&lt;Vec&lt;Point>></code>. If <code>None</code>, do what we did before. Otherwise, <code>is_solved</code> will take this into account. I&rsquo;m using <code>+</code> for a target on <code>Empty</code> and <code>=</code> for a target on <code>Snow</code> (so we don&rsquo;t lose out on that snow).</p><p>Next, in <code>is_solved</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// If there are targets, any completed snowman not on a target is invalid
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO: This probably shouldn&#39;t be in both is_valid and is_solved
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(targets) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>self.targets {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Snowman(LargeMediumSmall)) <span style=color:#f92672>=</span> self.get(Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>targets.contains(<span style=color:#f92672>&amp;</span>Point(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i8</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s really it. I did also invalidate (as mentioned) states that had a snowman complete in the wrong place, since we can&rsquo;t break them up once formed, but that&rsquo;s really it.</p><h2 id=future-work>Future work</h2><p>So, it works and I 100% completed the game. What could possibly be next?</p><p>Well, the performance is still bothering me a bit. So one solution would be, rather than generating each step of the player as a state, instead generate all possible state changes&ndash;those being pushing/stacking/unstacking a snowball. That will branch much faster but also generate far fewer states (and let caching work better). Worth a try!</p><p>But that&rsquo;s a post for another day. Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>