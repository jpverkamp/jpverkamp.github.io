<!doctype html><html><head><title>AoC 2024 Day 8: Vectorinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 8: Vectorinator</h1><div class=entry-meta><span class=entry-date>2024-12-08</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/benchmarking>Benchmarking</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2016/12/03/aoc-2016-day-3-triangle-validator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/geometry>Geometry</a><a href=https://blog.jverkamp.com/2024/12/12/aoc-2024-day-12-edginator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/hashing>Hashing</a></li><li><a href=https://blog.jverkamp.com/2022/12/09/aoc-2022-day-9-ropeinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/simulation>Simulation</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/02/23/genuary-2023.23-moir%C3%A9/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/vectors>Vectors</a></li><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/visualization>Visualization</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-8-resonant-collinearity>Source: <a href=https://adventofcode.com/2024/day/8 target=_blank rel=noopener>Day 8: Resonant Collinearity</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day8.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-8-resonant-collinearity>Source: <a href=https://adventofcode.com/2024/day/8>Day 8: Resonant Collinearity</a></a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-2>Part 2</a></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a grid with either open tiles (<code>.</code>) or towers (anything else), for each pair of towers, there is an antinode at each of the points that is 2x as far from one tower as the other. How many antinodes are there still within the bounds of the map?</p></blockquote><p>Parsing? Sounds <code>Grid</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[default]</span>
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Tower(<span style=color:#66d9ef>char</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day8)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Grid::read(input, <span style=color:#f92672>&amp;|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>=&gt;</span> Tile::Empty,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> Tile::Tower(c),
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Although it turns out we don&rsquo;t really care about the entire grid. Just for each tower ID, we want a list of points that have that ID.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day8, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> towers <span style=color:#f92672>=</span> hashbrown::HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (point, tile) <span style=color:#66d9ef>in</span> input.iter_enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Tower(c) <span style=color:#f92672>=</span> tile {
</span></span><span style=display:flex><span>            towers.entry(c).or_insert_with(Vec::new).push(point);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I really could have done that in the parsing and probably didn&rsquo;t need to do it with a <code>HashMap</code>&mldr; but I think tha tin this case, that&rsquo;s really the cleanest way to do it without writing a newer parsing function and honestly, it&rsquo;s been a long day. That&rsquo;s probably enough for the moment.</p><p>So how do we find the antinodes? Well, take each pair of towers as vectors <code>v1</code> and <code>v2</code>. The vector between them is <code>d = v2 - v1</code> and then one point will be at <code>v1 - d</code> and the other at <code>v2 + d</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day8, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> towers <span style=color:#f92672>=</span> hashbrown::HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (point, tile) <span style=color:#66d9ef>in</span> input.iter_enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Tower(c) <span style=color:#f92672>=</span> tile {
</span></span><span style=display:flex><span>            towers.entry(c).or_insert_with(Vec::new).push(point);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> antinodes <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (_, points) <span style=color:#66d9ef>in</span> towers.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p1 <span style=color:#66d9ef>in</span> points {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p2 <span style=color:#66d9ef>in</span> points {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> p1 <span style=color:#f92672>!=</span> p2 {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p2 <span style=color:#f92672>-</span> <span style=color:#f92672>*</span>p1;
</span></span><span style=display:flex><span>                    antinodes.set(<span style=color:#f92672>*</span>p1 <span style=color:#f92672>-</span> d, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                    antinodes.set(<span style=color:#f92672>*</span>p2 <span style=color:#f92672>+</span> d, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    antinodes.iter().filter(<span style=color:#f92672>|&amp;</span>b<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>b).count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it!</p><p>We&rsquo;ve saved some nice time here again by making it so that if you <code>set</code> a point out of bounds on a <code>Grid</code>, it just ignores it! Also, we get duplication removal for free (if towers with two different IDs end up having an antinode on the same point, it only counts once).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>8</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>8</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>299</span>
</span></span><span style=display:flex><span>	generator: 8.75µs,
</span></span><span style=display:flex><span>	runner: 13.75µs
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><blockquote><p>Instead of just 1 antinode in each direction, generate them in a repeating pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a......
</span></span><span style=display:flex><span>..a....
</span></span><span style=display:flex><span>....#..
</span></span><span style=display:flex><span>......#
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Where `a` are the towers and `#` the antinodes. 
</span></span></code></pre></div></blockquote><p>Mostly the same code, except instead of a single point for each, we&rsquo;ll loop until we actually hit <code>in_bounds</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day8, part2, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> towers <span style=color:#f92672>=</span> hashbrown::HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (point, tile) <span style=color:#66d9ef>in</span> input.iter_enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Tile::Tower(c) <span style=color:#f92672>=</span> tile {
</span></span><span style=display:flex><span>            towers.entry(c).or_insert_with(Vec::new).push(point);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> antinodes <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (_, points) <span style=color:#66d9ef>in</span> towers.iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p1 <span style=color:#66d9ef>in</span> points {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p2 <span style=color:#66d9ef>in</span> points {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> p1 <span style=color:#f92672>!=</span> p2 {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> delta <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p2 <span style=color:#f92672>-</span> <span style=color:#f92672>*</span>p1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p1 <span style=color:#f92672>+</span> delta;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> input.in_bounds(p) {
</span></span><span style=display:flex><span>                        antinodes.set(p, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                        p <span style=color:#f92672>+=</span> delta;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p1 <span style=color:#f92672>-</span> delta;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> input.in_bounds(p) {
</span></span><span style=display:flex><span>                        antinodes.set(p, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                        p <span style=color:#f92672>-=</span> delta;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    antinodes.iter().filter(<span style=color:#f92672>|&amp;</span>b<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>b).count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s probably not the <em>most</em> optimized code, but I actually think it&rsquo;s really clean!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>cargo aoc <span style=color:#f92672>--</span>day <span style=color:#ae81ff>8</span> <span style=color:#f92672>--</span>part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>AOC</span> <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> Part <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> v1 : <span style=color:#ae81ff>1032</span>
</span></span><span style=display:flex><span>	generator: <span style=color:#ae81ff>8.5</span><span style=color:#960050;background-color:#1e0010>µ</span>s,
</span></span><span style=display:flex><span>	runner: <span style=color:#ae81ff>18.625</span><span style=color:#960050;background-color:#1e0010>µ</span>s
</span></span></code></pre></div><p>I did render this one too. It&rsquo;s fun:</p><p><video controls src=/embeds/2024/aoc/day8-part2.mp4 width=100%></video></p><h2 id=benchmarks>Benchmarks</h2><p>It&rsquo;s been a long day, so I probably won&rsquo;t optimize this one too much more. We&rsquo;re probably paying a decent bit in parsing the <code>Grid</code> and then immediately throwing it away, plus (maybe) in keeping multiple <code>Vec</code> instead of one with offsets for each tower. So it goes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day8 - Part1/v1         time:   <span style=color:#f92672>[</span>4.4647 µs 4.5002 µs 4.5514 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day8 - Part2/v1         time:   <span style=color:#f92672>[</span>6.5027 µs 6.6171 µs 6.7712 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Honestly, it&rsquo;s faster than <a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/>yesterday</a>. I&rsquo;m okay with that!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>