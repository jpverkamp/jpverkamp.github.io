<!doctype html><html><head><title>AoC 2024 Day 21: Busy Workinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 21: Busy Workinator</h1><div class=entry-meta><span class=entry-date>2024-12-21</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/20/aoc-2024-day-20-shadow-catinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/20/aoc-2024-day-20-shadow-catinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memoization>Memoization</a><a href=https://blog.jverkamp.com/2024/12/23/aoc-2024-day-23-lan-partinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/12/17/aoc-2024-day-17-virtual-machininator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/recursion>Recursion</a><a href=https://blog.jverkamp.com/2024/12/23/aoc-2024-day-23-lan-partinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/tracing>Tracing</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/20/aoc-2024-day-20-shadow-catinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/20/aoc-2024-day-20-shadow-catinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/20/aoc-2024-day-20-shadow-catinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-21-keypad-conundrum>Source: <a href=https://adventofcode.com/2024/day/21 target=_blank rel=noopener>Day 21: Keypad Conundrum</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day21.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-21-keypad-conundrum>Source: <a href=https://adventofcode.com/2024/day/21>Day 21: Keypad Conundrum</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#failed-version-1-way-over-engineered>(Failed) Version 1: Way over engineered</a></li><li><a href=#version-2-direct-simulation>Version 2: Direct simulation</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#memoization>Memoization</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a><ul><li><a href=#tracing>Tracing</a></li></ul></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>You are trying to type a code on a keypad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>+---+---+---+
</span></span><span style=display:flex><span>| 7 | 8 | 9 |
</span></span><span style=display:flex><span>+---+---+---+
</span></span><span style=display:flex><span>| 4 | 5 | 6 |
</span></span><span style=display:flex><span>+---+---+---+
</span></span><span style=display:flex><span>| 1 | 2 | 3 |
</span></span><span style=display:flex><span>+---+---+---+
</span></span><span style=display:flex><span>    | 0 | A |
</span></span><span style=display:flex><span>    +---+---+
</span></span></code></pre></div><p>But you cannot type directly. Instead, you can control a pointer on the keypad with arrow keys:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    +---+---+
</span></span><span style=display:flex><span>    | ^ | A |
</span></span><span style=display:flex><span>+---+---+---+
</span></span><span style=display:flex><span>| &lt; | v | &gt; |
</span></span><span style=display:flex><span>+---+---+---+
</span></span></code></pre></div><p>Whenever you type a <code>^</code> on the arrow keys, the pointer on the keypad will move up one, etc. When you type <code>A</code>, then the pointer on the keypad will type whatever it is pointing at.</p><p>But that&rsquo;s not enough either. Add a second keypad. And then a third, that is the one you are actually controlling.</p><p>For each output sequence multiple the length of the minimum input sequence needed to generate it by the numeric value of the input sequence (ignoring any <code>A</code>); sum these.</p><p>Note: Moving off any keypad or into the blank spaces is an error.</p></blockquote><h3 id=failed-version-1-way-over-engineered>(Failed) Version 1: Way over engineered</h3><p>I&rsquo;m just going to leave this here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Keyboard</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    keys: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Keyboard {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> keys <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> value.lines() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> line.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            height <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            width <span style=color:#f92672>=</span> width.max(line.len());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> line.chars() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> c.is_whitespace() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;*&#39;</span> {
</span></span><span style=display:flex><span>                    keys.push(None);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    keys.push(Some(c));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            height,
</span></span><span style=display:flex><span>            keys,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Keyboard {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_key</span>(<span style=color:#f92672>&amp;</span>self, p: <span style=color:#a6e22e>Point</span>) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> p.x <span style=color:#f92672>&gt;=</span> self.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span> <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&gt;=</span> self.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            self.keys[p.y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> self.width <span style=color:#f92672>+</span> p.x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_point</span>(<span style=color:#f92672>&amp;</span>self, key: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> (x, y).into();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.get_key(p) <span style=color:#f92672>==</span> Some(key) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(p);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Typer</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kb</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    keyboard: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;kb</span> <span style=color:#a6e22e>Keyboard</span>,
</span></span><span style=display:flex><span>    p: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kb</span><span style=color:#f92672>&gt;</span> Typer<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kb</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(keyboard: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;kb</span> <span style=color:#a6e22e>Keyboard</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>keyboard.width {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>keyboard.height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> (x, y).into();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> keyboard.get_key(p) <span style=color:#f92672>==</span> Some(<span style=color:#e6db74>&#39;A&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Self { keyboard, p };
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;keyboard does not contain &#39;A&#39;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>go</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, c: <span style=color:#66d9ef>char</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.p <span style=color:#f92672>=</span> self.p
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;^&#39;</span> <span style=color:#f92672>=&gt;</span> Direction::Up,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;v&#39;</span> <span style=color:#f92672>=&gt;</span> Direction::Down,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;&lt;&#39;</span> <span style=color:#f92672>=&gt;</span> Direction::Left,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;&gt;&#39;</span> <span style=color:#f92672>=&gt;</span> Direction::Right,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>type_char_path</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, target: <span style=color:#66d9ef>char</span>) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> target_p <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.keyboard.get_point(target) {
</span></span><span style=display:flex><span>            Some(p) <span style=color:#f92672>=&gt;</span> p,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;could not find target&#34;</span>),
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> astar(
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>(self.p, None),
</span></span><span style=display:flex><span>            <span style=color:#f92672>|&amp;</span>(p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> neighbors <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Direction::all().into_iter().for_each(<span style=color:#f92672>|</span>d<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(c) <span style=color:#f92672>=</span> self.keyboard.get_key(p <span style=color:#f92672>+</span> d) {
</span></span><span style=display:flex><span>                        neighbors.push(((p <span style=color:#f92672>+</span> d, Some(d)), <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                neighbors
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#f92672>|&amp;</span>(p, _)<span style=color:#f92672>|</span> p.manhattan_distance(<span style=color:#f92672>&amp;</span>target_p),
</span></span><span style=display:flex><span>            <span style=color:#f92672>|&amp;</span>(p, _)<span style=color:#f92672>|</span> self.keyboard.get_key(p) <span style=color:#f92672>==</span> Some(target),
</span></span><span style=display:flex><span>        ) {
</span></span><span style=display:flex><span>            Some((path, _)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#f92672>&amp;</span>(last_p, _) <span style=color:#f92672>=</span> path.last().unwrap();
</span></span><span style=display:flex><span>                self.p <span style=color:#f92672>=</span> last_p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                path.iter()
</span></span><span style=display:flex><span>                    .filter_map(<span style=color:#f92672>|&amp;</span>(_, d)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> d {
</span></span><span style=display:flex><span>                        Some(Direction::Up) <span style=color:#f92672>=&gt;</span> Some(<span style=color:#e6db74>&#39;^&#39;</span>),
</span></span><span style=display:flex><span>                        Some(Direction::Down) <span style=color:#f92672>=&gt;</span> Some(<span style=color:#e6db74>&#39;v&#39;</span>),
</span></span><span style=display:flex><span>                        Some(Direction::Left) <span style=color:#f92672>=&gt;</span> Some(<span style=color:#e6db74>&#39;&lt;&#39;</span>),
</span></span><span style=display:flex><span>                        Some(Direction::Right) <span style=color:#f92672>=&gt;</span> Some(<span style=color:#e6db74>&#39;&gt;&#39;</span>),
</span></span><span style=display:flex><span>                        _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .chain(std::iter::once(<span style=color:#e6db74>&#39;A&#39;</span>))
</span></span><span style=display:flex><span>                    .collect()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;could not find path to target&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>type_string_path</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, target: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        target.chars().map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> self.type_char_path(c)).collect()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TyperChain</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    me: <span style=color:#a6e22e>Typer</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    next: Option<span style=color:#f92672>&lt;</span>Rc<span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>TyperChain<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span> std::hash::Hash <span style=color:#66d9ef>for</span> TyperChain<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>&lt;</span>H: <span style=color:#a6e22e>std</span>::hash::Hasher<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>self, state: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> H) {
</span></span><span style=display:flex><span>        self.me.hash(state);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#66d9ef>ref</span> next) <span style=color:#f92672>=</span> self.next {
</span></span><span style=display:flex><span>            next.borrow().hash(state);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span> TyperChain<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(keyboards: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;kbs</span> [Keyboard]) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> me <span style=color:#f92672>=</span> Typer::new(<span style=color:#f92672>&amp;</span>keyboards[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> keyboards.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            Some(Rc::new(RefCell::new(TyperChain::new(<span style=color:#f92672>&amp;</span>keyboards[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]))))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self { me, next }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Type a single char on this chain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>type_char</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, c: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>, ()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;A&#39;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// An A sends activates the next robot in line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// If there is none, return the A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This may recursively fail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(next) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>self.next {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> next.borrow_mut().type_char(c);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Ok(Some(<span style=color:#e6db74>&#39;A&#39;</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Any other character just updates this robot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// If there is no next robot in line, it also emits the character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// If we fail to move, that is our error case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.me.go(c) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.next.is_none() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Ok(Some(self.me.keyboard.get_key(self.me.p).unwrap()));
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Ok(None);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                Err(())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I think I went slightly insane with this.</p><p>We have a <code>Keyboard</code> which represents the layout of the keys, a <code>Typer</code> which controls a keyboard (so it&rsquo;s cheaper to <code>clone</code>), and a <code>TyperChain</code>, which is several of those chained together. All together, it&rsquo;s a bonkers combination&ndash;especially when I was actually keeping lifetimes around so I wasn&rsquo;t making a ton of different copies of the keyboards.</p><p>On top of that, I was going to throw A-Star at it once again, with this as a successor function. Turns out just about any puzzle is a graph traversal problem if you stare at it hard enough. &#x1f604;"</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> successors <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>(chain, index): <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>State</span><span style=color:#f92672>&lt;</span>&#39;_, <span style=color:#a6e22e>&#39;kbs</span><span style=color:#f92672>&gt;|</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>KEYS</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_chain <span style=color:#f92672>=</span> chain.clone();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> new_chain.type_char(c) {
</span></span><span style=display:flex><span>            Ok(Some(c)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we typed the correct next char, continue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// If we typed something else, this is an invalid branch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> target_chars[<span style=color:#f92672>*</span>index] {
</span></span><span style=display:flex><span>                    next.push(((new_chain, index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Ok(None) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Advanced but did not type anything
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                next.push(((new_chain, <span style=color:#f92672>*</span>index), <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Err(()) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Failed to advance somewhere along the line, this is an invalid branch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    next
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>It&rsquo;s&mldr; a mess and didn&rsquo;t end up working. &#x1f604;</p><h3 id=version-2-direct-simulation>Version 2: Direct simulation</h3><p>Okay, so I scrapped all that, but kept the basic idea. This time, I&rsquo;ll keep the entire state encapsulated as a <code>Vec&lt;Point></code>, which is the ordered position on each keyboard as we go along the line.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Day21Error</span> {
</span></span><span style=display:flex><span>    InvalidDirection,
</span></span><span style=display:flex><span>    OutOfBounds,
</span></span><span style=display:flex><span>    InvalidPosition,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(arrow_robots: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> points <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>arrow_robots {
</span></span><span style=display:flex><span>            points.push(Point::new(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        points.push(Point::new(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        State { points }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hit</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(State, Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>), Day21Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_points <span style=color:#f92672>=</span> self.points.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> c <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>new_points.len() {
</span></span><span style=display:flex><span>            tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;In level {i}, c={c}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> keys <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> new_points.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>KEYPAD</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>ARROWS</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> new_points.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> { <span style=color:#ae81ff>4</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> (new_points[i].y <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> new_points[i].x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;A&#39;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Type that character on the next level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                c <span style=color:#f92672>=</span> keys[index];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Try to move this layer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> d: <span style=color:#a6e22e>Direction</span> <span style=color:#f92672>=</span> c.try_into().map_err(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Day21Error::InvalidDirection)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_point <span style=color:#f92672>=</span> new_points[i] <span style=color:#f92672>+</span> d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> new_point.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> new_point.x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> new_point.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> new_point.y <span style=color:#f92672>&gt;=</span> height {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(Day21Error::OutOfBounds);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Moved to an invalid character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> new_index <span style=color:#f92672>=</span> (new_point.y <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> new_point.x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> keys[new_index] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;*&#39;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(Day21Error::InvalidPosition);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Otherwise, we&#39;re done without outputting a character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                new_points[i] <span style=color:#f92672>=</span> new_point;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Ok((State { points: <span style=color:#a6e22e>new_points</span> }, None));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we made it out of the list, we typed whatever is left in c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Ok((State { points: <span style=color:#a6e22e>new_points</span> }, Some(c)))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>for i in 0..new_points.len()</code> is the core of the algorithm. Basically, it&rsquo;s looping through each layer. If you ever type an <code>A</code>, that means we&rsquo;ve got to process the next level down. Otherwise, you only update a pointer and break the recursion (so most of the time, we don&rsquo;t loop the entire way).</p><p>This&mldr; took a while to get exactly right. Thus the slightly more fleshed out <code>Day21Error</code> types (which also lets me use the <code>?</code> operator) and using <code><a href=https://docs.rs//latest//><code></code></a></code>
.</p><p>But it does work!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>21</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - sim : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 250ns,
</span></span><span style=display:flex><span>	runner: 6.171459ms
</span></span></code></pre></div><p>We&rsquo;ll do better <a href=#part-1-continued>after part 2</a>.</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of 2 intermediate sets of arrow keys, you have 25.</p></blockquote><p>&mldr;</p><p>That&rsquo;s a lot.</p><p>I didn&rsquo;t even try the direct simulation to see how long it would possibly take to solve this problem with A*. Instead, let&rsquo;s use a couple of facts we know about the simulation:</p><ul><li>It&rsquo;s always better to hit the same button more times in a row (<code>&lt;v&lt;</code> is slower than <code>&lt;&lt;v</code>). This is because to hit <code>&lt;&lt;</code>, the next level up can just hit an extra <code>A</code> without having to move while <code>&lt;v&lt;</code> would require <code>>A</code> to move from <code>&lt;</code> to <code>v</code> and another <code>&lt;A</code> to move back to <code>&lt;</code>. When you chain that up 25 layers, that&rsquo;s huge savings.</li></ul><p>So for any difference in points, we&rsquo;ll always want to either move horizontally than vertically or vice versa.</p><p>This is going to be most important when it comes down the the lowest level, moving around on the numpad/keypad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// For each numpad key, where is it?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>keypad_position</span>(key: <span style=color:#66d9ef>char</span>) -&gt; (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> key {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;7&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;8&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;9&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;4&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;5&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;6&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;2&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;3&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>        <span style=color:#75715e>// missing bottom left key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Invalid key&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Generate sequences of ^v&lt;&gt;A that will move from src to dst on the keypad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>keypad_paths</span>(src: <span style=color:#66d9ef>char</span>, dst: <span style=color:#66d9ef>char</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert to points
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> (x1, y1) <span style=color:#f92672>=</span> keypad_position(src);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (x2, y2) <span style=color:#f92672>=</span> keypad_position(dst);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we&#39;re move left/up, use &lt;^; otherwise &gt;V (deal with zero later)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> h_char <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> x1 <span style=color:#f92672>&lt;</span> x2 { <span style=color:#e6db74>&#39;&gt;&#39;</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#39;&lt;&#39;</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v_char <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> y1 <span style=color:#f92672>&lt;</span> y2 { <span style=color:#e6db74>&#39;v&#39;</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#39;^&#39;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> h_delta <span style=color:#f92672>=</span> (x2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>-</span> x1 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).abs();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> h_string <span style=color:#f92672>=</span> std::iter::repeat_n(h_char, h_delta <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>).collect::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v_delta <span style=color:#f92672>=</span> (y2 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>-</span> y1 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).abs();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v_string <span style=color:#f92672>=</span> std::iter::repeat_n(v_char, v_delta <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>).collect::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we only have one of the two, then our path is simple :smile:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (This avoids duplicate paths in the _ case below)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> h_delta <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> v_delta <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{h_string}{v_string}</span><span style=color:#e6db74>A&#34;</span>)];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> (x1, y1, x2, y2) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Moving from the bottom to the left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Avoid the missing square by going up first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (_, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>, _) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{v_string}{h_string}</span><span style=color:#e6db74>A&#34;</span>)],
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Moving from the left to the bottom
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Avoid the missing square by going right first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#ae81ff>0</span>, _, _, <span style=color:#ae81ff>3</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{h_string}{v_string}</span><span style=color:#e6db74>A&#34;</span>)],
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, try both
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> vh <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{v_string}{h_string}</span><span style=color:#e6db74>A&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> hv <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{h_string}{v_string}</span><span style=color:#e6db74>A&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>vec!</span>[vh, hv]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, we define where each point is, then we define a series of key presses we&rsquo;d have to enter on the last level arrow keys in order to go from any one key to another at the lowest level.</p><p>There are the two mentioned edge cases to avoid the missing space on the <code>keypad</code> and a simplification if we&rsquo;re moving straight in a direction rather than diagonally: only return one instead of both cases.</p><p>So if we have to print <code>029A</code>, we have (note: we always start at <code>A</code>):</p><ul><li><code>A</code> to <code>2</code>: <code>^&lt;A</code> or <code>&lt;^A</code></li><li><code>2</code> to <code>9</code>: <code>^^>A</code> or <code>>^^A</code></li><li><code>9</code> to <code>A</code>: only <code>vvv</code></li></ul><p>Next, we use that to set up the cost of entering a sequence on the <code>keypad</code> with some number of <code>arrows</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// To move a given sequence of characters with that many arrow bots
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>keypad_cost</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, arrow_bots: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Assume we&#39;re starting at A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For each pair of characters, find the minimum path between them recursively
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input)
</span></span><span style=display:flex><span>        .chars()
</span></span><span style=display:flex><span>        .tuple_windows()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(src, dst)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            tracing::<span style=color:#a6e22e>info!</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;arrows cost outer map src={src}, dst={dst} with arrow_bots={arrow_bots}&#34;</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            keypad_paths(src, dst)
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>info!</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;arrow costs inner map path={path} with arrow_bots={arrow_bots}&#34;</span>
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> arrow_bots <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        path.len()
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        arrows_cost(path, arrow_bots)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .min()
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From the outside in, we&rsquo;re going to start by adding the <code>A</code> (as I mentioned, always start with <code>A</code>) and then looping over each pair (<code>tuple_windows</code> is from <code><a href=https://docs.rs//latest//><code></code></a></code>
and is like <code>ls.iter().zip(ls.iter().skip(1))</code>, but more concise.</p><p>Next, we go through each possible path from those two keys. This will always be either 1 or 2 lists. For each of that sequences, we&rsquo;ll pass off to another function (<code>arrows_cost</code>, coming soon) to do the actual recursion.</p><p>And now the actually recursive bits: implementing a stack of <code>arrows</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Generate sequences of movements on the arrow keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>arrows_paths</span>(src: <span style=color:#66d9ef>char</span>, dst: <span style=color:#66d9ef>char</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For any square one away, go directly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For any two away, return both options
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>match</span> (src, dst) {
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;^&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;^&#39;</span>, <span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;v&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;^&#39;</span>, <span style=color:#e6db74>&#39;v&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;vA&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;^&#39;</span>, <span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;vA&#34;</span>, <span style=color:#e6db74>&#34;v&gt;A&#34;</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;^&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;v&lt;&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;v&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;vA&#34;</span>, <span style=color:#e6db74>&#34;v&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;vA&#34;</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&lt;&#39;</span>, <span style=color:#e6db74>&#39;^&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;^A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&lt;&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;&gt;^A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&lt;&#39;</span>, <span style=color:#e6db74>&#39;v&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&lt;&#39;</span>, <span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;&gt;A&#34;</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;v&#39;</span>, <span style=color:#e6db74>&#39;^&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;^A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;v&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;^&gt;A&#34;</span>, <span style=color:#e6db74>&#34;&gt;^A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;v&#39;</span>, <span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;v&#39;</span>, <span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&gt;A&#34;</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&gt;&#39;</span>, <span style=color:#e6db74>&#39;^&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;^A&#34;</span>, <span style=color:#e6db74>&#34;^&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&gt;&#39;</span>, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;^A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&gt;&#39;</span>, <span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;&lt;A&#34;</span>],
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;&gt;&#39;</span>, <span style=color:#e6db74>&#39;v&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;&lt;A&#34;</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// I had a heck of a time debugging in here... v =/= V
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (a, b) <span style=color:#66d9ef>if</span> a <span style=color:#f92672>==</span> b <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#e6db74>&#34;A&#34;</span>],
</span></span><span style=display:flex><span>        (a, b) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Bad encoding for </span><span style=color:#e6db74>{a}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{b}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|&amp;</span>s<span style=color:#f92672>|</span> s.to_owned())
</span></span><span style=display:flex><span>    .collect()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To move level 0 from (x, y) to (x + xd, y + yd), what do we need to do at this level?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>arrows_cost</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, arrow_bots: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we don&#39;t have any more arrow bots, it&#39;s easy :smile:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> arrow_bots <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> input.len();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Otherwise, assume we&#39;re starting at A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For each pair of characters, find the minimum path between them with one less bot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input)
</span></span><span style=display:flex><span>        .chars()
</span></span><span style=display:flex><span>        .tuple_windows()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(src, dst)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            tracing::<span style=color:#a6e22e>info!</span>(<span style=color:#e6db74>&#34;keypad cost mapping src={src}, dst={dst}&#34;</span>);
</span></span><span style=display:flex><span>            arrows_paths(src, dst)
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> arrows_cost(path, arrow_bots <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                .min()
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Deceptively simple. &#x1f604;</p><p>Basically, we once again do all the combinations of keys, although this time I just hard coded them. We are always either moving to an adjacent key (in which case there&rsquo;s one path), a one step diagonal (two paths), or from <code>&lt;</code> to/from <code>A</code> (one path that keeps the <code>&lt;&lt;</code> or <code>>></code> together and avoids the empty space).</p><p>Then for the recursive function, we go again for each <code>tuple_windows</code> of <code>&lt;>^vA</code> that we generated either one layer up or in the <code>keypad_cost</code>, and recursively ask what&rsquo;s the best way that we could generate that sequence.</p><p>It&rsquo;s kind of amazing how relatively little code this ended up being. We can use it to directly implement either part 1 or 2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day21, part1, recur)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_recur</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> line_multiplier(line) <span style=color:#f92672>*</span> keypad_cost(line, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[aoc(day21, part2, recur)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_recur</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> line_multiplier(line) <span style=color:#f92672>*</span> keypad_cost(line, <span style=color:#ae81ff>25</span>))
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For part 1, we get <em>significant</em> speedup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>21</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - sim : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 250ns,
</span></span><span style=display:flex><span>	runner: 6.171459ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - recur : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 208ns,
</span></span><span style=display:flex><span>	runner: 120.084Âµs
</span></span></code></pre></div><p>Mostly, we&rsquo;re not actually calculating the lists, but just the counts (which is what we needed).</p><p>Unfortunately, this <em>still</em> isn&rsquo;t fast enough to solve part 2. But this is fixable, since we know we&rsquo;re doing a <em>ton</em> of repeated work. Once we&rsquo;ve figured out how to go from <code>&lt;</code> to <code>></code> halfway down the stack once&mldr; we can do that over and over again and it will always be the same length.</p><h3 id=memoization>Memoization</h3><p>So of course, we&rsquo;re going to add <code>memoization</code>.</p><p>Basically, all we have to do is introduce a cache, pass it through the other <code>keyboard_cost</code> layer and then use it in the <code>arrows_cost</code> functions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheType</span> <span style=color:#f92672>=</span> HashMap<span style=color:#f92672>&lt;</span>(String, <span style=color:#66d9ef>usize</span>), <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To move level 0 from (x, y) to (x + xd, y + yd), what do we need to do at this level?
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This function is the one we actually memoize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>arrows_cost_memo</span>(cache: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> CacheType, input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, arrow_bots: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we don&#39;t have any more arrow bots, it&#39;s easy :smile:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> arrow_bots <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> input.len();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Already cached
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// NOTE: This is expensive, since I&#39;m cloning a ton of strings and hashing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//       But when the alternative is branching trillions of times...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (input.to_owned(), arrow_bots);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#f92672>&amp;</span>value) <span style=color:#f92672>=</span> cache.get(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Otherwise, assume we&#39;re starting at A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For each pair of characters, find the minimum path between them with one less bot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input)
</span></span><span style=display:flex><span>        .chars()
</span></span><span style=display:flex><span>        .tuple_windows()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(src, dst)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            tracing::<span style=color:#a6e22e>info!</span>(<span style=color:#e6db74>&#34;keypad cost mapping src={src}, dst={dst}&#34;</span>);
</span></span><span style=display:flex><span>            arrows_paths(src, dst)
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> arrows_cost_memo(cache, path, arrow_bots <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                .min()
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cache.insert(cache_key, result);
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To move a given sequence of characters with that many arrow bots
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This function exists entirely to call arrows_cost_memo with the cache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[tracing::instrument(ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>keypad_cost_memo</span>(cache: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> CacheType, input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, arrow_bots: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Assume we&#39;re starting at A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For each pair of characters, find the minimum path between them recursively
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;A</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input)
</span></span><span style=display:flex><span>        .chars()
</span></span><span style=display:flex><span>        .tuple_windows()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(src, dst)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            tracing::<span style=color:#a6e22e>info!</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;arrows cost outer map src={src}, dst={dst} with arrow_bots={arrow_bots}&#34;</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            keypad_paths(src, dst)
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>info!</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;arrow costs inner map path={path} with arrow_bots={arrow_bots}&#34;</span>
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> arrow_bots <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        path.len()
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        arrows_cost_memo(cache, path, arrow_bots)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .min()
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And build and pass in the caches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day21, part1, memo)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_recur_memo</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cache <span style=color:#f92672>=</span> CacheType::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> line_multiplier(line) <span style=color:#f92672>*</span> keypad_cost_memo(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> cache, line, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[aoc(day21, part2, memo)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_recur_memo</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cache <span style=color:#f92672>=</span> CacheType::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> line_multiplier(line) <span style=color:#f92672>*</span> keypad_cost_memo(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> cache, line, <span style=color:#ae81ff>25</span>))
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>One interesting bit is that we <em>specifically</em> want to keep the cache across input runs, since we&rsquo;re going to end up doing much of the same work on any level higher than the <code>keypad</code> itself. You&rsquo;re always moving from <code>&lt;</code> to <code>></code> halfway up somewhere in the problem, so cache it between runs.</p><p>So how&rsquo;s it do for part 1?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>21</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - sim : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 250ns,
</span></span><span style=display:flex><span>	runner: 6.171459ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - recur : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 208ns,
</span></span><span style=display:flex><span>	runner: 120.084Âµs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> - Part <span style=color:#ae81ff>1</span> - memo : <span style=color:#ae81ff>205160</span>
</span></span><span style=display:flex><span>	generator: 20.042Âµs,
</span></span><span style=display:flex><span>	runner: 76.708Âµs
</span></span></code></pre></div><p>Not bad. But the real magic comes in part 2!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> cargo aoc <span style=color:#f92672>--</span>day <span style=color:#ae81ff>21</span> <span style=color:#f92672>--</span>part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>AOC</span> <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>21</span> <span style=color:#f92672>-</span> Part <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> memo : <span style=color:#ae81ff>252473394928452</span>
</span></span><span style=display:flex><span>	generator: <span style=color:#ae81ff>27.917</span><span style=color:#960050;background-color:#1e0010>Âµ</span>s,
</span></span><span style=display:flex><span>	runner: <span style=color:#ae81ff>582.166</span><span style=color:#960050;background-color:#1e0010>Âµ</span>s
</span></span></code></pre></div><p>Why yes, that is in fact a very large number.</p><p>Breaking it out a bit more, each three digit plus <code>A</code> code took 8-10 <strong>billion</strong> keystrokes to enter.</p><p>What&rsquo;s kind of crazier (and more awesome) to me is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>line 1, cache size: 362
</span></span><span style=display:flex><span>line 2, cache size: 370
</span></span><span style=display:flex><span>line 3, cache size: 375
</span></span><span style=display:flex><span>line 4, cache size: 378
</span></span><span style=display:flex><span>line 5, cache size: 380
</span></span></code></pre></div><p>After the first solved problem, we&rsquo;ve only put 362 items in our cache. This is because there are only 16 different strings we&rsquo;re going to do at any specific step on <code>arrows_cost</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1   &lt;&lt;A
</span></span><span style=display:flex><span>3   &lt;A
</span></span><span style=display:flex><span>1   &lt;^A
</span></span><span style=display:flex><span>1   &lt;vA
</span></span><span style=display:flex><span>1   &gt;&gt;A
</span></span><span style=display:flex><span>1   &gt;&gt;^A
</span></span><span style=display:flex><span>3   &gt;A
</span></span><span style=display:flex><span>2   &gt;^A
</span></span><span style=display:flex><span>1   &gt;vA
</span></span><span style=display:flex><span>1   ^&lt;A
</span></span><span style=display:flex><span>1   ^&gt;A
</span></span><span style=display:flex><span>2   ^A
</span></span><span style=display:flex><span>1   v&lt;&lt;A
</span></span><span style=display:flex><span>2   v&lt;A
</span></span><span style=display:flex><span>1   v&gt;A
</span></span><span style=display:flex><span>2   vA
</span></span></code></pre></div><p>That times 25 layers means that our maximum cache size is only 400.</p><p>So we&rsquo;ve gotten 362 in the first iterations and only add 12 the second, then 3, 2, 2. So much repeated work!</p><p>No wonder it&rsquo;s sub millisecond to (show that you need to) count to ten billion 4 times. &#x1f604;</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># With tracing</span>
</span></span><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part1/sim       time:   <span style=color:#f92672>[</span>1.7863 ms 1.7963 ms 1.8074 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/recur     time:   <span style=color:#f92672>[</span>45.440 Âµs 45.715 Âµs 46.027 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/memo      time:   <span style=color:#f92672>[</span>20.319 Âµs 20.428 Âµs 20.556 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part2/memo      time:   <span style=color:#f92672>[</span>180.37 Âµs 180.69 Âµs 181.02 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><h3 id=tracing>Tracing</h3><p>The <code><a href=https://docs.rs//latest//><code></code></a></code>
is awesome. It reminds me of <a href=https://docs.racket-lang.org/reference/debugging.html target=_blank rel=noopener><code>racket/trace</code></a> from my Racket days. A simple change and you get tracing over recursive functions basically for free.</p><p>I was actually surprised at how little impact it had on the overall timing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Removing tracing calls entirely</span>
</span></span><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part1/sim       time:   <span style=color:#f92672>[</span>1.3800 ms 1.3844 ms 1.3888 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/recur     time:   <span style=color:#f92672>[</span>46.511 Âµs 49.849 Âµs 56.418 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/memo      time:   <span style=color:#f92672>[</span>19.496 Âµs 19.621 Âµs 19.772 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part2/memo      time:   <span style=color:#f92672>[</span>157.90 Âµs 158.17 Âµs 158.44 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Now don&rsquo;t get me wrong, there <em>is</em> a measurable cost, but it&rsquo;s well within the same order of magnitude. What&rsquo;s interesting though is that you can also use <a href=https://docs.rs/tracing/latest/tracing/level_filters/index.html target=_blank rel=noopener>level filters</a> to turn that off as a <code>Cargo.toml</code> feature flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo add tracing -F release_max_level_off
</span></span></code></pre></div><p>From the documentation:</p><blockquote><p>Trace verbosity levels can be statically disabled at compile time via Cargo features, similar to the log crate. Trace instrumentation at disabled levels will be skipped and will not even be present in the resulting binary unless the verbosity level is specified dynamically.</p></blockquote><p>This should mean that all of the tracing macros I added are not compiled into our binary in <code>release</code> mode.</p><p>That&rsquo;s it, now we run it again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Keep tracing calls + remove with -F release_max_level_off</span>
</span></span><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part1/sim       time:   <span style=color:#f92672>[</span>1.4110 ms 1.4204 ms 1.4316 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/recur     time:   <span style=color:#f92672>[</span>32.581 Âµs 32.933 Âµs 33.459 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/memo      time:   <span style=color:#f92672>[</span>15.031 Âµs 15.263 Âµs 15.601 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part2/memo      time:   <span style=color:#f92672>[</span>125.56 Âµs 127.00 Âµs 128.95 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>I&rsquo;m not 100% sure what&rsquo;s going on here, although I&rsquo;ll dig into it more. By two guesses are:</p><ol><li>This will also disable tracing in libraries I&rsquo;m using</li><li>I previously had the <code>-F log -F log-always</code> features of <code><a href=https://docs.rs//latest//><code></code></a></code>
still enabled; so it could have been generating log messages (even though I didn&rsquo;t look at them)</li></ol><p>To see that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Tracing with -F log -F log-always -F release_max_level_off</span>
</span></span><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part1/sim       time:   <span style=color:#f92672>[</span>1.7860 ms 1.8005 ms 1.8220 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/recur     time:   <span style=color:#f92672>[</span>46.033 Âµs 46.552 Âµs 47.321 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day21 - Part1/memo      time:   <span style=color:#f92672>[</span>20.111 Âµs 20.190 Âµs 20.282 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day21 - Part2/memo      time:   <span style=color:#f92672>[</span>163.49 Âµs 165.21 Âµs 167.94 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>To compare more directly, we have:</p><table><thead><tr><th>Name</th><th>With tracing</th><th>Removed</th><th><code>log,log-always</code></th><th><code>release_max_level_off</code></th></tr></thead><tbody><tr><td>Part1/sim</td><td>1.7963 ms</td><td>1.3844 ms</td><td>1.8005 ms</td><td>1.4204 ms</td></tr><tr><td>Part1/recur</td><td>45.715 Âµs</td><td>49.849 Âµs</td><td>46.552 Âµs</td><td>32.933 Âµs</td></tr><tr><td>Part1/memo</td><td>20.428 Âµs</td><td>19.621 Âµs</td><td>20.190 Âµs</td><td>15.263 Âµs</td></tr><tr><td>Part2/memo</td><td>180.69 Âµs</td><td>158.17 Âµs</td><td>165.21 Âµs</td><td>127.00 Âµs</td></tr></tbody></table><p>I wonder how much of that is just noise, even though I am doing <code>aoc bench</code> with it&rsquo;s 100 iterations. It&rsquo;s just such a quick program and (as noted in <a href=#memoization>the memo section</a>) it&rsquo;s not actually doing that many recursive calls by the end of it.</p><p>If anyone has more experience with the whole thing, I&rsquo;d love to hear it. It&rsquo;s not really that critical for most large scale applications (you will want logging far more than a tiny bit of performance for most cases), but it&rsquo;s fascinating to me.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>