<!doctype html><html><head><title>AoC 2024 Day 9: Defraginator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.34a34d86b8aae11b989d80a1626629c053029d012419a1993cfb6c12ea175737.css integrity="sha256-NKNNhriq4RuYnYChYmYpwFMCnQEkGaGZPPtsEuoXVzc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 9: Defraginator</h1><div class=entry-meta><span class=entry-date>2024-12-09</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/benchmarking>Benchmarking</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/binary-tree>Binary Tree</a></li><li><a class=taxonomy-value href=/programming/topics/disk-fragmentation>Disk Fragmentation</a></li><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/grid-traversal>Grid Traversal</a></li><li><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/simulation>Simulation</a><a href=https://blog.jverkamp.com/2024/12/14/aoc-2024-day-14-chaosinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/visualization>Visualization</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-9-disk-fragmenter>Source: <a href=https://adventofcode.com/2024/day/9 target=_blank rel=noopener>Day 9: Disk Fragmenter</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day9.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-9-disk-fragmenter>Source: <a href=https://adventofcode.com/2024/day/9>Day 9: Disk Fragmenter</a></a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-2>Part 2</a><ul><li><a href=#optimization-attempt-1-btree-representation>Optimization (attempt) 1: BTree representation</a></li></ul></li><li><a href=#optimization-2-track-the-leftmost-empty-space>Optimization 2: Track the leftmost empty space</a></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a disk layout alternating between files and empty spaces, move all files as early on the disk is possible, splitting into multiple blocks. Return a checksum on the disk.</p><p>Alternating means: <code>23331</code> would mean a 2 block file, 3 empty, a 3 block file, 3 empty, and a 1 block file.</p><p>The checksum is the sum of <code>file_id * block_index</code> for all occupied blocks. File IDs are assigned sequentially on initial generation.</p></blockquote><p>Okay, let&rsquo;s define and load a <code>Disk</code>. I&rsquo;m going to keep a <code>Vec&lt;Block></code> as the main data structure. This has the upside of simplicity and cache friendliness, but has the downside that if we have very large files, there will be a lot of wasted space.</p><p>&mldr;but we already know that no file can take up more than <code>9</code> blocks, since they&rsquo;re only defined as numbers <code>1..=9</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Block</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[default]</span>
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    File(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>File</span> {
</span></span><span style=display:flex><span>    start: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    size: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Disk</span> {
</span></span><span style=display:flex><span>    blocks: Vec<span style=color:#f92672>&lt;</span>Block<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    files: Vec<span style=color:#f92672>&lt;</span>File<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Disk {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> blocks <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> files <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_is_file <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>c.is_ascii_digit() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> next_is_file {
</span></span><span style=display:flex><span>                files.push(File {
</span></span><span style=display:flex><span>                    start: <span style=color:#a6e22e>blocks</span>.len(),
</span></span><span style=display:flex><span>                    size: <span style=color:#a6e22e>v</span>,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>v {
</span></span><span style=display:flex><span>                    blocks.push(Block::File(next_index));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                next_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>v {
</span></span><span style=display:flex><span>                    blocks.push(Block::Empty);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            next_is_file <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>next_is_file;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Disk { blocks, files }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I do keep a bit of metadata for <code>files</code> as well. For each <code>id</code>, you have the <code>start</code> of the file (initially) and the <code>size</code> of the file in blocks.</p><p>Okay, next up, let&rsquo;s write up the algorithm itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day9, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> disk <span style=color:#f92672>=</span> Disk::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> left_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> right_index <span style=color:#f92672>=</span> disk.blocks.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left_index <span style=color:#f92672>&lt;</span> right_index {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Right index should always point at a file node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> disk.blocks[right_index] {
</span></span><span style=display:flex><span>            Block::Empty <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                right_index <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Block::File { <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If left index is empty, swap the right index into it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Otherwise, advance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> disk.blocks[left_index] {
</span></span><span style=display:flex><span>            Block::Empty <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                disk.blocks.swap(left_index, right_index);
</span></span><span style=display:flex><span>                left_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                right_index <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Block::File(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                left_index <span style=color:#f92672>+=</span> disk.files[id].size;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    disk.checksum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is basically running two counters, one from the left looking for the next empty space and one from the right, looking for the next block to move. That&rsquo;s it!</p><p>We do need a checksum though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Disk {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>checksum</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        self.blocks
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(i, b)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> b {
</span></span><span style=display:flex><span>                Block::Empty <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                Block::File(id) <span style=color:#f92672>=&gt;</span> i <span style=color:#f92672>*</span> id,
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .sum()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it for part 1!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>9</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>9</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>6201130364722</span>
</span></span><span style=display:flex><span>	generator: 42ns,
</span></span><span style=display:flex><span>	runner: 626.458Âµs
</span></span></code></pre></div><p>Sub millisecond.</p><p>As an extra bonus, I did render this one:</p><p><video controls src=/embeds/2024/aoc/day9-part1.mp4 width=100%></video></p><p>These are always fun to watch.</p><h2 id=part-2>Part 2</h2><blockquote><p>This ends up fragmenting files. Instead, move each file (from highest to lowest ID, so right to left in initial order) to the leftmost space that is large enough to fit the entire file.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day9, part2, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> disk <span style=color:#f92672>=</span> Disk::from(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We&#39;re going to try to move each file from right to left exactly once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>&#39;each_file</span>: <span style=color:#a6e22e>for</span> moving_id <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>disk.files.len()).rev() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: We can probably cache the leftmost empty block to start at
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> left_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> empty_starts_at <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left_index <span style=color:#f92672>&lt;</span> disk.files[moving_id].start {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> disk.blocks[left_index] {
</span></span><span style=display:flex><span>                Block::File(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    left_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    empty_starts_at <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Block::Empty <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> empty_starts_at.is_none() {
</span></span><span style=display:flex><span>                        empty_starts_at <span style=color:#f92672>=</span> Some(left_index);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Found a large enough space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> empty_starts_at.is_some_and(<span style=color:#f92672>|</span>empty_starts_at<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        left_index <span style=color:#f92672>-</span> empty_starts_at <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> disk.files[moving_id].size
</span></span><span style=display:flex><span>                    }) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>disk.files[moving_id].size {
</span></span><span style=display:flex><span>                            disk.blocks.swap(
</span></span><span style=display:flex><span>                                disk.files[moving_id].start <span style=color:#f92672>+</span> i,
</span></span><span style=display:flex><span>                                empty_starts_at.unwrap() <span style=color:#f92672>+</span> i,
</span></span><span style=display:flex><span>                            );
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        disk.files[moving_id].start <span style=color:#f92672>=</span> empty_starts_at.unwrap();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;each_file;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        left_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    disk.checksum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So that&rsquo;s a chunk more code. Most of it comes from having to find a large enough space to fit the entire file. As soon as we do though, we move the file the same way as before: block by block. It seems wrong&mldr; but for the moment, it&rsquo;s pretty quick.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>9</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>9</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>6221662795602</span>
</span></span><span style=display:flex><span>	generator: 42ns,
</span></span><span style=display:flex><span>	runner: 119.026458ms
</span></span></code></pre></div><h3 id=optimization-attempt-1-btree-representation>Optimization (attempt) 1: BTree representation</h3><p>Okay, let&rsquo;s actually try it. Rather than representing each block in a <code>Vec</code>, let&rsquo;s make a <code>BTreeMap</code> of <code>index -> Node</code> where <code>Node</code> is either empty space or a file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>BTreeBlock</span> {
</span></span><span style=display:flex><span>    Empty { size: <span style=color:#66d9ef>usize</span> },
</span></span><span style=display:flex><span>    File { id: <span style=color:#66d9ef>usize</span>, size: <span style=color:#66d9ef>usize</span> },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BTreeDisk</span> {
</span></span><span style=display:flex><span>    blocks: <span style=color:#a6e22e>BTreeMap</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span>, BTreeBlock<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> BTreeDisk {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data <span style=color:#f92672>=</span> BTreeMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_is_file <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_file_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c.is_ascii_digit() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> next_is_file {
</span></span><span style=display:flex><span>                    data.insert(
</span></span><span style=display:flex><span>                        next_index,
</span></span><span style=display:flex><span>                        BTreeBlock::File {
</span></span><span style=display:flex><span>                            id: <span style=color:#a6e22e>next_file_id</span>,
</span></span><span style=display:flex><span>                            size,
</span></span><span style=display:flex><span>                        },
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                    next_file_id <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    data.insert(next_index, BTreeBlock::Empty { size });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                next_index <span style=color:#f92672>+=</span> size;
</span></span><span style=display:flex><span>                next_is_file <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>next_is_file;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        BTreeDisk { blocks: <span style=color:#a6e22e>data</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s at least a little easier to load.</p><p>Does it make the actual algorithm any better?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day9, part2, btree)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_btree</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> disk <span style=color:#f92672>=</span> BTreeDisk::from(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Collect the starting start index of each file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> files <span style=color:#f92672>=</span> disk
</span></span><span style=display:flex><span>        .blocks
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter_map(<span style=color:#f92672>|</span>(i, block)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> block {
</span></span><span style=display:flex><span>            BTreeBlock::File { size, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> Some((<span style=color:#f92672>*</span>i, <span style=color:#f92672>*</span>size)),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Try to move each file exactly once, from right to left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (_, <span style=color:#f92672>&amp;</span>(file_start, file_size)) <span style=color:#66d9ef>in</span> files.iter().enumerate().rev() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find the first empty space we can that will fit it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> empty_index <span style=color:#f92672>=</span> disk.blocks.iter().find(<span style=color:#f92672>|</span>(_, block)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> block {
</span></span><span style=display:flex><span>            BTreeBlock::Empty { size } <span style=color:#f92672>=&gt;</span> size <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>&amp;</span>file_size,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// No blocks that fit it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> empty_index.is_none() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (<span style=color:#f92672>&amp;</span>empty_index, _) <span style=color:#f92672>=</span> empty_index.unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Only move left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> empty_index <span style=color:#f92672>&gt;=</span> file_start {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> removed_empty_node <span style=color:#f92672>=</span> disk.blocks.remove(<span style=color:#f92672>&amp;</span>empty_index).unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> removed_file_node <span style=color:#f92672>=</span> disk.blocks.remove(<span style=color:#f92672>&amp;</span>file_start).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        disk.blocks.insert(empty_index, removed_file_node);
</span></span><span style=display:flex><span>        disk.blocks
</span></span><span style=display:flex><span>            .insert(file_start, BTreeBlock::Empty { size: <span style=color:#a6e22e>file_size</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we have extra empty space, insert a new empty node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> (removed_empty_node, removed_file_node) {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                BTreeBlock::Empty { size: <span style=color:#a6e22e>empty_size</span> },
</span></span><span style=display:flex><span>                BTreeBlock::File {
</span></span><span style=display:flex><span>                    id: <span style=color:#a6e22e>_</span>,
</span></span><span style=display:flex><span>                    size: <span style=color:#a6e22e>file_size</span>,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            ) <span style=color:#66d9ef>if</span> empty_size <span style=color:#f92672>&gt;</span> file_size <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                disk.blocks.insert(
</span></span><span style=display:flex><span>                    empty_index <span style=color:#f92672>+</span> file_size,
</span></span><span style=display:flex><span>                    BTreeBlock::Empty {
</span></span><span style=display:flex><span>                        size: <span style=color:#a6e22e>empty_size</span> <span style=color:#f92672>-</span> file_size,
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// While we have two neighboring empty nodes, combine them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// There are empty consecutive blocks at a and b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> maybe_empties <span style=color:#f92672>=</span> disk.blocks.iter().zip(disk.blocks.iter().skip(<span style=color:#ae81ff>1</span>)).find_map(
</span></span><span style=display:flex><span>                <span style=color:#f92672>|</span>((index, block), (next_index, next_block))<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> (block, next_block) {
</span></span><span style=display:flex><span>                    (BTreeBlock::Empty { size: <span style=color:#a6e22e>size1</span> }, BTreeBlock::Empty { size: <span style=color:#a6e22e>size2</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        Some((<span style=color:#f92672>*</span>index, <span style=color:#f92672>*</span>next_index, size1 <span style=color:#f92672>+</span> size2))
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((a, b, size)) <span style=color:#f92672>=</span> maybe_empties {
</span></span><span style=display:flex><span>                disk.blocks.remove(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>                disk.blocks.remove(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>                disk.blocks.insert(a, BTreeBlock::Empty { size });
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// No more consecutive empty blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    disk.checksum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I actually think that&rsquo;s a fair bit uglier. There are more edge cases to deal with and we don&rsquo;t actually gain much finding the first empty block.</p><p>And the checksum isn&rsquo;t even any better:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> BTreeDisk {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>checksum</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        self.blocks
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>index, <span style=color:#f92672>&amp;</span>b)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> b {
</span></span><span style=display:flex><span>                BTreeBlock::Empty { <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                BTreeBlock::File { id, size } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// TODO: We should be able to calculate this directly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// id * (2 * index + size) * (size - 1) / 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    ((index)<span style=color:#f92672>..</span>(index <span style=color:#f92672>+</span> size)).map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> i <span style=color:#f92672>*</span> id).sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .sum()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So how does it perform?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>9</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>9</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>6221662795602</span>
</span></span><span style=display:flex><span>	generator: 42ns,
</span></span><span style=display:flex><span>	runner: 119.026458ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>9</span> - Part <span style=color:#ae81ff>2</span> - btree : <span style=color:#ae81ff>6221662795602</span>
</span></span><span style=display:flex><span>	generator: 11.084Âµs,
</span></span><span style=display:flex><span>	runner: 929.480416ms
</span></span></code></pre></div><p>All righty then! I suppose we don&rsquo;t need that after all.</p><p>I think this does show off one slight annoyance with the <code>cargo-aoc</code> set up. You can&rsquo;t really have two different data structures and still use their <code>generate</code> code. At least not easily. I expect you could if you used an <code>enum</code>.</p><h2 id=optimization-2-track-the-leftmost-empty-space>Optimization 2: Track the leftmost empty space</h2><p>I rendered this one as well (using the original version):</p><p><video controls src=/embeds/2024/aoc/day9-part2-original.mp4 width=100%></video></p><p>If you watch to the end, you&rsquo;ll start to notice something a bit strange. It&rsquo;s getting slower and slower to update each file location.</p><p>To fix this, all we have to do is make sure that we start the search for new empty blocks to the left:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day9, part2, leftmost_empty)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_leftmost_empty</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> disk <span style=color:#f92672>=</span> Disk::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> leftmost_empty <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We&#39;re going to try to move each file from right to left exactly once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>&#39;each_file</span>: <span style=color:#a6e22e>for</span> moving_id <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>disk.files.len()).rev() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Advance the leftmost empty block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This will be cached so we ignore already filled parts of the drive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> leftmost_empty <span style=color:#f92672>&lt;</span> disk.blocks.len() <span style=color:#f92672>&amp;&amp;</span> disk.blocks[leftmost_empty] <span style=color:#f92672>!=</span> Block::Empty {
</span></span><span style=display:flex><span>            leftmost_empty <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span></code></pre></div><p><video controls src=/embeds/2024/aoc/day9-part2.mp4 width=100%></video></p><p>Much smoother!</p><p>Doesn&rsquo;t actually impact performance though unfortunately.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>9</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day9 - Part2/v1             time:   <span style=color:#f92672>[</span>113.13 ms 113.40 ms 113.70 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day9 - Part2/leftmost_empty time:   <span style=color:#f92672>[</span>114.89 ms 115.25 ms 115.69 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>If anything, it&rsquo;s slower.</p><p>Which is because scanning from the front to find an empty space is actually plenty fast. It&rsquo;s mostly a bug in the rendering&mldr; I generate a potential frame on each index scanning, so of course that&rsquo;s going to be slower.</p><p>So it goes!</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day9 - Part1/v1         time:   <span style=color:#f92672>[</span>384.69 Âµs 386.91 Âµs 389.41 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day9 - Part2/v1         time:   <span style=color:#f92672>[</span>115.96 ms 117.00 ms 118.18 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day9 - Part2/btree      time:   <span style=color:#f92672>[</span>884.94 ms 886.85 ms 888.92 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>