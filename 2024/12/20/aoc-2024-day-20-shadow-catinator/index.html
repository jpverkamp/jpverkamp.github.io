<!doctype html><html><head><title>AoC 2024 Day 20: Shadow Catinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 20: Shadow Catinator</h1><div class=entry-meta><span class=entry-date>2024-12-20</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/18/aoc-2024-day-18-last-chancinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/a-star>A-Star</a></li><li><a class=taxonomy-value href=/programming/topics/dijkstras-algorithm>Dijkstra's Algorithm</a></li><li><a href=https://blog.jverkamp.com/2024/12/18/aoc-2024-day-18-last-chancinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/pathfinding>Pathfinding</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/20/alcatraz-versus-the-scriveners-bones/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-20-race-condition>Source: <a href=https://adventofcode.com/2024/day/20 target=_blank rel=noopener>Day 20: Race Condition</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day20.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-20-race-condition>Source: <a href=https://adventofcode.com/2024/day/20>Day 20: Race Condition</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#version-1-entirely-over-complicated>Version 1: Entirely over complicated&mldr;</a></li><li><a href=#version-2-floodfill>Version 2: Floodfill</a></li><li><a href=#version-3-directly-scan-along-the-path>Version 3: Directly scan along the path</a></li><li><a href=#optimization-1-calculate-distances-once-dijkstras-algorithm>Optimization 1: Calculate distances once (Dijkstra&rsquo;s algorithm)</a></li><li><a href=#optimization-2-store-distances-in-a-grid>Optimization 2: Store distances in a <code>Grid</code></a></li><li><a href=#pretty-pictures>Pretty pictures</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#optimization-3-store-distances-in-a-grid>Optimization 3: Store distances in a <code>Grid</code></a></li><li><a href=#optimization-4-inverting-the-loop>Optimization 4: Inverting the loop</a></li><li><a href=#prettier-pictures>Prettier pictures</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a maze with exactly one path, find how many single walls you can walk through (remove) that shorten the best path by at least 100 units.</p></blockquote><p>Well this one was quite the ride.</p><p>I went quite down the rabbit hole on a really cool (in my opinion) solution before realizing I was missing a few things and badly overestimating how much work I needed to do for this problem. Then a number of times, I had <a href=https://en.wikipedia.org/wiki/off%20by%20one%20errors>off by one errors</a> and incorrect inequalities. Oy. I really could have done better with test cases, but it&rsquo;s a tricky one to write for.</p><h3 id=version-1-entirely-over-complicated>Version 1: Entirely over complicated&mldr;</h3><p>Okay, first version (that never did finish; it works on the examples, but not sure about the full puzzle).</p><p>The basic idea:</p><ul><li>Find the length of the best path using <a href=https://en.wikipedia.org/wiki/A*%20search>A* search</a></li><li>Repeatedly:<ul><li>Run A* with a modified successors function that takes both the point and a state machine<ul><li>If we&rsquo;re in the starting state, we can move or start skipping</li><li>If we&rsquo;re skipping, we can continue the skip</li><li>If we&rsquo;re done skipping, we can never skip again</li></ul></li><li>Once that returns, you have a new valid skip; store that so that the above A* cannot finish a skip with the same list</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    PreSkip,
</span></span><span style=display:flex><span>    Skip0,
</span></span><span style=display:flex><span>    Skip1(Point),
</span></span><span style=display:flex><span>    PostSkip(Point),
</span></span><span style=display:flex><span>    NoSkip,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This works in theory but is *very very slow* on the main input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day20, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Keep track of skips we&#39;ve used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We cannot use the same one more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> applied_skips <span style=color:#f92672>=</span> Rc::new(RefCell::new(HashSet::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Shared successor function, combining the point we&#39;re at and the state we&#39;re in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> successor <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>(point, state): <span style=color:#66d9ef>&amp;</span>(Point, State)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> successors <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re pre-skip, we can always start the skip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Do not include the move as part of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>state <span style=color:#f92672>==</span> State::PreSkip {
</span></span><span style=display:flex><span>            successors.push(((<span style=color:#f92672>*</span>point, State::Skip0), <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re out of skip points, transition to post skip without moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This means there are *no more cases*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Also, we can&#39;t skip the exact same set of walls more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> State::Skip1(p1) <span style=color:#f92672>=</span> state {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>applied_skips.borrow().contains(p1) {
</span></span><span style=display:flex><span>                successors.push(((<span style=color:#f92672>*</span>point, State::PostSkip(<span style=color:#f92672>*</span>p1)), <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> successors;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to move in each direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we&#39;re in a skip state, we can ignore walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Direction::all()
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> (<span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir, <span style=color:#f92672>*</span>state))
</span></span><span style=display:flex><span>            .for_each(<span style=color:#f92672>|</span>(new_point, state)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// We can never walk off the edge of the map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> input.walls.get(new_point).is_none() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> state {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Pre-skip, post-skip, and no-skip states have to obey walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    State::PreSkip <span style=color:#f92672>|</span> State::PostSkip(_) <span style=color:#f92672>|</span> State::NoSkip <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                            successors.push(((new_point, state), <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Skip means we can only walk on walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    State::Skip0 <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        successors.push(((new_point, State::Skip1(new_point)), <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Skip 2 should not be evalulate here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    State::Skip1(_) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>unreachable!</span>(<span style=color:#e6db74>&#34;Skip1 should not be evaluated here&#34;</span>),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        successors
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The initial time doesn&#39;t include skipping, so use the NoSkip state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> initial_time <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> astar(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>(input.start, State::NoSkip),
</span></span><span style=display:flex><span>        successor,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>(point, _)<span style=color:#f92672>|</span> point.manhattan_distance(<span style=color:#f92672>&amp;</span>input.end) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>(point, _)<span style=color:#f92672>|</span> point <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>input.end,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        Some((_path, cost)) <span style=color:#f92672>=&gt;</span> cost,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;No initial path found&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Keep going so long as we find &#39;cheating&#39; skips
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some((path, cost)) <span style=color:#f92672>=</span> astar(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>(input.start, State::PreSkip),
</span></span><span style=display:flex><span>        successor,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>(point, _)<span style=color:#f92672>|</span> point.manhattan_distance(<span style=color:#f92672>&amp;</span>input.end) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>(point, state)<span style=color:#f92672>|</span> point <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>input.end <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>matches!</span>(state, State::PostSkip(_)),
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The last point on the path stores the skip we used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> last_state <span style=color:#f92672>=</span> path.last().unwrap().<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> skip_used <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> last_state {
</span></span><span style=display:flex><span>            State::PostSkip(p) <span style=color:#f92672>=&gt;</span> p,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>unreachable!</span>(<span style=color:#e6db74>&#34;We should have ended in a post-skip state, was in </span><span style=color:#e6db74>{last_state:?}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// How much time did we save?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> savings <span style=color:#f92672>=</span> initial_time <span style=color:#f92672>-</span> cost;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we didn&#39;t save enough time (or any time!), we&#39;re done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> savings <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>if</span> input.example { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>100</span> } {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We have a new skip, so store that we used it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        applied_skips.borrow_mut().insert(skip_used);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> applied_skips.borrow().len();
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&mldr; is bonkers code, but I worked on it for a while and I wanted to share it. I have no idea if it would ever finish, I expect I&rsquo;d have errors anyways&mldr;</p><h3 id=version-2-floodfill>Version 2: Floodfill</h3><p>Okay, now I actually <em>looked</em> at the puzzle input. It&rsquo;s a very tight maze.</p><p>So option 2 was to perform a floodfill, start at the first point and flood outwards. At each point, try to go across a wall<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. If you haven&rsquo;t had a shortcut to that point yet, include it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// This doesn&#39;t work because it doesn&#39;t account for the skip bound
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day20, part1, floodfill)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_floodfill</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> point <span style=color:#f92672>=</span> input.start;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> Grid::new(input.walls.width, input.walls.height);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> skipped <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcuts <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>&#39;next_point</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>        visited.set(point, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are there any walls that we can skip that will lead us back on to the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// It has to be straight two steps, otherwise it will end up the same length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (We&#39;d be cutting off a corner)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.walls.get(point <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> input.walls.get(point <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited.get(point <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>skipped.contains(<span style=color:#f92672>&amp;</span>(point <span style=color:#f92672>+</span> d, point <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Can only skip the same point once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                skipped.insert((point <span style=color:#f92672>+</span> d, point <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                shortcuts <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re at the end, stop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> point <span style=color:#f92672>==</span> input.end {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, find the one point that we&#39;ve not already visited
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.walls.get(point <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited.get(point <span style=color:#f92672>+</span> d).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                point <span style=color:#f92672>=</span> point <span style=color:#f92672>+</span> d;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;next_point;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we make it here, we failed to find the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>unreachable!</span>(<span style=color:#e6db74>&#34;No path found at </span><span style=color:#e6db74>{point:?}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcuts
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem with this is that (for some reason :p) we don&rsquo;t actually want the entire count of these, we only want those that cut off at least 100 steps. Which&mldr; this algorithm has no good way of calculating. I could run A* from the far point each time&mldr; but when working on that, I was already thinking of the next solution!</p><h3 id=version-3-directly-scan-along-the-path>Version 3: Directly scan along the path</h3><p>Okay, the first actually working version for part1!</p><p>And so far as actually reading the problem&mldr; turns out there was one <em>very</em> important bit of that:</p><blockquote><p>Because there is <strong>only a single path</strong> from the start to the end and the programs all go the same speed, the races used to be pretty boring.</p></blockquote><p>Emphasis mine.</p><p>So what we can do is find that best path. Because of the structure of the input, we actually find that all possible shortcuts are on this path. I&rsquo;m not <strong>100%</strong> sure that you can actually generally say that&mldr; at least if it&rsquo;s possible to have deadends you can cut over to. But since that&rsquo;s not the case, you&rsquo;ll always cut from a point on this path to another point on the path!</p><p>So, now we scan the path, then for each point it, we try each wall, will going in that direction (once again ignoring corners) lead to a point further along the path? (As opposed to before us).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part1, pathscan)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_pathscan</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First, find the one true path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> astar(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>input.start,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            Direction::all()
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir)
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|&amp;</span>new_point<span style=color:#f92672>|</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>new_point<span style=color:#f92672>|</span> (new_point, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> point.manhattan_distance(<span style=color:#f92672>&amp;</span>input.end),
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>==</span> input.end,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .expect(<span style=color:#e6db74>&#34;No path found&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cutoff <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.example { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>100</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now, for each point in that path, see if we can skip to a point further along the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcut_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, p) <span style=color:#66d9ef>in</span> path.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are there any walls that we can skip that will lead us back on to the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// It has to be straight two steps, otherwise it will end up the same length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (We&#39;d be cutting off a corner)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.walls.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> input.walls.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> path
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .position(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> p2 <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d)
</span></span><span style=display:flex><span>                    .is_some_and(<span style=color:#f92672>|</span>i2<span style=color:#f92672>|</span> i2 <span style=color:#f92672>&gt;</span> i <span style=color:#f92672>&amp;&amp;</span> i2 <span style=color:#f92672>-</span> i <span style=color:#f92672>&gt;</span> cutoff)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcut_count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here, finally, we have a solution!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - pathscan : <span style=color:#ae81ff>1399</span>
</span></span><span style=display:flex><span>	generator: 158.916Âµs,
</span></span><span style=display:flex><span>	runner: 36.663209ms
</span></span></code></pre></div><p>Now that&rsquo;s already fairly quick, but I think that I have a little bit of room to do better.</p><h3 id=optimization-1-calculate-distances-once-dijkstras-algorithm>Optimization 1: Calculate distances once (Dijkstra&rsquo;s algorithm)</h3><p>First optimization, we are currently doing a bunch of vector scanning to figure out how much space we&rsquo;ve saved. We can beat that by using <a href=https://en.wikipedia.org/wiki/Dijkstra%e2%80%99s%20algorithm>Dijkstraâ€™s algorithm</a> to pre-calculate how far each point is from the end and directly know how much we&rsquo;re saving:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part1, dijkstra)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_dijkstra</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find every point&#39;s distance to the end using dijkstra&#39;s algorithm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> distances <span style=color:#f92672>=</span> dijkstra_all(<span style=color:#f92672>&amp;</span>input.end, <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        Direction::all()
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir)
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|&amp;</span>new_point<span style=color:#f92672>|</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>new_point<span style=color:#f92672>|</span> (new_point, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cutoff <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.example { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>100</span> };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> input.start;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcut_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Follow the shortest path via dijkstra&#39;s algorithm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some((next_point, current_distance)) <span style=color:#f92672>=</span> distances.get(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are there any walls that we can skip that will lead us back on to the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// It has to be straight two steps, otherwise it will end up the same length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (We&#39;d be cutting off a corner)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.walls.get(p <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>) <span style=color:#f92672>&amp;&amp;</span> input.walls.get(p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Special case the exit (it&#39;s not in the distances map)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d <span style=color:#f92672>==</span> input.end {
</span></span><span style=display:flex><span>                    shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// For all other cases, calculate up how much we&#39;re saving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>match</span> distances.get(<span style=color:#f92672>&amp;</span>(p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d)) {
</span></span><span style=display:flex><span>                    Some((_, new_distance)) <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>new_distance <span style=color:#f92672>&gt;</span> current_distance <span style=color:#f92672>+</span> cutoff <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Advance along dijkstra&#39;s path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>next_point;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcut_count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not that complicated a change and:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - pathscan : <span style=color:#ae81ff>1399</span>
</span></span><span style=display:flex><span>	generator: 158.916Âµs,
</span></span><span style=display:flex><span>	runner: 36.663209ms
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - dijkstra : <span style=color:#ae81ff>1382</span>
</span></span><span style=display:flex><span>	generator: 112.125Âµs,
</span></span><span style=display:flex><span>	runner: 4.388792ms
</span></span></code></pre></div><p>It also is significantly faster!</p><h3 id=optimization-2-store-distances-in-a-grid>Optimization 2: Store distances in a <code>Grid</code></h3><p>But there is still room for just a <em>bit</em> of optimization. Dijkstra&rsquo;s still requires hashing each of the points to figure out where on the path we are. We&rsquo;ve already found in previous days that we can get a speedup by flattening that into direct access in a <code>Grid</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part1, grid)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_grid</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First, find the one true path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> astar(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>input.start,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            Direction::all()
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir)
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|&amp;</span>new_point<span style=color:#f92672>|</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>new_point<span style=color:#f92672>|</span> (new_point, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> point.manhattan_distance(<span style=color:#f92672>&amp;</span>input.end),
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>==</span> input.end,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .expect(<span style=color:#e6db74>&#34;No path found&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store distances as a grid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distances <span style=color:#f92672>=</span> Grid::new(input.walls.width, input.walls.height);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, p) <span style=color:#66d9ef>in</span> path.iter().enumerate() {
</span></span><span style=display:flex><span>        distances.set(<span style=color:#f92672>*</span>p, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cutoff <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.example { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>100</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now, for each point in that path, see if we can skip to a point further along the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcut_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, p) <span style=color:#66d9ef>in</span> path.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are there any walls that we can skip that will lead us back on to the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// It has to be straight two steps, otherwise it will end up the same length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (We&#39;d be cutting off a corner)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> input.walls.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> input.walls.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> distances
</span></span><span style=display:flex><span>                    .get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d <span style=color:#f92672>+</span> d)
</span></span><span style=display:flex><span>                    .map_or(<span style=color:#66d9ef>false</span>, <span style=color:#f92672>|</span>i2<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>i2 <span style=color:#f92672>&gt;</span> i <span style=color:#f92672>+</span> cutoff)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcut_count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we get just a bit of speedup from that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - pathscan : <span style=color:#ae81ff>1399</span>
</span></span><span style=display:flex><span>	generator: 158.916Âµs,
</span></span><span style=display:flex><span>	runner: 36.663209ms
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - dijkstra : <span style=color:#ae81ff>1382</span>
</span></span><span style=display:flex><span>	generator: 112.125Âµs,
</span></span><span style=display:flex><span>	runner: 4.388792ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>1</span> - grid : <span style=color:#ae81ff>1399</span>
</span></span><span style=display:flex><span>	generator: 66.25Âµs,
</span></span><span style=display:flex><span>	runner: 2.931375ms
</span></span></code></pre></div><p>And&mldr; I think that&rsquo;s probably enough for a moment. I&rsquo;m not quite in the sub millisecond range (man, I used to go for sub 1 second, or even 1 minute!), but that&rsquo;s still pretty crazy fast.</p><p>(Plus, when I actually do the benchmarking, it <em>is</em> submillisecond. 633.33 Âµs &#x1f604;)</p><h3 id=pretty-pictures>Pretty pictures</h3><p>Okay, let&rsquo;s look at what this algorithm is actually doing:</p><p><video controls src=/embeds/2024/aoc/day20-part1.mp4></video></p><p>What you&rsquo;re seeing is the point following the path, scanning each point around it. If it&rsquo;s a valid skip, it will get saved in green, if not it will flash red but otherwise be skipped.</p><p>The acceleration here is not actually part of the image, it&rsquo;s just a really long path. &#x1f604;</p><h2 id=part-2>Part 2</h2><blockquote><p>Allow skips of up to 20 spaces. Unique skips are identified by the start and end point (both on the path), different skips with the same start and end are considered the same. How many skips are there now?</p></blockquote><p>Okay, now that&rsquo;s a complicated!</p><p>Luckily, I ended up on a pretty decent algorithm the first time around with caching the distances.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part2, pathscan)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_pathscan</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> skiplength <span style=color:#f92672>=</span> <span style=color:#ae81ff>20_</span><span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cutoff <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.example { <span style=color:#ae81ff>50</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>100</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First, find the one true path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> astar(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>input.start,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            Direction::all()
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir)
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|&amp;</span>new_point<span style=color:#f92672>|</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>new_point<span style=color:#f92672>|</span> (new_point, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> point.manhattan_distance(<span style=color:#f92672>&amp;</span>input.end),
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>==</span> input.end,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .expect(<span style=color:#e6db74>&#34;No path found&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the distance from the exit to every point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// This will be used to verify &#39;better&#39; paths
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We need this because it&#39;s possible to take a shortcut to a previous dead end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distances <span style=color:#f92672>=</span> dijkstra_all(<span style=color:#f92672>&amp;</span>input.end, <span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        Direction::all()
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|&amp;</span>dir<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>point <span style=color:#f92672>+</span> dir)
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|&amp;</span>new_point<span style=color:#f92672>|</span> input.walls.get(new_point) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>new_point<span style=color:#f92672>|</span> (new_point, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add the exit :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    distances.insert(input.end, (input.end, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now, for each point in that path, see if we can skip to a point further along the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We can skip up to 20, so any point that within manhattan distance 20 is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcut_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, p) <span style=color:#66d9ef>in</span> path.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are there any walls that we can skip that will lead us back on to the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// It has to be straight two steps, otherwise it will end up the same length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (We&#39;d be cutting off a corner)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> xd <span style=color:#66d9ef>in</span> <span style=color:#f92672>-</span>skiplength<span style=color:#f92672>..=</span>skiplength {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> yd <span style=color:#66d9ef>in</span> <span style=color:#f92672>-</span>skiplength<span style=color:#f92672>..=</span>skiplength {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Ignore skipping to yourself or skipping too far
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> xd <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> yd <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> xd.abs() <span style=color:#f92672>+</span> yd.abs() <span style=color:#f92672>&gt;</span> skiplength {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> d: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> (xd, yd).into();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p2: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Cannot end on a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// This is covered by the distanced map, but this lookup is faster
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// With: 112.44 ms, Without: 189.61 ms
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> input.walls.get(p2) <span style=color:#f92672>!=</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Cannot get from the target to the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>distances.contains_key(<span style=color:#f92672>&amp;</span>p2) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// The distance using the shortcut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> new_distance <span style=color:#f92672>=</span> i <span style=color:#75715e>// To start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#f92672>+</span> d.manhattan_distance(<span style=color:#f92672>&amp;</span>Point::<span style=color:#66d9ef>ZERO</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#75715e>// Shortcut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#f92672>+</span> distances.get(<span style=color:#f92672>&amp;</span>p2).unwrap().<span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#75715e>// To end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Doesn&#39;t cut off enough
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> new_distance <span style=color:#f92672>&gt;</span> path.len() <span style=color:#f92672>-</span> cutoff {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we&#39;ve made it this far, we can shortcut!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcut_count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, we do have a few more cases to check, but the core is the same. For each point, we&rsquo;re going to scan out to a <a href=https://en.wikipedia.org/wiki/Manhattan%20distance>Manhattan distance</a> of 20. For each of those points, we have to make sure we&rsquo;re not in a wall, we have a path to the end (this should always be true, since there aren&rsquo;t branches), and the distance is within the cutoff.</p><p>One interesting thing is that we don&rsquo;t actually have to care about unique paths at all! Since we&rsquo;re scanning each exit point exactly once&mldr; there&rsquo;s no way for it possibly to have duplicates. I had code for a while that checked that, but when optimizing imagine my amusement realizing it was completely unnecessary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - pathscan : <span style=color:#ae81ff>994807</span>
</span></span><span style=display:flex><span>	generator: 31.125Âµs,
</span></span><span style=display:flex><span>	runner: 110.209833ms
</span></span></code></pre></div><h3 id=optimization-3-store-distances-in-a-grid>Optimization 3: Store distances in a <code>Grid</code></h3><p>The one optimization I&rsquo;ll do for this one (I spent a lot more on the <a href=#prettier-pictures>rendering</a>) is once again using <code>Grid</code> instead of <code>HashMap</code> for the distances.</p><p>Since it&rsquo;s basically the same change and doesn&rsquo;t change the algorithm at all, I&rsquo;m not going to include the code here, but you can see it <a href=https://github.com/jpverkamp/advent-of-code/blob/47a31aa60a307cd8913cb80db3a742341d3aad3e/2024/src/day20.rs#L461-L544 target=_blank rel=noopener>on github</a> if you are curious.</p><p>And how&rsquo;s it do?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - pathscan : <span style=color:#ae81ff>994807</span>
</span></span><span style=display:flex><span>	generator: 31.125Âµs,
</span></span><span style=display:flex><span>	runner: 110.209833ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - griddist : <span style=color:#ae81ff>4712224</span>
</span></span><span style=display:flex><span>	generator: 62.625Âµs,
</span></span><span style=display:flex><span>	runner: 38.130625ms
</span></span></code></pre></div><p>There are <em>a lot</em> more lookups this time around, so that&rsquo;s a fairly dramatic speedup from not having to hash.</p><p>Onward!</p><h3 id=optimization-4-inverting-the-loop>Optimization 4: Inverting the loop</h3><p>Okay, a bit later, one final way to look at the problem.</p><p>Very specifically, because we know that there is only one path and every point is on the path, instead of searching from each point out to a radius of 20, instead, we can:</p><ul><li>From each point on the path:<ul><li>For each point starting 100 after that point:<ul><li>If the two points are within 20 of each other AND at least 100 better overall</li></ul></li></ul></li></ul><p>We still need to find the best path and all the distance to each point and it&rsquo;s really dependent on the structure of the problem, but it turns out that it&rsquo;s got a slightly better constant on the runtime.</p><p>If you want to write it with iters:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part2, listiter)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_listiter</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For any point on the path, for any point at least cutoff further along the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If those two points are within skip_length, there is a shortcut between them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    path.iter()
</span></span><span style=display:flex><span>        .enumerate()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(start, p1)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            path.iter()
</span></span><span style=display:flex><span>                .skip(start <span style=color:#f92672>+</span> cutoff)
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>p2<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// The skip is short enough + the distance saved is big enough
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    p1.manhattan_distance(p2) <span style=color:#f92672>&lt;=</span> skip_length
</span></span><span style=display:flex><span>                        <span style=color:#f92672>&amp;&amp;</span> distances.get(<span style=color:#f92672>*</span>p1).unwrap()
</span></span><span style=display:flex><span>                            <span style=color:#f92672>-</span> distances.get(<span style=color:#f92672>**</span>p2).unwrap()
</span></span><span style=display:flex><span>                            <span style=color:#f92672>-</span> p1.manhattan_distance(p2)
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&gt;=</span> cutoff <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .count()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And if you want to write it with nested for loops:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day20, part2, listfor)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_listfor</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Puzzle</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For any point on the path, for any point at least cutoff further along the path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If those two points are within skip_length, there is a shortcut between them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> shortcut_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (start, p1) <span style=color:#66d9ef>in</span> path.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p2 <span style=color:#66d9ef>in</span> path.iter().skip(start <span style=color:#f92672>+</span> cutoff) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The skip is short enough + the distance saved is big enough
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> p1.manhattan_distance(p2) <span style=color:#f92672>&lt;=</span> skip_length
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> distances.get(<span style=color:#f92672>*</span>p1).unwrap()
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-</span> distances.get(<span style=color:#f92672>*</span>p2).unwrap()
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-</span> p1.manhattan_distance(p2)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>&gt;=</span> cutoff <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                shortcut_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shortcut_count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And they do perform <em>slightly</em> quicker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>20</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - pathscan : <span style=color:#ae81ff>994807</span>
</span></span><span style=display:flex><span>	generator: 31.125Âµs,
</span></span><span style=display:flex><span>	runner: 110.209833ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - griddist : <span style=color:#ae81ff>4712224</span>
</span></span><span style=display:flex><span>	generator: 62.625Âµs,
</span></span><span style=display:flex><span>	runner: 38.130625ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - listiter : <span style=color:#ae81ff>994807</span>
</span></span><span style=display:flex><span>	generator: 30.25Âµs,
</span></span><span style=display:flex><span>	runner: 30.332125ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>20</span> - Part <span style=color:#ae81ff>2</span> - listfor : <span style=color:#ae81ff>994807</span>
</span></span><span style=display:flex><span>	generator: 62.625Âµs,
</span></span><span style=display:flex><span>	runner: 23.924083ms
</span></span></code></pre></div><h3 id=prettier-pictures>Prettier pictures</h3><p>Okay, rendering time. I had quite a time getting something both interesting and in a reasonable time/filesize:</p><p><video controls src=/embeds/2024/aoc/day20-part2.mp4></video></p><p>This time, you&rsquo;re not seeing the shortcuts themselves (since I never actually calculate those paths) but instead how many possible shortcuts end at each point as a heatmap (from blue to red).</p><p>The white point is where we are scanning and the green diamond is the radius we&rsquo;re looking for shortcut exits in.</p><p>Pretty cool.</p><h2 id=benchmarks>Benchmarks</h2><pre tabindex=0><code>$ cargo aoc bench --day 20

Day20 - Part1/pathscan  time:   [28.508 ms 28.768 ms 29.124 ms]
Day20 - Part1/dijkstra  time:   [1.2037 ms 1.2152 ms 1.2269 ms]
Day20 - Part1/grid      time:   [627.17 Âµs 633.33 Âµs 641.92 Âµs]

Day20 - Part2/pathscan  time:   [113.84 ms 114.70 ms 115.77 ms]
Day20 - Part2/griddist  time:   [34.101 ms 34.353 ms 34.697 ms]
Day20 - Part2/listiter  time:   [30.221 ms 30.579 ms 31.203 ms]
Day20 - Part2/listfor   time:   [22.468 ms 22.921 ms 23.492 ms]
</code></pre><p>None too shabby. I spent&mldr; more time than I care to admit on this one. But it was a fun one, so it goes!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>One of the skips here is that because you&rsquo;re skipping across a single point, you can never cut off corners, it always has to be a straight line.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>