<!doctype html><html><head><title>AoC 2024 Day 7: Mathinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 7: Mathinator</h1><div class=entry-meta><span class=entry-date>2024-12-07</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2024/12/17/aoc-2024-day-17-virtual-machininator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/benchmarking>Benchmarking</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/combinatorial-search>Combinatorial Search</a></li><li><a class=taxonomy-value href=/programming/topics/depth-first-search>Depth First Search</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memoization>Memoization</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/02/17/genuary-2023.17-a-grid-inside-a-grid-inside-a-grid/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/recursion>Recursion</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/03/14/infinite-craft-bot/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/search>Search</a><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-7-bridge-repair>Source: <a href=https://adventofcode.com/2024/day/7 target=_blank rel=noopener>Day 7: Bridge Repair</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day7.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-7-bridge-repair>Source: <a href=https://adventofcode.com/2024/day/7>Day 7: Bridge Repair</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#optimization-attempt-1-queue>Optimization (attempt) 1: Queue</a></li></ul></li><li><a href=#part-2>Part 2</a></li><li><a href=#a-cleaner-way-of-looking-at-it-opset>A &lsquo;cleaner&rsquo; way of looking at it: <code>OpSet</code></a></li><li><a href=#benchmarks>Benchmarks</a></li><li><a href=#future-work>Future work</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a result and a list of numbers, determine if any combination of addition (<code>+</code>) and/or multiplication (<code>*</code>) using all the given numbers in order can return the result. Ignore order of operations.</p></blockquote><p>Let&rsquo;s do some <a href=https://en.wikipedia.org/wiki/recursion>recursion</a>! Basically, for any given list, take the smaller list consisting of all but the first element. Then check first the case of first element <code>+</code> the recur and then <code>*</code> the recur. If either of those are true, we&rsquo;re correct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day7, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span>[Equation]) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solvable</span>(target: <span style=color:#66d9ef>u64</span>, acc: <span style=color:#66d9ef>u64</span>, values: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u64</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> values.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> target <span style=color:#f92672>==</span> acc;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        is_solvable(target, acc <span style=color:#f92672>+</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> is_solvable(target, acc <span style=color:#f92672>*</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> is_solvable(eq.result, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>eq.input))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> eq.result)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>One nice thing about this is that we get short circuiting basically for free. It&rsquo;s going to do a <a href=https://en.wikipedia.org/wiki/depth-first%20search>depth-first search</a> down all <code>+</code>, then all <code>+</code> and one <code>*</code> etc, and finally all <code>*</code>. As soon as any branch returns <code>true</code>, all the rest at that level won&rsquo;t be checked.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>7</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>975671981569</span>
</span></span><span style=display:flex><span>	generator: 280.667Âµs,
</span></span><span style=display:flex><span>	runner: 1.594708ms
</span></span></code></pre></div><p>That&rsquo;s not bad. I bet I could get it under 1ms, but it&rsquo;s good enough for now.</p><h3 id=optimization-attempt-1-queue>Optimization (attempt) 1: Queue</h3><p>One thing that I&rsquo;d like to try is to avoid the overhead of function calls. Specifically, instead of keeping the results in the function call stack, instead keep our own:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day7, part1, queue)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_queue</span>(input: <span style=color:#66d9ef>&amp;</span>[Equation]) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::with_capacity(<span style=color:#ae81ff>2_</span><span style=color:#66d9ef>usize</span>.pow(eq.input.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>));
</span></span><span style=display:flex><span>            queue.push((eq.result, <span style=color:#ae81ff>0</span>, eq.input.as_slice()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some((target, acc, values)) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> values.is_empty() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> target <span style=color:#f92672>==</span> acc {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    queue.push((target, acc <span style=color:#f92672>+</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]));
</span></span><span style=display:flex><span>                    queue.push((target, acc <span style=color:#f92672>*</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> eq.result)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In my opinion, it&rsquo;s actually a bit harder to read this way, but perhaps that&rsquo;s all those years of <a href=https://blog.jverkamp.com/programming/languages/racket/>Racket</a>/<a href=https://blog.jverkamp.com/programming/languages/scheme/>Scheme</a> coming back. &#x1f604;</p><p>Amusingly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>7</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>975671981569</span>
</span></span><span style=display:flex><span>	generator: 280.667Âµs,
</span></span><span style=display:flex><span>	runner: 1.594708ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>1</span> - queue : <span style=color:#ae81ff>975671981569</span>
</span></span><span style=display:flex><span>	generator: 365.916Âµs,
</span></span><span style=display:flex><span>	runner: 3.117834ms
</span></span></code></pre></div><p>It doesn&rsquo;t actually perform any better anyways! I should have managed to avoid allocations <code>with_capacity</code>, but that doesn&rsquo;t mean there aren&rsquo;t other optimizations this version can&rsquo;t do. So it goes!</p><h2 id=part-2>Part 2</h2><blockquote><p>Add the <code>||</code> operator: <a href=https://en.wikipedia.org/wiki/concatenation>concatenation</a>.</p></blockquote><p>That one is going to be a bit more of a pain to implement, but still doable. Basically, to implement <code>a || b</code>, we can either convert both to strings, concat, and convert them back&mldr; or we can figure out how many digits <code>b</code> has (with <code>log10</code>) and multiple by <code>10^that</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day7, part2, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_v1</span>(input: <span style=color:#66d9ef>&amp;</span>[Equation]) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solvable</span>(target: <span style=color:#66d9ef>u64</span>, acc: <span style=color:#66d9ef>u64</span>, values: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u64</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> values.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> target <span style=color:#f92672>==</span> acc;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        is_solvable(target, acc <span style=color:#f92672>+</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> is_solvable(target, acc <span style=color:#f92672>*</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> digits <span style=color:#f92672>=</span> values[<span style=color:#ae81ff>0</span>].ilog10() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> multiplier <span style=color:#f92672>=</span> <span style=color:#ae81ff>10_</span><span style=color:#66d9ef>u64</span>.pow(digits);
</span></span><span style=display:flex><span>                is_solvable(target, acc <span style=color:#f92672>*</span> multiplier <span style=color:#f92672>+</span> values[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span>values[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>])
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> is_solvable(eq.result, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>eq.input))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> eq.result)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How&rsquo;s it do?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>cargo aoc <span style=color:#f92672>--</span>day <span style=color:#ae81ff>7</span> <span style=color:#f92672>--</span>part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> <span style=color:#f92672>-</span> Part <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> v1 : <span style=color:#ae81ff>223472064194845</span>
</span></span><span style=display:flex><span>	generator: <span style=color:#ae81ff>170.208</span><span style=color:#960050;background-color:#1e0010>Âµ</span>s,
</span></span><span style=display:flex><span>	runner: <span style=color:#ae81ff>42.832875</span>ms
</span></span></code></pre></div><p>We actually have two different problems here: not only is <code>||</code> <em>significantly</em> slower to compute than <code>+</code> or <code>*</code>, but we&rsquo;re also checking <code>O(3^n)</code> possibilities instead of <code>O(2^n)</code>. Still, relatively fast. We&rsquo;ll go with this for now.</p><h2 id=a-cleaner-way-of-looking-at-it-opset>A &lsquo;cleaner&rsquo; way of looking at it: <code>OpSet</code></h2><p>One thing that bugged me a bit about this program was how difficult (relatively) it is to extend. To add another operator, you have to add another whole call to <code>is_solvable</code> with the new op. What if we could abstract that?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OpSet</span> {
</span></span><span style=display:flex><span>    ops: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>fn</span>(<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> OpSet {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self { ops: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[] }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>include</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, op: <span style=color:#a6e22e>fn</span>(<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span>) {
</span></span><span style=display:flex><span>        self.ops.push(op);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_solve</span>(<span style=color:#f92672>&amp;</span>self, target: <span style=color:#66d9ef>u64</span>, args: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u64</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(me: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>OpSet</span>, target: <span style=color:#66d9ef>u64</span>, acc: <span style=color:#66d9ef>u64</span>, args: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u64</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> args.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> target <span style=color:#f92672>==</span> acc;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            me.ops
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .any(<span style=color:#f92672>|</span>op<span style=color:#f92672>|</span> recur(me, target, op(acc, args[<span style=color:#ae81ff>0</span>]), <span style=color:#f92672>&amp;</span>args[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        recur(self, target, <span style=color:#ae81ff>0</span>, args)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically, we can create a <code>struct</code> that will hold as many binary operators as we want! Then use <code>any</code> to check each of them recursively the same as we did before, still short circuiting (<code>any</code> does this naturally).</p><p>With that, both solutions become (in my opinion) even cleaner:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day7, part1, opset)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_opset</span>(input: <span style=color:#66d9ef>&amp;</span>[Equation]) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> op_set <span style=color:#f92672>=</span> OpSet::new();
</span></span><span style=display:flex><span>    op_set.include(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>    op_set.include(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a <span style=color:#f92672>*</span> b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> op_set.can_solve(eq.result, <span style=color:#f92672>&amp;</span>eq.input))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> eq.result)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[aoc(day7, part2, opset)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_opset</span>(input: <span style=color:#66d9ef>&amp;</span>[Equation]) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> op_set <span style=color:#f92672>=</span> OpSet::new();
</span></span><span style=display:flex><span>    op_set.include(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>    op_set.include(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a <span style=color:#f92672>*</span> b);
</span></span><span style=display:flex><span>    op_set.include(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> digits <span style=color:#f92672>=</span> b.ilog10() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10_</span><span style=color:#66d9ef>u64</span>.pow(digits) <span style=color:#f92672>*</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> op_set.can_solve(eq.result, <span style=color:#f92672>&amp;</span>eq.input))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>eq<span style=color:#f92672>|</span> eq.result)
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nice.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>975671981569</span>
</span></span><span style=display:flex><span>	generator: 425.625Âµs,
</span></span><span style=display:flex><span>	runner: 2.212291ms
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>1</span> - opset : <span style=color:#ae81ff>975671981569</span>
</span></span><span style=display:flex><span>	generator: 543.959Âµs,
</span></span><span style=display:flex><span>	runner: 8.823625ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>223472064194845</span>
</span></span><span style=display:flex><span>	generator: 141.875Âµs,
</span></span><span style=display:flex><span>	runner: 42.646083ms
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>7</span> - Part <span style=color:#ae81ff>2</span> - opset : <span style=color:#ae81ff>223472064194845</span>
</span></span><span style=display:flex><span>	generator: 313.333Âµs,
</span></span><span style=display:flex><span>	runner: 131.050583ms
</span></span></code></pre></div><p>A couple times slower though. So it goes.</p><h2 id=benchmarks>Benchmarks</h2><p>So how do we do overall?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day7 - Part1/v1         time:   <span style=color:#f92672>[</span>844.49 Âµs 851.40 Âµs 860.95 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day7 - Part1/queue      time:   <span style=color:#f92672>[</span>1.3142 ms 1.3193 ms 1.3237 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day7 - Part1/opset      time:   <span style=color:#f92672>[</span>3.2182 ms 3.2283 ms 3.2389 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day7 - Part2/v1         time:   <span style=color:#f92672>[</span>45.336 ms 45.701 ms 46.153 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day7 - Part2/opset      time:   <span style=color:#f92672>[</span>112.29 ms 112.70 ms 113.16 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Not bad. Still well under a second, although we&rsquo;re certainly creeping up!</p><h2 id=future-work>Future work</h2><p>In addition to the above, I&rsquo;ve also considered a few different potential ways to attack the problem that may (or may not) be faster.</p><ul><li><a href=https://en.wikipedia.org/wiki/Memoization>Memoization</a> - Cache the work we&rsquo;re doing recursively so if we already know a branch doesn&rsquo;t work out, we don&rsquo;t have to do it again.</li><li><a href=https://en.wikipedia.org/wiki/Sorting>Sorting</a> - For part 1, we can rely on the fact that <code>+</code> and <code>*</code> have the same <a href=https://en.wikipedia.org/wiki/precedence>precedence</a> in this problem and are <a href=https://en.wikipedia.org/wiki/commutative>commutative</a>. Because of that, we should be able to sort the input lists, which should improve memoization (above) or other algorithms.</li><li><a href=https://en.wikipedia.org/wiki/Divide%20and%20conquer>Divide and conquer</a> - The problem with <code>||</code> is that it&rsquo;s not commutative, but I expect we could split the problem to attack that.<ul><li>One option would be to calculate all of the different ways that the list can be split up quickly (see above) and then try each ordering of those results (as strings).</li><li>Another option would be to split the list and recursively check each half as either 1) only <code>+</code> and <code>*</code> (which can use the speedups above) and/or 2) including another <code>||</code> in that half recursively.</li></ul></li></ul><p>We&rsquo;ll see if I get to actually doing those though. If you ended up implementing either and it seems faster, I&rsquo;d love to see it / here about it though!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>