<!doctype html><html><head><title>AoC 2024 Day 17: Virtual Machininator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 17: Virtual Machininator</h1><div class=entry-meta><span class=entry-date>2024-12-17</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a></li><li><a class=taxonomy-value href=/programming/topics/bitwise-operations>Bitwise operations</a></li><li><a class=taxonomy-value href=/programming/topics/quines>Quines</a></li><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/recursion>Recursion</a></li><li><a class=taxonomy-value href=/programming/topics/shift-operations>Shift operations</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=previous-link>Prev</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=previous-link>Prev</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-17-chronospatial-computerhttpsadventofcodecom2024day17>Source: <a href=https://adventofcode.com/2024/day/17 target=_blank rel=noopener>Day 17: Chronospatial Computer</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day17.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-17-chronospatial-computerhttpsadventofcodecom2024day17>Source: <a href=https://adventofcode.com/2024/day/17>Day 17: Chronospatial Computer</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#instructions>Instructions</a></li><li><a href=#parameter-specification>Parameter specification</a></li><li><a href=#unit-tests>Unit tests</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#so-what-is-our-program-actually-doing>So what is our program actually doing?</a></li><li><a href=#psuedo-code-hash>Psuedo-code hash</a></li><li><a href=#whats-actually-changing>What&rsquo;s actually changing?</a></li><li><a href=#zero-guarantees>Zero guarantees</a></li><li><a href=#the-actual-answer>The actual answer</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Implement a virtual machine. The machine will have 3 unbounded signed registers, 8 opcodes (see below), a variable parameter scheme (see below that). You will be given the initial values of the 3 registers and a program. Find the final output.</p></blockquote><h3 id=instructions>Instructions</h3><table><thead><tr><th>Opcode</th><th>Instruction</th><th>Description</th><th>Notes</th></tr></thead><tbody><tr><td>0</td><td><code>adv reg/val</code></td><td><code>A = A >> OP</code></td><td></td></tr><tr><td>1</td><td><code>bxl val</code></td><td><code>B = B ^ OP</code></td><td></td></tr><tr><td>2</td><td><code>bst reg/val</code></td><td><code>B = OP & 0b111</code></td><td></td></tr><tr><td>3</td><td><code>jnz val</code></td><td>If <code>a =/= 0</code>, jump to <code>LIT</code></td><td></td></tr><tr><td>4</td><td><code>bxc ignore</code></td><td><code>B = B ^ C</code></td><td>Still takes param, but ignores it</td></tr><tr><td>5</td><td><code>out reg/val</code></td><td>Output <code>b</code></td><td>Only outputs lowest 3 bits</td></tr><tr><td>6</td><td><code>bdv reg/val</code></td><td><code>B = A >> OP</code></td><td>Same as <code>adv</code> but writes to <code>b</code></td></tr><tr><td>7</td><td><code>cdv reg/val</code></td><td><code>C = A >> OP</code></td><td>Same as <code>adv</code> but writes to <code>c</code></td></tr></tbody></table><h3 id=parameter-specification>Parameter specification</h3><p>For instructions that can take <code>reg/val</code>, <code>0</code> to <code>3</code> (inclusive) are treated as literal values, <code>4</code> is register <code>A</code>, <code>5</code> is <code>B</code>, <code>6</code>, is <code>C</code>, and <code>7</code> is an error (should never happen).</p><p>For instructions that only take <code>val</code>, it&rsquo;s always a literal value in the range <code>0</code> to <code>7</code> (inclusive).</p><p>I do love <a href=/programming/topics/virtual-machines>virtual machines</a>.</p><p>Here&rsquo;s a representation of the instructions, parameters, and the virtual machine itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Instruction</span> {
</span></span><span style=display:flex><span>    Adv,
</span></span><span style=display:flex><span>    Bxl,
</span></span><span style=display:flex><span>    Bst,
</span></span><span style=display:flex><span>    Jnz,
</span></span><span style=display:flex><span>    Bxc,
</span></span><span style=display:flex><span>    Out,
</span></span><span style=display:flex><span>    Bdv,
</span></span><span style=display:flex><span>    Cdv,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Instruction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> Self::Adv,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> Self::Bxl,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> Self::Bst,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> Self::Jnz,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span> <span style=color:#f92672>=&gt;</span> Self::Bxc,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>5</span> <span style=color:#f92672>=&gt;</span> Self::Out,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>6</span> <span style=color:#f92672>=&gt;</span> Self::Bdv,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>7</span> <span style=color:#f92672>=&gt;</span> Self::Cdv,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid instruction&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> fmt::Display <span style=color:#66d9ef>for</span> Instruction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
</span></span><span style=display:flex><span>        write!(f, <span style=color:#e6db74>&#34;{:?}&#34;</span>, self)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Instruction {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// True if the operand is always a literal value, false if it&#39;s a combo operand (below)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_literally_literal</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Self::Adv <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>            Self::Bxl <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            Self::Bst <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>            Self::Jnz <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            Self::Bxc <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// Takes one but ignores it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Self::Out <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>            Self::Bdv <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>            Self::Cdv <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Operand</span> {
</span></span><span style=display:flex><span>    Literal(<span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>    A,
</span></span><span style=display:flex><span>    B,
</span></span><span style=display:flex><span>    C,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Operand {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> Self::Literal(value),
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span> <span style=color:#f92672>=&gt;</span> Self::A,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>5</span> <span style=color:#f92672>=&gt;</span> Self::B,
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>6</span> <span style=color:#f92672>=&gt;</span> Self::C,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid combo operand&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> fmt::Display <span style=color:#66d9ef>for</span> Operand {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Self::Literal(value) <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;{}&#34;</span>, value),
</span></span><span style=display:flex><span>            Self::A <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;A&#34;</span>),
</span></span><span style=display:flex><span>            Self::B <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;B&#34;</span>),
</span></span><span style=display:flex><span>            Self::C <span style=color:#f92672>=&gt;</span> write!(f, <span style=color:#e6db74>&#34;C&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Machine</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> a: <span style=color:#66d9ef>u128</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> b: <span style=color:#66d9ef>u128</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> c: <span style=color:#66d9ef>u128</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> ip: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> ram: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> halted: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> output: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Machine {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decompile</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> output <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, <span style=color:#f92672>&amp;</span>byte) <span style=color:#66d9ef>in</span> self.ram.iter().enumerate().step_by(<span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> instruction <span style=color:#f92672>=</span> Instruction::from(byte);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> operand <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> instruction.is_literally_literal() {
</span></span><span style=display:flex><span>                Operand::Literal(self.ram[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                Operand::from(self.ram[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            output.push_str(<span style=color:#f92672>&amp;</span>format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{instruction}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{operand}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Most of that should be a direct translation of the specification, although I do have a few extra fields on the machine:</p><ul><li><code>ip</code> is the <a href=https://en.wikipedia.org/wiki/instruction%20pointer>instruction pointer</a>; the current instruction to decode</li><li><code>ram</code> is the program to run; technically I suppose it should be <a href=https://en.wikipedia.org/wiki/read-only%20memory>ROM</a> since you can never actually write to it</li><li><code>halted</code> means the machine has stopped running, this happens whenever <code>ip</code> runs past the <code>ram</code></li><li><code>output</code> is a vector of values that have been written by the <code>out</code> instructions</li></ul><p>To load a machine, we have this wonderfully ugly bit of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day17)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Machine</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> input.lines();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> lines.next().unwrap().rsplit_once(<span style=color:#e6db74>&#34; &#34;</span>).unwrap().<span style=color:#ae81ff>1.</span>parse().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> lines.next().unwrap().rsplit_once(<span style=color:#e6db74>&#34; &#34;</span>).unwrap().<span style=color:#ae81ff>1.</span>parse().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> lines.next().unwrap().rsplit_once(<span style=color:#e6db74>&#34; &#34;</span>).unwrap().<span style=color:#ae81ff>1.</span>parse().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines.next(); <span style=color:#75715e>// Skip the empty line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ram <span style=color:#f92672>=</span> lines
</span></span><span style=display:flex><span>        .next()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .rsplit_once(<span style=color:#e6db74>&#34; &#34;</span>)
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        .split(<span style=color:#e6db74>&#34;,&#34;</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.parse().unwrap())
</span></span><span style=display:flex><span>        .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Machine {
</span></span><span style=display:flex><span>        a,
</span></span><span style=display:flex><span>        b,
</span></span><span style=display:flex><span>        c,
</span></span><span style=display:flex><span>        ip: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        ram,
</span></span><span style=display:flex><span>        halted: <span style=color:#a6e22e>false</span>,
</span></span><span style=display:flex><span>        output: Vec::new(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; I probably should have written that with <code>nom</code> or the like. It&rsquo;s functional though.</p><p>And finally, the actual interpreter itself!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Machine {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>value_of</span>(<span style=color:#f92672>&amp;</span>self, operand: <span style=color:#a6e22e>Operand</span>) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> operand {
</span></span><span style=display:flex><span>            Operand::Literal(value) <span style=color:#f92672>=&gt;</span> value <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u128</span>,
</span></span><span style=display:flex><span>            Operand::A <span style=color:#f92672>=&gt;</span> self.a,
</span></span><span style=display:flex><span>            Operand::B <span style=color:#f92672>=&gt;</span> self.b,
</span></span><span style=display:flex><span>            Operand::C <span style=color:#f92672>=&gt;</span> self.c,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>self.halted {
</span></span><span style=display:flex><span>            self.step();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.halted {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Always read an instruction + operand, out of bounds is an error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self.ip <span style=color:#f92672>&gt;=</span> self.ram.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            self.halted <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> instruction <span style=color:#f92672>=</span> Instruction::from(self.ram[self.ip]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> operand <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> instruction.is_literally_literal() {
</span></span><span style=display:flex><span>            Operand::Literal(self.ram[self.ip <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Operand::from(self.ram[self.ip <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> instruction {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Division (actually a right shift)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Adv <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.a <span style=color:#f92672>&gt;&gt;=</span> self.value_of(operand);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Bitwise XOR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Bxl <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.b <span style=color:#f92672>^=</span> self.value_of(operand);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Bitwise set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Bst <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.b <span style=color:#f92672>=</span> self.value_of(operand) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0b111</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Jump (if not zero)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Jnz <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.a <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    self.ip <span style=color:#f92672>=</span> self.value_of(operand) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// Don&#39;t increment the IP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Bitwise XOR between b and c (ignores operand)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Bxc <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.b <span style=color:#f92672>^=</span> self.c;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Out <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.output.push((self.value_of(operand) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0b111</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Division (actually a right shift) to b, still reads from a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Bdv <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.b <span style=color:#f92672>=</span> self.a <span style=color:#f92672>&gt;&gt;</span> self.value_of(operand);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Division (actually a right shift) to c, still reads from a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Instruction::Cdv <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.c <span style=color:#f92672>=</span> self.a <span style=color:#f92672>&gt;&gt;</span> self.value_of(operand);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.ip <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>value_of</code> takes either a literal and returns it or a register and returns the value of the register, so any instruction, it will be the operand. Choosing if it&rsquo;s treated as a <code>literal</code> or <code>combo</code> type operand is handled in <code>step</code>.</p><p><code>step</code> will advance the machine exactly one step. <code>run</code> will run the machine until it <code>halts</code>. And hopefully doesn&rsquo;t <a href=https://en.wikipedia.org/wiki/halt%20and%20catch%20fire>catch fire</a>.</p><p>And that&rsquo;s it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day17, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Machine</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    machine.run();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    machine
</span></span><span style=display:flex><span>        .output
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.to_string())
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;,&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; it took me longer than I care to admit to realize that I needed to include the <code>,</code> in the output this time around.</p><h3 id=unit-tests>Unit tests</h3><p>I actually did write some tests for each operation (based on comments in the Advent of Code specification):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If register C contains 9, the program 2,6 would set register B to 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_instruction_1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> Machine::default();
</span></span><span style=display:flex><span>        machine.c <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>        machine.ram <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(machine.b, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If register A contains 10, the program 5,0,5,1,5,4 would output 0,1,2.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_instruction_2</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> Machine::default();
</span></span><span style=display:flex><span>        machine.a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>        machine.ram <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(machine.output, vec![<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If register A contains 2024, the program 0,1,5,4,3,0 would output 4,2,5,6,7,7,7,7,3,1,0 and leave 0 in register A.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_instruction_3</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> Machine::default();
</span></span><span style=display:flex><span>        machine.a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2024</span>;
</span></span><span style=display:flex><span>        machine.ram <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>machine.halted {
</span></span><span style=display:flex><span>            machine.step();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(machine.output, vec![<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        assert_eq!(machine.a, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If register B contains 29, the program 1,7 would set register B to 26.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_instruction_4</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> Machine::default();
</span></span><span style=display:flex><span>        machine.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>29</span>;
</span></span><span style=display:flex><span>        machine.ram <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>7</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(machine.b, <span style=color:#ae81ff>26</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If register B contains 2024 and register C contains 43690, the program 4,0 would set register B to 44354.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_instruction_5</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> Machine::default();
</span></span><span style=display:flex><span>        machine.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2024</span>;
</span></span><span style=display:flex><span>        machine.c <span style=color:#f92672>=</span> <span style=color:#ae81ff>43690</span>;
</span></span><span style=display:flex><span>        machine.ram <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        machine.step();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(machine.b, <span style=color:#ae81ff>44354</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ll admit, I threw an LLM at those. It did perfectly at turning the plain text specification into test cases after I wrote the first one. And the one it did mess up&mldr; that was actually a problem they found in my implementation!</p><h2 id=part-2>Part 2</h2><blockquote><p>Find the initial value of <code>a</code> so that your program outputs it&rsquo;s own code.</p></blockquote><p>Make a <a href=https://en.wikipedia.org/wiki/quine>quine</a>!</p><p>Let&rsquo;s brute force it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day17, part2, bruteforce)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_bruteforce</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Machine</span>) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>8</span> <span style=color:#f92672>^</span> <span style=color:#ae81ff>15</span>)<span style=color:#f92672>..</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>        machine.a <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>        machine.run();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> machine.output <span style=color:#f92672>==</span> machine.ram {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    panic!(<span style=color:#e6db74>&#34;No solution found&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;</p><p>&mldr; &mldr;</p><p>What&rsquo;s that even outputting?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --bin day17-iterator | head -n <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Input A    Octal      Output
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>          <span style=color:#ae81ff>0</span>          <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>          <span style=color:#ae81ff>1</span>          <span style=color:#f92672>[</span>3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>          <span style=color:#ae81ff>2</span>          <span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>          <span style=color:#ae81ff>3</span>          <span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>          <span style=color:#ae81ff>4</span>          <span style=color:#f92672>[</span>7<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>          <span style=color:#ae81ff>5</span>          <span style=color:#f92672>[</span>7<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>          <span style=color:#ae81ff>6</span>          <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>          <span style=color:#ae81ff>7</span>          <span style=color:#f92672>[</span>6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8</span>          <span style=color:#ae81ff>10</span>         <span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span>          <span style=color:#ae81ff>11</span>         <span style=color:#f92672>[</span>3, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10</span>         <span style=color:#ae81ff>12</span>         <span style=color:#f92672>[</span>0, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>11</span>         <span style=color:#ae81ff>13</span>         <span style=color:#f92672>[</span>1, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>12</span>         <span style=color:#ae81ff>14</span>         <span style=color:#f92672>[</span>5, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>13</span>         <span style=color:#ae81ff>15</span>         <span style=color:#f92672>[</span>6, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>14</span>         <span style=color:#ae81ff>16</span>         <span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>15</span>         <span style=color:#ae81ff>17</span>         <span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>16</span>         <span style=color:#ae81ff>20</span>         <span style=color:#f92672>[</span>2, 0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>17</span>         <span style=color:#ae81ff>21</span>         <span style=color:#f92672>[</span>3, 0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>18</span>         <span style=color:#ae81ff>22</span>         <span style=color:#f92672>[</span>1, 0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>19</span>         <span style=color:#ae81ff>23</span>         <span style=color:#f92672>[</span>1, 0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>62</span>         <span style=color:#ae81ff>76</span>         <span style=color:#f92672>[</span>2, 6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>63</span>         <span style=color:#ae81ff>77</span>         <span style=color:#f92672>[</span>2, 6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span>         <span style=color:#ae81ff>100</span>        <span style=color:#f92672>[</span>3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>65</span>         <span style=color:#ae81ff>101</span>        <span style=color:#f92672>[</span>3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>66</span>         <span style=color:#ae81ff>102</span>        <span style=color:#f92672>[</span>4, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>67</span>         <span style=color:#ae81ff>103</span>        <span style=color:#f92672>[</span>3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>68</span>         <span style=color:#ae81ff>104</span>        <span style=color:#f92672>[</span>7, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>510</span>        <span style=color:#ae81ff>776</span>        <span style=color:#f92672>[</span>2, 2, 6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>511</span>        <span style=color:#ae81ff>777</span>        <span style=color:#f92672>[</span>2, 2, 6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>512</span>        <span style=color:#ae81ff>1000</span>       <span style=color:#f92672>[</span>2, 3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>513</span>        <span style=color:#ae81ff>1001</span>       <span style=color:#f92672>[</span>7, 3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>514</span>        <span style=color:#ae81ff>1002</span>       <span style=color:#f92672>[</span>0, 3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>515</span>        <span style=color:#ae81ff>1003</span>       <span style=color:#f92672>[</span>1, 3, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span></code></pre></div><p>Okay, so if we treat the input <code>a</code> as an <a href=https://en.wikipedia.org/wiki/octal>octal</a> value (which makes sense, since everything is working with 3 bits), then each time we add another octet to the input&mldr; we get another octet of output. So if we need all 16 octets of output, our input needs to be&mldr; 16 octets = 48 bits long. That&rsquo;s&mldr; 281 trillion! Even for a really fast computer&mldr; that might take a while.</p><p>I did some quick timing and showed that without much more optimization, we&rsquo;re running at ~4 MHz (4 million values per second). Since the value we&rsquo;re looking for is ~ $8^16$, we&rsquo;d need&mldr; about 800 days to find the answer. Even if we start at $8^15$ instead of $1$&mldr; that only cuts off ~100 days.</p><p>It&rsquo;s like the saying says: what&rsquo;s the difference between $1 million and $1 billion? About $1 billion.</p><p>Anyways.</p><p>Let&rsquo;s be smarter about this.</p><h3 id=so-what-is-our-program-actually-doing>So what is our program actually doing?</h3><p>I already wrote a <code>decompile</code> method, let&rsquo;s see what the program is doing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Bst A
</span></span><span style=display:flex><span>Bxl 6
</span></span><span style=display:flex><span>Cdv B
</span></span><span style=display:flex><span>Bxc 6
</span></span><span style=display:flex><span>Bxl 4
</span></span><span style=display:flex><span>Out B
</span></span><span style=display:flex><span>Adv 3
</span></span><span style=display:flex><span>Jnz 0
</span></span></code></pre></div><p>Well that&rsquo;s helpful. ðŸ˜„</p><p>To translate a bit more, we have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Bst A   B0 = A{N}           Truncated to 3 bits
</span></span><span style=display:flex><span>Bxl 6   B1 = A{N} ^ 110
</span></span><span style=display:flex><span>Cdv B   C0 = A{N} &gt;&gt; B1     C0 = A{N + B1}
</span></span><span style=display:flex><span>Bxc 6   B2 = C0 ^ B1
</span></span><span style=display:flex><span>Bxl 4   B = B ^ [0 1 1]
</span></span><span style=display:flex><span>Out B   output B            Truncated to 3 bits
</span></span><span style=display:flex><span>Adv 3   A = A{N+3}
</span></span><span style=display:flex><span>Jnz 0   loop
</span></span></code></pre></div><p>I&rsquo;m using <code>A{N}</code> to represent the bits of <code>A</code> starting from the <code>N</code>th <a href=https://en.wikipedia.org/wiki/least%20significant%20bit>least significant bit</a>. I&rsquo;m using <code>B0</code>/<code>B1</code>/<code>B2</code> to put this in <a href=https://en.wikipedia.org/wiki/static%20single-assignment>static single-assignment</a> form (and so it&rsquo;s easier to tell which B is which).</p><h3 id=psuedo-code-hash>Psuedo-code hash</h3><p>So essentially, we have code that does this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while A &gt; 0 {
</span></span><span style=display:flex><span>    output A{N} ^ A{N + ?} ^ some_literal_bytes
</span></span><span style=display:flex><span>    A = A &gt;&gt;&gt; 3
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically it&rsquo;s a <a href=https://en.wikipedia.org/wiki/hashing%20function>hashing function</a>. Although not a great one&mldr;</p><p>The interesting part is that <code>A{N + ?}</code>. Because <code>B1</code> is based on <code>B0</code> which is truncated, we know that the <code>?</code> is at most <code>7</code>. So at most, each output value is based on the three bits directly above it + up to 7 more.</p><p>This is probably interesting. ðŸ˜„</p><h3 id=whats-actually-changing>What&rsquo;s actually changing?</h3><p>As an aside, I did do a quick visualization of this, starting with the program (converted as octal) as the input to <code>A</code> then I tried changing each <code>tribble</code> (3 bit nibble?) and showing which octets of the output changed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decimalize</span>(ram: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> nibble <span style=color:#66d9ef>in</span> ram.iter() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> (a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> (<span style=color:#f92672>*</span>nibble <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u128</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    a
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> a <span style=color:#f92672>=</span> input.ram.clone();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> change_map <span style=color:#f92672>=</span> Grid::new(input.ram.len(), input.ram.len());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Which bytes change which bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.ram.len() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>    machine.a <span style=color:#f92672>=</span> decimalize(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>    machine.run();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> output_1 <span style=color:#f92672>=</span> machine.output.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> new_value <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>        a[index] <span style=color:#f92672>=</span> new_value;
</span></span><span style=display:flex><span>        machine.a <span style=color:#f92672>=</span> decimalize(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>        machine.run();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> output_2 <span style=color:#f92672>=</span> machine.output.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output_1
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .zip(output_2.iter())
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|</span>(_, (a, b))<span style=color:#f92672>|</span> a <span style=color:#f92672>!=</span> b)
</span></span><span style=display:flex><span>            .for_each(<span style=color:#f92672>|</span>(i, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                change_map.set((index, i), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println!(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>    change_map.to_string(<span style=color:#f92672>&amp;|</span>b<span style=color:#f92672>|</span> (<span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>b { <span style=color:#e6db74>&#39;X&#39;</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#39;.&#39;</span> }).to_string())
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>This outputs this fun looking chart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>.............X.X
</span></span><span style=display:flex><span>............XXX.
</span></span><span style=display:flex><span>...........XXX..
</span></span><span style=display:flex><span>..........X.X...
</span></span><span style=display:flex><span>..........XX....
</span></span><span style=display:flex><span>.........XX.....
</span></span><span style=display:flex><span>........XX......
</span></span><span style=display:flex><span>.....XX.X.......
</span></span><span style=display:flex><span>.......X........
</span></span><span style=display:flex><span>.....XX.........
</span></span><span style=display:flex><span>....XX..........
</span></span><span style=display:flex><span>...XX...........
</span></span><span style=display:flex><span>...X............
</span></span><span style=display:flex><span>X.X.............
</span></span><span style=display:flex><span>XX..............
</span></span><span style=display:flex><span>X...............
</span></span></code></pre></div><p>Which shows pretty much exactly what I expected: each octet is based on up to a set of 4 above it.</p><h3 id=zero-guarantees>Zero guarantees</h3><p>So what else do we know?</p><p>Well, we know that in the final loop, we have <code>A{N} = 0</code>. And from there, for each octet, we should be able to try each different octet (<code>0</code> to <code>7</code>) as input. Some subset of those should output the next correct value&ndash;and if we continue down this line, only some of <em>those</em> should still be valid. Eventually, we run out of characters to generate in our <a href=https://en.wikipedia.org/wiki/quine>quine</a>.</p><p>That sounds an awful lot like <a href=https://en.wikipedia.org/wiki/recursion>recursion</a>.</p><h3 id=the-actual-answer>The actual answer</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day17, part2, backtrack)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_backtrack</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Machine</span>) -&gt; <span style=color:#66d9ef>u128</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(original_machine: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Machine</span>, a: <span style=color:#66d9ef>u128</span>, index: <span style=color:#66d9ef>usize</span>) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> tribble <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> machine <span style=color:#f92672>=</span> original_machine.clone();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> next_a <span style=color:#f92672>=</span> (a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> tribble;
</span></span><span style=display:flex><span>            machine.a <span style=color:#f92672>=</span> next_a;
</span></span><span style=display:flex><span>            machine.run();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> machine.output[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> machine.ram[index] {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Recursive base case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(next_a);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(a) <span style=color:#f92672>=</span> recur(original_machine, next_a, index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(a);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    recur(input, <span style=color:#ae81ff>0</span>, input.ram.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At each <code>recur</code>sive step, we assume we have <code>a</code> that is correct up until <code>index</code> of the target string. Try each next <code>tribble</code> (octet), recurring down on the next <code>index</code> for each. If any of those returns a value, that&rsquo;s also the final answer. If none do, this branch doesn&rsquo;t have the answer, so backtrack (by the power of recursion!) and try another value somewhere earlier in the program.</p><p>That&rsquo;s&mldr; amazingly simple.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>17</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>17</span> - Part <span style=color:#ae81ff>2</span> - backtrack : <span style=color:#ae81ff>90938893795561</span>
</span></span><span style=display:flex><span>	generator: 709ns,
</span></span><span style=display:flex><span>	runner: 45.041Âµs
</span></span></code></pre></div><p>And $\frac{log{(90938893795561)}}{log{(8)}} \approx 15.45$, so exactly the 16 octets long we were expecting!</p><p>In case you were wondering, you can print out the values of <code>a</code> and <code>index</code> to see how many different branches we actually end up needing to try:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>recur 0 15
</span></span><span style=display:flex><span>recur 2 14
</span></span><span style=display:flex><span>recur 17 13
</span></span><span style=display:flex><span>recur 20 13
</span></span><span style=display:flex><span>recur 165 12
</span></span><span style=display:flex><span>recur 1323 11
</span></span><span style=display:flex><span>recur 10586 10
</span></span><span style=display:flex><span>recur 84690 9
</span></span><span style=display:flex><span>recur 84693 9
</span></span><span style=display:flex><span>recur 677547 8
</span></span><span style=display:flex><span>recur 5420377 7
</span></span><span style=display:flex><span>recur 43363017 6
</span></span><span style=display:flex><span>recur 346904138 5
</span></span><span style=display:flex><span>recur 2775233106 4
</span></span><span style=display:flex><span>recur 2775233109 4
</span></span><span style=display:flex><span>recur 43363021 6
</span></span><span style=display:flex><span>recur 5420380 7
</span></span><span style=display:flex><span>recur 43363041 6
</span></span><span style=display:flex><span>recur 43363042 6
</span></span><span style=display:flex><span>recur 43363043 6
</span></span><span style=display:flex><span>recur 346904349 5
</span></span><span style=display:flex><span>recur 2775234796 4
</span></span><span style=display:flex><span>recur 22201878368 3
</span></span><span style=display:flex><span>recur 177615026944 2
</span></span><span style=display:flex><span>recur 1420920215555 1
</span></span><span style=display:flex><span>recur 11367361724445 0
</span></span></code></pre></div><p>26! (No, not <a href="https://www.wolframalpha.com/input?i=26%21" target=_blank rel=noopener>that 26!</a>).</p><p>That&rsquo;s it.</p><p>And while it doesn&rsquo;t generalize to any possible program, since we can only right shift and xor, most programs should be similarly impacted.</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day17 - Part1/v1        time:   <span style=color:#f92672>[</span>465.51 ns 469.71 ns 474.07 ns<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day17 - Part2/backtrack time:   <span style=color:#f92672>[</span>43.640 Âµs 43.798 Âµs 43.951 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>