<!doctype html><html><head><title>AoC 2024 Day 6: Wanderinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 6: Wanderinator</h1><div class=entry-meta><span class=entry-date>2024-12-06</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/05/aoc-2024-day-5-not-transitivinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/05/aoc-2024-day-5-not-transitivinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/grid-traversal>Grid Traversal</a><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/hashing>Hashing</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/loop-detection>Loop Detection</a></li><li><a class=taxonomy-value href=/programming/topics/parallel-programming>Parallel Programming</a></li><li><a href=https://blog.jverkamp.com/2022/12/24/aoc-2022-day-24-blizzinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/visualization>Visualization</a><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/05/aoc-2024-day-5-not-transitivinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/05/aoc-2024-day-5-not-transitivinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/05/aoc-2024-day-5-not-transitivinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-6-guard-gallivant>Source: <a href=https://adventofcode.com/2024/day/6 target=_blank rel=noopener>Day 6: Guard Gallivant</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day6.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-6-guard-gallivant>Source: <a href=https://adventofcode.com/2024/day/6>Day 6: Guard Gallivant</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#direction><code>Direction</code></a></li><li><a href=#point><code>Point</code></a></li><li><a href=#actually-solving-the-problem>Actually solving the problem</a></li></ul></li><li><a href=#part-2>Part 2</a><ul><li><a href=#optimization-1-only-checking-the-path>Optimization 1: Only checking the path</a></li><li><a href=#optimization-2-rayon-parallelization>Optimization 2: Rayon parallelization</a></li><li><a href=#optimization-3-avoiding-clone>Optimization 3: Avoiding clone</a></li><li><a href=#optimization-4-no-hash>Optimization 4: No hash</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>You are given a grid of walls (<code>#</code>), floors (<code>.</code>), and a guard (<code>^</code>, initially facing up/north). The guard walks forward until they run into a wall at which point they turn right. How many tiles does the guard reach before leaving the map.</p></blockquote><p>This is a great opportunity to use that <code>Grid</code> we introduced <a href>last time</a>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[default]</span>
</span></span><span style=display:flex><span>    Empty,
</span></span><span style=display:flex><span>    Wall,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    guard: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    facing: <span style=color:#a6e22e>Direction</span>,
</span></span><span style=display:flex><span>    grid: <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day6)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> grid <span style=color:#f92672>=</span> Grid::read(input, <span style=color:#f92672>&amp;|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>=&gt;</span> Tile::Empty,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> Tile::Wall,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;^&#39;</span> <span style=color:#f92672>=&gt;</span> Tile::Empty,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Invalid character: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, c),
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> guard_index <span style=color:#f92672>=</span> input.find(<span style=color:#e6db74>&#39;^&#39;</span>).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> per_row <span style=color:#f92672>=</span> grid.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> guard <span style=color:#f92672>=</span> Point::new(
</span></span><span style=display:flex><span>        (guard_index <span style=color:#f92672>%</span> per_row) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>        (guard_index <span style=color:#f92672>/</span> per_row) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> facing <span style=color:#f92672>=</span> Direction::Up;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Map {
</span></span><span style=display:flex><span>        guard,
</span></span><span style=display:flex><span>        facing,
</span></span><span style=display:flex><span>        grid,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We do introduce two new structure (that I have used in previous years: <code>Point</code> and <code>Direction</code>). I&rsquo;ve done a few new things, so let&rsquo;s see how those work.</p><h3 id=direction><code>Direction</code></h3><p>A <code>Direction</code> is something we need for the facing of the guard. It can be represented as North/South/East/West or Up/Down/Left/Right. For the moment, we&rsquo;ll go with the latter. It&rsquo;s mostly just a data structure. Here&rsquo;s the <a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/direction.rs target=_blank rel=noopener>full code</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>    Up,
</span></span><span style=display:flex><span>    Down,
</span></span><span style=display:flex><span>    Left,
</span></span><span style=display:flex><span>    Right,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Direction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rotate_cw</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Direction::Up <span style=color:#f92672>=&gt;</span> Direction::Right,
</span></span><span style=display:flex><span>            Direction::Right <span style=color:#f92672>=&gt;</span> Direction::Down,
</span></span><span style=display:flex><span>            Direction::Down <span style=color:#f92672>=&gt;</span> Direction::Left,
</span></span><span style=display:flex><span>            Direction::Left <span style=color:#f92672>=&gt;</span> Direction::Up,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rotate_right</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>        self.rotate_cw()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rotate_ccw</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Direction::Up <span style=color:#f92672>=&gt;</span> Direction::Left,
</span></span><span style=display:flex><span>            Direction::Left <span style=color:#f92672>=&gt;</span> Direction::Down,
</span></span><span style=display:flex><span>            Direction::Down <span style=color:#f92672>=&gt;</span> Direction::Right,
</span></span><span style=display:flex><span>            Direction::Right <span style=color:#f92672>=&gt;</span> Direction::Up,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rotate_left</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>        self.rotate_ccw()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=point><code>Point</code></h3><p>Currently only a 32-bit number. I may decide to change that down the line when (I doubt this is an if) I need bigger numbers &#x1f604;. It&rsquo;s signed because we quite often need to add/subtract negative points.</p><p>The full code is <a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/point.rs target=_blank rel=noopener>here</a> if you&rsquo;re curious. Some specific bits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> x: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> y: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self { x, y }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>manhattan_distance</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        (self.x <span style=color:#f92672>-</span> other.x).abs() <span style=color:#f92672>+</span> (self.y <span style=color:#f92672>-</span> other.y).abs()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>neighbors</span>(<span style=color:#f92672>&amp;</span>self) -&gt; [Self; <span style=color:#ae81ff>4</span>] {
</span></span><span style=display:flex><span>        [
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>self <span style=color:#f92672>+</span> Direction::Up,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>self <span style=color:#f92672>+</span> Direction::Down,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>self <span style=color:#f92672>+</span> Direction::Left,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>self <span style=color:#f92672>+</span> Direction::Right,
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next up, I have standard implementations of <code>Add</code>, <code>AddAssign</code>, etc. But what&rsquo;s interesting is a few <code>From</code> conversions that I haven&rsquo;t done before:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>((x, y): (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>)) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>        Point::new(x, y)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>((x, y): (<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>)) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>        Point::new(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>((x, y): (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>)) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>        Point::new(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>, y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i32</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This lets me take <code>isize</code> or <code>usize</code> tuples and turn them into <code>Point</code>, which is kind of neat. Of course, if those values are out of range, things will explode&mldr; but we&rsquo;ll just deal with that for the time being!</p><p>Otherwise, we also want the ability to turn a <code>Direction</code> into a <code>Point</code> (for adding) or adding them together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Interop between points and directions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(direction: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> direction {
</span></span><span style=display:flex><span>            Direction::Up <span style=color:#f92672>=&gt;</span> Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Direction::Down <span style=color:#f92672>=&gt;</span> Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            Direction::Left <span style=color:#f92672>=&gt;</span> Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            Direction::Right <span style=color:#f92672>=&gt;</span> Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> std::ops::Add<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        self <span style=color:#f92672>+</span> std::convert::Into::<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>::into(rhs)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=actually-solving-the-problem>Actually solving the problem</h3><p>Okay, we have the framework out of the way.</p><p>To solve it, I&rsquo;m going to implement a <code>Map::walk</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>walk</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> Map {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> guard,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> facing,
</span></span><span style=display:flex><span>            grid,
</span></span><span style=display:flex><span>        } <span style=color:#f92672>=</span> self;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates <span style=color:#f92672>=</span> hashbrown::HashSet::new();
</span></span><span style=display:flex><span>        duplicates.insert((guard, facing));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> grid.in_bounds(guard) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> grid.get(guard <span style=color:#f92672>+</span> facing) {
</span></span><span style=display:flex><span>                Some(Tile::Empty) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    guard <span style=color:#f92672>+=</span> facing.into();
</span></span><span style=display:flex><span>                    visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Some(Tile::Wall) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    facing <span style=color:#f92672>=</span> facing.rotate_cw();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        visited
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essentially, this implements the algorithm described in the problem statement and returns a <code>Grid&lt;bool></code> of all the points the guard visits. We&rsquo;ll have a problem if the guard ever starts walking in a loop&mldr; but that&rsquo;s a problem for <a href=#part-2>part 2</a>. &#x1f604;</p><p>Now that we have that, the actual solution is&mldr; count them!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day6, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    input.walk(<span style=color:#66d9ef>false</span>).unwrap().iter().filter(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>v).count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it. &#x1f604;</p><p>I suppose that needs an <code>iter</code> function on <code>Grid</code> (and I implemented an <code>iter_enumerate</code> for good measure that will also return the point for each):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Grid {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data.iter()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iter_enumerate</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> (Point, <span style=color:#f92672>&amp;</span>T)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.data
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(i, v)<span style=color:#f92672>|</span> ((i <span style=color:#f92672>%</span> self.width, i <span style=color:#f92672>/</span> self.width).into(), v))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>5551</span>
</span></span><span style=display:flex><span>	generator: 59.375µs,
</span></span><span style=display:flex><span>	runner: 38.458µs
</span></span></code></pre></div><p>Quick enough for now!</p><p>I did have some fun rendering this one:</p><p><video controls src=/embeds/2024/aoc/day6-part1.mp4 width=100%></video></p><p>The colors don&rsquo;t mean anything, they just look fun.</p><h2 id=part-2>Part 2</h2><blockquote><p>How many points are there such that you can add exactly 1 wall to make the guard walk in a repeating loop?</p></blockquote><p>Told you we&rsquo;d need to loop!</p><p>This does require a small modification to the <code>walk</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>walk</span>(<span style=color:#f92672>&amp;</span>self, check_loops: <span style=color:#66d9ef>bool</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Grid<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> Map {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> guard,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> facing,
</span></span><span style=display:flex><span>            grid,
</span></span><span style=display:flex><span>        } <span style=color:#f92672>=</span> self;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates <span style=color:#f92672>=</span> hashbrown::HashSet::new();
</span></span><span style=display:flex><span>        duplicates.insert((guard, facing));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> grid.in_bounds(guard) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> grid.get(guard <span style=color:#f92672>+</span> facing) {
</span></span><span style=display:flex><span>                Some(Tile::Empty) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    guard <span style=color:#f92672>+=</span> facing.into();
</span></span><span style=display:flex><span>                    visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Some(Tile::Wall) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    facing <span style=color:#f92672>=</span> facing.rotate_cw();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> check_loops {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> duplicates.contains(<span style=color:#f92672>&amp;</span>(guard, facing)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                duplicates.insert((guard, facing));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(visited)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I did leave it optional, since <code>Hash</code> isn&rsquo;t free. So if we don&rsquo;t think we need it, just don&rsquo;t use it. Part 1 with <code>check_loops=true</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># With check_loops=false</span>
</span></span><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>5551</span>
</span></span><span style=display:flex><span>	generator: 59.375µs,
</span></span><span style=display:flex><span>	runner: 38.458µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># With check_loops=true</span>
</span></span><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>5551</span>
</span></span><span style=display:flex><span>	generator: 56.875µs,
</span></span><span style=display:flex><span>	runner: 159.667µs
</span></span></code></pre></div><p>Significant for such a small change.</p><p>For the first round on this problem, let&rsquo;s brute force it. Try every single point on the grid (even if it&rsquo;s already a wall!). Run <code>walk</code> and check if we get <code>None</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// For each point on the grid, check if adding a wall there would create a loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day6, part2, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>iproduct!</span>(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.width, <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.height)
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|&amp;</span>(x, y)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// The &#39;visited&#39; function returns None on loops (no path found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>            input.grid.set((x, y), Tile::Wall);
</span></span><span style=display:flex><span>            input.walk(<span style=color:#66d9ef>true</span>).is_none()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>iproduct!</code> is a macro from <a href=https://docs.rs/itertools/latest/itertools/ target=_blank rel=noopener><code>itertools</code></a> that basically will generate each point for me in a clean way.</p><p>Anyways, how does it do?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.583µs,
</span></span><span style=display:flex><span>	runner: 1.584841459s
</span></span></code></pre></div><p>More than a second?! That cannot stand!</p><p><a href=#optimization-1-only-checking-the-path>First optimization</a>? We don&rsquo;t need to check <em>every</em> point.</p><p>After that, we&rsquo;re also doing a <code>clone</code> every iteration of the loop, which I suppose we can avoid by undoing each change. I&rsquo;ll have to <a href=#optimization-3-avoiding-clone>try that</a>.</p><p>It is nice to have an answer to verify against though.</p><h3 id=optimization-1-only-checking-the-path>Optimization 1: Only checking the path</h3><p>Okay, first optimization. Because the guard only changes their facing (and thus may introduce a loop) when they run into a wall, we can optimize by only putting walls where they might have some impact:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Only check adding walls to the original path
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We don&#39;t have to check adjacent since you have to &#39;run into&#39; a wall to turn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day6, part2, limited)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_limited</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> visited <span style=color:#f92672>=</span> input.walk(<span style=color:#66d9ef>false</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>iproduct!</span>(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.width, <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.height)
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|&amp;</span>(x, y)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::from((x, y));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> visited.get(p) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>                input.grid.set(p, Tile::Wall);
</span></span><span style=display:flex><span>                input.walk(<span style=color:#66d9ef>true</span>).is_none()
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For this, we&rsquo;re going to run the algorithm one extra time first (basically part 1), to get all the points on the path. Then, we filter out any points that are not on the path and only check the rest.</p><p>As mentioned in the comment, we don&rsquo;t have to check points adjacent to the path (I originally) did, since if you are &lsquo;beside&rsquo; the original path, it won&rsquo;t turn.</p><p>This is a bit more than 3x faster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.583µs,
</span></span><span style=display:flex><span>	runner: 1.584841459s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 54.084µs,
</span></span><span style=display:flex><span>	runner: 377.670083ms
</span></span></code></pre></div><p>Not too bad, but we can do better!</p><h3 id=optimization-2-rayon-parallelization>Optimization 2: Rayon parallelization</h3><p>This problem fits pretty well into the <a href=https://en.wikipedia.org/wiki/embarrassingly%20parallel>embarrassingly parallel</a> category. Since we&rsquo;re cloning, we can check every single point at the same time (if we have enough CPU cores) and just add them up. Enter <a href=https://docs.rs/rayon/latest/rayon/ target=_blank rel=noopener><code>rayon</code></a>: easy to use (mostly) drop in parallelization!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Add rayon parallelization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day6, part2, limited_rayon)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_limited_rayon</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> visited <span style=color:#f92672>=</span> input.walk(<span style=color:#66d9ef>false</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>iproduct!</span>(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.width, <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.height)
</span></span><span style=display:flex><span>        .par_bridge()
</span></span><span style=display:flex><span>        .into_par_iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(x, y)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::from((x, y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> visited.get(p) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>                input.grid.set(p, Tile::Wall);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> input.walk(<span style=color:#66d9ef>true</span>).is_none() {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, it&rsquo;s not <em>quite</em> a free change. Because there&rsquo;s a bit of a change in API from a standard <code>Iter</code> to the <code>Itertools</code> <code>iproduct!</code>, we need to add a <code>par_bridge</code> to convert. After that, you appearnly can&rsquo;t <code>filter</code> in <code>rayon</code>, so instead we&rsquo;ll <code>map</code> and <code>sum</code>. But the general idea is the same!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 54.084µs,
</span></span><span style=display:flex><span>	runner: 377.670083ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited_rayon : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.667µs,
</span></span><span style=display:flex><span>	runner: 44.247666ms
</span></span></code></pre></div><p>Another 10x speedup! Which is mostly due to the machine I&rsquo;m running on. On a single core machine, it would probably run if anything a bit slower. But I like it, so in it stays!</p><h3 id=optimization-3-avoiding-clone>Optimization 3: Avoiding clone</h3><p>One last thing to look at: <code>clone</code>. In both of the above cases, we <code>clone</code> the <code>input</code> on every iterations. We can&rsquo;t actually fix that in the parallel <code>rayon</code> case (because we don&rsquo;t want to mutate data in one thread that another might be trying to use), but we can for the single threaded case.</p><p>The basic idea: before running the inner <code>walk</code>, set the <code>Wall</code>. Then when we&rsquo;re done, unset it!</p><p>That&rsquo;s really it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Try without cloning the input (more than once)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[aoc(day6, part2, no_clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_limited_no_clone</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> input.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> visited <span style=color:#f92672>=</span> input.walk(<span style=color:#66d9ef>false</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>iproduct!</span>(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.width, <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input.grid.height)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any points not on or adjacent to original path cannot introduce a loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .filter(<span style=color:#f92672>|&amp;</span>(x, y)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point::from((x, y));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> visited.get(p) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                input.grid.set((x, y), Tile::Wall);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> input.walk(<span style=color:#66d9ef>true</span>).is_none();
</span></span><span style=display:flex><span>                input.grid.set((x, y), Tile::Empty);
</span></span><span style=display:flex><span>                result
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .count()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Unfortunately:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.583µs,
</span></span><span style=display:flex><span>	runner: 1.584841459s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 54.084µs,
</span></span><span style=display:flex><span>	runner: 377.670083ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited_rayon : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.667µs,
</span></span><span style=display:flex><span>	runner: 44.247666ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - no_clone : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 39.209µs,
</span></span><span style=display:flex><span>	runner: 376.155625ms
</span></span></code></pre></div><p>It&rsquo;s actually pretty much exactly the same speed as the initial <code>limited</code> case. This one is dominated by the cost of the <code>Hash</code> in loop detection. Still, it was an interesting idea I suppose.</p><h3 id=optimization-4-no-hash>Optimization 4: No hash</h3><p>Speaking of which&mldr; didn&rsquo;t we say that <code>Hash</code> is expensive? (Even with <code>hashbrown</code>. It&rsquo;s worse with the built in hash function, since it has to make additional security guarantees).</p><p>Instead of a duplicates <code>HashSet</code>, let&rsquo;s create 4 <code>Grid&lt;bool></code>, one for each direction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>walk</span>(<span style=color:#f92672>&amp;</span>self, check_loops: <span style=color:#66d9ef>bool</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Grid<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> Map {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> guard,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>mut</span> facing,
</span></span><span style=display:flex><span>            grid,
</span></span><span style=display:flex><span>        } <span style=color:#f92672>=</span> self;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates_up <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        duplicates_up.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates_left <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates_right <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> duplicates_down <span style=color:#f92672>=</span> Grid::new(grid.width, grid.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> grid.in_bounds(guard) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> grid.get(guard <span style=color:#f92672>+</span> facing) {
</span></span><span style=display:flex><span>                Some(Tile::Empty) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    guard <span style=color:#f92672>+=</span> facing.into();
</span></span><span style=display:flex><span>                    visited.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Some(Tile::Wall) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    facing <span style=color:#f92672>=</span> facing.rotate_cw();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> check_loops {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> duplicates <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>match</span> facing {
</span></span><span style=display:flex><span>                    Direction::Up <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> duplicates_up,
</span></span><span style=display:flex><span>                    Direction::Left <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> duplicates_left,
</span></span><span style=display:flex><span>                    Direction::Right <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> duplicates_right,
</span></span><span style=display:flex><span>                    Direction::Down <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> duplicates_down,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> duplicates.get(guard) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                duplicates.set(guard, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(visited)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&mldr; is slightly ugly. But was it worth it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># hashmap </span>
</span></span><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.583µs,
</span></span><span style=display:flex><span>	runner: 1.584841459s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited_rayon : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 50.667µs,
</span></span><span style=display:flex><span>	runner: 44.247666ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Grid&lt;bool&gt;</span>
</span></span><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>6</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 45.666µs,
</span></span><span style=display:flex><span>	runner: 409.640417ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>6</span> - Part <span style=color:#ae81ff>2</span> - limited_rayon : <span style=color:#ae81ff>1939</span>
</span></span><span style=display:flex><span>	generator: 52µs,
</span></span><span style=display:flex><span>	runner: 13.176792ms
</span></span></code></pre></div><p>Huh&mldr; that&rsquo;s pretty good. Even the original solution is sub half a second now!</p><p>Worth it!</p><h2 id=benchmarks>Benchmarks</h2><p>Overall benchmarks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># hashmap</span>
</span></span><span style=display:flex><span>cargo aoc bench --day <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day6 - Part1/v1             time:   <span style=color:#f92672>[</span>18.340 µs 18.428 µs 18.521 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/v1             time:   <span style=color:#f92672>[</span>1.6568 s 1.6652 s 1.6735 s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/limited        time:   <span style=color:#f92672>[</span>392.86 ms 394.18 ms 395.57 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/limited_rayon  time:   <span style=color:#f92672>[</span>45.311 ms 45.548 ms 45.807 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/no_clone       time:   <span style=color:#f92672>[</span>413.63 ms 416.32 ms 419.08 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Grid&lt;bool&gt;</span>
</span></span><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day6 - Part1/v1             time:   <span style=color:#f92672>[</span>19.739 µs 19.906 µs 20.106 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/v1             time:   <span style=color:#f92672>[</span>428.06 ms 429.59 ms 431.26 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/limited        time:   <span style=color:#f92672>[</span>95.354 ms 95.921 ms 96.571 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/limited_rayon  time:   <span style=color:#f92672>[</span>12.414 ms 12.441 ms 12.467 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day6 - Part2/no_clone       time:   <span style=color:#f92672>[</span>97.974 ms 98.957 ms 100.32 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>