<!doctype html><html><head><title>AoC 2024 Day 23: LAN Partinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 23: LAN Partinator</h1><div class=entry-meta><span class=entry-date>2024-12-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/10/aoc-2024-day-10-take-a-hikinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graph-theory>Graph Theory</a></li><li><a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memoization>Memoization</a></li><li><a class=taxonomy-value href=/programming/topics/np-complete>NP Complete</a></li><li><a href=https://blog.jverkamp.com/2024/12/21/aoc-2024-day-21-busy-workinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/recursion>Recursion</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=previous-link>Prev</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=previous-link>Prev</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-23-lan-partyhttpsadventofcodecom2024day23>Source: <a href=https://adventofcode.com/2024/day/23 target=_blank rel=noopener>Day 23: LAN Party</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day23.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-23-lan-partyhttpsadventofcodecom2024day23>Source: <a href=https://adventofcode.com/2024/day/23>Day 23: LAN Party</a></a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-2>Part 2</a><ul><li><a href=#corrected-version-1-largest-completely-connected>Corrected version 1: Largest completely connected</a></li><li><a href=#corrected-version-2-recursion--memoization>Corrected version 2: Recursion + memoization</a></li><li><a href=#corrected-version-3-ordering-by-most-connected-nodes>Corrected version 3: Ordering by most connected nodes</a></li><li><a href=#this-is-stupid>This is stupid&mldr;</a></li><li><a href=#and-complicated>&mldr;and complicated</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>You are given the edges of an <a href=https://en.wikipedia.org/wiki/undirected%20graph>undirected graph</a>. Count how many <a href=https://en.wikipedia.org/wiki/complete%20graph>complete</a> <a href=https://en.wikipedia.org/wiki/subgraphs>subgraphs</a> of size three exist that contain one or more starting with the letter <code>t</code>.</p></blockquote><p>Aside: Games with local (but not hotseat) multiplayer have gotten rather rarer over the years&mldr; how many people still know what a <a href=https://en.wikipedia.org/wiki/LAN%20party>LAN party</a> is/was?</p><p>I spent a little while making a <code>StrGraph&lt;'a></code> library for this one. You can see the entire source for that module <a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/strgraph.rs target=_blank rel=noopener>here</a>. Essentially:</p><ul><li>It can read <code>From&lt;&'a str></code></li><li>Internally, it stores <code>nodes</code>, <code>edges</code>, and <code>neighbors</code> as <code>HashSets</code>/<code>HashMaps</code>. I store both <code>edges</code> and <code>neighbors</code> because I needed <code>edges</code> first and only later realized it would be nice to have both.</li><li>Accessors for <code>nodes</code>, <code>edges</code>, and <code>neighbors</code> return <code>impl Iterator&lt;Item = &' str></code> (or a tuple for <code>edges</code>)</li></ul><p>And the following methods (in the order I wrote them):</p><ul><li><code>completely_connected(node: &'a str)</code> - Returns <em>a</em> completely connected subgraph containing <code>node</code></li><li><code>largest_completely_connected(node: &'a str)</code> - Returns the <em>largest</em> completely connected subgraph containing <code>node</code>; this is super inefficient</li><li><code>is_completely_connected(nodes: &[&'a str])</code> - A helper to check if the given list of nodes is a completely connected component</li></ul><p>All that being said, I only used the accessor for <code>part1</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> g <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sorted_nodes <span style=color:#f92672>=</span> g.nodes().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    sorted_nodes.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, a) <span style=color:#66d9ef>in</span> sorted_nodes.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (j, b) <span style=color:#66d9ef>in</span> sorted_nodes.iter().skip(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>).enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>g.has_edge(a, b) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> sorted_nodes.iter().skip(i <span style=color:#f92672>+</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>g.has_edge(a, c) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>g.has_edge(b, c) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> a.starts_with(<span style=color:#e6db74>&#39;t&#39;</span>) <span style=color:#f92672>||</span> b.starts_with(<span style=color:#e6db74>&#39;t&#39;</span>) <span style=color:#f92672>||</span> c.starts_with(<span style=color:#e6db74>&#39;t&#39;</span>) {
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It really does just look for an <code>a</code>, <code>b</code>, and <code>c</code> that are connected and have one starting with <code>t</code>. THere is a slight improvement in that it guarantees that <code>i &lt; j &lt; k</code> so we only count each ordering once and also doesn&rsquo;t bother searching for <code>c</code> if <code>a</code> and <code>b</code> are already not connected.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>23</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>1467</span>
</span></span><span style=display:flex><span>	generator: 3.166Âµs,
</span></span><span style=display:flex><span>	runner: 26.880625ms
</span></span></code></pre></div><p>Woot.</p><p>Why did I sort the nodes first? To guarantee a consistent ordering. For this problem, it doesn&rsquo;t matter&mldr;</p><h2 id=part-2>Part 2</h2><blockquote><p>Find the largest complete subgraph. Print the nodes <a href=https://en.wikipedia.org/wiki/lexicographically>lexicographically</a> sorted, comma delimited.</p></blockquote><p>There we go.</p><p>Okay, first attempt essentially uses</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, sorted_complete)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_sorted_complete</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> g <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> checked <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// NOTE: This would not actually work in general
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    g.nodes()
</span></span><span style=display:flex><span>        .sorted() <span style=color:#75715e>// This at least guarantees we&#39;ll get the same ordering
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .filter_map(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> checked.contains(n) {
</span></span><span style=display:flex><span>                None
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> component <span style=color:#f92672>=</span> g.completely_connected(n);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span>n <span style=color:#66d9ef>in</span> component.iter() {
</span></span><span style=display:flex><span>                    checked.insert(n);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Some(component)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .max_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.len().cmp(<span style=color:#f92672>&amp;</span>b.len()))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.iter().sorted().join(<span style=color:#e6db74>&#34;,&#34;</span>))
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With <code>completely_connected</code> being:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> StrGraph<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This will return *a* completely connected component for a node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>completely_connected</span>(<span style=color:#f92672>&amp;</span>self, node: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> connected <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>        connected.insert(node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// For each node, add it if it&#39;s connected to all other added nodes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span>n <span style=color:#66d9ef>in</span> self.nodes.iter().sorted() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>connected.iter().all(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> self.has_edge(n, c)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            connected.insert(n);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        connected
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to make sure that this function doesn&rsquo;t work sometimes but not others, I do again make sure that we&rsquo;re working on a sorted list (both in the <code>part2*</code> function and in <code>completely_connected</code>). Being able to do that inline in an <code>iter</code> is a function of <code><a href=https://docs.rs//latest//><code></code></a></code>
.</p><p>Basically, we go through each node, getting <em>a</em> complete subgraph it&rsquo;s connected to. These are then not checked again, plus we keep the longest of these. <code>c.iter().sorted().join(",")</code> is a delightful way to get a sorted, comma delimited list of nodes.</p><p>So&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>23</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - most_connected : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 17.666Âµs,
</span></span><span style=display:flex><span>	runner: 3.456209ms
</span></span></code></pre></div><p>This is technically the correct answer. But we actually got lucky with that. Alphabetical ordering of nodes <em>happens</em> to create this connected node when scanning through.</p><p>Basically, if we have something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    D
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>    C
</span></span><span style=display:flex><span>   / \
</span></span><span style=display:flex><span>A-B---F-E
</span></span></code></pre></div><p>Assume our HashSet returns things in alphabetical order (as a worst case):</p><ol><li>We&rsquo;ll start with <code>A</code>, get <code>A,B</code>; so we&rsquo;ll skip <code>B</code></li><li>Then we&rsquo;ll do <code>D</code>, get <code>C,D</code>; so we&rsquo;ll skip <code>D</code></li><li>Then we&rsquo;ll do <code>E</code>, get <code>E,F</code>; so we&rsquo;ll skip <code>F</code></li></ol><p>We never return the component <code>B,C,F</code>, which is what we actually want.</p><p>Even removing the checked.contains doesn&rsquo;t actually fix this, in the worst case. Since if we get an ordering such that <code>A</code> and <code>B</code> return <code>A,B</code> and <code>C</code> and <code>D</code> return <code>C,D</code>; etc.</p><p>We&rsquo;ll still never see the component <code>B,C,F</code>.</p><p>Here&rsquo;s a test showing that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructed to fail part2_largest_complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// See the comment in that function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     D
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     C
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    / \
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// A-B---F-E
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>EXAMPLE2</span>: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>a-b
</span></span></span><span style=display:flex><span><span style=color:#e6db74>b-c
</span></span></span><span style=display:flex><span><span style=color:#e6db74>c-d
</span></span></span><span style=display:flex><span><span style=color:#e6db74>c-f
</span></span></span><span style=display:flex><span><span style=color:#e6db74>f-e
</span></span></span><span style=display:flex><span><span style=color:#e6db74>b-f&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is constructed to fail due to the ordering of the graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[ignore]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_part2_largest_complete_example2</span>() {
</span></span><span style=display:flex><span>        assert_eq!(part2_largest_complete(<span style=color:#66d9ef>EXAMPLE2</span>), <span style=color:#e6db74>&#34;b,c,f&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What we need is completely_connected to return the <em>largest</em> component for a node. But this is <em>significantly</em> more expensive.</p><h3 id=corrected-version-1-largest-completely-connected>Corrected version 1: Largest completely connected</h3><p>Okay, so we found the answer, but there&rsquo;s no guarantee that if our input will return the correct answer. What does it need to actually guarantee that? Well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> StrGraph<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This will return the *largest* completely connected component for a node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>largest_completely_connected</span>(<span style=color:#f92672>&amp;</span>self, node: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>            nodes: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            neighbors: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span>, HashSet<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>            component: Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ) -&gt; Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            nodes
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Don&#39;t check nodes we&#39;ve already done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .filter(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>component.contains(n))
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Check if all neighbors are in the component
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .filter(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    component
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .all(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> neighbors.get(n).unwrap().contains(c))
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Recur adding that component
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .map(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    recur(nodes, neighbors, {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> component <span style=color:#f92672>=</span> component.clone();
</span></span><span style=display:flex><span>                        component.push(n);
</span></span><span style=display:flex><span>                        component
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Which is the largest
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .max_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.len().cmp(<span style=color:#f92672>&amp;</span>b.len()))
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we didn&#39;t find a larger child, return all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .unwrap_or_else(<span style=color:#f92672>||</span> component.to_vec())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        recur(<span style=color:#f92672>&amp;</span>self.nodes, <span style=color:#f92672>&amp;</span>self.neighbors, vec![node])
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .collect()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The obvious (to me) at least way of doing this is to start at the given node, then write a recursive function that will try adding each neighbor, one at a time. Any time we have no more neighbors that are connected to all previous nodes, return the component. As we&rsquo;re unwinding, we only keep the largest branch.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, largest_complete)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_largest_complete</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> g <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> checked <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The &#39;significantly more expensive&#39; version
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    g.nodes()
</span></span><span style=display:flex><span>        .filter_map(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> checked.contains(n) {
</span></span><span style=display:flex><span>                None
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> component <span style=color:#f92672>=</span> g.largest_completely_connected(n);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span>n <span style=color:#66d9ef>in</span> component.iter() {
</span></span><span style=display:flex><span>                    checked.insert(n);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Some(component)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .max_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.len().cmp(<span style=color:#f92672>&amp;</span>b.len()))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c.iter().sorted().join(<span style=color:#e6db74>&#34;,&#34;</span>))
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This does technically work (on both given example graphs), but man is it slow. I let it run an hour and still no progress. It turns out this problem is <a href=https://en.wikipedia.org/wiki/%20NP-complete>NP-complete</a> and running it on 3000+ nodes is <em>slow</em>.</p><h3 id=corrected-version-2-recursion--memoization>Corrected version 2: Recursion + memoization</h3><p>Just out of curiosity, I did take the observation that since it&rsquo;s a recursive problem, we should be able to cut off a lot of branches with memoization:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, recur_memo)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_recur_memo</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> graph <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>largest_completely_connected_subgraph</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>        graph: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>StrGraph</span>,
</span></span><span style=display:flex><span>        cache: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> HashMap<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>, Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>        nodes: Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We&#39;ve already cached this result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(result) <span style=color:#f92672>=</span> cache.get(<span style=color:#f92672>&amp;</span>nodes) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result.clone();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if we&#39;re already completely connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> graph.is_completely_connected(<span style=color:#f92672>&amp;</span>nodes) {
</span></span><span style=display:flex><span>            cache.insert(nodes.clone(), nodes.clone());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> nodes;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, for each node, try removing it and recurring
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> largest: Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, _) <span style=color:#66d9ef>in</span> nodes.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_nodes <span style=color:#f92672>=</span> nodes.clone();
</span></span><span style=display:flex><span>            new_nodes.remove(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> largest_completely_connected_subgraph(graph, cache, new_nodes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> largest.is_none() <span style=color:#f92672>||</span> result.len() <span style=color:#f92672>&gt;</span> largest.as_ref().unwrap().len() {
</span></span><span style=display:flex><span>                largest <span style=color:#f92672>=</span> Some(result);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> largest <span style=color:#f92672>=</span> largest.unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cache.insert(nodes, largest.clone());
</span></span><span style=display:flex><span>        largest
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nodes <span style=color:#f92672>=</span> graph.nodes().sorted().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cache <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    largest_completely_connected_subgraph(<span style=color:#f92672>&amp;</span>graph, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> cache, nodes)
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .sorted()
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;,&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This sort of works the other way around. It starts with the entire graph, then one at a time, tries removing nodes and recurring. As soon as we have a complete subgraph, we&rsquo;re done. Then cache each of those subgraphs.</p><p>The problem is&mldr; this can&rsquo;t possibly be efficient, again because of the whole NP-complete thing.</p><p>It does work perfectly well on my smaller examples and I assume it would be fine for my input&mldr; but again, I didn&rsquo;t let it finish.</p><h3 id=corrected-version-3-ordering-by-most-connected-nodes>Corrected version 3: Ordering by most connected nodes</h3><p>Okay, last but not least, we can actually use the structure of our input while at the same time guaranteeing that we&rsquo;ll eventually find an answer even in the worst case.</p><p>Here&rsquo;s some quick Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> collections<span style=color:#f92672>,</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>neighbors <span style=color:#f92672>=</span> collections<span style=color:#f92672>.</span>Counter()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> sys<span style=color:#f92672>.</span>stdin:
</span></span><span style=display:flex><span>    (a, b) <span style=color:#f92672>=</span> line<span style=color:#f92672>.</span>strip()<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;-&#34;</span>)
</span></span><span style=display:flex><span>    neighbors[a] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    neighbors[b] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>by_count <span style=color:#f92672>=</span> collections<span style=color:#f92672>.</span>defaultdict(set)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> node, count <span style=color:#f92672>in</span> neighbors<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>    by_count[count]<span style=color:#f92672>.</span>add(node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> count <span style=color:#f92672>in</span> sorted(by_count<span style=color:#f92672>.</span>keys(), reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>    nodes <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>.</span>join(sorted(node <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> by_count[count]))
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>count<span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>nodes<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>Which outputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>13: aa,ab,ac,ad,af,ag,ah,ai,ak,al,am,an,ao,aq,ar,as,at,au,av,aw,ay,az,ba,bb,bc,bg,bh,bi,bj,bm,bo,bp,br,bt,bu,bv,bw,bx,by,bz,cd,cf,cg,ch,ci,cj,ck,cl,cm,co,cp,cq,cr,cs,ct,cu,cv,cw,cx,cy,cz,dd,de,df,dg,dh,di,dj,dk,dl,dm,do,dp,dr,ds,dt,dv,dw,dx,ea,eb,ec,ed,ee,ef,eh,ei,ep,er,es,et,ev,ew,ex,ey,fb,fc,fe,fg,fh,fj,fk,fl,fm,fn,fo,fq,fr,fs,ft,fu,fv,fw,fx,fy,ga,gb,gc,ge,gf,gg,gh,gi,gj,gk,gm,gn,gp,gq,gr,gs,gt,gu,gv,gw,gx,gy,gz,hc,he,hj,hk,hn,ho,hp,hq,hr,ht,hv,hw,hx,hy,hz,ia,ib,ie,if,ig,ih,ii,ij,il,im,in,io,ip,iq,ir,it,iu,iv,iw,ix,iy,iz,ja,jb,jc,jd,jg,jh,jk,jl,jm,jo,jp,jq,jr,js,ju,jv,jw,jx,jz,ka,kc,kd,kf,kg,kh,ki,kk,kn,ko,kp,kq,kr,kt,ku,kv,kx,ky,kz,la,lb,lc,ld,le,lf,lg,lh,ll,lm,ln,lo,lp,lq,lr,lt,lu,lw,lx,ly,lz,ma,mb,mc,md,me,mf,mg,mi,mj,mk,ml,mn,mo,mq,mr,ms,mt,mu,mw,my,mz,na,nb,nc,nf,ng,nh,ni,nk,nl,nm,nn,no,np,nr,ns,nt,nu,nw,nx,ny,nz,oa,oc,od,oe,of,og,oj,ok,ol,oo,op,oq,or,ot,ou,ov,ow,ox,oy,oz,pa,pb,pc,pd,pe,pg,ph,pj,pl,pm,pn,po,pp,pq,pr,pt,pu,pv,pw,px,py,pz,qb,qc,qf,qg,qi,qj,qk,ql,qm,qo,qp,qq,qr,qs,qt,qu,qv,qw,qy,ra,rd,re,rg,rh,ri,rj,rl,rm,rn,ro,rp,rq,rs,ru,rv,rw,ry,sa,sb,sd,se,sf,sg,sh,si,sj,sk,sl,sn,so,sq,sr,ss,st,su,sw,sy,sz,ta,tb,tc,td,te,tf,tg,th,ti,tj,tk,tl,tm,to,tp,tq,tr,ts,tt,tu,tv,tw,tx,ty,ua,uc,ud,ue,uf,ug,uh,ui,uk,ul,um,uo,up,uq,ur,us,uw,ux,uy,uz,va,vb,vd,ve,vf,vi,vj,vk,vl,vm,vn,vo,vp,vq,vr,vs,vu,vw,vx,vy,vz,wa,wd,we,wf,wg,wj,wk,wl,wm,wn,wo,wp,wr,ws,wv,ww,wx,wy,wz,xb,xd,xe,xf,xg,xh,xk,xl,xn,xo,xp,xq,xr,xs,xt,xu,xv,xx,xy,yb,yd,ye,yf,yg,yh,yi,yj,yl,yn,yo,yp,yq,yr,ys,yt,yu,yv,yw,yx,yy,yz,za,zc,ze,zf,zg,zi,zj,zk,zl,zm,zn,zo,zq,zr,zs,zt,zu,zw,zx
</span></span></code></pre></div><p>&mldr;</p><p>So every single node in the graph is connected to exactly 13 others. That does <em>heavily</em> imply that our largest connected subgraph is going to have 12 nodes (even if we didn&rsquo;t already know that).</p><p>I ended up writing a solution from that that&rsquo;s still a bit more general:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, most_connected)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_most_connected</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> graph <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Order nodes by descending number of neighbors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For each, check if removing any single neighbor is connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Any nodes with higher order than the connected component will be checked first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// But due to the structure of our graph, this way is efficient
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    graph
</span></span><span style=display:flex><span>        .nodes()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>node<span style=color:#f92672>|</span> (node, graph.neighbors(node).count()))
</span></span><span style=display:flex><span>        .sorted_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.<span style=color:#ae81ff>1.</span>cmp(<span style=color:#f92672>&amp;</span>b.<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        .rev()
</span></span><span style=display:flex><span>        .find_map(<span style=color:#f92672>|</span>(node, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> neighbors <span style=color:#f92672>=</span> graph.neighbors(node).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try removing each single neighbor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> neighbor <span style=color:#66d9ef>in</span> neighbors.iter() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> neighbors_without <span style=color:#f92672>=</span> neighbors.clone();
</span></span><span style=display:flex><span>                neighbors_without.retain(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> n <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>neighbor);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> graph.is_completely_connected(<span style=color:#f92672>&amp;</span>neighbors_without) {
</span></span><span style=display:flex><span>                    neighbors_without.push(node);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(neighbors_without.iter().sorted().join(<span style=color:#e6db74>&#34;,&#34;</span>));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we made it here, we couldn&#39;t find a solution removing more than 1 neighbor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            None
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As noted, it&rsquo;s going to go through the nodes in descending order of number of neighbors (when I wrote this, I didn&rsquo;t realize that they were all 13 yet&mldr; ðŸ˜„).Â For each node, it will take the list of neighbors (guaranteed all connected to that node), and try removing them each one at a time. As soon as we find a complete subgraph, return (<code>find_map</code>).</p><p>This works specifically on any graph that has the structure of a bunch of complete subgraphs (of any size really), where any node in the graph has exactly <em>1</em> connection outside of that complete subgraph. If all of the nodes in it have more than one connect, this will fail.</p><p>But for our specific input (and I assume any generated the same way), it works great!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>23</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - sorted_complete : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 16.666Âµs,
</span></span><span style=display:flex><span>	runner: 9.681875ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - most_connected : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 17.666Âµs,
</span></span><span style=display:flex><span>	runner: 3.456209ms
</span></span></code></pre></div><p>Better even than the sorted case, and &lsquo;slightly&rsquo; more guaranteed to return a correct answer?</p><h3 id=this-is-stupid>This is stupid&mldr;</h3><p>Because I would be remiss if I didn&rsquo;t mention it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, nested_loops)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_nested_loops</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> graph <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nodes <span style=color:#f92672>=</span> graph.nodes().sorted().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i0, n0) <span style=color:#66d9ef>in</span> nodes.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i1, n1) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i0 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> [n0].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n1)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (i2, n2) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> [n0, n1].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n2)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (i3, n3) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> [n0, n1, n2].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n3)) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (i4, n4) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> [n0, n1, n2, n3].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n4)) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (i5, n5) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i4 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n5)) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (i6, n6) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i5 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n6)) {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>for</span> (i7, n7) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i6 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n7)) {
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>i8</span>, n8) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i7 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6, n7].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n8)) {
</span></span><span style=display:flex><span>                                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>for</span> (i9, n9) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(<span style=color:#66d9ef>i8</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                            <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6, n7, n8].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n9)) {
</span></span><span style=display:flex><span>                                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                            <span style=color:#66d9ef>for</span> (i10, n10) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i9 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                                <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n10)) {
</span></span><span style=display:flex><span>                                                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                                <span style=color:#66d9ef>for</span> (i11, n11) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i10 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                                    <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n11)) {
</span></span><span style=display:flex><span>                                                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                                    <span style=color:#66d9ef>for</span> (_, n12) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(i11 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                                                        <span style=color:#66d9ef>if</span> [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, n12)) {
</span></span><span style=display:flex><span>                                                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                                                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                                        <span style=color:#66d9ef>return</span> [n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12]
</span></span><span style=display:flex><span>                                                            .iter()
</span></span><span style=display:flex><span>                                                            .sorted()
</span></span><span style=display:flex><span>                                                            .join(<span style=color:#e6db74>&#34;,&#34;</span>);
</span></span><span style=display:flex><span>                                                    }
</span></span><span style=display:flex><span>                                                }
</span></span><span style=display:flex><span>                                            }
</span></span><span style=display:flex><span>                                        }
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    unreachable!(<span style=color:#e6db74>&#34;No solution&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>23</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - sorted_complete : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 16.666Âµs,
</span></span><span style=display:flex><span>	runner: 9.681875ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - most_connected : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 17.666Âµs,
</span></span><span style=display:flex><span>	runner: 3.456209ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - nested_loops : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 1.084Âµs,
</span></span><span style=display:flex><span>	runner: 167.462333ms
</span></span></code></pre></div><p>It&rsquo;s slower and stupider&mldr; but it works?</p><h3 id=and-complicated>&mldr;and complicated</h3><p>I have to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day23, part2, nested_loops_macro)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_nested_loops_macro</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> graph <span style=color:#f92672>=</span> StrGraph::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nodes <span style=color:#f92672>=</span> graph.nodes().sorted().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    macro_rules<span style=color:#f92672>!</span> wtf {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// First case / outermost loop, starts the recursion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#75715e>$i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$n</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$($rest_i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$rest_n</span>:<span style=color:#a6e22e>ident</span>)<span style=color:#f92672>*</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#75715e>$i</span>, <span style=color:#75715e>$n</span>) <span style=color:#66d9ef>in</span> nodes.iter().enumerate() {
</span></span><span style=display:flex><span>                wtf!(<span style=color:#75715e>$($rest_i</span> <span style=color:#75715e>$rest_n</span>)<span style=color:#f92672>*</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$i</span> <span style=color:#75715e>$n</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Base case / innermost loop, finally does the return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#75715e>$last_i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$last_n</span>:<span style=color:#a6e22e>ident</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$prev_i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$($prev_n</span>:<span style=color:#a6e22e>ident</span>),<span style=color:#f92672>*</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (_, <span style=color:#75715e>$last_n</span>) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(<span style=color:#75715e>$prev_i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> [<span style=color:#75715e>$($prev_n</span>),<span style=color:#f92672>*</span>].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, <span style=color:#75715e>$last_n</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> [<span style=color:#75715e>$($prev_n</span>),<span style=color:#f92672>*</span>, <span style=color:#75715e>$last_n</span>]
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .sorted()
</span></span><span style=display:flex><span>                    .join(<span style=color:#e6db74>&#34;,&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Intermediate cases, continues the recursion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#75715e>$i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$n</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$($rest_i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$rest_n</span>:<span style=color:#a6e22e>ident</span>)<span style=color:#f92672>*</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$prev_i</span>:<span style=color:#a6e22e>ident</span> <span style=color:#75715e>$($prev_n</span>:<span style=color:#a6e22e>ident</span>),<span style=color:#f92672>*</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#75715e>$i</span>, <span style=color:#75715e>$n</span>) <span style=color:#66d9ef>in</span> nodes.iter().enumerate().skip(<span style=color:#75715e>$prev_i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> [ <span style=color:#75715e>$($prev_n</span>),<span style=color:#f92672>*</span> ].iter().any(<span style=color:#f92672>|&amp;</span>n<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>graph.has_edge(n, <span style=color:#75715e>$n</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                wtf!(<span style=color:#75715e>$($rest_i</span> <span style=color:#75715e>$rest_n</span>)<span style=color:#f92672>*</span> <span style=color:#f92672>=&gt;</span> <span style=color:#75715e>$i</span> <span style=color:#75715e>$n</span>, <span style=color:#75715e>$($prev_n</span>),<span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    wtf!(
</span></span><span style=display:flex><span>        i0 n0
</span></span><span style=display:flex><span>        i1 n1
</span></span><span style=display:flex><span>        i2 n2
</span></span><span style=display:flex><span>        i3 n3
</span></span><span style=display:flex><span>        i4 n4
</span></span><span style=display:flex><span>        i5 n5
</span></span><span style=display:flex><span>        i6 n6
</span></span><span style=display:flex><span>        i7 n7
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>i8</span> n8
</span></span><span style=display:flex><span>        i9 n9
</span></span><span style=display:flex><span>        i10 n10
</span></span><span style=display:flex><span>        i11 n11
</span></span><span style=display:flex><span>        i12 n12
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    unreachable!(<span style=color:#e6db74>&#34;No solution&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&mldr; was certainly a macro.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>23</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - sorted_complete : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 16.666Âµs,
</span></span><span style=display:flex><span>	runner: 9.681875ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - most_connected : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 17.666Âµs,
</span></span><span style=display:flex><span>	runner: 3.456209ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - nested_loops : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 1.084Âµs,
</span></span><span style=display:flex><span>	runner: 167.462333ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>23</span> - Part <span style=color:#ae81ff>2</span> - nested_loops_macro : di,gs,jw,kz,md,nc,qp,rp,sa,ss,uk,xk,yn
</span></span><span style=display:flex><span>	generator: 1.542Âµs,
</span></span><span style=display:flex><span>	runner: 263.257291ms
</span></span></code></pre></div><p>And kind of hilarious.</p><h2 id=benchmarks>Benchmarks</h2><p>Anyways.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>23</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day23 - Part1/v1                    time:   <span style=color:#f92672>[</span>20.133 ms 20.535 ms 21.110 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day23 - Part2/sorted_complete       time:   <span style=color:#f92672>[</span>4.5812 ms 4.6292 ms 4.6934 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day23 - Part2/most_connected        time:   <span style=color:#f92672>[</span>650.01 Âµs 662.88 Âµs 681.55 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day23 - Part2/nested_loops          time:   <span style=color:#f92672>[</span>181.16 ms 182.90 ms 184.81 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day23 - Part2/nested_loops_macro    time:   <span style=color:#f92672>[</span>291.93 ms 293.87 ms 295.91 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>