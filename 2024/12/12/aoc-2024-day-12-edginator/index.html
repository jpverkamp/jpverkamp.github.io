<!doctype html><html><head><title>AoC 2024 Day 12: Edginator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 12: Edginator</h1><div class=entry-meta><span class=entry-date>2024-12-12</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/edge-detection>Edge Detection</a></li><li><a class=taxonomy-value href=/programming/topics/flood-fill>Flood Fill</a></li><li><a href=https://blog.jverkamp.com/2024/12/08/aoc-2024-day-8-vectorinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/geometry>Geometry</a></li><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-12-garden-groupshttpsadventofcodecom2024day12>Source: <a href=https://adventofcode.com/2024/day/12 target=_blank rel=noopener>Day 12: Garden Groups</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day12.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-12-garden-groupshttpsadventofcodecom2024day12>Source: <a href=https://adventofcode.com/2024/day/12>Day 12: Garden Groups</a></a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-2>Part 2</a><ul><li><a href=#optimization-1-detect-corners-instead-of-edges>Optimization 1: Detect corners instead of edges</a></li></ul></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a <code>Grid</code> of regions, calculate the sum of the product <code>perimeter * area</code> for each region.</p></blockquote><p>Okay, we can load it as a <code>Grid</code>, but we&rsquo;re going to need two new bits of code to actually get the regions.</p><p>First, the code that will scan across the input and for each (unassigned) point, find all connected points to it (and mark them all as assigned so we get each region once):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day12)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Grid::read(input, <span style=color:#f92672>&amp;|</span>c<span style=color:#f92672>|</span> c)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_regions</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span>T, Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>)<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: Clone <span style=color:#f92672>+</span> Default <span style=color:#f92672>+</span> PartialEq,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> assigned_regions <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> regions <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Calculate the points in each region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>(input.width) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>(input.height) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> (x, y).into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> assigned_regions.get(p).is_some_and(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>v) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> input.get(p).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> region <span style=color:#f92672>=</span> input.flood_fill(p);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> region.iter() {
</span></span><span style=display:flex><span>                assigned_regions.set(<span style=color:#f92672>*</span>p, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            regions.push((c, region));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    regions
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That of course requires we extend <code>Grid</code> with <code>flood_fill</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Grid<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    T: PartialEq <span style=color:#f92672>+</span> Clone <span style=color:#f92672>+</span> Default,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>flood_fill</span>(<span style=color:#f92672>&amp;</span>self, p: <span style=color:#a6e22e>impl</span> Into<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> p.into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.in_bounds(p) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Vec::new();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> self.data[self.index(<span style=color:#f92672>&amp;</span>p)].clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stack <span style=color:#f92672>=</span> vec![p];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> vec![<span style=color:#66d9ef>false</span>; self.data.len()];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(p) <span style=color:#f92672>=</span> stack.pop() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.in_bounds(p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.get(p) <span style=color:#f92672>!=</span> Some(<span style=color:#f92672>&amp;</span>target) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.index(<span style=color:#f92672>&amp;</span>p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> visited[index] {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            visited[index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            result.push(p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            stack.push(p <span style=color:#f92672>+</span> Point::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>            stack.push(p <span style=color:#f92672>+</span> Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>            stack.push(p <span style=color:#f92672>+</span> Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            stack.push(p <span style=color:#f92672>+</span> Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s a different block, since this does require the <code>T</code> to be <code>PartialEq</code> where most of the <code>impl&lt;T> Grid&lt;T></code> does not. It&rsquo;s really neat how Rust templated <code>impl</code> can have different requirements. So you can use this method if you are <code>PartialEq</code>, but you don&rsquo;t need to be <code>PartialEq</code> to just <code>.get</code> or <code>.set</code>.</p><p>Once we have that, we know enough to solve the problem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day12, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> regions <span style=color:#f92672>=</span> get_regions(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each region, find the perimeter, area, and then the score
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    regions
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>c, region)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For each point, each neighbor which doesn&#39;t match is an edge
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Score is area times this perimeter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            region.len()
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span> region
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        p.neighbors()
</span></span><span style=display:flex><span>                            .iter()
</span></span><span style=display:flex><span>                            .map(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#f92672>&amp;</span>v) <span style=color:#f92672>=</span> input.get(<span style=color:#f92672>*</span>n) {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> c {
</span></span><span style=display:flex><span>                                        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                    }
</span></span><span style=display:flex><span>                                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            })
</span></span><span style=display:flex><span>                            .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That nested a bit more than I&rsquo;d like. The innermost block <code>p.neighbors()</code> is doing perimeter detection: for each neighbor of a point, if it&rsquo;s different, that&rsquo;s 1 unit on the perimeter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>cargo aoc <span style=color:#f92672>--</span>day <span style=color:#ae81ff>12</span> <span style=color:#f92672>--</span>part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>AOC</span> <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>12</span> <span style=color:#f92672>-</span> Part <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> v1 : <span style=color:#ae81ff>1450816</span>
</span></span><span style=display:flex><span>	generator: <span style=color:#ae81ff>43.125</span><span style=color:#960050;background-color:#1e0010>µ</span>s,
</span></span><span style=display:flex><span>	runner: <span style=color:#ae81ff>910.625</span><span style=color:#960050;background-color:#1e0010>µ</span>s
</span></span></code></pre></div><p>In case you are curious (I was!) the regions look like this:</p><figure><img src=/embeds/2024/aoc/day12.png></figure><p>We&rsquo;ve got both some really big ones and a few tiny little islands. We do also have to deal with regions completely contained within another region.</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of the perimeter, count the number of edges.</p></blockquote><p>I&rsquo;ve got a sneaky way to do this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day12, part2, edge_detection)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_edge_detection</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> regions <span style=color:#f92672>=</span> get_regions(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each region, find the number of edges, area, and then the score
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    regions
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>c, region)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Edges in this version run along the border of the region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Score is area times number of edges
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            region.len()
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span> Direction::all()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|&amp;</span>direction<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Run edge detection in each direction once per region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// This will create a new grid that is true for edges in that direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> edges <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>                        region.iter().for_each(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> input.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> direction).is_none_or(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>!=</span> c) {
</span></span><span style=display:flex><span>                                edges.set(<span style=color:#f92672>*</span>p, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// For edges in that direction, identify &#39;regions&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// Each of those is a single contiguous edge
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        get_regions(<span style=color:#f92672>&amp;</span>edges).iter().filter(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>c, _)<span style=color:#f92672>|</span> c).count()
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;re going to actually re-use and duplicate the region detection for edges! If we make a grid that is <code>true</code> for all points that are an &lsquo;up&rsquo; edge then the number of regions is exactly equal to the number of up edges total!</p><p>Here&rsquo;s a graphic showing the up/down edges:</p><figure><img src=/embeds/2024/aoc/day12-edges-up.png></figure><p>And the left/right edges:</p><figure><img src=/embeds/2024/aoc/day12-edges-right.png></figure><p>It&rsquo;s somewhat slower, since we&rsquo;re calculating the edges for each region as it&rsquo;s own <code>Grid</code>. I expect I could optimize that, but for the moment, we need each edges because it&rsquo;s multiplied by each area.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>12</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>12</span> - Part <span style=color:#ae81ff>2</span> - edge_detection : <span style=color:#ae81ff>865662</span>
</span></span><span style=display:flex><span>	generator: 63.959µs,
</span></span><span style=display:flex><span>	runner: 608.089958ms
</span></span></code></pre></div><h3 id=optimization-1-detect-corners-instead-of-edges>Optimization 1: Detect corners instead of edges</h3><p>Okay, that&rsquo;s kind of expensive. Here&rsquo;s a fun math trick: polygons have the same number of sides and edges. So what&rsquo;s a corner?</p><p>Either this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>*x
</span></span><span style=display:flex><span>xC
</span></span></code></pre></div><p>Where <code>C</code> is the corner of the region, <code>x</code> is anything that&rsquo;s not <code>C</code> (including out of bounds), and <code>*</code> can be anything (including <code>C</code>&ndash;in that case we&rsquo;ll have two corners).</p><p>Or this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>xC
</span></span><span style=display:flex><span>CC
</span></span></code></pre></div><p>With the same conditions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day12, part2, corners)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_corners</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> regions <span style=color:#f92672>=</span> get_regions(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each region, find the number of edges, area, and then the score
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    regions
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(_, region)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// There are an equal number of edges and corners
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Each corner is either:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//  *x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//  xC where each x is anything not C and * can be C or not
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// or
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//  xC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//  CC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            region.len()
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span> region
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> me <span style=color:#f92672>=</span> input.get(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> xd <span style=color:#66d9ef>in</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>].iter() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> yd <span style=color:#66d9ef>in</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>].iter() {
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// *x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>// xC case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// Along the x and y directions match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#66d9ef>let</span> neighbor_xd <span style=color:#f92672>=</span> input.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::new(<span style=color:#f92672>*</span>xd, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> neighbor_yd <span style=color:#f92672>=</span> input.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::new(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>*</span>yd));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> me <span style=color:#f92672>!=</span> neighbor_xd <span style=color:#f92672>&amp;&amp;</span> me <span style=color:#f92672>!=</span> neighbor_yd {
</span></span><span style=display:flex><span>                                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e>// xC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>// CC case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> neighbor_both <span style=color:#f92672>=</span> input.get(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::new(<span style=color:#f92672>*</span>xd, <span style=color:#f92672>*</span>yd));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> me <span style=color:#f92672>==</span> neighbor_xd <span style=color:#f92672>&amp;&amp;</span> me <span style=color:#f92672>==</span> neighbor_yd <span style=color:#f92672>&amp;&amp;</span> me <span style=color:#f92672>!=</span> neighbor_both {
</span></span><span style=display:flex><span>                                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        count
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s a bit longer, but I think fairly elegant with the comments. One neat trick is that since I keep <code>me</code> as an <code>Option&lt;c></code>, we get the border checks (which return <code>None</code>) for free. So we loop in the 4 directions (top left, top right, bottom left, bottom right) and check those two cases, counting how many are corners and&mldr; we&rsquo;re done!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>12</span> --part <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>12</span> - Part <span style=color:#ae81ff>2</span> - edge_detection : <span style=color:#ae81ff>865662</span>
</span></span><span style=display:flex><span>	generator: 63.959µs,
</span></span><span style=display:flex><span>	runner: 608.089958ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>12</span> - Part <span style=color:#ae81ff>2</span> - corners : <span style=color:#ae81ff>865662</span>
</span></span><span style=display:flex><span>	generator: 56.583µs,
</span></span><span style=display:flex><span>	runner: 1.282333ms
</span></span></code></pre></div><p>That is <em>bonkers</em> faster. 600x.</p><p>I think the other algorithm is sneakier (edge detection! re-using &lsquo;regions&rsquo; to define edges!), but I like the edges = corners of this one and&ndash;when in a programming challenge&ndash;it&rsquo;s good to find code that is <em>both</em> fast and elegant.</p><p>Heck, I expect this could be done while doing the floodfill to gain even more of a buff&mldr; but I think ~1ms is pretty good for now.</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day12 - Part1/v1                time:   <span style=color:#f92672>[</span>827.45 µs 829.68 µs 832.26 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day12 - Part2/edge_detection    time:   <span style=color:#f92672>[</span>607.70 ms 615.13 ms 626.18 ms<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day12 - Part2/corners           time:   <span style=color:#f92672>[</span>1.0763 ms 1.0787 ms 1.0812 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>That&rsquo;s by far my slowest so far, but still under a second, so we&rsquo;ll go with it for the moment.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>