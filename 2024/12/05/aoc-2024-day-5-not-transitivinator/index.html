<!doctype html><html><head><title>AoC 2024 Day 5: (Not) Transitivinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 5: (Not) Transitivinator</h1><div class=entry-meta><span class=entry-date>2024-12-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/04/aoc-2024-day-4-gridnator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/04/aoc-2024-day-4-gridnator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/binary-search>Binary Search</a><a href=https://blog.jverkamp.com/2024/12/18/aoc-2024-day-18-last-chancinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2023/08/12/stacklang-part-ix-better-testing/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2017/12/11/deterministic-shuffling-using-hashes/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/sorting>Sorting</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/04/aoc-2024-day-4-gridnator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/04/aoc-2024-day-4-gridnator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/04/aoc-2024-day-4-gridnator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/06/aoc-2024-day-6-wanderinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-day-5-print-queue>Source: <a href=https://adventofcode.com/2024/day/5 target=_blank rel=noopener>Day Day 5: Print Queue</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day5.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-day-5-print-queue>Source: <a href=https://adventofcode.com/2024/day/5>Day Day 5: Print Queue</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#parsing>Parsing</a></li><li><a href=#is-it-transitive>Is it transitive?</a></li></ul></li><li><a href=#part-2>Part 2</a></li><li><a href=#benchmarks>Benchmarks</a></li><li><a href=#optimization-1-drop-the-hashmap>Optimization 1: Drop the <code>hashmap</code></a></li><li><a href=#optimization-2-bitvec>Optimization 2: <code>bitvec</code></a></li><li><a href=#optimization-attempt-3-a-vec-of-pairs>Optimization (attempt) 3: A <code>vec</code> of pairs</a><ul><li><a href=#optimization-attempt-4-sorted-vec-of-pairs>Optimization (attempt) 4: Sorted <code>vec</code> of pairs</a></li></ul></li><li><a href=#overall-timing-graph>Overall timing graph</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>The input is a list of pairs of the form <code>a|b</code> which defines that <code>b</code> must not come before <code>a</code>, an empty line, and then a list of values <code>a,b,c,d</code>.</p><p>For each line that is valid for all given <code>a|b</code> rules, sum the middle number of each list.</p></blockquote><p>We&rsquo;ll go ahead and start with a hash of <code>a -> Set(b)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Default, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ordering</span> {
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>hashbrown</span>::HashMap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span>, hashbrown::HashSet<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            data: <span style=color:#a6e22e>hashbrown</span>::HashMap::new(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        self.data.entry(a).or_default().insert(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That lets us define <code>can_precede</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>self.data.contains_key(<span style=color:#f92672>&amp;</span>b) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>self.data[<span style=color:#f92672>&amp;</span>b].contains(<span style=color:#f92672>&amp;</span>a)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If <code>b</code> isn&rsquo;t in any pair, than <code>a</code> is always fine. Otherwise, <code>a</code> can never appear in any list <code>b</code>.</p><p>This then tells us if a given <code>Vec</code> is sorted by this <code>Ordering</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>validates</span>(<span style=color:#f92672>&amp;</span>self, list: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u32</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        list.iter().is_sorted_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> self.can_precede(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which in turn basically solves the problem for us:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day5, part1, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_v1</span>((ordering, data): <span style=color:#66d9ef>&amp;</span>(Ordering, Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span>)) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    data.iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> ordering.validates(list))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> list[list.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s fun when most of the work is setting up abstractions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>5</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>5</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>4924</span>
</span></span><span style=display:flex><span>	generator: 119.083µs,
</span></span><span style=display:flex><span>	runner: 19.25µs
</span></span></code></pre></div><p>Quick enough!</p><h3 id=parsing>Parsing</h3><p>Not <em>super</em> relevant to the problem (especially since it&rsquo;s a fairly tame format so far as puzzle input goes), but here&rsquo;s my <code>nom</code> parsing function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day5)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; (Ordering, Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> nom::{
</span></span><span style=display:flex><span>        character::complete::{self, newline},
</span></span><span style=display:flex><span>        multi::{many1, separated_list1},
</span></span><span style=display:flex><span>        sequence::separated_pair,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_ordering</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>nom</span>::IResult<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Ordering<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (rest, ls) <span style=color:#f92672>=</span> separated_list1(
</span></span><span style=display:flex><span>            newline,
</span></span><span style=display:flex><span>            separated_pair(complete::<span style=color:#66d9ef>u32</span>, complete::<span style=color:#66d9ef>char</span>(<span style=color:#e6db74>&#39;|&#39;</span>), complete::<span style=color:#66d9ef>u32</span>),
</span></span><span style=display:flex><span>        )(input)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ordering <span style=color:#f92672>=</span> Ordering::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (a, b) <span style=color:#66d9ef>in</span> ls {
</span></span><span style=display:flex><span>            ordering.insert(a, b);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Ok((rest, ordering))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_list</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>nom</span>::IResult<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        separated_list1(complete::<span style=color:#66d9ef>char</span>(<span style=color:#e6db74>&#39;,&#39;</span>), complete::<span style=color:#66d9ef>u32</span>)(input)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_input</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>nom</span>::IResult<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span>, (Ordering, Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (input, ordering) <span style=color:#f92672>=</span> parse_ordering(input)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (input, _) <span style=color:#f92672>=</span> many1(newline)(input)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (input, data) <span style=color:#f92672>=</span> separated_list1(newline, parse_list)(input)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        Ok((input, (ordering, data)))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    parse_input(input).unwrap().<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It actually runs about 20% faster than a <code>.lines()</code> + <code>.split_once('|')</code>, which I found interesting. And at least for me, just as easy to read if not a bit more clear.</p><h3 id=is-it-transitive>Is it transitive?</h3><p>Second aside: one thing that really tripped me up when running this problem was the assumption that the rules in the first part would be defined such that they were <a href=https://en.wikipedia.org/wiki/transitive>transitive</a>. So if you have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a|b
</span></span><span style=display:flex><span>b|c
</span></span></code></pre></div><p>You can infer <code>a|c</code>. Which works perfectly well for their given example&mldr; but doesn&rsquo;t for our actually given test cases. It ends up you can have these rules:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a|b
</span></span><span style=display:flex><span>b|c
</span></span><span style=display:flex><span>c|a
</span></span></code></pre></div><p>Thus forming a loop. It doesn&rsquo;t make any sense if you have all three <code>a,b,c</code> in an input (I guess it could just be always invalid), <em>but</em> it actually works out perfectly if you only ever include no more than two of them. <code>a,b</code> <code>b,c</code> and <code>c,a</code> are all perfectly valid to have within a given list.</p><p>Spent more time than I wanted to track that one down:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This was my original (more complicated!) version, but it&#39;s not actually correct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Imagine this input:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>        98|51
</span></span></span><span style=display:flex><span><span style=color:#75715e>        51|22
</span></span></span><span style=display:flex><span><span style=color:#75715e>        22|98
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    This would imply both that 98 is before 51 but that 51 is before 22 which is before 98.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    But... that doesn&#39;t make any sense... *unless* you can never a valid list that has all three.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    If you have 98 and 51, 98 goes first. But if you have 51,22 or 22,98 those are correct.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    I expect this would do funny things to sort_by if you end up with all three :smile:
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// To proceed, either a is directly before b or recursively before it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede_transitive</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.data.contains_key(<span style=color:#f92672>&amp;</span>a)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> (self.data[<span style=color:#f92672>&amp;</span>a].contains(<span style=color:#f92672>&amp;</span>b) <span style=color:#f92672>||</span> self.data[<span style=color:#f92672>&amp;</span>a].iter().any(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> self.can_precede(c, b)))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede_transitive_path</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.data.contains_key(<span style=color:#f92672>&amp;</span>a) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.data[<span style=color:#f92672>&amp;</span>a].contains(<span style=color:#f92672>&amp;</span>b) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(<span style=color:#a6e22e>vec!</span>[a, b]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span>c <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>self.data[<span style=color:#f92672>&amp;</span>a] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(<span style=color:#66d9ef>mut</span> path) <span style=color:#f92672>=</span> self.can_precede_transitive_path(c, b) {
</span></span><span style=display:flex><span>                path.insert(<span style=color:#ae81ff>0</span>, a);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(path);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And <code>bin/day5-check.rs</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> aoc2024::day5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Used to determine/verify that the ordering is *not* transitive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> filename <span style=color:#f92672>=</span> std::env::args().nth(<span style=color:#ae81ff>1</span>).expect(<span style=color:#e6db74>&#34;missing filename argument&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> content <span style=color:#f92672>=</span> std::fs::read_to_string(filename).expect(<span style=color:#e6db74>&#34;cannot read file&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (ordering, _) <span style=color:#f92672>=</span> day5::parse(<span style=color:#f92672>&amp;</span>content);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a <span style=color:#66d9ef>in</span> ordering.values() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> b <span style=color:#66d9ef>in</span> ordering.values() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> proceeds <span style=color:#f92672>=</span> ordering.can_precede(a, b);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> proceeds_transitive <span style=color:#f92672>=</span> ordering.can_precede_transitive(a, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> proceeds_transitive <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>proceeds {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{a}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{b}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ordering.can_precede_transitive_path(a, b));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That was how I actually verified that you can have rules that don&rsquo;t work transitively, but are perfectly valid for the given input.</p><p>I&rsquo;ll admit, that&rsquo;s one of the things that both annoys me and is <em>such a perfect encapsulation of software development</em>: Occasionally ambiguous specifications. And/or specifications that are specifically written in English, but not given as concrete and comprehensive examples.</p><blockquote><p>The second and third updates are also in the correct order according to the rules. Like the first update, they also do not include every page number, and so only some of the ordering rules apply - within each update, the ordering rules that involve missing page numbers are not used.</p></blockquote><p>Which does <em>technically</em> cover that edge case, but so it goes.</p><p>Whee. &#x1f604;</p><h2 id=part-2>Part 2</h2><blockquote><p>For each list that is not currently valid, sort it by the given ordering and then sum the middle values.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day5, part2, v1)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_v1</span>((ordering, data): <span style=color:#66d9ef>&amp;</span>(Ordering, Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;&gt;</span>)) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    data.iter()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>ordering.validates(list))
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TODO: I don&#39;t want to have to clone this here, but AOC requires it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> list <span style=color:#f92672>=</span> list.clone();
</span></span><span style=display:flex><span>            list.sort_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ordering.can_precede(a, b) {
</span></span><span style=display:flex><span>                    std::cmp::Ordering::Less
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    std::cmp::Ordering::Greater
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            list
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>list<span style=color:#f92672>|</span> list[list.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing much to see here; we <code>filter</code> out the ones that are already sorted, <code>sort_by</code> the ones left, and <code>map</code> to the middle values.</p><p>As mentioned, I do have one <code>TODO:</code> because of how the <code>cargo-aoc</code> crate passes input, you cannot directly mutate the input (it&rsquo;s always a <code>&amp;T</code> for whatever <code>T</code> the <code>generator</code> function returns). This makes sense when it comes to benchmarking&ndash;you can&rsquo;t mutate the input if you&rsquo;re going to run the algorithm on that input 10k times. &#x1f604;</p><p>Anyways. Still quick!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cargo aoc --day 5 --part 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC 2024
</span></span><span style=display:flex><span>Day 5 - Part 2 - v1 : 6085
</span></span><span style=display:flex><span>	generator: 124.917µs,
</span></span><span style=display:flex><span>	runner: 207.5µs
</span></span></code></pre></div><p>Onward.</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day5 - Part1/v1         time:   <span style=color:#f92672>[</span>8.1412 µs 8.2175 µs 8.3300 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day5 - Part2/v1         time:   <span style=color:#f92672>[</span>59.691 µs 60.810 µs 62.017 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>It&rsquo;s interesting how much faster that is than one run. Some impressive caching going on there I expect.</p><h2 id=optimization-1-drop-the-hashmap>Optimization 1: Drop the <code>hashmap</code></h2><p>Okay, <code>hashbrown</code> is fast enough, but we don&rsquo;t <em>really</em> need that if we really want this solution to be fast. Instead, let&rsquo;s just throw some memory at it. We know (from looking at our input) that all values will be two digits, so let&rsquo;s just initialize a 100*100 array of booleans:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ordering</span> {
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>bool</span>; <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            data: [<span style=color:#66d9ef>false</span>; <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span>],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        self.data[(a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>100</span><span style=color:#f92672>+</span>(b <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>self.data[(a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>100</span><span style=color:#f92672>+</span>(b <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>validates</span>(<span style=color:#f92672>&amp;</span>self, list: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u32</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        list.iter().is_sorted_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> self.can_precede(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing else actually needs to change (although this can certainly <code>panic!</code> if any input is > 100).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day5 - Part1/v1         time:   <span style=color:#f92672>[</span>229.10 ns 230.04 ns 231.17 ns<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day5 - Part2/v1         time:   <span style=color:#f92672>[</span>14.302 µs 14.369 µs 14.437 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>That&rsquo;s &mldr; nanoseconds. Whee! And a 4x speedup on part 2.</p><p>Can we go further?</p><h2 id=optimization-2-bitvec>Optimization 2: <code>bitvec</code></h2><p>I&rsquo;m not 100% sure how optimized Rust&rsquo;s <code>[bool]</code> is under the hood, but what if we directly use a crate that&rsquo;s designed to work with a <code>vec</code> of <code>bits</code>? <a href=https://docs.rs/bitvec/latest/bitvec/ target=_blank rel=noopener><code>bitvec</code></a>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ordering</span> {
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>BitVec</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            data: <span style=color:#a6e22e>bitvec</span><span style=color:#f92672>!</span>[<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span>],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        self.data.set((a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>100</span><span style=color:#f92672>+</span>(b <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>self.data[(a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>100</span><span style=color:#f92672>+</span>(b <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>)]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>validates</span>(<span style=color:#f92672>&amp;</span>self, list: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u32</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        list.iter().is_sorted_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> self.can_precede(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically the same; only a few names have changed and <code>IndexMut</code> isn&rsquo;t defined.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day5 - Part1/v1         time:   <span style=color:#f92672>[</span>304.75 ns 306.14 ns 307.66 ns<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day5 - Part2/v1         time:   <span style=color:#f92672>[</span>20.223 µs 20.430 µs 20.766 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Huh, we&rsquo;ll that&rsquo;s certainly interesting. The runtimes are a <em>bit</em> slower. It seems that the Rust folks did a pretty good job optimization <code>[bool]</code> already!</p><p>One interesting thing to note though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># With [bool]</span>
</span></span><span style=display:flex><span>cargo aoc --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>5</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>4924</span>
</span></span><span style=display:flex><span>	generator: 101.291µs,
</span></span><span style=display:flex><span>	runner: 3.292µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>5</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>6085</span>
</span></span><span style=display:flex><span>	generator: 69.458µs,
</span></span><span style=display:flex><span>	runner: 22.583µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># With bitvec</span>
</span></span><span style=display:flex><span>cargo aoc --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>5</span> - Part <span style=color:#ae81ff>1</span> - v1 : <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	generator: 83.584µs,
</span></span><span style=display:flex><span>	runner: 1.583µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>5</span> - Part <span style=color:#ae81ff>2</span> - v1 : <span style=color:#ae81ff>11009</span>
</span></span><span style=display:flex><span>	generator: 62.041µs,
</span></span><span style=display:flex><span>	runner: 34.834µs
</span></span></code></pre></div><p>The <code>generator</code> part (that does the parsing and building of the initial <code>bitvec</code>) <em>is</em> ~20% faster.</p><p>It would be interesting to dig into why exactly that is!</p><h2 id=optimization-attempt-3-a-vec-of-pairs>Optimization (attempt) 3: A <code>vec</code> of pairs</h2><p>Okay, let&rsquo;s keep going. Next attempt, let&rsquo;s see if a <code>vec</code> of <code>(a, b)</code> does any better. In theory, we can store the whole vec in memory, but we do have to scan through <code>O(n)</code> (~1k) entries on each search.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ordering</span> {
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>u32</span>, <span style=color:#66d9ef>u32</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            data: Vec::with_capacity(<span style=color:#ae81ff>2000</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> point <span style=color:#f92672>=</span> (a, b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.data.binary_search(<span style=color:#f92672>&amp;</span>(a, b)).unwrap_or_else(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e);
</span></span><span style=display:flex><span>        self.data.insert(index, point);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.data.binary_search(<span style=color:#f92672>&amp;</span>(a, b)).is_ok()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>validates</span>(<span style=color:#f92672>&amp;</span>self, list: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u32</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        list.iter().is_sorted_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> self.can_precede(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day5 - Part1/v1         time:   <span style=color:#f92672>[</span>380.36 µs 381.16 µs 382.14 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day5 - Part2/v1         time:   <span style=color:#f92672>[</span>2.2590 ms 2.2695 ms 2.2801 ms<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Part 1 is slightly slower, but part 2&mldr; ouch! That&rsquo;s many times slower. It turns out that sorting has to do a bunch of comparisons, which actually makes that <code>O(n)</code> meaningful&mldr;</p><h3 id=optimization-attempt-4-sorted-vec-of-pairs>Optimization (attempt) 4: Sorted <code>vec</code> of pairs</h3><p>I don&rsquo;t think this will actually help, but one last try down this method: let&rsquo;s store the <code>(a, b)</code> list as sorted and use a <a href=https://en.wikipedia.org/wiki/binary%20search>binary search</a> to check each comparison. It should be <code>O(log n)</code> instead (roughly 3 comparisons, since N ≅ 1k)!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ordering</span> {
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>u32</span>, <span style=color:#66d9ef>u32</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ordering {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            data: Vec::with_capacity(<span style=color:#ae81ff>2000</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> point <span style=color:#f92672>=</span> (a, b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.data.binary_search(<span style=color:#f92672>&amp;</span>(a, b)).unwrap_or_else(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e);
</span></span><span style=display:flex><span>        self.data.insert(index, point);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_precede</span>(<span style=color:#f92672>&amp;</span>self, a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.data.binary_search(<span style=color:#f92672>&amp;</span>(a, b)).is_ok()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>validates</span>(<span style=color:#f92672>&amp;</span>self, list: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u32</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        list.iter().is_sorted_by(<span style=color:#f92672>|&amp;</span>a, <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>|</span> self.can_precede(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That <code>binary_search</code> is an interesting API. It returns <code>Ok</code> if the value was found and <code>Err</code> if not; thus the <code>unwrap_or_else</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day5 - Part1/v1         time:   <span style=color:#f92672>[</span>42.928 µs 43.629 µs 44.586 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day5 - Part2/v1         time:   <span style=color:#f92672>[</span>245.26 µs 248.05 µs 251.44 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Well, that&rsquo;s ~10x as fast as the unsorted <code>vec</code>! But still ~10x <em>slower</em> than the <code>bitvec</code>. So I guess no luck either way!</p><h2 id=overall-timing-graph>Overall timing graph</h2><p>Since I&rsquo;ve done a chunk of optimizations for this one, here are the benchmarks in a nice table.</p><table><thead><tr><th>Version</th><th>Part 1</th><th>Part 2</th></tr></thead><tbody><tr><td><code>hashbrown</code></td><td>8.2175 µs</td><td>60.810 µs</td></tr><tr><td><code>[bool]</code></td><td><strong>230.04 ns</strong></td><td><strong>14.369 µs</strong></td></tr><tr><td><code>bitvec</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></td><td>306.14 ns</td><td>20.420 µs</td></tr><tr><td><code>Vec&lt;(a, b)></code></td><td>381.16 µs</td><td>2.2695 ms</td></tr><tr><td><code>binary_search</code></td><td>42.629 µs</td><td>248.05 µs</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>But it does load faster; so it&rsquo;s better if you include parsing time.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>