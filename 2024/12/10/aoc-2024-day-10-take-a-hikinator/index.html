<!doctype html><html><head><title>AoC 2024 Day 10: Take-a-Hikinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.34a34d86b8aae11b989d80a1626629c053029d012419a1993cfb6c12ea175737.css integrity="sha256-NKNNhriq4RuYnYChYmYpwFMCnQEkGaGZPPtsEuoXVzc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 10: Take-a-Hikinator</h1><div class=entry-meta><span class=entry-date>2024-12-10</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/benchmarking>Benchmarking</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/bitmasking>Bitmasking</a></li><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/depth-first-search>Depth First Search</a></li><li><a class=taxonomy-value href=/programming/topics/dynamic-programming>Dynamic Programming</a></li><li><a class=taxonomy-value href=/programming/topics/graph-algorithms>Graph Algorithms</a></li><li><a href=https://blog.jverkamp.com/2024/03/14/infinite-craft-bot/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graph-theory>Graph Theory</a><a href=https://blog.jverkamp.com/2024/12/23/aoc-2024-day-23-lan-partinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphs>Graphs</a></li><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/pathfinding>Pathfinding</a><a href=https://blog.jverkamp.com/2024/12/16/aoc-2024-day-16-astarinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/search>Search</a></li><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/visualization>Visualization</a><a href=https://blog.jverkamp.com/2024/12/22/aoc-2024-day-22-xorshiftinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a><a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/12/11/aoc-2024-day-11-exponential-growthinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-10-hoof-it>Source: <a href=https://adventofcode.com/2024/day/10 target=_blank rel=noopener>Day 10: Hoof It</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day10.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-10-hoof-it>Source: <a href=https://adventofcode.com/2024/day/10>Day 10: Hoof It</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#optimization-1-using-dynamic-programming>Optimization 1: Using dynamic programming</a></li><li><a href=#optimization-2-smarter-bitmasks>Optimization 2: Smarter bitmasks</a></li></ul></li><li><a href=#part-2>Part 2</a></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a heightmap (<code>0</code> to <code>9</code>), for each <code>0</code> count how many <code>9</code> you can reach on paths that only ever increase height by exactly 1 at a time. Sum these values.</p></blockquote><p>We&rsquo;re just reading a <code>Grid</code> of heights, so that part is easy enough:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day10)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Grid::read(input, <span style=color:#f92672>&amp;|</span>c<span style=color:#f92672>|</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First thought to solve this:</p><ul><li>For each <code>0</code>:<ul><li>Perform a <a href=https://en.wikipedia.org/wiki/depth%20first%20search>depth first search</a> to all <code>9s</code></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, search)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_search</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For each 0, search for how man 9s are reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> checked <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[p];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nines_reached <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(p) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> input.get(p) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>9</span>) {
</span></span><span style=display:flex><span>                    nines_reached <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// no points higher than 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                p.neighbors()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        input.in_bounds(<span style=color:#f92672>*</span>p2)
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> input.get(p).unwrap() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>input.get(<span style=color:#f92672>*</span>p2).unwrap()
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .for_each(<span style=color:#f92672>|</span>p2<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>checked.get(<span style=color:#f92672>*</span>p2).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                            checked.set(<span style=color:#f92672>*</span>p2, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                            queue.push(<span style=color:#f92672>*</span>p2);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            nines_reached
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s fairly elegant code if I do say so myself. On the outer level, we&rsquo;ll <code>filter</code> for only the <code>0</code>s, then the <code>map</code> contains the search.</p><p>This is plenty for this test and relatively fast:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 20.5µs,
</span></span><span style=display:flex><span>	runner: 340.208µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 6.75µs,
</span></span><span style=display:flex><span>	runner: 73.042µs
</span></span></code></pre></div><p>If you want to watch it go, I did make a nice little rendering of it:</p><p><video controls src=/embeds/2024/aoc/day10-part1-search.mp4></video></p><p>The dark red points are the paths as we scan outwards from each point with the <code>9s</code> highlighted in brighter red.</p><h3 id=optimization-1-using-dynamic-programming>Optimization 1: Using dynamic programming</h3><p>Okay, I think that we can do a bit better than this. The realization comes partly from <a href=#part-2>part 2</a>, but also from looking at that pretty picture and realizing: there may be paths from multiple <code>0</code> that join together at any point up their hike before getting to a <code>9</code>; possibly splitting off. We&rsquo;re duplicating all that effort!</p><p>So instead, let&rsquo;s try a solution that uses <a href=https://en.wikipedia.org/wiki/dynamic%20programming>dynamic programming</a>:</p><ul><li>Initialize each <code>9</code> with a <code>Set</code> containing itself</li><li>For <code>8</code> down to <code>0</code>:<ul><li>For each point of this height, find all neighbors one higher than ourselves; store the union of each of those sets</li></ul></li></ul><p>Because of the <code>Set</code>, this means that if you can reach the same <code>9</code> two different ways, it will only be counted once. When you get down to <code>0</code>, each one will have a <code>Set</code> of the <code>9</code> reachable by it, so some the counts of those.</p><p>But&mldr; I don&rsquo;t <em>really</em> need to use a <code>Set</code> (since we&rsquo;ve already seen that hashing can be surprisingly expensive). Instead, let&rsquo;s make a <code>bitmap</code> where each <code>9</code> has a unique bit set. The problem with this&mldr; is that we have more than 128 <code>9s</code> in the puzzle (I expect this is intentional).</p><p>Originally, I used the <code>bitvec</code> crate to solve this, but on looking, it appears that we have ~230 <code>9s</code> in our puzzle, so let&rsquo;s store the state as <code>(u128, u128)</code> (and explicitly fall back to the search above if our puzzle input so happens to have more than 256 entries):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, dynamic_tupled)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_dynamic_tupled</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> trail_counts: <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>u128</span>, <span style=color:#66d9ef>u128</span>)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flag each 9 with a unique bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            trail_counts.set(
</span></span><span style=display:flex><span>                p,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>128</span> {
</span></span><span style=display:flex><span>                    (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> index, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (index <span style=color:#f92672>-</span> <span style=color:#ae81ff>128</span>))
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Failsafe just in case we have more than 256 nines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>256</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> part1_search(input) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each height, we&#39;re going to OR the bits of reachable 9s together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> height <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>8</span>).rev() {
</span></span><span style=display:flex><span>        input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> height {
</span></span><span style=display:flex><span>                trail_counts.set(
</span></span><span style=display:flex><span>                    p,
</span></span><span style=display:flex><span>                    p.neighbors()
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> input.get(<span style=color:#f92672>*</span>p2).is_some_and(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>trail_counts.get(p2).unwrap())
</span></span><span style=display:flex><span>                        .reduce(<span style=color:#f92672>|</span>(a1, a2), (b1, b2)<span style=color:#f92672>|</span> (a1 <span style=color:#f92672>|</span> b1, a2 <span style=color:#f92672>|</span> b2))
</span></span><span style=display:flex><span>                        .unwrap_or((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sum the ratings of the 9s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#f92672>&amp;</span>(a, b) <span style=color:#f92672>=</span> trail_counts.get(p).unwrap();
</span></span><span style=display:flex><span>            a.count_ones() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>+</span> b.count_ones() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because we have the tuple, we do end up with this wacky line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>.reduce(<span style=color:#f92672>|</span>(a1, a2), (b1, b2)<span style=color:#f92672>|</span> (a1 <span style=color:#f92672>|</span> b1, a2 <span style=color:#f92672>|</span> b2))
</span></span></code></pre></div><p>But I think it still works out well enough.</p><p>And it is faster!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - search : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.958µs,
</span></span><span style=display:flex><span>	runner: 111.917µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 20.5µs,
</span></span><span style=display:flex><span>	runner: 340.208µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 6.75µs,
</span></span><span style=display:flex><span>	runner: 73.042µs
</span></span></code></pre></div><p>Almost 2x speedup. The <code>dynamic</code> version in the middle there is the <code>bitvec</code> solution.</p><p>If you&rsquo;d like to see roughly how this solution works:</p><p><video controls src=/embeds/2024/aoc/day10-part1-dynamic.mp4></video></p><p>The red for each pixel is how many <code>9s</code> you can reach, getting brighter as you collect more of them.</p><p>Just to show a bit more dramatically how much faster the dynamic algorithm can be, here are both videos side by side:</p><p><video controls src=/embeds/2024/aoc/day10-part1.mp4 width=100%></video></p><p>It&rsquo;s not a perfect comparison, since the amount of actual work done per frame isn&rsquo;t <em>exactly</em> the same, but it&rsquo;s pretty close.</p><h3 id=optimization-2-smarter-bitmasks>Optimization 2: Smarter bitmasks</h3><p>I realized after writing most of this up but before publishing it: We don&rsquo;t actually <em>need</em> globally unique bitmasks! Because each <code>9</code> can only be reached by a <code>0</code> at most <code>8</code> tiles away from it, we can store them all in a <code>u128</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, dynamic_smart)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_dynamic_smart</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> trail_counts: <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flag each 9 with a unique bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// The bits only have to be unique within 10 tiles of each other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// So within a 10x10 area, assign to that bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>u128</span> <span style=color:#f92672>&lt;&lt;</span> ((p.x <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>+</span> (p.y <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>            trail_counts.set(p, mask);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Originally, I was only using an <code>8x8</code> area (thus a <code>u64</code>), but that doesn&rsquo;t <em>quite</em> work, since it&rsquo;s possible for two <code>9s</code> that are right on the edges of that to get the same ID and thus get missed. Out of 659, this missed 2.</p><p>But&mldr; does it actually perform any better?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.166µs,
</span></span><span style=display:flex><span>	runner: 80.084µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_smart : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.666µs,
</span></span><span style=display:flex><span>	runner: 77.709µs
</span></span></code></pre></div><p>Barely.</p><p>I think it&rsquo;s worth it when comparing complexity though. The mask generation is a bit more complicated, but the algorithm itself is cleaner. (the reduce is just <code>.reduce(|a, b| a | b)</code>).</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of counting reachable <code>9s</code>, count how many <em>unique</em> paths there are to any <code>9</code>.</p></blockquote><p>This actually ends up being a lot easier to do with dynamic programming:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part2, dynamic)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_dynamic</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ratings <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All 9s can be reached one way
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            ratings.set(p, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each height, we&#39;re going to sum the ratings of all points one higher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> height <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>8</span>).rev() {
</span></span><span style=display:flex><span>        input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> height {
</span></span><span style=display:flex><span>                ratings.set(
</span></span><span style=display:flex><span>                    p,
</span></span><span style=display:flex><span>                    p.neighbors()
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> input.get(<span style=color:#f92672>*</span>p2).is_some_and(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|</span>p2<span style=color:#f92672>|</span> ratings.get(<span style=color:#f92672>*</span>p2).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                        .sum(),
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sum the ratings of the 0s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> ratings.get(p).unwrap())
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, we&rsquo;re going to start at the <code>9s</code> and initialize that we can get to each one <code>1</code> way. Then as we go from <code>8</code> to <code>1</code> the same way, we just have to add the neighboring values together. This represents &lsquo;how many ways can we get to any different 9 via each neighbor&rsquo;.</p><p>The video for this one ends up mostly the same as what I did for <a href=#optimization-1-using-dynamic-programming>part 1</a>:</p><p><video controls src=/embeds/2024/aoc/day10-part2.mp4></video></p><p>Colorscale changed entirely to be confusing &#x1f604;. Red is lower, blue is higher.</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day10 - Part1/search            time:   <span style=color:#f92672>[</span>65.198 µs 66.052 µs 67.339 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic           time:   <span style=color:#f92672>[</span>278.43 µs 280.80 µs 283.53 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic_tupled    time:   <span style=color:#f92672>[</span>42.502 µs 43.356 µs 44.197 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic_smart     time:   <span style=color:#f92672>[</span>41.415 µs 42.406 µs 43.625 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day10 - Part2/dynamic           time:   <span style=color:#f92672>[</span>34.976 µs 36.044 µs 37.158 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Part 2 faster than part 1. Funny. Although it makes sense, we don&rsquo;t have to deal with the mask generation and <code>+</code> should be as fast as <code>|</code> (might even be faster, since you potentially don&rsquo;t have to deal with all of the bits?).</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>