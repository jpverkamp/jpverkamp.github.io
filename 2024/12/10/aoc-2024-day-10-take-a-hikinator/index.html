<!doctype html><html><head><title>AoC 2024 Day 10: Take-a-Hikinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2024 Day 10: Take-a-Hikinator</h1><div class=entry-meta><span class=entry-date>2024-12-10</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2024>Advent of Code 2024</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link>Prev</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/12/09/aoc-2024-day-9-defraginator/ class=previous-link>Prev</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-10-hoof-ithttpsadventofcodecom2024day10>Source: <a href=https://adventofcode.com/2024/day/10 target=_blank rel=noopener>Day 10: Hoof It</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day10.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-10-hoof-ithttpsadventofcodecom2024day10>Source: <a href=https://adventofcode.com/2024/day/10>Day 10: Hoof It</a></a></li><li><a href=#part-1>Part 1</a><ul><li><a href=#optimization-1-using-dynamic-programming>Optimization 1: Using dynamic programming</a></li><li><a href=#optimization-2-smarter-bitmasks>Optimization 2: Smarter bitmasks</a></li></ul></li><li><a href=#part-2>Part 2</a></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Given a heightmap (<code>0</code> to <code>9</code>), for each <code>0</code> count how many <code>9</code> you can reach on paths that only ever increase height by exactly 1 at a time. Sum these values.</p></blockquote><p>We&rsquo;re just reading a <code>Grid</code> of heights, so that part is easy enough:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc_generator(day10)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Grid::read(input, <span style=color:#f92672>&amp;|</span>c<span style=color:#f92672>|</span> c.to_digit(<span style=color:#ae81ff>10</span>).unwrap() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First thought to solve this:</p><ul><li>For each <code>0</code>:<ul><li>Perform a <a href=https://en.wikipedia.org/wiki/depth%20first%20search>depth first search</a> to all <code>9s</code></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, search)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_search</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For each 0, search for how man 9s are reachable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> checked <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> vec![p];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> nines_reached <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(p) <span style=color:#f92672>=</span> queue.pop() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> input.get(p) <span style=color:#f92672>==</span> Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>9</span>) {
</span></span><span style=display:flex><span>                    nines_reached <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// no points higher than 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                p.neighbors()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        input.in_bounds(<span style=color:#f92672>*</span>p2)
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> input.get(p).unwrap() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>input.get(<span style=color:#f92672>*</span>p2).unwrap()
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .for_each(<span style=color:#f92672>|</span>p2<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>checked.get(<span style=color:#f92672>*</span>p2).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>                            checked.set(<span style=color:#f92672>*</span>p2, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                            queue.push(<span style=color:#f92672>*</span>p2);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            nines_reached
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s fairly elegant code if I do say so myself. On the outer level, we&rsquo;ll <code>filter</code> for only the <code>0</code>s, then the <code>map</code> contains the search.</p><p>This is plenty for this test and relatively fast:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 20.5Âµs,
</span></span><span style=display:flex><span>	runner: 340.208Âµs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 6.75Âµs,
</span></span><span style=display:flex><span>	runner: 73.042Âµs
</span></span></code></pre></div><p>If you want to watch it go, I did make a nice little rendering of it:</p><p><video controls src=/embeds/2024/aoc/day10-part1-search.mp4></video></p><p>The dark red points are the paths as we scan outwards from each point with the <code>9s</code> highlighted in brighter red.</p><h3 id=optimization-1-using-dynamic-programming>Optimization 1: Using dynamic programming</h3><p>Okay, I think that we can do a bit better than this. The realization comes partly from <a href=#part-2>part 2</a>, but also from looking at that pretty picture and realizing: there may be paths from multiple <code>0</code> that join together at any point up their hike before getting to a <code>9</code>; possibly splitting off. We&rsquo;re duplicating all that effort!</p><p>So instead, let&rsquo;s try a solution that uses <a href=https://en.wikipedia.org/wiki/dynamic%20programming>dynamic programming</a>:</p><ul><li>Initialize each <code>9</code> with a <code>Set</code> containing itself</li><li>For <code>8</code> down to <code>0</code>:<ul><li>For each point of this height, find all neighbors one higher than ourselves; store the union of each of those sets</li></ul></li></ul><p>Because of the <code>Set</code>, this means that if you can reach the same <code>9</code> two different ways, it will only be counted once. When you get down to <code>0</code>, each one will have a <code>Set</code> of the <code>9</code> reachable by it, so some the counts of those.</p><p>But&mldr; I don&rsquo;t <em>really</em> need to use a <code>Set</code> (since we&rsquo;ve already seen that hashing can be surprisingly expensive). Instead, let&rsquo;s make a <code>bitmap</code> where each <code>9</code> has a unique bit set. The problem with this&mldr; is that we have more than 128 <code>9s</code> in the puzzle (I expect this is intentional).</p><p>Originally, I used the <code>bitvec</code> crate to solve this, but on looking, it appears that we have ~230 <code>9s</code> in our puzzle, so let&rsquo;s store the state as <code>(u128, u128)</code> (and explicitly fall back to the search above if our puzzle input so happens to have more than 256 entries):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, dynamic_tupled)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_dynamic_tupled</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> trail_counts: <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>u128</span>, <span style=color:#66d9ef>u128</span>)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flag each 9 with a unique bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            trail_counts.set(
</span></span><span style=display:flex><span>                p,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>128</span> {
</span></span><span style=display:flex><span>                    (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> index, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (index <span style=color:#f92672>-</span> <span style=color:#ae81ff>128</span>))
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Failsafe just in case we have more than 256 nines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>256</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> part1_search(input) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each height, we&#39;re going to OR the bits of reachable 9s together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> height <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>8</span>).rev() {
</span></span><span style=display:flex><span>        input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> height {
</span></span><span style=display:flex><span>                trail_counts.set(
</span></span><span style=display:flex><span>                    p,
</span></span><span style=display:flex><span>                    p.neighbors()
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> input.get(<span style=color:#f92672>*</span>p2).is_some_and(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>trail_counts.get(p2).unwrap())
</span></span><span style=display:flex><span>                        .reduce(<span style=color:#f92672>|</span>(a1, a2), (b1, b2)<span style=color:#f92672>|</span> (a1 <span style=color:#f92672>|</span> b1, a2 <span style=color:#f92672>|</span> b2))
</span></span><span style=display:flex><span>                        .unwrap_or((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)),
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sum the ratings of the 9s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#f92672>&amp;</span>(a, b) <span style=color:#f92672>=</span> trail_counts.get(p).unwrap();
</span></span><span style=display:flex><span>            a.count_ones() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>+</span> b.count_ones() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because we have the tuple, we do end up with this wacky line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>.reduce(<span style=color:#f92672>|</span>(a1, a2), (b1, b2)<span style=color:#f92672>|</span> (a1 <span style=color:#f92672>|</span> b1, a2 <span style=color:#f92672>|</span> b2))
</span></span></code></pre></div><p>But I think it still works out well enough.</p><p>And it is faster!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - search : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.958Âµs,
</span></span><span style=display:flex><span>	runner: 111.917Âµs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 20.5Âµs,
</span></span><span style=display:flex><span>	runner: 340.208Âµs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 6.75Âµs,
</span></span><span style=display:flex><span>	runner: 73.042Âµs
</span></span></code></pre></div><p>Almost 2x speedup. The <code>dynamic</code> version in the middle there is the <code>bitvec</code> solution.</p><p>If you&rsquo;d like to see roughly how this solution works:</p><p><video controls src=/embeds/2024/aoc/day10-part1-dynamic.mp4></video></p><p>The red for each pixel is how many <code>9s</code> you can reach, getting brighter as you collect more of them.</p><p>Just to show a bit more dramatically how much faster the dynamic algorithm can be, here are both videos side by side:</p><p><video controls src=/embeds/2024/aoc/day10-part1.mp4 width=100%></video></p><p>It&rsquo;s not a perfect comparison, since the amount of actual work done per frame isn&rsquo;t <em>exactly</em> the same, but it&rsquo;s pretty close.</p><h3 id=optimization-2-smarter-bitmasks>Optimization 2: Smarter bitmasks</h3><p>I realized after writing most of this up but before publishing it: We don&rsquo;t actually <em>need</em> globally unique bitmasks! Because each <code>9</code> can only be reached by a <code>0</code> at most <code>8</code> tiles away from it, we can store them all in a <code>u128</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part1, dynamic_smart)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_dynamic_smart</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> trail_counts: <span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u128</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flag each 9 with a unique bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// The bits only have to be unique within 10 tiles of each other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// So within a 10x10 area, assign to that bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>u128</span> <span style=color:#f92672>&lt;&lt;</span> ((p.x <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>+</span> (p.y <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>            trail_counts.set(p, mask);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Originally, I was only using an <code>8x8</code> area (thus a <code>u64</code>), but that doesn&rsquo;t <em>quite</em> work, since it&rsquo;s possible for two <code>9s</code> that are right on the edges of that to get the same ID and thus get missed. Out of 659, this missed 2.</p><p>But&mldr; does it actually perform any better?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc --day <span style=color:#ae81ff>10</span> --part <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AOC <span style=color:#ae81ff>2024</span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_tupled : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.166Âµs,
</span></span><span style=display:flex><span>	runner: 80.084Âµs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day <span style=color:#ae81ff>10</span> - Part <span style=color:#ae81ff>1</span> - dynamic_smart : <span style=color:#ae81ff>659</span>
</span></span><span style=display:flex><span>	generator: 7.666Âµs,
</span></span><span style=display:flex><span>	runner: 77.709Âµs
</span></span></code></pre></div><p>Barely.</p><p>I think it&rsquo;s worth it when comparing complexity though. The mask generation is a bit more complicated, but the algorithm itself is cleaner. (the reduce is just <code>.reduce(|a, b| a | b)</code>).</p><h2 id=part-2>Part 2</h2><blockquote><p>Instead of counting reachable <code>9s</code>, count how many <em>unique</em> paths there are to any <code>9</code>.</p></blockquote><p>This actually ends up being a lot easier to do with dynamic programming:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc(day10, part2, dynamic)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2_dynamic</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ratings <span style=color:#f92672>=</span> Grid::new(input.width, input.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All 9s can be reached one way
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>            ratings.set(p, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each height, we&#39;re going to sum the ratings of all points one higher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> height <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>8</span>).rev() {
</span></span><span style=display:flex><span>        input.iter_enumerate().for_each(<span style=color:#f92672>|</span>(p, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> height {
</span></span><span style=display:flex><span>                ratings.set(
</span></span><span style=display:flex><span>                    p,
</span></span><span style=display:flex><span>                    p.neighbors()
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|&amp;</span>p2<span style=color:#f92672>|</span> input.get(<span style=color:#f92672>*</span>p2).is_some_and(<span style=color:#f92672>|&amp;</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|</span>p2<span style=color:#f92672>|</span> ratings.get(<span style=color:#f92672>*</span>p2).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                        .sum(),
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sum the ratings of the 0s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    input
</span></span><span style=display:flex><span>        .iter_enumerate()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(_, <span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>|</span> v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> ratings.get(p).unwrap())
</span></span><span style=display:flex><span>        .sum()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, we&rsquo;re going to start at the <code>9s</code> and initialize that we can get to each one <code>1</code> way. Then as we go from <code>8</code> to <code>1</code> the same way, we just have to add the neighboring values together. This represents &lsquo;how many ways can we get to any different 9 via each neighbor&rsquo;.</p><p>The video for this one ends up mostly the same as what I did for <a href=#optimization-1-using-dynamic-programming>part 1</a>:</p><p><video controls src=/embeds/2024/aoc/day10-part2.mp4></video></p><p>Colorscale changed entirely to be confusing ðŸ˜„. Red is lower, blue is higher.</p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo aoc bench --day <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day10 - Part1/search            time:   <span style=color:#f92672>[</span>65.198 Âµs 66.052 Âµs 67.339 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic           time:   <span style=color:#f92672>[</span>278.43 Âµs 280.80 Âµs 283.53 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic_tupled    time:   <span style=color:#f92672>[</span>42.502 Âµs 43.356 Âµs 44.197 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Day10 - Part1/dynamic_smart     time:   <span style=color:#f92672>[</span>41.415 Âµs 42.406 Âµs 43.625 Âµs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Day10 - Part2/dynamic           time:   <span style=color:#f92672>[</span>34.976 Âµs 36.044 Âµs 37.158 Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Part 2 faster than part 1. Funny. Although it makes sense, we don&rsquo;t have to deal with the mask generation and <code>+</code> should be as fast as <code>|</code> (might even be faster, since you potentially don&rsquo;t have to deal with all of the bits?).</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>