<!doctype html><html><head><title>Solving Sokobond â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Solving Sokobond</h1><div class=entry-meta><span class=entry-date>2024-04-06</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/chemistry>Chemistry</a></li><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/sokoban>Sokoban</a><a href=https://blog.jverkamp.com/2024/12/15/aoc-2024-day-15-sokobaninator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a><a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2024/04/04/ms.-marvel-vol.-10-time-and-again/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2024/04/06/jade-legacy/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another solver that I&rsquo;ve been working on, after <a href=https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/>A Good Snowman Is Hard To &mldr; Solve?</a>. This time, we have <a href=https://store.steampowered.com/app/290260/Sokobond/ target=_blank rel=noopener>Sokobond</a>! It&rsquo;s a <a href=https://en.wikipedia.org/wiki/Sokobon>Sokobon</a>&mldr; but with chemical bonds! Yeah, that&rsquo;s a really good title.</p><p>The basic idea is you have a field of elements with (chemical accurate) free electrons):</p><p><img src=basic-image.png alt="A basic level"></p><p>Here we have 4 hydrogens (1 bond each) and a carbon (4 bonds). It should seem pretty obvious that the carbon should end up with a hydrogen on each end. The one last bit of interest: the element with the dashed border is the one we actually control, that will never change.</p><p>This eventually gets more complicated, adding:</p><ul><li>Modifiers that are placed on the map between squares:<ul><li>One that strengthens bonds, turning a single bond into double into triple</li><li>One that weakens bonds, turning triple to double to single or breaking single bonds</li><li>One that rotates bonds as you move by it</li></ul></li><li>More elements, eventually hydrogen (1), oxygen (2), nitrogen (3), carbon (4), and helium (0)</li><li>Solutions that require forming multiple elements at the same time</li></ul><p>It&rsquo;s a pretty neat puzzle game with 144 levels of increasing difficulty. Perfect to solve.</p><hr><nav id=TableOfContents><ul><li><a href=#initial-state>Initial state</a><ul><li><a href=#helper-structs>Helper structs</a></li><li><a href=#global-state>Global state</a></li><li><a href=#local-state>Local state</a></li></ul></li><li><a href=#the-rest-of-the-owl-gorithm>The rest of the owl-gorithm</a><ul><li><a href=#is_valid><code>is_valid</code></a></li><li><a href=#is_solved><code>is_solved</code></a></li><li><a href=#heuristic><code>heuristic</code></a></li><li><a href=#next_states><code>next_states</code></a></li></ul></li><li><a href=#running-test-cases>Running test cases</a><ul><li><a href=#test-macro><code>test!</code> macro</a></li><li><a href=#a-single-parallel-test-case>A single (parallel) test case</a></li></ul></li></ul></nav><h2 id=initial-state>Initial state</h2><p>Okay, let&rsquo;s define an additional state. I&rsquo;m planning to use global + local state this time, with the global state (as it should be) being the parts that can&rsquo;t change&ndash;walls, empty space, and modifiers&ndash;and the local state containing a list of molecules. Each of the molecules in turn will have a list of elements and a list of bonds.</p><h3 id=helper-structs>Helper structs</h3><p>First, we have a few helper structs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// A point in 2D space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Add<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>+</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>+</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Sub<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sub</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.x <span style=color:#f92672>-</span> rhs.x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.y <span style=color:#f92672>-</span> rhs.y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Into<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>isize</span>, <span style=color:#66d9ef>isize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into</span>(self) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>        Point {
</span></span><span style=display:flex><span>            x: <span style=color:#a6e22e>self</span>.<span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>self</span>.<span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ZERO</span>: <span style=color:#a6e22e>Point</span> <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>manhattan_distance</span>(<span style=color:#f92672>&amp;</span>self, other: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>        (self.x <span style=color:#f92672>-</span> other.x).abs() <span style=color:#f92672>+</span> (self.y <span style=color:#f92672>-</span> other.y).abs()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is one I&rsquo;ve implemented any number of times. Specifically this time, we&rsquo;ll allows signed numbers, since we&rsquo;re going to represent elements in a molecule using relative coordinates. So you very well might have an element &rsquo;left&rsquo; of the center of the molecule, needing a <code>x</code> that&rsquo;s negative.</p><h3 id=global-state>Global state</h3><p>Next up, we&rsquo;re going to represent the <code>Map</code>, which will be our global state. This is the final form, you can look at the rather lengthy <a href=https://github.com/jpverkamp/rust-solvers/commits/main/ target=_blank rel=noopener>git history</a> to see how it&rsquo;s evolved over time.</p><h4 id=map><code>Map</code></h4><p>First, the <code>Map</code> itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Global state: a set of walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    walls: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    modifiers: Vec<span style=color:#f92672>&lt;</span>Modifier<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    allow_multiple: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    solutions: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will be the map. We have a grid of <code>width</code> x <code>height</code> and a <code>Vec</code> of the same length that will store if a point is a <code>wall</code> or not. After that, we have <code>Vec</code> of <code>Modifiers</code> (we&rsquo;ll <a href=#modifier>come back to this</a>), a flag for tests that <code>allow_multiple</code> molecules in the final answer, and a list of embedded <code>solutions</code> (for <a href=#running-test-cases>test cases</a>).</p><p>The <code>Map</code> itself only really has a single interesting function: <code>load</code>. This will take a <code>&amp;str</code> and create a <code>Map</code> plus the associated local <a href=#state><code>State</code></a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; (Map, LocalState) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> walls <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> modifiers <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> molecules <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> solutions <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Version 1 files are just the grid of elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Version 2 files start with v2 on the first line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// After that, grid elements are spaced out with extra items in between, like:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// H - -
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//    /
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// H - -
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> input.lines().peekable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> multiple <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// In v2, build a new input array as alternating lines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> grid <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> lines.peek().is_some_and(<span style=color:#f92672>|</span>l<span style=color:#f92672>|</span> l.starts_with(<span style=color:#e6db74>&#34;v2&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Look for additional options
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> options <span style=color:#f92672>=</span> lines.next().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> options.contains(<span style=color:#e6db74>&#34;multiple&#34;</span>) {
</span></span><span style=display:flex><span>                multiple <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_input <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(line) <span style=color:#f92672>=</span> lines.next() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;=&#34;</span>) {
</span></span><span style=display:flex><span>                    new_input.push_str(line);
</span></span><span style=display:flex><span>                    new_input.push(<span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                y <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> y <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                            new_input.push(c);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39; &#39;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;unexpected character in v2 grid spacing: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, c);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    new_input.push(<span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39; &#39;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> x <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                        modifiers.push(Modifier {
</span></span><span style=display:flex><span>                            location: <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>                                x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                                y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                            kind: <span style=color:#a6e22e>ModifierKind</span>::from(c),
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            new_input
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            String::from(input)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Now grid contains just the elements, walls, and empty space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (y, line) <span style=color:#66d9ef>in</span> grid.lines().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Lines starting with = represent solutions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// They should only be at the end of the file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#39;=&#39;</span>) {
</span></span><span style=display:flex><span>                solutions.push(line[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>].to_string());
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            width <span style=color:#f92672>=</span> width.max(line.len());
</span></span><span style=display:flex><span>            height <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (x, c) <span style=color:#66d9ef>in</span> line.chars().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> pt <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> ElementKind::try_from(c) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// A new element, convert it to a molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Primaries are uppercase and put at the start of the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// The rest are added to the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Technically only one primary is supported, this will take the last if multiple
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    Ok(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> molecule <span style=color:#f92672>=</span> Molecule::new(pt, e);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> c.is_uppercase() {
</span></span><span style=display:flex><span>                            molecules.insert(<span style=color:#ae81ff>0</span>, molecule);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            molecules.push(molecule);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        walls.push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Err(_) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>=&gt;</span> walls.push(<span style=color:#66d9ef>false</span>),
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;x&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;X&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>=&gt;</span> walls.push(<span style=color:#66d9ef>true</span>),
</span></span><span style=display:flex><span>                        _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;unknown character: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, c),
</span></span><span style=display:flex><span>                    },
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to bond each original pair of molecules
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>&#39;bonding</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>molecules.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>molecules.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> j {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> primary <span style=color:#f92672>=</span> molecules[i].clone();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> primary.try_bond(Point::<span style=color:#66d9ef>ZERO</span>, <span style=color:#f92672>&amp;</span>molecules[j]) {
</span></span><span style=display:flex><span>                        molecules[i] <span style=color:#f92672>=</span> primary;
</span></span><span style=display:flex><span>                        molecules[j].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;bonding;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> &#39;bonding;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Remove molecules marked inactive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        molecules.retain(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.active);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Modifiers have to be applied in a specific order: weaken, strengthen, rotate(?)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        modifiers.sort_by_key(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.kind);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            Map {
</span></span><span style=display:flex><span>                width,
</span></span><span style=display:flex><span>                height,
</span></span><span style=display:flex><span>                walls,
</span></span><span style=display:flex><span>                modifiers,
</span></span><span style=display:flex><span>                allow_multiple: <span style=color:#a6e22e>multiple</span>,
</span></span><span style=display:flex><span>                solutions,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            LocalState { molecules },
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_wall</span>(<span style=color:#f92672>&amp;</span>self, x: <span style=color:#66d9ef>usize</span>, y: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;=</span> self.width <span style=color:#f92672>||</span> y <span style=color:#f92672>&gt;=</span> self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.walls[y <span style=color:#f92672>*</span> self.width <span style=color:#f92672>+</span> x]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I think the most interesting part of this is the versioning and solution loading that I eventually built into it. Each basic input file will look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>xxxxxxxxx
</span></span><span style=display:flex><span>xxxx----x
</span></span><span style=display:flex><span>xxxx----x
</span></span><span style=display:flex><span>x----xh-X
</span></span><span style=display:flex><span>x---ox--x
</span></span><span style=display:flex><span>x-H-----x
</span></span><span style=display:flex><span>x----xxxx
</span></span><span style=display:flex><span>xxxxxxxxx
</span></span></code></pre></div><p>We have <code>x</code> for walls, <code>-</code> for open space, <code>h</code>, <code>o</code>, <code>n</code>, <code>c</code>, and <code>e</code> for <a href=#element><code>Elements</code></a>&ndash;there should be a single capital element that will represent the one we have to move.</p><p>We don&rsquo;t actually have to specify the bonds between elements since they&rsquo;ll always bind immediately on load. There aren&rsquo;t any levels where which bonds exist are ambiguous, like this would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>hh
</span></span><span style=display:flex><span>hh
</span></span></code></pre></div><p>But eventually, we started needing <a href=#modifier><code>Modifiers</code></a>, which are between spots on the level. Initially, I wanted to put them at the top left position, but sometimes there&rsquo;s a wall or element there, so that wouldn&rsquo;t work. So instead, I updated the save format. If the first line is <code>v2</code>, load something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v2
</span></span><span style=display:flex><span>- - x x x x x x - -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- - x - - - - x - -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- - x - - - - x - -
</span></span><span style=display:flex><span>         /
</span></span><span style=display:flex><span>x x x - - - - x x x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x H h - - - - - o x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x x x x x x x x x x
</span></span></code></pre></div><p>In this case, we have a <code>/</code> representing a <code>Modifier</code> that will <code>Weaken</code> bonds.</p><p>To load these, I&rsquo;ll actually take every other line, removing the spaces and making a <code>v1</code> <code>&amp;str</code> out of it. The remaining lines will all be <code>Modifiers</code>, so record the type and location of each.</p><p>Finally, we have potential solutions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v2
</span></span><span style=display:flex><span>x x x x x x x -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x - h - x h x x
</span></span><span style=display:flex><span>   / /
</span></span><span style=display:flex><span>x - N - - - - x
</span></span><span style=display:flex><span>   / /
</span></span><span style=display:flex><span>x - h - x x x x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x x x x x - - -
</span></span><span style=display:flex><span>=ASDWDWASSAWSDWDDD
</span></span><span style=display:flex><span>=DSAWAWDSSDWSAWDDD
</span></span></code></pre></div><p>If there are one or more lines at the end starting with <code>=</code>, it will represent a series of keystrokes that is a valid solution to the problem generated by various iterations of this solver and validated against the actual game. We get multiple solutions since each time I change the algorithm, it&rsquo;s possible that it will change the order we&rsquo;re searching in. It&rsquo;s not always perfect!</p><p>We&rsquo;ll come back to how those are actually used when talking about <a href=#running-test-cases>testing</a>.</p><h4 id=modifier><code>Modifier</code></h4><p>So how do the <code>Modifiers</code> work? Well, we have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Modifier</span> {
</span></span><span style=display:flex><span>    kind: <span style=color:#a6e22e>ModifierKind</span>,
</span></span><span style=display:flex><span>    location: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ModifierKind</span> {
</span></span><span style=display:flex><span>    Weaken,
</span></span><span style=display:flex><span>    Strengthen,
</span></span><span style=display:flex><span>    Rotate,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> ModifierKind {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>char</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>=&gt;</span> ModifierKind::Weaken,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;+&#39;</span> <span style=color:#f92672>=&gt;</span> ModifierKind::Strengthen,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;@&#39;</span> <span style=color:#f92672>=&gt;</span> ModifierKind::Rotate,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;unknown modifier: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, value),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Into<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> ModifierKind {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into</span>(self) -&gt; <span style=color:#66d9ef>char</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            ModifierKind::Weaken <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;/&#39;</span>,
</span></span><span style=display:flex><span>            ModifierKind::Strengthen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;+&#39;</span>,
</span></span><span style=display:flex><span>            ModifierKind::Rotate <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;@&#39;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Originally, I directly stored data as a tuple of <code>(ModifierKind, Point)</code> rather than a struct, but all the <code>.0</code> and <code>.1</code> got confusing, so I went through a large series of clarifying refactors. This is much better.</p><h3 id=local-state>Local state</h3><p>Okay, we have the global state, so what do we need to track locally? A list (or <code>Vec</code> I suppose) of <code>Molecule</code>, each made of <code>Elements</code> and <code>Bonds</code>.</p><h4 id=localstate><code>LocalState</code></h4><p>Okay, lets start at the top. Our state is &mldr; kind of boring:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LocalState</span> {
</span></span><span style=display:flex><span>    molecules: Vec<span style=color:#f92672>&lt;</span>Molecule<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s really all it is. It&rsquo;s nice to have a type to make sure I&rsquo;m passing the right thing around (it was originally directly a <code>Vec&lt;Molecule></code>). We do have two interesting functions: <a href=#localstatetry_move><code>try_move</code></a> and <a href=#localstatesplit_at_bond><code>split_at_bond</code></a>. We&rsquo;ll get to those after we define everything that makes up a <code>LocalState</code>.</p><h4 id=molecule><code>Molecule</code></h4><p>Next, we have the implementation of the <code>Molecules</code> themselves:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Molecule</span> {
</span></span><span style=display:flex><span>    active: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    offset: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    elements: Vec<span style=color:#f92672>&lt;</span>Element<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    bonds: Vec<span style=color:#f92672>&lt;</span>Bond<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>offset</code> is where the center of the <code>Molecule</code> is within the full <code>Map</code>. All <code>Elements</code> in this <code>Molecule</code> are relative to this point. Then a <code>Vec</code> each of <a href=#element><code>Elements</code></a> and <a href=#bond><code>Bonds</code></a>.</p><p>The first (last added) field is a bit more interesting. <code>active</code> is set to <code>false</code> when a molecule should not be considered to still exist or otherwise interact with anything. I do this rather than removing the elements immediately since a lot of things deal with indexes rather than references. This &mldr; is not perfect. But it works well enough.</p><p>Now, a few functions. First, we have a few basic constructors and accessors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Molecule {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(offset: <span style=color:#a6e22e>Point</span>, element: <span style=color:#a6e22e>ElementKind</span>) -&gt; <span style=color:#a6e22e>Molecule</span> {
</span></span><span style=display:flex><span>        Molecule {
</span></span><span style=display:flex><span>            active: <span style=color:#a6e22e>true</span>,
</span></span><span style=display:flex><span>            offset,
</span></span><span style=display:flex><span>            elements: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[Element {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>element</span>,
</span></span><span style=display:flex><span>                offset: <span style=color:#a6e22e>Point</span>::<span style=color:#66d9ef>ZERO</span>,
</span></span><span style=display:flex><span>                free_electrons: <span style=color:#a6e22e>element</span>.free_electrons(),
</span></span><span style=display:flex><span>            }],
</span></span><span style=display:flex><span>            bonds: Vec::new(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Test for molecular helium
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_helium</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.elements.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> self.elements[<span style=color:#ae81ff>0</span>].kind <span style=color:#f92672>==</span> ElementKind::Helium
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// How many free electrons in the hole molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>free_electrons</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        self.elements
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.free_electrons)
</span></span><span style=display:flex><span>            .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, intersections. This is where <code>active</code> comes in (you can&rsquo;t intersect with something that no longer exists).</p><p>Things like <code>intersects</code> do get a bit interesting, since the <code>Elements</code> in each <code>Molecule</code> are relative to their own center. So we always have to add the offset to them. It works out clearly enough I think though.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Molecule {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the given molecule at an offset would intersect with a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>intersects_wall</span>(<span style=color:#f92672>&amp;</span>self, offset: <span style=color:#a6e22e>Point</span>, map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>self.elements {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> target <span style=color:#f92672>=</span> self.offset <span style=color:#f92672>+</span> element.offset <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> map.is_wall(target.x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>, target.y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the given molecule + an offset would intersect another molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If there&#39;s an intersection, return the intersecting point of each molecule (without offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>intersects</span>(<span style=color:#f92672>&amp;</span>self, offset: <span style=color:#a6e22e>Point</span>, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Molecule</span>) -&gt; Option<span style=color:#f92672>&lt;</span>(Point, Point)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.active <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>other.active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>self.elements {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> other_element <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>other.elements {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.offset <span style=color:#f92672>+</span> element.offset <span style=color:#f92672>+</span> offset <span style=color:#f92672>==</span> other.offset <span style=color:#f92672>+</span> other_element.offset {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some((element.offset, other_element.offset));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, a function that will bond two molecules together. It&rsquo;s named <code>try_bond</code> since it doesn&rsquo;t always bond them. This &mldr; probably is badly named, but I wrote i a long time ago.</p><p>If the two elements can be bond, we&rsquo;ll go ahead and do it. All of the <code>Elements</code> and <code>Bonds</code> in <code>other</code> will be added to <code>self</code> along with the newly created bond. It will be the responsibility of the caller to properly set <code>other.active = false</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Molecule {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Try to bond two molecules together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Offset is between the centers of the molecules
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Updates and returns true if successful
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_bond</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, offset: <span style=color:#a6e22e>Point</span>, other: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Molecule</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.active <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>other.active {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bound <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Make local mutable copies
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> other <span style=color:#f92672>=</span> other.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Go through each molecule pairwise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> a <span style=color:#66d9ef>in</span> self.elements.iter_mut() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> b <span style=color:#66d9ef>in</span> other.elements.iter_mut() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> real_a <span style=color:#f92672>=</span> self.offset <span style=color:#f92672>+</span> offset <span style=color:#f92672>+</span> a.offset;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> real_b <span style=color:#f92672>=</span> other.offset <span style=color:#f92672>+</span> b.offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Not adjacent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> real_a.manhattan_distance(real_b) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Not enough free electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> a.free_electrons <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> b.free_electrons <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Bond the two elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                bound <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                self.bonds.push(Bond {
</span></span><span style=display:flex><span>                    a: <span style=color:#a6e22e>offset</span> <span style=color:#f92672>+</span> a.offset,
</span></span><span style=display:flex><span>                    b: <span style=color:#a6e22e>other</span>.offset <span style=color:#f92672>-</span> self.offset <span style=color:#f92672>+</span> b.offset,
</span></span><span style=display:flex><span>                    count: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                a.free_electrons <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                b.free_electrons <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we bound anything, add the other elements and bonds to our molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> bound {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> other.elements {
</span></span><span style=display:flex><span>                self.elements.push(Element {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>element</span>.kind,
</span></span><span style=display:flex><span>                    offset: <span style=color:#a6e22e>other</span>.offset <span style=color:#f92672>-</span> self.offset <span style=color:#f92672>+</span> element.offset,
</span></span><span style=display:flex><span>                    free_electrons: <span style=color:#a6e22e>element</span>.free_electrons,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> bond <span style=color:#66d9ef>in</span> other.bonds {
</span></span><span style=display:flex><span>                self.bonds.push(Bond {
</span></span><span style=display:flex><span>                    a: <span style=color:#a6e22e>other</span>.offset <span style=color:#f92672>-</span> self.offset <span style=color:#f92672>+</span> bond.a,
</span></span><span style=display:flex><span>                    b: <span style=color:#a6e22e>other</span>.offset <span style=color:#f92672>-</span> self.offset <span style=color:#f92672>+</span> bond.b,
</span></span><span style=display:flex><span>                    count: <span style=color:#a6e22e>bond</span>.count,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, we have a function to change where the center of the <code>Molecule</code> is. This will come up when we split a <code>Molecule</code> into two. The first will keep it&rsquo;s center, but the second will have no element at <code>0,0</code>. While this doesn&rsquo;t actually break our code, it does make some things easier. So this will set the center to a specific point instead!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Molecule {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recenter</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, new_zero: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>        self.offset <span style=color:#f92672>=</span> self.offset <span style=color:#f92672>+</span> new_zero;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.elements {
</span></span><span style=display:flex><span>            element.offset <span style=color:#f92672>=</span> element.offset <span style=color:#f92672>-</span> new_zero;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dst_bond <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.bonds {
</span></span><span style=display:flex><span>            dst_bond.a <span style=color:#f92672>=</span> dst_bond.a <span style=color:#f92672>-</span> new_zero;
</span></span><span style=display:flex><span>            dst_bond.b <span style=color:#f92672>=</span> dst_bond.b <span style=color:#f92672>-</span> new_zero;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, so now we need <a href=#element><code>Elements</code></a> and <a href=#bond><code>Bonds</code></a>.</p><h4 id=element><code>Element</code></h4><p>One step further down, <code>Molecule</code> is made of <code>Elements</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Element</span> {
</span></span><span style=display:flex><span>    kind: <span style=color:#a6e22e>ElementKind</span>,
</span></span><span style=display:flex><span>    offset: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    free_electrons: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ElementKind</span> {
</span></span><span style=display:flex><span>    Hydrogen,
</span></span><span style=display:flex><span>    Helium,
</span></span><span style=display:flex><span>    Nitrogen,
</span></span><span style=display:flex><span>    Carbon,
</span></span><span style=display:flex><span>    Oxygen,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> ElementKind {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(value: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> ElementKind::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;h&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;H&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Hydrogen),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;e&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;E&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Helium),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;n&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;N&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Nitrogen),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;c&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;C&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Carbon),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;o&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;O&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Oxygen),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(()),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Into<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> ElementKind {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into</span>(self) -&gt; <span style=color:#66d9ef>char</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            ElementKind::Hydrogen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;H&#39;</span>,
</span></span><span style=display:flex><span>            ElementKind::Helium <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;E&#39;</span>,
</span></span><span style=display:flex><span>            ElementKind::Nitrogen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;N&#39;</span>,
</span></span><span style=display:flex><span>            ElementKind::Carbon <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;C&#39;</span>,
</span></span><span style=display:flex><span>            ElementKind::Oxygen <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;O&#39;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> ElementKind {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>free_electrons</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> ElementKind::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Hydrogen <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            Helium <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            Nitrogen <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>            Carbon <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>            Oxygen <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Each <code>Element</code> has 1 of the 5 kinds, which we need to load and print back out. In addition, it will store the <code>offset</code>, which is a relative location to the <code>Molecule</code> containing this <code>Element</code>. And finally, a number of <code>free_electrons</code>. This is how many more bonds this <code>Element</code> can have.</p><h4 id=bond><code>Bond</code></h4><p><code>Bonds</code> themselves don&rsquo;t do anything in particular, they&rsquo;re mostly storage for the link between points:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bond</span> {
</span></span><span style=display:flex><span>    a: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    b: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>    count: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Add<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Bond {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Bond;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Bond {
</span></span><span style=display:flex><span>            a: <span style=color:#a6e22e>self</span>.a <span style=color:#f92672>+</span> rhs,
</span></span><span style=display:flex><span>            b: <span style=color:#a6e22e>self</span>.b <span style=color:#f92672>+</span> rhs,
</span></span><span style=display:flex><span>            count: <span style=color:#a6e22e>self</span>.count,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Sub<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Bond {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Bond;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sub</span>(self, rhs: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Bond {
</span></span><span style=display:flex><span>            a: <span style=color:#a6e22e>self</span>.a <span style=color:#f92672>-</span> rhs,
</span></span><span style=display:flex><span>            b: <span style=color:#a6e22e>self</span>.b <span style=color:#f92672>-</span> rhs,
</span></span><span style=display:flex><span>            count: <span style=color:#a6e22e>self</span>.count,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s&mldr; not great that I&rsquo;m using <code>Points</code> here. If I went back to implement this from scratch, it would probably be <em>much</em> easier to have a reference to some sort of <code>ElementId</code>. But&mldr; it eventually worked!</p><h4 id=localstatetry_move><code>LocalState.try_move</code></h4><p>Okay, we have all the pieces. Here&rsquo;s where things get&mldr; really long. This is <em>really</em> the bulk of the function and is messy at times.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Try to move the ith molecule by the given offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Will also move all other touching molecules out of the way
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Returns the new state if successful
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_move</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>, index: <span style=color:#66d9ef>usize</span>, offset: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.__try_move_recursive__(map, index, offset, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__try_move_recursive__</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>,
</span></span><span style=display:flex><span>        index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        offset: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>        first: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> original_molecules <span style=color:#f92672>=</span> self.molecules.clone();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> moved_early <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Collect all map modifiers that we are trying to cross (this may take multiple passes)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> modifiers_applied <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bond_to_modify <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We want to handle bonds from the closest to origin first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This will help with cases with multiple rotators when we only want to hit the &#39;first&#39; one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sorted_bonds <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>                .molecules[index]
</span></span><span style=display:flex><span>                .bonds
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .enumerate()
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            sorted_bonds.sort_by_key(<span style=color:#f92672>|</span>(_, bond)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                bond.a.manhattan_distance(Point::<span style=color:#66d9ef>ZERO</span>) <span style=color:#f92672>+</span> bond.b.manhattan_distance(Point::<span style=color:#66d9ef>ZERO</span>)
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>&#39;find_bond</span>: <span style=color:#a6e22e>for</span> (bond_index, bond) <span style=color:#66d9ef>in</span> sorted_bonds {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sorted_modifiers <span style=color:#f92672>=</span> map.modifiers.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                sorted_modifiers.sort_by_key(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> real_bond <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>bond <span style=color:#f92672>+</span> self.molecules[index].offset;
</span></span><span style=display:flex><span>                    real_bond.a.manhattan_distance(m.location) <span style=color:#f92672>+</span> real_bond.b.manhattan_distance(m.location)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// TODO: Do we still need to sort by type? 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> modifier <span style=color:#66d9ef>in</span> sorted_modifiers {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> modifiers_applied.contains(<span style=color:#f92672>&amp;</span>modifier) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> real_a <span style=color:#f92672>=</span> bond.a <span style=color:#f92672>+</span> self.molecules[index].offset;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> real_b <span style=color:#f92672>=</span> bond.b <span style=color:#f92672>+</span> self.molecules[index].offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Vertical bonds have the same x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> is_vertical <span style=color:#f92672>=</span> bond.a.x <span style=color:#f92672>==</span> bond.b.x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// We&#39;ll hit a vertical splitter if the offset is horizontal and we&#39;re moving across it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Ignore bonds that are moving the wrong way
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> is_vertical <span style=color:#f92672>&amp;&amp;</span> offset.x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>is_vertical <span style=color:#f92672>&amp;&amp;</span> offset.y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Moving &#39;positive&#39; is down or right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> is_positive <span style=color:#f92672>=</span> offset.x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> offset.y <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Because either x or y is the same for all bonds, min is top/left and max is bottom/right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// This will always match the splitter if we&#39;re moving across it right or down
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> pre_min <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>real_a</span>.x.min(real_b.x),
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>real_a</span>.y.min(real_b.y),
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// The post point is the one after we&#39;ve moved
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> post_a <span style=color:#f92672>=</span> real_a <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> post_b <span style=color:#f92672>=</span> real_b <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> post_min <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>post_a</span>.x.min(post_b.x),
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>post_a</span>.y.min(post_b.y),
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we&#39;re moving positive, the min (top left) will equal the splitter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> is_positive <span style=color:#f92672>&amp;&amp;</span> modifier.location <span style=color:#f92672>!=</span> pre_min {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we&#39;re moving negative, then the *post* min will equal the splitter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>is_positive <span style=color:#f92672>&amp;&amp;</span> modifier.location <span style=color:#f92672>!=</span> post_min {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// We have a bond to try to modify
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    bond_to_modify <span style=color:#f92672>=</span> Some((bond_index, modifier));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> &#39;find_bond;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We found no more bonds to modify
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> bond_to_modify.is_none() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Note it, so we don&#39;t apply the same modifier more than once per move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> (bond_index, modifier) <span style=color:#f92672>=</span> bond_to_modify.unwrap();
</span></span><span style=display:flex><span>            modifiers_applied.push(modifier);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Figure out which elements we&#39;re dealing with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> bond <span style=color:#f92672>=</span> self.molecules[index].bonds[bond_index];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> el_a_index <span style=color:#f92672>=</span> self.molecules[index]
</span></span><span style=display:flex><span>                .elements
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .position(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> el.offset <span style=color:#f92672>==</span> bond.a)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> el_b_index <span style=color:#f92672>=</span> self.molecules[index]
</span></span><span style=display:flex><span>                .elements
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .position(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> el.offset <span style=color:#f92672>==</span> bond.b)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Handle different modifier types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>match</span> modifier.kind {
</span></span><span style=display:flex><span>                ModifierKind::Weaken <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Reduce the bond and give back electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.molecules[index].elements[el_a_index].free_electrons <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    self.molecules[index].elements[el_b_index].free_electrons <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    self.molecules[index].bonds[bond_index].count <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If it was more than a single bond (originally), we&#39;re done now (no splitting)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> self.molecules[index].bonds[bond_index].count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Try to performe a split at that bond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// If this returns None, it means we have a ring, so have nothing else to do
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Otherwise, update our molecule list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((part_a, part_b)) <span style=color:#f92672>=</span> self.split_at_bond(index, bond_index) {
</span></span><span style=display:flex><span>                        self.molecules[index] <span style=color:#f92672>=</span> part_a;
</span></span><span style=display:flex><span>                        self.molecules.push(part_b);
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ModifierKind::Strengthen <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Verify we have enough free electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> self.molecules[index].elements[el_a_index].free_electrons <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> self.molecules[index].elements[el_b_index].free_electrons <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If so, strengthen the bond and take the electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.molecules[index].elements[el_a_index].free_electrons <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    self.molecules[index].elements[el_b_index].free_electrons <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    self.molecules[index].bonds[bond_index].count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ModifierKind::Rotate <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// When rotating, the rest of the molecule will move as expected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// But the bond with the primary will &#39;wrap&#39; around
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// I expect I will get this wrong
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Split the molecule into two parts, (temporarily) removing the rotate bond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// The part with the old primary will move as expected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// The other part will be &#39;pulled&#39; along the bond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Both have to move without colliding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// And then we&#39;ll merge them and put the bond back
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Part b will move &#39;along&#39; the path of the original bond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> parts <span style=color:#f92672>=</span> self.split_at_bond(index, bond_index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If it doesn&#39;t split, we have a ring; rotator won&#39;t work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> parts.is_none() {
</span></span><span style=display:flex><span>                        self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> (part_a, part_b) <span style=color:#f92672>=</span> parts.unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Determine how which way part b will remove because we&#39;ll move a and b shortly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Find the half of the bond that is still in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> part_a_el_of_bond <span style=color:#f92672>=</span> part_a.offset <span style=color:#f92672>+</span> part_a
</span></span><span style=display:flex><span>                        .elements
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .find(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> part_a.offset <span style=color:#f92672>+</span> el.offset <span style=color:#f92672>==</span> part_a.offset <span style=color:#f92672>+</span> bond.a <span style=color:#f92672>||</span> part_a.offset <span style=color:#f92672>+</span> el.offset <span style=color:#f92672>==</span> part_a.offset <span style=color:#f92672>+</span> bond.b)
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;couldn&#39;t find bond in part a&#34;</span>)
</span></span><span style=display:flex><span>                        .offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> part_b_el_of_bond<span style=color:#f92672>=</span> part_b.offset <span style=color:#f92672>+</span> part_b
</span></span><span style=display:flex><span>                        .elements
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .find(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> part_b.offset <span style=color:#f92672>+</span> el.offset <span style=color:#f92672>==</span> part_a.offset <span style=color:#f92672>+</span> bond.a <span style=color:#f92672>||</span> part_b.offset <span style=color:#f92672>+</span> el.offset <span style=color:#f92672>==</span> part_a.offset <span style=color:#f92672>+</span> bond.b)
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;couldn&#39;t find bond in part b&#34;</span>)
</span></span><span style=display:flex><span>                        .offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Determine which side of the rotate modifier that element is in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> left_side <span style=color:#f92672>=</span> part_a_el_of_bond.x <span style=color:#f92672>==</span> modifier.location.x;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> top_side <span style=color:#f92672>=</span> part_a_el_of_bond.y <span style=color:#f92672>==</span> modifier.location.y;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> moving_horizontal <span style=color:#f92672>=</span> offset.x <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// And use that information to figure out how the b half of the bond will move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> new_b_offset <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> (left_side, top_side, moving_horizontal) {
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>) <span style=color:#f92672>=&gt;</span> Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Part a becomes the new primary, b is added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.molecules[index] <span style=color:#f92672>=</span> part_a;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> part_b_index <span style=color:#f92672>=</span> self.molecules.len();
</span></span><span style=display:flex><span>                    self.molecules.push(part_b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Part a contains the original primary, it moves in the original direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Disable collision checking with b to allow tail chasing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.molecules[part_b_index].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> moved <span style=color:#f92672>=</span> self.__try_move_recursive__(map, index, offset, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>moved {
</span></span><span style=display:flex><span>                        self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    self.molecules[part_b_index].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Part b contains the &#39;other&#39; half which moves along the bond (as calculated earlier)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Likewise, disable collision checking with a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    self.molecules[index].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> moved <span style=color:#f92672>=</span> self.__try_move_recursive__(map, part_b_index, new_b_offset, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>moved {
</span></span><span style=display:flex><span>                        self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    self.molecules[index].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Once they&#39;ve both moved, make sure they&#39;re non intersecting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> self.molecules[index].intersects(Point::<span style=color:#66d9ef>ZERO</span>, <span style=color:#f92672>&amp;</span>self.molecules[part_b_index]).is_some() {
</span></span><span style=display:flex><span>                        self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Combine b into a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> part_a <span style=color:#f92672>=</span> self.molecules[index].clone();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> part_b <span style=color:#f92672>=</span> self.molecules[part_b_index].clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> part_b.elements {
</span></span><span style=display:flex><span>                        part_a.elements.push(Element {
</span></span><span style=display:flex><span>                            kind: <span style=color:#a6e22e>element</span>.kind,
</span></span><span style=display:flex><span>                            offset: <span style=color:#a6e22e>part_b</span>.offset <span style=color:#f92672>-</span> part_a.offset <span style=color:#f92672>+</span> element.offset,
</span></span><span style=display:flex><span>                            free_electrons: <span style=color:#a6e22e>element</span>.free_electrons,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> bond <span style=color:#66d9ef>in</span> part_b.bonds {
</span></span><span style=display:flex><span>                        part_a.bonds.push(Bond {
</span></span><span style=display:flex><span>                            a: <span style=color:#a6e22e>part_b</span>.offset <span style=color:#f92672>-</span> part_a.offset <span style=color:#f92672>+</span> bond.a,
</span></span><span style=display:flex><span>                            b: <span style=color:#a6e22e>part_b</span>.offset <span style=color:#f92672>-</span> part_a.offset <span style=color:#f92672>+</span> bond.b,
</span></span><span style=display:flex><span>                            count: <span style=color:#a6e22e>bond</span>.count,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Create the new bond, this will be based on the part_a_el_of_bond and the new_b_offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> new_bond <span style=color:#f92672>=</span> Bond {
</span></span><span style=display:flex><span>                        a: <span style=color:#a6e22e>part_a_el_of_bond</span> <span style=color:#f92672>+</span> offset <span style=color:#f92672>-</span> part_a.offset,
</span></span><span style=display:flex><span>                        b: <span style=color:#a6e22e>part_b_el_of_bond</span> <span style=color:#f92672>+</span> new_b_offset <span style=color:#f92672>-</span> part_a.offset,
</span></span><span style=display:flex><span>                        count: <span style=color:#a6e22e>bond</span>.count,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Validate that we didn&#39;t create a screwy bond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>assert!</span>(part_a.elements.iter().any(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> el.offset <span style=color:#f92672>==</span> new_bond.a));
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>assert!</span>(part_a.elements.iter().any(<span style=color:#f92672>|</span>el<span style=color:#f92672>|</span> el.offset <span style=color:#f92672>==</span> new_bond.b));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Validate we don&#39;t have any overlapping bonds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>assert!</span>(
</span></span><span style=display:flex><span>                        <span style=color:#f92672>!</span>part_a.bonds.iter().enumerate().any(<span style=color:#f92672>|</span>(i, b1)<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                            part_a.bonds.iter().enumerate().any(<span style=color:#f92672>|</span>(j, b2)<span style=color:#f92672>|</span> 
</span></span><span style=display:flex><span>                                i <span style=color:#f92672>!=</span> j <span style=color:#f92672>&amp;&amp;</span> (
</span></span><span style=display:flex><span>                                    (b1.a <span style=color:#f92672>==</span> b2.a <span style=color:#f92672>&amp;&amp;</span> b1.b <span style=color:#f92672>==</span> b2.b)
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>||</span> (b1.a <span style=color:#f92672>==</span> b2.b <span style=color:#f92672>&amp;&amp;</span> b1.b <span style=color:#f92672>==</span> b2.a)
</span></span><span style=display:flex><span>                                )
</span></span><span style=display:flex><span>                            )
</span></span><span style=display:flex><span>                        )
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    part_a.bonds.push(new_bond);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    self.molecules[index] <span style=color:#f92672>=</span> part_a;
</span></span><span style=display:flex><span>                    self.molecules[part_b_index].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// We&#39;ve already moved both parts, so don&#39;t move again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    moved_early <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// HACK: Only apply one rotate per move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>moved_early {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Make sure we won&#39;t hit a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Check each moving molecule to see if it would hit a wall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.molecules[index].intersects_wall(offset, map) {
</span></span><span style=display:flex><span>                self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try to update each molecule we&#39;re pushing on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>&#39;moving</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> other_index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.molecules.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> other_index <span style=color:#f92672>==</span> index {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((_, other_intersection_offset)) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                        self.molecules[index].intersects(offset, <span style=color:#f92672>&amp;</span>self.molecules[other_index])
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// HACK: Don&#39;t try to move the primary molecule more than once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// This can happen if the primary wraps around another, like:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        O-O-O
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        |   |
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        H h H
</span></span></span><span style=display:flex><span><span style=color:#75715e>                        */</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// This can happen for non-primaries, but I don&#39;t have a good way to fix that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// Assume if we made it this far, the primary *can* move, but don&#39;t actually do it here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>if</span> other_index <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Recenter the other point so that the intersection is at 0,0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// This will properly handle a molecule being pushed across a split
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// TODO: This won&#39;t properly work if multiple points are being pushed since only one is returned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        self.molecules[other_index].recenter(other_intersection_offset);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> moved <span style=color:#f92672>=</span> self.__try_move_recursive__(map, other_index, offset, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>moved {
</span></span><span style=display:flex><span>                            self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;moving;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span> &#39;moving;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Verify that after pushing, we&#39;re no longer intersecting anything
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.molecules.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> index {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.molecules[index]
</span></span><span style=display:flex><span>                    .intersects(offset, <span style=color:#f92672>&amp;</span>self.molecules[i])
</span></span><span style=display:flex><span>                    .is_some()
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    self.molecules <span style=color:#f92672>=</span> original_molecules;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Finally, update our own location
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            self.molecules[index].offset <span style=color:#f92672>=</span> self.molecules[index].offset <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;re the first call, re-apply bonds and remove inactive molecules
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> first {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>&#39;bonding</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.molecules.len() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.molecules.len() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> j {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> primary <span style=color:#f92672>=</span> self.molecules[i].clone();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> primary.try_bond(Point::<span style=color:#66d9ef>ZERO</span>, <span style=color:#f92672>&amp;</span>self.molecules[j]) {
</span></span><span style=display:flex><span>                            self.molecules[i] <span style=color:#f92672>=</span> primary;
</span></span><span style=display:flex><span>                            self.molecules[j].active <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span> &#39;bonding;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span> &#39;bonding;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self.molecules.retain(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.active);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s &mldr; complicated. Essentially, we kick off the recursive version of the function with the molecule we&rsquo;re trying to move (the <code>Molecule</code> at <code>index</code>) and the move we&rsquo;re making&ndash;<code>offset</code>.</p><p>The algorithm should be well commented, but here&rsquo;s where we ended up:</p><ul><li>Try to apply any modifiers<ul><li>First, loop over each <code>Bond</code>, starting at the <code>0,0</code> point of the molecule and moving out; this fixes a bug with <code>Rotation</code> modifiers (where you&rsquo;d hit more than one at the same time without this)</li><li>Within that, loop over each <code>Modifier</code></li><li>Check if the <code>Bond</code> plus the <code>offset</code> crosses the <code>Modifier</code>, if so apply it:<ul><li><code>Weaken</code> modifiers will take one level from the <code>Bond</code> and give back <code>free_electrons</code> on each half; if this was the last level of the <code>Bond</code>, we&rsquo;ll need to call <code>LocalState.split_at_bond</code> to create two halves. This gets interesting, since only the half containing the <code>0,0</code> will keep moving, the other is left in place.</li><li><code>Strengthen</code> is much easier: if there are free electrons on both halves, increase the strength of the <code>Bond</code> up to the maximum (of these elements) of a triple bond (<code>count = 3</code>)</li><li><code>Rotate</code> is&mldr; by far the most complicated. Implementation wise, what we end up doing is:<ul><li><p>Split the <code>Molecule</code> into <code>part_a</code> (that contains the <code>0,0</code>) and <code>part_b</code> (that doesn&rsquo;t). <code>part_a</code> will move with the <code>offset</code> and <code>part_b</code> has to calculate a new offset that will be perpendicular to that. Both halves move, then we&rsquo;ll remerge them, and put the bond back.</p><p>This&mldr; took forever to get right&mldr; and it still isn&rsquo;t. I wrote a number of <a href=#running-test-cases>test cases</a> throughout this, each making sure that 1) it&rsquo;s implemented correctly and 2) when I change something, it doesn&rsquo;t break.</p><p>But it&rsquo;s close enough to solve most of the puzzles!</p></li></ul></li></ul></li></ul></li><li>Now that we&rsquo;ve applied modifiers, check that moving won&rsquo;t hit a wall; this is done here because of things like <code>Weaken</code> (which means half the <code>Molecule</code> might not move)</li><li>Next, check for any other <code>Molecules</code> that we&rsquo;re running into. If we do, <code>try_move</code> (recursive version) <em>those</em> in turn, going through this whole mess.<ul><li>Here&rsquo;s why this is <code>try_move</code>. If any of these recursive calls fail, we&rsquo;ll return <code>false</code> up the call tree. This will then reset the <code>self.molecules</code> to the original value (this is why we cloned it), undoing any mutations! Alternatively, I could have not modified anything, returning a <code>Result&lt;Molecule></code> instead, but&mldr; that&rsquo;s just not how I ended up doing this.</li></ul></li><li>Now that we&rsquo;ve checked collisions, actually move this molecule (except in the case of <code>Rotation</code>, those are moved earlier).</li><li>Finally, check if there are any new bonds to add. This is one case where I can generate solutions that look completely &lsquo;correct&rsquo; but the game won&rsquo;t accept. If bonds are ambiguous, I don&rsquo;t know what order the game generates them in&mldr; I expect it will bond the oldest <code>Molecules</code> first, but that doesn&rsquo;t seem completely right. Such it goes.</li></ul><p>Hopefully either the code and comments above and/or the description here of the algorithm helps. It&rsquo;s&mldr; really a lot of code and kind of a mess. But it&rsquo;s <em>so cool</em> to see this working.</p><h4 id=localstatesplit_at_bond><code>LocalState.split_at_bond</code></h4><p>Finally, one more helper function. Originally, this was part of the <code>Weaken</code> code, but <code>Rotate</code> also uses it, so I factored it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>split_at_bond</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>, bond_index: <span style=color:#66d9ef>usize</span>) -&gt; Option<span style=color:#f92672>&lt;</span>(Molecule, Molecule)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a new primary half of the molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> part_a <span style=color:#f92672>=</span> self.molecules[index].clone();
</span></span><span style=display:flex><span>        part_a.bonds.remove(bond_index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Flood fill to determine what elements and bonds are part of part A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> connected_elements <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> connected_bonds <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> todo <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[Point::<span style=color:#66d9ef>ZERO</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> done <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Keep going until we find all connected elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(pt) <span style=color:#f92672>=</span> todo.pop() {
</span></span><span style=display:flex><span>            done.push(pt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If any element matches the point, add to connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (i, element) <span style=color:#66d9ef>in</span> part_a.elements.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> element.offset <span style=color:#f92672>==</span> pt <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>connected_elements.contains(<span style=color:#f92672>&amp;</span>i) {
</span></span><span style=display:flex><span>                    connected_elements.push(i);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If any bond matches the point, add to connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Then, if the other end isn&#39;t already accounted for, add it to the list to do
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (i, src_bond) <span style=color:#66d9ef>in</span> part_a.bonds.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> src_bond.a <span style=color:#f92672>==</span> pt {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>connected_bonds.contains(<span style=color:#f92672>&amp;</span>i) {
</span></span><span style=display:flex><span>                        connected_bonds.push(i);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>(todo.contains(<span style=color:#f92672>&amp;</span>src_bond.b) <span style=color:#f92672>||</span> done.contains(<span style=color:#f92672>&amp;</span>src_bond.b)) {
</span></span><span style=display:flex><span>                        todo.push(src_bond.b);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> src_bond.b <span style=color:#f92672>==</span> pt {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>connected_bonds.contains(<span style=color:#f92672>&amp;</span>i) {
</span></span><span style=display:flex><span>                        connected_bonds.push(i);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>(todo.contains(<span style=color:#f92672>&amp;</span>src_bond.a) <span style=color:#f92672>||</span> done.contains(<span style=color:#f92672>&amp;</span>src_bond.a)) {
</span></span><span style=display:flex><span>                        todo.push(src_bond.a);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we are still connected to everything, this split will not create a new molecule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This can happen if you have a ring
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> connected_elements.len() <span style=color:#f92672>==</span> part_a.elements.len() {
</span></span><span style=display:flex><span>            self.molecules[index] <span style=color:#f92672>=</span> part_a;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create the second element
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The first will remove anything that is *not* connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The second (this one) will remove anything that *is* connected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> part_b <span style=color:#f92672>=</span> part_a.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort the elements and bonds and remove from the end so the indexes are correct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connected_elements.sort();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> connected_elements.iter().rev() {
</span></span><span style=display:flex><span>            part_b.elements.remove(<span style=color:#f92672>*</span>i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        connected_bonds.sort();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> connected_bonds.iter().rev() {
</span></span><span style=display:flex><span>            part_b.bonds.remove(<span style=color:#f92672>*</span>i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Likewise, remove anything not in the list from the end to preserve indexes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>part_a.elements.len()).rev() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>connected_elements.contains(<span style=color:#f92672>&amp;</span>i) {
</span></span><span style=display:flex><span>                part_a.elements.remove(i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>part_a.bonds.len()).rev() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>connected_bonds.contains(<span style=color:#f92672>&amp;</span>i) {
</span></span><span style=display:flex><span>                part_a.bonds.remove(i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Part b no longer has an element at (0,0), choose one arbitrarily and recenter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        part_b.recenter(part_b.elements[<span style=color:#ae81ff>0</span>].offset);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Return the new parts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Some((part_a, part_b))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essentially:</p><ul><li>Remove the target bond</li><li>Use a flood fill to collect all <code>Elements</code> and <code>Bonds</code> that are still reachable from the <code>0,0</code> element</li><li>If this is still all <code>Elements</code>, that means broke a loop and this doesn&rsquo;t actually split the molecule, so return <code>None</code></li><li>Otherwise, create a new <code>part_b</code> Molecule<ul><li>Remove all connected <code>Elements</code> and <code>Bonds</code> from <code>part_b</code></li><li>Remove all non-connected ones from <code>part_a</code></li></ul></li><li>Return both</li></ul><p>I&rsquo;m expecting that the caller will replace the <code>Molecule</code> at <code>index</code> with <code>part_a</code> and add <code>part_b</code> to the list, but that&rsquo;s not strictly required.</p><p>And there we have the entire state, both <a href=#global-state>global</a> and <a href=#local-state>local</a>.</p><h2 id=the-rest-of-the-owl-gorithm>The rest of the owl-gorithm</h2><p>Okay, that&rsquo;s a whole lot of code to say &lsquo;how do we represent this problem&rsquo;. Now we need to implement <code>State&lt;Map, Step></code> to actually solve it.</p><h3 id=is_valid><code>is_valid</code></h3><p>First, check if a state is valid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Map, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.is_solved(map) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If it&#39;s a board that allows multiples, anything goes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> map.allow_multiple {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we have any splitters, anything goes :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>map.modifiers.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The primary molecule must have free electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>(self.molecules[<span style=color:#ae81ff>0</span>].is_helium() <span style=color:#f92672>||</span> self.molecules[<span style=color:#ae81ff>0</span>].free_electrons() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Any non-primary (other than helium) must have free electrons
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> self
</span></span><span style=display:flex><span>            .molecules
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .skip(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            .any(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>m.is_helium() <span style=color:#f92672>&amp;&amp;</span> m.free_electrons() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Technically, I actually don&rsquo;t really do anything interesting here, since almost all but the most basic solutions either <code>allow_multiple</code> <code>Molecules</code> or have <code>modifiers</code> (since those can re-split something that would otherwise be invalid).</p><p>This isn&rsquo;t perfect. There are certainly cases we can get in that we should prune. But&mldr; it&rsquo;s good enough.</p><h3 id=is_solved><code>is_solved</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Map, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solved</span>(<span style=color:#f92672>&amp;</span>self, _global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.molecules.iter().all(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.free_electrons() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At one point, I actually took <code>allow_multiple</code> into account here&mldr; but not that I look at it while writing this up&mldr; well, it seems I don&rsquo;t care about that.</p><p>In any case, the puzzle is solved when all <code>Molecules</code> (and thus all <code>Elements</code> within them) have no more <code>free_electrons</code>. That&rsquo;s it!</p><h3 id=heuristic><code>heuristic</code></h3><p>This&mldr; is not really anything interesting. I&rsquo;m mostly just doing a breadth-first search but not really accounting for this. Mostly, I count more the more <code>free_electrons</code> we still have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Map, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>heuristic</span>(<span style=color:#f92672>&amp;</span>self, _global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        self.molecules
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.free_electrons() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>)
</span></span><span style=display:flex><span>            .sum()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is something that could really be done better, but at this point, I&rsquo;ve spent&mldr; more hours than I&rsquo;d care to admit on this, so that will have to be another day.</p><h3 id=next_states><code>next_states</code></h3><p>And finally, the heart of the algorithm, <code>next_states</code>. With everything (mostly <code>try_move</code>), this is really short:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Map, Step<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> LocalState {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Map</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, Step, LocalState)<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_states <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to move the primary each direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> step <span style=color:#66d9ef>in</span> [Step::North, Step::South, Step::East, Step::West].iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> next_state.try_move(map, <span style=color:#ae81ff>0</span>, (<span style=color:#f92672>*</span>step).into()) {
</span></span><span style=display:flex><span>                next_states.push((<span style=color:#ae81ff>1</span>, <span style=color:#f92672>*</span>step, next_state));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> next_states.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(next_states);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s really it. Try to move the <code>primary</code> <code>Molecule</code> (the first one) each direction; if we can, queue that state. That&rsquo;s it! That&rsquo;s the entire program.</p><p>Out of all 144 cases, it solves ~135 of them. There are a few that have bugs that prevent solving (all but 1 in rotations, I expect it&rsquo;s to do with two rotations on the same move) and a few that aren&rsquo;t efficient (mostly with many free <code>Helium</code>, since that generates many more states without getting closer to a solution.</p><h2 id=running-test-cases>Running test cases</h2><p>this one was a fun mess, trying to work out how things were going wrong. I wrote a rather good number of test cases of individual parts. That way, as I added more code, I would be able to determine if I&rsquo;d broken anything! (And if so, what). I&rsquo;m not going to go through all of them, but you can see them here:</p><ul><li><a href=https://github.com/jpverkamp/rust-solvers/blob/633d32a5cfac93d553f4b2d5432a3d91e4f77ae0/src/bin/sokobond.rs#L274 target=_blank rel=noopener><code>test_map</code></a> - Test cases for <code>Map::load</code></li><li><a href=https://github.com/jpverkamp/rust-solvers/blob/633d32a5cfac93d553f4b2d5432a3d91e4f77ae0/src/bin/sokobond.rs#L544 target=_blank rel=noopener><code>test_molecule</code></a> - Test cases for molecules; primarily intersections but also <code>try_bond</code></li><li><a href=https://github.com/jpverkamp/rust-solvers/blob/633d32a5cfac93d553f4b2d5432a3d91e4f77ae0/src/bin/sokobond.rs#L1116 target=_blank rel=noopener><code>test_localstate</code></a> - The lion&rsquo;s share of test cases, these represent loading some small map, performing a sequence of <a href=#localstatetry_move><code>try_moves</code></a>, and validating the state is correct</li></ul><p>And finally, a single test for each and every level. This is why I loaded <code>solutions</code> above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo nextest run --release --bin sokobond
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   Compiling solver v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/rust-solvers<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 1.33s
</span></span><span style=display:flex><span>warning: the following packages contain code that will be rejected by a future version of Rust: nom v4.2.3
</span></span><span style=display:flex><span>note: to see what the problems were, use the option <span style=color:#e6db74>`</span>--future-incompat-report<span style=color:#e6db74>`</span>, or run <span style=color:#e6db74>`</span>cargo report future-incompatibilities --id 1<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    Starting <span style=color:#ae81ff>35</span> tests across <span style=color:#ae81ff>1</span> binary
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.012s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_bump_into_wall
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_doubler
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.012s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_cats_cradle
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.013s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_join_split
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.009s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_move_push
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_move_and_bond
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.014s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_move_across_splitter
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_no_move_push_into_wall
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_not_double_rotate
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.013s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_move_basic
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_partial_split
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_push_across_splitter
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.009s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_push_and_bond
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_push_across_splitter_inverse
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_push_unbound
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.008s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_chain_succeed
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_chain_fail
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.008s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_split_and_push
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_simple
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_chase_tail
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_in_a_corner
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_rotate_tail_part
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_small_key
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_split_multiple
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.011s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_split_join
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.009s<span style=color:#f92672>]</span> solver::bin/sokobond test_map::test_load
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.010s<span style=color:#f92672>]</span> solver::bin/sokobond test_localstate::test_splitter_second_join
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.008s<span style=color:#f92672>]</span> solver::bin/sokobond test_map::test_load_prebond
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.006s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_molecule_intersection
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.008s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_bond
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.006s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_nobond_no_free
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.006s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_nobond_too_far
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.007s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_single_bond_o2_not_double
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   0.006s<span style=color:#f92672>]</span> solver::bin/sokobond test_molecule::test_wall_intersection_hit
</span></span><span style=display:flex><span>        PASS <span style=color:#f92672>[</span>   2.901s<span style=color:#f92672>]</span> solver::bin/sokobond test_solutions::test_all_solutions
</span></span><span style=display:flex><span>------------
</span></span><span style=display:flex><span>     Summary <span style=color:#f92672>[</span>   2.932s<span style=color:#f92672>]</span> <span style=color:#ae81ff>35</span> tests run: <span style=color:#ae81ff>35</span> passed, <span style=color:#ae81ff>0</span> skipped
</span></span></code></pre></div><p>Woot!</p><h3 id=test-macro><code>test!</code> macro</h3><p>Originally, I had a <code>test!</code> macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> test {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$folder</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$file</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$expected</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$folder</span>:<span style=color:#a6e22e>literal</span>, <span style=color:#75715e>$file</span>:<span style=color:#a6e22e>literal</span>, <span style=color:#75715e>$expected</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#75715e>$name</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#75715e>$name</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> <span style=color:#a6e22e>include_str!</span>(<span style=color:#a6e22e>concat!</span>(<span style=color:#e6db74>&#34;../../data/sokobond/&#34;</span>, <span style=color:#75715e>$folder</span>, <span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#75715e>$file</span>));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> <span style=color:#a6e22e>include_str!</span>(<span style=color:#a6e22e>concat!</span>(<span style=color:#e6db74>&#34;../../data/sokobond/&#34;</span>, <span style=color:#75715e>$folder</span>, <span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#75715e>$file</span>));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solve(input);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solve(input);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>assert_eq!</span>(solution.expect(<span style=color:#e6db74>&#34;solution exists&#34;</span>), <span style=color:#75715e>$expected</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>assert_eq!</span>(solution.expect(<span style=color:#e6db74>&#34;solution exists&#34;</span>), <span style=color:#75715e>$expected</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This lets us write test cases like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a6e22e>test!</span> {test_01_01, <span style=color:#e6db74>&#34;01 - Yellow&#34;</span>, <span style=color:#e6db74>&#34;01 - Let&#39;s Go.txt&#34;</span>, <span style=color:#e6db74>&#34;WWDDWWDD&#34;</span>}
</span></span></code></pre></div><p>That&rsquo;s pretty cool. We have the input in folders/files (one per problem). And for a while, it worked. I would change the solution part when I changed the algorithm. But eventually that got annoying, so I added a second form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> test {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$folder</span>:<span style=color:#a6e22e>literal</span>, <span style=color:#75715e>$file</span>:<span style=color:#a6e22e>literal</span> <span style=color:#66d9ef>in</span> <span style=color:#75715e>$expected_list</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#75715e>$name</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> <span style=color:#a6e22e>include_str!</span>(<span style=color:#a6e22e>concat!</span>(<span style=color:#e6db74>&#34;../../data/sokobond/&#34;</span>, <span style=color:#75715e>$folder</span>, <span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#75715e>$file</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solve(input).expect(<span style=color:#e6db74>&#34;solution exists&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>assert!</span>(<span style=color:#75715e>$expected_list</span>.contains(<span style=color:#f92672>&amp;</span>solution.as_str()), <span style=color:#e6db74>&#34;{solution} not in {:?}&#34;</span>, <span style=color:#75715e>$expected_list</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$folder</span>:<span style=color:#a6e22e>literal</span>, <span style=color:#75715e>$file</span>:<span style=color:#a6e22e>literal</span>, <span style=color:#75715e>$expected</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, we can have more than one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a6e22e>test!</span> {test_03_06, <span style=color:#e6db74>&#34;03 - Gray&#34;</span>, <span style=color:#e6db74>&#34;06 - Three Doors.txt&#34;</span> <span style=color:#66d9ef>in</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;DAWWSAAWWAWDDSDSSAASDSDWWWSDDWSDSSAWWAAAAWWDD&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;AWAWSDDWSDDWWDWAAASSSDDSASAWWWSDDWWAASSSASAWW&#34;</span>,
</span></span><span style=display:flex><span>]}
</span></span></code></pre></div><p>Now so long as we generate any one of them, it&rsquo;s great!</p><p>But eventually, this got messy and I wanted to extract the solutions.</p><h3 id=a-single-parallel-test-case>A single (parallel) test case</h3><p>I wanted a nice macro that could generate the <code>test!</code> above for each file/folder/solution in that file&mldr; but that would require procedural macros. So instead, a single test function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> test_solutions {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> std::{fs::File, io::Read, sync::mpsc, thread};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> rayon::iter::{IntoParallelRefIterator, ParallelIterator};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_all_solutions</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Timeout after 1 second or SOKOBOND_TEST_TIMEOUT if set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> timeout <span style=color:#f92672>=</span> std::time::Duration::from_secs(
</span></span><span style=display:flex><span>            std::env::var(<span style=color:#e6db74>&#34;SOKOBOND_TEST_TIMEOUT&#34;</span>)
</span></span><span style=display:flex><span>                .ok()
</span></span><span style=display:flex><span>                .and_then(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.parse().ok())
</span></span><span style=display:flex><span>                .unwrap_or(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Collect all tests to run in order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> test_files <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> entry <span style=color:#66d9ef>in</span> std::fs::read_dir(<span style=color:#e6db74>&#34;data/sokobond&#34;</span>).unwrap() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> entry <span style=color:#f92672>=</span> entry.unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> entry.path();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>path.is_dir() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> entry <span style=color:#66d9ef>in</span> std::fs::read_dir(<span style=color:#f92672>&amp;</span>path).unwrap() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> entry <span style=color:#f92672>=</span> entry.unwrap();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> entry.path();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> path.extension().unwrap() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;txt&#34;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                test_files.push(path);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        test_files.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Run each test with timeout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>#[derive(Debug, Clone, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>TestResult</span> {
</span></span><span style=display:flex><span>            Success,
</span></span><span style=display:flex><span>            NoSolution,
</span></span><span style=display:flex><span>            InvalidSolution(String),
</span></span><span style=display:flex><span>            TimedOut,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> results <span style=color:#f92672>=</span> test_files
</span></span><span style=display:flex><span>            .par_iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>path<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> file <span style=color:#f92672>=</span> File::open(<span style=color:#f92672>&amp;</span>path).unwrap();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>                file.read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (map, _) <span style=color:#f92672>=</span> Map::load(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (tx, rx) <span style=color:#f92672>=</span> mpsc::channel();
</span></span><span style=display:flex><span>                thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solve(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>match</span> tx.send(solution) {
</span></span><span style=display:flex><span>                        Ok(_) <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                        Err(_) <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                    } <span style=color:#75715e>// I don&#39;t actually care if this succeeds, but need to consume it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> rx.recv_timeout(timeout) {
</span></span><span style=display:flex><span>                    Ok(solution) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> solution.is_none() {
</span></span><span style=display:flex><span>                            log::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;No solution: {:?}&#34;</span>, path);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> TestResult::NoSolution;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> solution.unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>map.solutions.contains(<span style=color:#f92672>&amp;</span>solution) {
</span></span><span style=display:flex><span>                            log::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Invalid solution ({}): {:?}&#34;</span>, solution, path);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> TestResult::InvalidSolution(solution);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        log::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Solved: {:?}&#34;</span>, path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> TestResult::Success;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Err(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        log::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Timed out: {:?}&#34;</span>, path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> TestResult::TimedOut;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Print out the results
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> results.iter().any(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>r <span style=color:#f92672>==</span> TestResult::TimedOut) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Timed out tests:&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (path, result) <span style=color:#66d9ef>in</span> test_files.iter().zip(results.iter()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>result <span style=color:#f92672>==</span> TestResult::TimedOut {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, path);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> results.iter().any(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>r <span style=color:#f92672>==</span> TestResult::NoSolution) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Unsolved tests:&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (path, result) <span style=color:#66d9ef>in</span> test_files.iter().zip(results.iter()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>result <span style=color:#f92672>==</span> TestResult::NoSolution {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, path);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> results.iter().any(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> TestResult::InvalidSolution(_) <span style=color:#f92672>=</span> r {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Failed tests:&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (path, result) <span style=color:#66d9ef>in</span> test_files.iter().zip(results.iter()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> TestResult::InvalidSolution(solution) <span style=color:#f92672>=</span> result {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, path, solution);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> perfect <span style=color:#f92672>=</span> results
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .all(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>r <span style=color:#f92672>==</span> TestResult::Success <span style=color:#f92672>||</span> <span style=color:#f92672>*</span>r <span style=color:#f92672>==</span> TestResult::TimedOut);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>perfect {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>assert!</span>(perfect);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is actually pretty fun. It uses two interesting tricks:</p><ul><li><code>mpsc</code> channels + <code>recv_timeout</code> to allow timing out tests; some of these take a while to run</li><li><a href=https://docs.rs/rayon/latest/rayon/ target=_blank rel=noopener><code>rayon</code></a> for <code>par_iter</code> to run all of the tests automagically in parallel</li></ul><p>And that&rsquo;s it! We have full output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test test_all_solutions -- --nocapture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.02s
</span></span><span style=display:flex><span>warning: the following packages contain code that will be rejected by a future version of Rust: nom v4.2.3
</span></span><span style=display:flex><span>note: to see what the problems were, use the option <span style=color:#e6db74>`</span>--future-incompat-report<span style=color:#e6db74>`</span>, or run <span style=color:#e6db74>`</span>cargo report future-incompatibilities --id 1<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>     Running unittests src/lib.rs <span style=color:#f92672>(</span>target/debug/deps/solver-dfc21431ff367efe<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/cosmic-express.rs <span style=color:#f92672>(</span>target/debug/deps/cosmic_express-ed8c5ceee43a9e50<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/good-snowman.rs <span style=color:#f92672>(</span>target/debug/deps/good_snowman-a3689d1d47ea7196<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/sokobond.rs <span style=color:#f92672>(</span>target/debug/deps/sokobond-1de5d97c6b7c7bd4<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>1</span> test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Timed out tests:
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/04 - Against the Wall.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/05 - Pathways.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/06 - Three Doors.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/08 - Planning.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/09 - Out of the Way.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/10 - Impasse.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/03 - Gray/11 - Fetch.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/04 - Red/07 - Wingman.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/06 - Dark Green/02 - Airplane.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/07 - Dark Red/01 - Plunge.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/07 - Dark Red/07 - Grater.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/07 - Dark Red/09 - Home.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/07 - Dark Red/11 - Station.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/07 - Dark Red/12 - Arena.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/04 - Aye.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/06 - Double-Bleached.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/07 - Spaceship.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/08 - Counterintuitive.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/10 - Ocean.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/11 - Much Methane.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/08 - Light Gray/12 - Hydrogen Machine.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/09 - Blue/10 - Feng Shui.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/09 - Blue/11 - Jumbo Jet.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/09 - Blue/12 - Cross.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/10 - Blue Green/07 - Diagonal.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/10 - Blue Green/10 - Right Angle.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/11 - Dark Blue/05 - Quadro.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/02 - Grand Slam.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/04 - Skull.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/06 - Combine.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/08 - Guards.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/11 - Jellyfish.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/14 - The Monster.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/15 - Square.txt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data/sokobond/12 - Bonus/17 - Fortress.txt&#34;</span>
</span></span><span style=display:flex><span>test test_solutions::test_all_solutions ... ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>1</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>34</span> filtered out; finished in 4.13s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/main.rs <span style=color:#f92672>(</span>target/debug/deps/solver-a5093a0a26171edd<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/sudoku.rs <span style=color:#f92672>(</span>target/debug/deps/sudoku-a4a50a2deb34d5ac<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Running unittests src/bin/transmission.rs <span style=color:#f92672>(</span>target/debug/deps/transmission-d37caa0346cda4ef<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>0</span> tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>0</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span></code></pre></div><p>We can set <code>SOKOBOND_TEST_TIMEOUT</code> to a longer value to run more of the tests, but this was a great way to make sure nothing broke.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>