<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Word Games on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/word-games/</link><description>Recent content in Word Games on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/word-games/atom.xml" rel="self" type="application/rss+xml"/><item><title>Generating perfect portmanteaus</title><link>https://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/07/generating-perfect-portmanteaus/</guid><description>&lt;p>A quick programming post, since it&amp;rsquo;s been a while, inspired by this video:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/QVn2PZGZxaI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>I&amp;rsquo;m not going to go quite as far as that, but I thought it would be interesting to write up some quick code to generate portmanteaus&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p></description></item><item><title>Number words</title><link>https://blog.jverkamp.com/2014/08/13/number-words/</link><pubDate>Wed, 13 Aug 2014 14:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2014/08/13/number-words/</guid><description>&lt;p>Today&amp;rsquo;s five minute post brought to you via &lt;a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis&lt;/a> / &lt;a href="http://www.careercup.com/question?id=5120347909128192">Career Cup&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -&amp;gt; A, 2 -&amp;gt; B, …, 26 -&amp;gt; Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.&lt;/p>
&lt;/blockquote></description></item><item><title>Dis/re-emvowelification</title><link>https://blog.jverkamp.com/2014/02/27/dis/re-emvowelification/</link><pubDate>Thu, 27 Feb 2014 14:00:21 +0000</pubDate><guid>https://blog.jverkamp.com/2014/02/27/dis/re-emvowelification/</guid><description>&lt;p>So far this week we&amp;rsquo;ve had a pair of related posts at the DailyProgrammer subreddit&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/">[02/24/14] Challenge #149 [Easy] Disemvoweler&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/1yzlde/022614_challenge_150_intermediate_reemvoweler_1/">[02/26/14] Challenge #150 [Intermediate] Re-emvoweler 1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Basically, if you&amp;rsquo;re given a string with vowels, take them out. If you&amp;rsquo;re given one without vowels, put them back in. One of the two is certainly easier than the other&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. :)&lt;/p></description></item><item><title>Path to philosophy</title><link>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</link><pubDate>Thu, 28 Mar 2013 14:00:05 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</guid><description>&lt;p>Yesterday, &lt;a title="Daily programmer sub-reddit" href="http://www.reddit.com/r/dailyprogrammer/">the daily programmer Subreddit&lt;/a> had &lt;a title="[03/27/13] Challenge #121 [Intermediate] Path to Philosophy" href="http://www.reddit.com/r/dailyprogrammer/comments/1b3ka1/032713_challenge_121_intermediate_path_to/">a post that&lt;/a> mirrored a problem I&amp;rsquo;ve often seen before: the idea that if you follow first links ((With some caveats)) on &lt;a href="https://en.wikipedia.org/wiki/Main%20Page">Wikipedia&lt;/a>, you eventually end with &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>. For example, if you follow the first links from &lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a>, you get the following path:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Atom">Atom&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Matter">Matter&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Rest%20Mass">Rest Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Invariant%20Mass">Invariant Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Energy">Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Kinetic%20Energy">Kinetic Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Physics">Physics&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Natural%20Philosophy">Natural Philosophy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>NPR Sunday Puzzle</title><link>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</link><pubDate>Wed, 20 Feb 2013 14:00:26 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</guid><description>&lt;p>&lt;a title="NPR Sunday Puzzle" href="https://programmingpraxis.com/2013/02/19/npr-sunday-puzzle/">Yesterday&amp;rsquo;s puzzle&lt;/a> from Programming Praxis asks us to solve a Sunday Puzzle from NPR:&lt;/p>
&lt;blockquote>
&lt;p>Think of two familiar, unhyphenated, eight-letter words that contain the letters A, B, C, D, E and F, plus two others, in any order. What words are these?&lt;/p>
&lt;/blockquote>
&lt;p>It&amp;rsquo;s another in a &lt;a title="jverkamp.com: Word games" href="http://blog.jverkamp.com/tag/word-games/">long history of word games&lt;/a>, my favorite sort of puzzle.&lt;/p></description></item><item><title>Numbers as words in arbitrary bases</title><link>https://blog.jverkamp.com/2013/02/06/numbers-as-words-in-arbitrary-bases/</link><pubDate>Wed, 06 Feb 2013 23:00:10 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/06/numbers-as-words-in-arbitrary-bases/</guid><description>&lt;p>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/17zn6g/020613_challenge_120_intermediate_base_conversion/" title="Challenge #120 [Intermediate] Base Conversion Words">Today&amp;rsquo;s intermediate challenge&lt;/a> on Reddit&amp;rsquo;s /r/dailyprogrammer intrigued me somewhat, so I decided to take a crack at it. The basic idea is if you are given a number, try converting it to all bases from 2 to 64 (with a special encoding). Print out any of those that are words.&lt;/p>
&lt;p>For example, if you interpret the number 44,269 as a &lt;a href="https://en.wikipedia.org/wiki/Hexadecimal">base 16 (Hexadecimal)&lt;/a> number, you get the word &amp;ldquo;aced&amp;rdquo;. So just how many of these words are there out there?&lt;/p></description></item><item><title>Chopping words</title><link>https://blog.jverkamp.com/2012/10/15/chopping-words/</link><pubDate>Mon, 15 Oct 2012 14:00:13 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/15/chopping-words/</guid><description>&lt;p>&lt;a title="Programming Praxis: Chopping Words" href="http://programmingpraxis.com/2012/07/03/chopping-words/">One more challenge&lt;/a> from Programming Praxis' &lt;a title="Programming Praxis: Themes: Word Games" href="http://programmingpraxis.com/contents/themes/#Word Games">Word Games&lt;/a> today (there are only a few left!). This time we have the challenge of cutting off bits of words, one letter at a time, such that each step is still a word.&lt;/p>
&lt;p>The example given in their post is &lt;code>planet → plane → plan → pan → an → a&lt;/code>, although surely many such examples exist.&lt;/p></description></item><item><title>Dodgson’s Doublets</title><link>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</link><pubDate>Sun, 14 Oct 2012 14:00:20 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</guid><description>Today we have doublets source code, dictionary source code, queue source code.
Using the same source code as the previous two posts (here and here, described originally here) for the dictionary, the code is a pretty straight forward case of using recursion to do backtracking. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:</description></item><item><title>Word cubes</title><link>https://blog.jverkamp.com/2012/10/13/word-cubes/</link><pubDate>Sat, 13 Oct 2012 14:00:38 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/13/word-cubes/</guid><description>Continuing in my recent set of word-cube source code. Like yesterday, it&amp;rsquo;s designed to work in Racket 5.3+.</description></item><item><title>Squaring the Bishop</title><link>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</link><pubDate>Thu, 11 Oct 2012 14:00:40 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</guid><description>Okay, this one was just neat. Based on word-squares source. I&amp;rsquo;ve only tested it in Racket 5.3+, but newer versions should work as well. Racket 5.2 won&amp;rsquo;t work without some tweaking as (at the very least) it&amp;rsquo;s missing a definition for string-trim.</description></item><item><title>Dictionary tries in Racket</title><link>https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/</link><pubDate>Thu, 11 Oct 2012 13:55:38 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/</guid><description>For the next few posts, we&amp;rsquo;re going to need a way to represent a dictionary. You could go with just a flat list containing all of the words in the dictionary, but the runtime doesn&amp;rsquo;t seem optimal. Instead, we want a data structure that lets you easily get all possible words that start with a given prefix. We want a trie.
. Source: dictionary source code</description></item><item><title>Two Word Games</title><link>https://blog.jverkamp.com/2012/10/10/two-word-games/</link><pubDate>Wed, 10 Oct 2012 14:00:09 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/10/two-word-games/</guid><description>&lt;p>Another day, &lt;a title="Programming Praxis: Two Word Games" href="http://programmingpraxis.com/2012/10/09/two-word-games/">another post&lt;/a> from Programming Praxis. Today they posted a word game that seems simple enough: first find all words in a given dictionary that contain all five vowels (a, e, i, o, u) in ascending order and then find any words (at least six letters long) where the letters are all in ascending alphabetical order.&lt;/p></description></item></channel></rss>