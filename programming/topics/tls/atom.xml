<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TLS on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/tls/</link><description>Recent content in TLS on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/tls/atom.xml" rel="self" type="application/rss+xml"/><item><title>Wildcard Let's Encrypt certificates with Nginx Proxy Manager and Cloudflare</title><link>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</link><pubDate>Mon, 27 Mar 2023 00:02:00 +0000</pubDate><guid>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</guid><description>&lt;p>Another quick snippet that I figured out this weekend. It&amp;rsquo;s not hard, but it&amp;rsquo;s something that I really wanted to do and had to look up where it was, so perhaps it will help you.&lt;/p>
&lt;p>Problem statement:&lt;/p>
&lt;p>I run a bunch of local services in my network. They aren&amp;rsquo;t exposed publicly (I use Wireguard to access them when out and about), so I really don&amp;rsquo;t &lt;em>need&lt;/em> HTTPS. But (rightfully) a number of services behave better when they&amp;rsquo;re behind HTTPS + if there&amp;rsquo;s ever a service that&amp;rsquo;s running amuck (Internet of Things devices?) that&amp;rsquo;s listening, I don&amp;rsquo;t want them to see anything.&lt;/p>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#options">Options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#start-adding-the-certificate">Start adding the certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="#generate-a-cloudflare-api-token">Generate a Cloudflare API token&lt;/a>&lt;/li>
&lt;li>&lt;a href="#change-your-proxy-host-to-use-it">Change your proxy host to use it.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;h2 id="options">Options&lt;/h2>
&lt;p>Option 1: Use Nginx Proxy Manager to request certificates for each subdomain. It works quickly and well. Problem: All certificates are published to Certificate Transparency Logs. I don&amp;rsquo;t immediately mind exposing what I&amp;rsquo;m running&amp;hellip; but I&amp;rsquo;d still rather now.&lt;/p>
&lt;p>Option 2: Set up wildcard certificates. This requires integration with your DNS provider (since wildcards need a DNS challenge, not TCP).&lt;/p>
&lt;p>Of course (based on the title), we&amp;rsquo;re going with option 2. ðŸ˜„&lt;/p></description></item><item><title>Automatic self-signed HTTPS for local development</title><link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link><pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid><description>&lt;p>From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p>
&lt;p>In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p>
&lt;p>Today I will show you &lt;code>autohttps&lt;/code>, a thin nginx proxy using Docker and a &lt;a href="https://en.wikipedia.org/wiki/self%20signed%20certificate">self signed certificate&lt;/a> to automatically create an HTTPS proxy in front of your application.&lt;/p></description></item><item><title>A Quick Look at RC4</title><link>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</link><pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</guid><description>&lt;p>In cryptography work, &lt;a href="https://en.wikipedia.org/wiki/RC4">RC4&lt;/a> (Rivest Cipher 4) is well known as both one of the easiest to implement and fastest to run &lt;a href="https://en.wikipedia.org/wiki/symmetric%20encryption">symmetric encryption&lt;/a> algorithms. Unfortunately, over time there have been a number of attacks on RC4, both in poorly written protocols (such as in the case of &lt;a href="https://en.wikipedia.org/wiki/WEP">WEP&lt;/a>) or statistical attacks against the protocol itself.&lt;/p>
&lt;p>Still, for how well it formed, it&amp;rsquo;s an amazingly simple algorithm, so I decided to try my hand at implementing it.&lt;/p></description></item></channel></rss>