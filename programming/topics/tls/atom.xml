<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TLS on jverkamp.com</title>
    <link>https://blog.jverkamp.com/programming/topics/tls/</link>
    <description>Recent content in TLS on jverkamp.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/tls/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Automatic self-signed HTTPS for local development</title>
      <link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid>
      <description>&lt;p&gt;From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p&gt;
&lt;p&gt;In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p&gt;
&lt;p&gt;Today I will show you &lt;code&gt;autohttps&lt;/code&gt;, a thin nginx proxy using Docker and a &lt;a href=&#34;https://en.wikipedia.org/wiki/self%20signed%20certificate&#34;&gt;self signed certificate&lt;/a&gt; to automatically create an HTTPS proxy in front of your application.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Quick Look at RC4</title>
      <link>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</guid>
      <description>&lt;p&gt;In cryptography work, &lt;a href=&#34;https://en.wikipedia.org/wiki/RC4&#34;&gt;RC4&lt;/a&gt; (Rivest Cipher 4) is well known as both one of the easiest to implement and fastest to run &lt;a href=&#34;https://en.wikipedia.org/wiki/symmetric%20encryption&#34;&gt;symmetric encryption&lt;/a&gt; algorithms. Unfortunately, over time there have been a number of attacks on RC4, both in poorly written protocols (such as in the case of &lt;a href=&#34;https://en.wikipedia.org/wiki/WEP&#34;&gt;WEP&lt;/a&gt;) or statistical attacks against the protocol itself.&lt;/p&gt;
&lt;p&gt;Still, for how well it formed, it&amp;rsquo;s an amazingly simple algorithm, so I decided to try my hand at implementing it.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
