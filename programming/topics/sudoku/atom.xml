<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sudoku on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/sudoku/</link><description>Recent content in Sudoku on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/programming/topics/sudoku/atom.xml" rel="self" type="application/rss+xml"/><item><title>Stateful Solvers and Iterators</title><link>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</guid><description>&lt;p&gt;&lt;a href="programming/languages/rust/"&gt;Rust&lt;/a&gt;, yet again! Let&amp;rsquo;s take what we did last time with &lt;a href="https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/"&gt;Solving Sudoku (again)&lt;/a&gt; and improve the code structure a bit more.&lt;/p&gt;
&lt;p&gt;Goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a &amp;lsquo;Solver&amp;rsquo; struct that can maintain state (such as how many states we&amp;rsquo;ve visited, how much time we&amp;rsquo;ve spent)&lt;/li&gt;
&lt;li&gt;Track the above stats&lt;/li&gt;
&lt;li&gt;Turn the &amp;lsquo;Solver&amp;rsquo; into an iterator which will iterate through given solutions (a single call will give the first solution or you can run through the iterator to get all of them)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;rsquo;d like to follow along, I&amp;rsquo;ve started uploading the code here: &lt;a href="https://github.com/jpverkamp/rust-solvers" target="_blank" rel="noopener"&gt;https://github.com/jpverkamp/rust-solvers&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Solving Sudoku (again)</title><link>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</guid><description>&lt;p&gt;More &lt;a href="programming/languages/rust/"&gt;Rust&lt;/a&gt;! This time, I want to go back to my post on &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/"&gt;A Generic Brute Force Backtracking Solver&lt;/a&gt;. For one, because I&amp;rsquo;m learning Rust. For two, because there is a crate specifically for &lt;code&gt;&lt;a href="https://docs.rs/im/latest/im/"&gt;im&lt;/a&gt;&lt;/code&gt;
mutable data structures. And for three, because I expect it will be much faster. We shall see!&lt;/p&gt;</description></item><item><title>Immutable.js Solvers</title><link>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</guid><description>&lt;p&gt;A bit ago I wrote about writing a &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/"&gt;generic brute force solver&lt;/a&gt; (wow, was that really two months ago?). It got &amp;hellip; complicate. Mostly, because every time I wrote a &lt;code&gt;step&lt;/code&gt; function, I had to be careful to undo the same. Wouldn&amp;rsquo;t it be nice if we could just write a step function and get backtracking for &amp;lsquo;free&amp;rsquo;?&lt;/p&gt;
&lt;p&gt;Well, with immutability you can!&lt;/p&gt;</description></item></channel></rss>