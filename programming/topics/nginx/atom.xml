<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nginx on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/nginx/</link><description>Recent content in nginx on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/nginx/atom.xml" rel="self" type="application/rss+xml"/><item><title>Wildcard Let's Encrypt certificates with Nginx Proxy Manager and Cloudflare</title><link>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</link><pubDate>Mon, 27 Mar 2023 00:02:00 +0000</pubDate><guid>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</guid><description>&lt;p>Another quick snippet that I figured out this weekend. It&amp;rsquo;s not hard, but it&amp;rsquo;s something that I really wanted to do and had to look up where it was, so perhaps it will help you.&lt;/p>
&lt;p>Problem statement:&lt;/p>
&lt;p>I run a bunch of local services in my network. They aren&amp;rsquo;t exposed publicly (I use Wireguard to access them when out and about), so I really don&amp;rsquo;t &lt;em>need&lt;/em> HTTPS. But (rightfully) a number of services behave better when they&amp;rsquo;re behind HTTPS + if there&amp;rsquo;s ever a service that&amp;rsquo;s running amuck (Internet of Things devices?) that&amp;rsquo;s listening, I don&amp;rsquo;t want them to see anything.&lt;/p>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#options">Options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#start-adding-the-certificate">Start adding the certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="#generate-a-cloudflare-api-token">Generate a Cloudflare API token&lt;/a>&lt;/li>
&lt;li>&lt;a href="#change-your-proxy-host-to-use-it">Change your proxy host to use it.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;h2 id="options">Options&lt;/h2>
&lt;p>Option 1: Use Nginx Proxy Manager to request certificates for each subdomain. It works quickly and well. Problem: All certificates are published to Certificate Transparency Logs. I don&amp;rsquo;t immediately mind exposing what I&amp;rsquo;m running&amp;hellip; but I&amp;rsquo;d still rather now.&lt;/p>
&lt;p>Option 2: Set up wildcard certificates. This requires integration with your DNS provider (since wildcards need a DNS challenge, not TCP).&lt;/p>
&lt;p>Of course (based on the title), we&amp;rsquo;re going with option 2. ðŸ˜„&lt;/p></description></item><item><title>Automatic self-signed HTTPS for local development</title><link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link><pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid><description>&lt;p>From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p>
&lt;p>In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p>
&lt;p>Today I will show you &lt;code>autohttps&lt;/code>, a thin nginx proxy using Docker and a &lt;a href="https://en.wikipedia.org/wiki/self%20signed%20certificate">self signed certificate&lt;/a> to automatically create an HTTPS proxy in front of your application.&lt;/p></description></item><item><title>Audiobooks to Podcasts</title><link>https://blog.jverkamp.com/2016/02/26/audiobooks-to-podcasts/</link><pubDate>Fri, 26 Feb 2016 00:05:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/02/26/audiobooks-to-podcasts/</guid><description>&lt;p>I&amp;rsquo;ve recently started to listen to audiobooks again (The Aeronaut&amp;rsquo;s Windlass). If you buy books through Audible or some other setup that has their own app, it&amp;rsquo;s a straight forward enough process. On the other hand, if you have them on CD and want to play them on a mobile device&amp;hellip; It&amp;rsquo;s a little more interesting.&lt;/p>
&lt;p>I tried a few different apps that purport to do exactly what I wanted: import an audiobook as a folder full of MP3s and play them, but none that quite meet what I wanted. Since I also listen to a lot of podcasts and have more than one podcast app that I really like (I&amp;rsquo;ve used and liked both &lt;a href="http://www.downcastapp.com/">Downcast&lt;/a> and &lt;a href="http://www.shiftyjelly.com/pocketcasts">Pocket Casts&lt;/a>), I decided to see if I couldn&amp;rsquo;t use one of those as an audiobook player.&lt;/p></description></item><item><title>Configuring Websockets behind an AWS ELB</title><link>https://blog.jverkamp.com/2015/07/20/configuring-websockets-behind-an-aws-elb/</link><pubDate>Mon, 20 Jul 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/07/20/configuring-websockets-behind-an-aws-elb/</guid><description>&lt;p>Recently at work, we were trying to get an application that uses &lt;a href="https://en.wikipedia.org/wiki/websockets">websockets&lt;/a> working on an &lt;a href="https://aws.amazon.com/">AWS&lt;/a> instance behind an &lt;a href="https://aws.amazon.com/elasticloadbalancing/">ELB (load balancer)&lt;/a> and &lt;a href="http://nginx.org/">nginx&lt;/a> on the instance.&lt;/p>
&lt;p>If you&amp;rsquo;re either not using a secure connection or handling the cryptography on the instance (either in nginx or Flask), it works right out of the box. But if you want the ELB to handle TLS termination it doesn&amp;rsquo;t work nearly as well&amp;hellip; Luckily, after a bit of fiddling, I got it working.&lt;/p>
&lt;p>&lt;strong>Update 2018-05-31:&lt;/strong> A much easier solution, [https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/](just use an ALB):&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>WebSocket&lt;/strong> allows you to set up long-standing TCP connections between your client and your server. This is a more efficient alternative to the old-school method which involved HTTP connections that were held open with a â€œheartbeatâ€ for very long periods of time. WebSocket is great for mobile devices and can be used to deliver stock quotes, sports scores, and other dynamic data while minimizing power consumption. ALB provides native support for WebSocket via the &lt;code>ws://&lt;/code> and &lt;code>wss://&lt;/code> protocols.&lt;/p>
&lt;/blockquote></description></item><item><title>Performance problems with Flask and Docker</title><link>https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/</guid><description>&lt;p>I had an interesting problem recently on a project I was working on. It&amp;rsquo;s a simple &lt;a href="http://flask.pocoo.org/">Flask&lt;/a>-based webapp, designed to be deployed to &lt;a href="https://aws.amazon.com/">AWS&lt;/a> using &lt;a href="https://www.docker.com/">Docker&lt;/a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container&amp;hellip;&lt;/p>
&lt;p>Latency spikes. Bad enough that the application was failing AWS&amp;rsquo;s healthy host checks, cycling in and out of existence&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2015/health-check.png"/>
&lt;/figure></description></item></channel></rss>