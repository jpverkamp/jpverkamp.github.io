<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/security/</link><description>Recent content in Security on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/security/atom.xml" rel="self" type="application/rss+xml"/><item><title>SSRF Protection in Rails</title><link>https://blog.jverkamp.com/2020/06/30/ssrf-protection-in-rails/</link><pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2020/06/30/ssrf-protection-in-rails/</guid><description>&lt;p>One of the more subtle bugs that a lot of companies miss is Server Side Request Forgery (SSRF). Like it&amp;rsquo;s cousin CSRF (cross-site request forgery), SSRF involves carefully crafting a request that runs in a way that the original developers didn&amp;rsquo;t expect to do things that shouldn&amp;rsquo;t be done. In the case of CSRF, one site is making a request on behalf of another in a user&amp;rsquo;s browser (cross-site), but in SSRF, a request is being made by a server on behalf of a client, but you can trick it into making a request that wasn&amp;rsquo;t intended.&lt;/p>
&lt;p>For a perhaps more obvious example, consider a website with a service that will render webpages as preview images&amp;ndash;consider sharing links on a social network. A user makes a request such as &lt;code>/render?url=https://www.google.com&lt;/code>. This goes to the server, which will then fetch &lt;a href="https://www.google.com">https://www.google.com&lt;/a>, render the page to a screenshot, and then return that as a thumbnail.&lt;/p>
&lt;p>This seems like rather useful functionality, but what if instead, the user gives the url: &lt;code>/render?url=https://secret-internal-site.company.com&lt;/code>. Normally, &lt;code>company.com&lt;/code> would be an internal only domain that cannot be viewed by users, but in this case&amp;ndash;the server is within the corporate network. Off the server goes, helpfully taking and returning a screenshot. Another option&amp;ndash;if you&amp;rsquo;re hosted on AWS&amp;ndash;is the AWS &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">metadata endpoint&lt;/a>: &lt;code>http://169.254.169.254/latest/meta-data/&lt;/code>. All sorts of interesting private things there. Or even more insidious, &lt;code>/render?url=file:///etc/password&lt;/code>. That shouldn&amp;rsquo;t work in most cases, since most libraries know better than to rener &lt;code>file://&lt;/code> protocol URLs, but&amp;hellip; not always!&lt;/p></description></item><item><title>Rack::Cors Configuration Tricks</title><link>https://blog.jverkamp.com/2020/01/16/rackcors-configuration-tricks/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2020/01/16/rackcors-configuration-tricks/</guid><description>&lt;p>&lt;a href="https://github.com/cyu/rack-cors">cyu&amp;rsquo;s Rack::Cors middleware&lt;/a> is rather handy if want to control your &lt;a href="https://en.wikipedia.org/wiki/CORS">CORS&lt;/a> (Cross-Origin Resource Sharing) settings in a Ruby-on-Rails project. Previously, there was a fairly major issue where &lt;code>:credentials =&amp;gt; true&lt;/code> was the default (which you generally do not want), but there were also some more complicated tweaks that I wanted to make.&lt;/p>
&lt;p>One problem I recently had to deal with was wanting to:&lt;/p>
&lt;ul>
&lt;li>Allow CORS connections from arbitrary domains (this site functions as an API)&lt;/li>
&lt;li>Do not allow CORS from http domains at all&lt;/li>
&lt;li>Only allow cookies (&lt;code>Access-Control-Allow-Credentials&lt;/code>) to be sent for sibling subdomains&lt;/li>
&lt;li>Prevent cookies from being sent from specific sibling subdomains (that are actually run by a third party)&lt;/li>
&lt;li>On development (non-production) versions of the site, allow credentials from localhost&lt;/li>
&lt;/ul></description></item><item><title>Prevent JavaScript links by parsing URLs</title><link>https://blog.jverkamp.com/2019/05/02/prevent-javascript-links-by-parsing-urls/</link><pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2019/05/02/prevent-javascript-links-by-parsing-urls/</guid><description>&lt;p>If you have a website that allows users to submit URLs, one of the (many many) things people will try to do to break your site is to submit URLs that use the &lt;code>javascript:&lt;/code> protocol (rather than the more expected &lt;code>http:&lt;/code> or &lt;code>https:&lt;/code>). This is almost never something that you want, since it allows users to submit essentially arbitrary code that other users will run on click in the context of your domain (&lt;a href="https://en.wikipedia.org/wiki/same%20origin%20policy">same origin policy&lt;/a>).&lt;/p>
&lt;p>So how do you fix it?&lt;/p>
&lt;p>First thought would be to try to check the protocol:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">safe_url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">url&lt;/span>) =&amp;gt; &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#e6db74">/^javascript:/&lt;/span>)
[Function&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">safe_url&lt;/span>]
&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">safe_url&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;http://www.example.com&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">safe_url&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;javascript:alert(1)&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Forcing Secure Cookies Behind an ELB in Ruby/Rails</title><link>https://blog.jverkamp.com/2019/04/30/forcing-secure-cookies-behind-an-elb-in-ruby/rails/</link><pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2019/04/30/forcing-secure-cookies-behind-an-elb-in-ruby/rails/</guid><description>&lt;p>As part of general security good practices, you should always (whenever possible):&lt;/p>
&lt;ul>
&lt;li>use HTTPS to serve all requests&lt;/li>
&lt;li>serve redirects to upgrade HTTP requests to HTTPS&lt;/li>
&lt;li>set session cookies to &lt;code>secure&lt;/code> and &lt;code>http_only&lt;/code>&lt;/li>
&lt;li>enable HTTP Strict Transport Security (&lt;code>HSTS&lt;/code>)&lt;/li>
&lt;/ul></description></item><item><title>A Quick Look at RC4</title><link>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</link><pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/14/a-quick-look-at-rc4/</guid><description>&lt;p>In cryptography work, &lt;a href="https://en.wikipedia.org/wiki/RC4">RC4&lt;/a> (Rivest Cipher 4) is well known as both one of the easiest to implement and fastest to run &lt;a href="https://en.wikipedia.org/wiki/symmetric%20encryption">symmetric encryption&lt;/a> algorithms. Unfortunately, over time there have been a number of attacks on RC4, both in poorly written protocols (such as in the case of &lt;a href="https://en.wikipedia.org/wiki/WEP">WEP&lt;/a>) or statistical attacks against the protocol itself.&lt;/p>
&lt;p>Still, for how well it formed, it&amp;rsquo;s an amazingly simple algorithm, so I decided to try my hand at implementing it.&lt;/p></description></item><item><title>CSRF protection injection with jQuery and Zend</title><link>https://blog.jverkamp.com/2014/01/13/csrf-protection-injection-with-jquery-and-zend/</link><pubDate>Mon, 13 Jan 2014 14:00:24 +0000</pubDate><guid>https://blog.jverkamp.com/2014/01/13/csrf-protection-injection-with-jquery-and-zend/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Csrf">Cross-site request forgery&lt;/a> attacks are among the most common vulnerabilities against websites, listed as &lt;a href="https://www.owasp.org/index.php/Top_10_2013-A8-Cross-Site_Request_Forgery_(CSRF)">number 8&lt;/a> on &lt;a href="https://www.owasp.org/index.php/Top_10_2013-Top_10">OWASP&amp;rsquo;s 2013 Top 10 list&lt;/a>.&lt;/p></description></item><item><title>Scanning for DNS resolvers</title><link>https://blog.jverkamp.com/2013/01/31/scanning-for-dns-resolvers/</link><pubDate>Thu, 31 Jan 2013 14:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/31/scanning-for-dns-resolvers/</guid><description>&lt;p>For a research project I&amp;rsquo;m working on, it has become necessary to scan potentially large &lt;a href="https://en.wikipedia.org/wiki/Cidr">IPv4 prefixes&lt;/a> in order to find any &lt;a href="https://en.wikipedia.org/wiki/DNS%20resolver">DNS revolvers&lt;/a> that I can and classify them as either open (accepting queries from anyone) or closed.&lt;/p>
&lt;p>Disclaimer: This is a form of &lt;a href="https://en.wikipedia.org/wiki/port%20scanning">port scanning&lt;/a> and thus has associated ethical and legal considerations. Use it at your own risk. &lt;/p>
&lt;p>This project is available on GitHub: &lt;a href="https://github.com/jpverkamp/dnsscan" title="GitHub: jpverkamp: dnsscan">jpverkamp/dnsscan&lt;/a>&lt;/p></description></item></channel></rss>