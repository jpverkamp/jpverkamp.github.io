<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HTTPS on jverkamp.com</title>
    <link>https://blog.jverkamp.com/programming/topics/https/</link>
    <description>Recent content in HTTPS on jverkamp.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.jverkamp.com/programming/topics/https/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Automatic self-signed HTTPS for local development</title>
      <link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid>
      <description>&lt;p&gt;From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p&gt;

&lt;p&gt;In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p&gt;

&lt;p&gt;Today I will show you &lt;code&gt;autohttps&lt;/code&gt;, a thin nginx proxy using Docker and a &lt;a href=&#34;https://en.wikipedia.org/wiki/self%20signed%20certificate&#34;&gt;self signed certificate&lt;/a&gt; to automatically create an HTTPS proxy in front of your application.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>