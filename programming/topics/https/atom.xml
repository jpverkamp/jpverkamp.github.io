<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HTTPS on jverkamp.com</title>
    <link>https://blog.jverkamp.com/programming/topics/https/</link>
    <description>Recent content in HTTPS on jverkamp.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/https/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Adding HSTS to Redirects in Apache</title>
      <link>https://blog.jverkamp.com/2018/07/18/adding-hsts-to-redirects-in-apache/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.jverkamp.com/2018/07/18/adding-hsts-to-redirects-in-apache/</guid>
      <description>&lt;p&gt;TLDR:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-apache&#34; data-lang=&#34;apache&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Use &amp;#39;always&amp;#39; so headers are also set for non-2XX and unset to avoid duplicates&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;IfModule&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;headers_module&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
	header unset Strict-Transport-Security
	header always set Strict-Transport-Security &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;max-age=16070400; includeSubDomains;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/IfModule&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Slightly&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; longer version:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eff.org/https-everywhere&#34;&gt;HTTPS everywhere&lt;/a&gt; is a worthwhile goal. Even when you have traffic that isn&amp;rsquo;t super interesting or sensitive by itself, the fact that you&amp;rsquo;re encrypting it makes traffic that really does need to be encrypted safer against tools that grab all of the encrypted traffic they can to decrypt later if/when possible.&lt;/p&gt;
&lt;p&gt;One of the downsides of using HTTPS though is that without certain things in place, many users will still type &lt;code&gt;domain.com&lt;/code&gt; in their address bar from time to time, completely missing out on the &lt;code&gt;https://&lt;/code&gt;. While you can immediately redirect them, that very first request is a risk, since if a &lt;a href=&#34;https://en.wikipedia.org/wiki/man-in-the-middle%20attack&#34;&gt;man-in-the-middle attack&lt;/a&gt; happens to catch that request, they can downgrade the entire connection.&lt;/p&gt;
&lt;p&gt;Enter &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&#34;&gt;HTTP Strict Transport Security&lt;/a&gt; (HSTS). It&amp;rsquo;s a HTTP header that you can send on the first &lt;code&gt;HTTPS&lt;/code&gt; connection you establish with a compatible client. Once you&amp;rsquo;ve done that, any further requests (until the header&amp;rsquo;s TTL expires without being renewed) will be sent to &lt;code&gt;https://&lt;/code&gt; no matter what the user types. Which solves the first request problem for all sessions&amp;hellip; but it still doesn&amp;rsquo;t fix the very first time you have to get the header. So how do you fix that?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Automatic self-signed HTTPS for local development</title>
      <link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid>
      <description>&lt;p&gt;From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p&gt;
&lt;p&gt;In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p&gt;
&lt;p&gt;Today I will show you &lt;code&gt;autohttps&lt;/code&gt;, a thin nginx proxy using Docker and a &lt;a href=&#34;https://en.wikipedia.org/wiki/self%20signed%20certificate&#34;&gt;self signed certificate&lt;/a&gt; to automatically create an HTTPS proxy in front of your application.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
