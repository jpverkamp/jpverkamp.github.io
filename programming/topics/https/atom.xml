<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTPS on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/https/</link><description>Recent content in HTTPS on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/https/atom.xml" rel="self" type="application/rss+xml"/><item><title>Wildcard Let's Encrypt certificates with Nginx Proxy Manager and Cloudflare</title><link>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</link><pubDate>Mon, 27 Mar 2023 00:02:00 +0000</pubDate><guid>https://blog.jverkamp.com/2023/03/27/wildcard-lets-encrypt-certificates-with-nginx-proxy-manager-and-cloudflare/</guid><description>&lt;p>Another quick snippet that I figured out this weekend. It&amp;rsquo;s not hard, but it&amp;rsquo;s something that I really wanted to do and had to look up where it was, so perhaps it will help you.&lt;/p>
&lt;p>Problem statement:&lt;/p>
&lt;p>I run a bunch of local services in my network. They aren&amp;rsquo;t exposed publicly (I use Wireguard to access them when out and about), so I really don&amp;rsquo;t &lt;em>need&lt;/em> HTTPS. But (rightfully) a number of services behave better when they&amp;rsquo;re behind HTTPS + if there&amp;rsquo;s ever a service that&amp;rsquo;s running amuck (Internet of Things devices?) that&amp;rsquo;s listening, I don&amp;rsquo;t want them to see anything.&lt;/p>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#options">Options&lt;/a>&lt;/li>
&lt;li>&lt;a href="#start-adding-the-certificate">Start adding the certificate&lt;/a>&lt;/li>
&lt;li>&lt;a href="#generate-a-cloudflare-api-token">Generate a Cloudflare API token&lt;/a>&lt;/li>
&lt;li>&lt;a href="#change-your-proxy-host-to-use-it">Change your proxy host to use it.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;h2 id="options">Options&lt;/h2>
&lt;p>Option 1: Use Nginx Proxy Manager to request certificates for each subdomain. It works quickly and well. Problem: All certificates are published to Certificate Transparency Logs. I don&amp;rsquo;t immediately mind exposing what I&amp;rsquo;m running&amp;hellip; but I&amp;rsquo;d still rather now.&lt;/p>
&lt;p>Option 2: Set up wildcard certificates. This requires integration with your DNS provider (since wildcards need a DNS challenge, not TCP).&lt;/p>
&lt;p>Of course (based on the title), we&amp;rsquo;re going with option 2. ðŸ˜„&lt;/p></description></item><item><title>Adding HSTS to Redirects in Apache</title><link>https://blog.jverkamp.com/2018/07/18/adding-hsts-to-redirects-in-apache/</link><pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2018/07/18/adding-hsts-to-redirects-in-apache/</guid><description>&lt;p>TLDR:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-apache" data-lang="apache">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Use &amp;#39;always&amp;#39; so headers are also set for non-2XX and unset to avoid duplicates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;IfModule&lt;/span> &lt;span style="color:#e6db74">headers_module&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> header unset Strict-Transport-Security
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> header always set Strict-Transport-Security &lt;span style="color:#e6db74">&amp;#34;max-age=16070400; includeSubDomains;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/IfModule&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Slightly&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> longer version:&lt;/p>
&lt;p>&lt;a href="https://www.eff.org/https-everywhere" target="_blank" rel="noopener">HTTPS everywhere&lt;/a> is a worthwhile goal. Even when you have traffic that isn&amp;rsquo;t super interesting or sensitive by itself, the fact that you&amp;rsquo;re encrypting it makes traffic that really does need to be encrypted safer against tools that grab all of the encrypted traffic they can to decrypt later if/when possible.&lt;/p>
&lt;p>One of the downsides of using HTTPS though is that without certain things in place, many users will still type &lt;code>domain.com&lt;/code> in their address bar from time to time, completely missing out on the &lt;code>https://&lt;/code>. While you can immediately redirect them, that very first request is a risk, since if a &lt;a href="https://en.wikipedia.org/wiki/man-in-the-middle%20attack">man-in-the-middle attack&lt;/a> happens to catch that request, they can downgrade the entire connection.&lt;/p>
&lt;p>Enter &lt;a href="https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security">HTTP Strict Transport Security&lt;/a> (HSTS). It&amp;rsquo;s a HTTP header that you can send on the first &lt;code>HTTPS&lt;/code> connection you establish with a compatible client. Once you&amp;rsquo;ve done that, any further requests (until the header&amp;rsquo;s TTL expires without being renewed) will be sent to &lt;code>https://&lt;/code> no matter what the user types. Which solves the first request problem for all sessions&amp;hellip; but it still doesn&amp;rsquo;t fix the very first time you have to get the header. So how do you fix that?&lt;/p></description></item><item><title>Automatic self-signed HTTPS for local development</title><link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link><pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid><description>&lt;p>From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p>
&lt;p>In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p>
&lt;p>Today I will show you &lt;code>autohttps&lt;/code>, a thin nginx proxy using Docker and a &lt;a href="https://en.wikipedia.org/wiki/self%20signed%20certificate">self signed certificate&lt;/a> to automatically create an HTTPS proxy in front of your application.&lt;/p></description></item></channel></rss>