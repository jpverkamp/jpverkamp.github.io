<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Generators on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/generators/</link><description>Recent content in Generators on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/generators/atom.xml" rel="self" type="application/rss+xml"/><item><title>Stateful Solvers and Iterators</title><link>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</guid><description>&lt;p>&lt;a href="programming/languages/rust/">Rust&lt;/a>, yet again! Let&amp;rsquo;s take what we did last time with &lt;a href="https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/">Solving Sudoku (again)&lt;/a> and improve the code structure a bit more.&lt;/p>
&lt;p>Goals:&lt;/p>
&lt;ul>
&lt;li>Create a &amp;lsquo;Solver&amp;rsquo; struct that can maintain state (such as how many states we&amp;rsquo;ve visited, how much time we&amp;rsquo;ve spent)&lt;/li>
&lt;li>Track the above stats&lt;/li>
&lt;li>Turn the &amp;lsquo;Solver&amp;rsquo; into an iterator which will iterate through given solutions (a single call will give the first solution or you can run through the iterator to get all of them)&lt;/li>
&lt;/ul>
&lt;p>If you&amp;rsquo;d like to follow along, I&amp;rsquo;ve started uploading the code here: &lt;a href="https://github.com/jpverkamp/rust-solvers">https://github.com/jpverkamp/rust-solvers&lt;/a>&lt;/p></description></item><item><title>Solving Sudoku (again)</title><link>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</guid><description>&lt;p>More &lt;a href="programming/languages/rust/">Rust&lt;/a>! This time, I want to go back to my post on &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/">A Generic Brute Force Backtracking Solver&lt;/a>. For one, because I&amp;rsquo;m learning Rust. For two, because there is a crate specifically for &lt;code>&lt;a href="https://docs.rs/im/latest/im/">im&lt;/a>&lt;/code>
mutable data structures. And for three, because I expect it will be much faster. We shall see!&lt;/p></description></item><item><title>Solving Snakebird</title><link>https://blog.jverkamp.com/2021/08/18/solving-snakebird/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2021/08/18/solving-snakebird/</guid><description>&lt;p>&lt;a href="https://store.steampowered.com/app/357300/Snakebird/">Snakebird!&lt;/a>&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2021/snakebird-0.png"/>
&lt;/figure>
&lt;p>A cute little puzzle game, where you move around snake(birds). Move any number of snakes around the level, eating fruit, and getting to the exit. The main gotchas are that you have gravity to content with&amp;ndash;your snake will easily fall off the edge of the world&amp;ndash;and each time you eat a fruit, your snake gets bigger. This can help get longer to get into hard to reach places or it can cause trouble when you trap yourself in corners.&lt;/p>
&lt;p>Let&amp;rsquo;s use the new &lt;a href="2021-08-17-immutable.js-solvers">immutable.js solver&lt;/a> to solve these problems!&lt;/p></description></item><item><title>Immutable.js Solvers</title><link>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</guid><description>&lt;p>A bit ago I wrote about writing a &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/">generic brute force solver&lt;/a> (wow, was that really two months ago?). It got &amp;hellip; complicate. Mostly, because every time I wrote a &lt;code>step&lt;/code> function, I had to be careful to undo the same. Wouldn&amp;rsquo;t it be nice if we could just write a step function and get backtracking for &amp;lsquo;free&amp;rsquo;?&lt;/p>
&lt;p>Well, with immutability you can!&lt;/p></description></item><item><title>AoC 2017 Day 15: Two Generators</title><link>https://blog.jverkamp.com/2017/12/15/aoc-2017-day-15-two-generators/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/15/aoc-2017-day-15-two-generators/</guid><description>&lt;h3 id="source-dueling-generatorshttpadventofcodecom2017day15">Source: &lt;a href="http://adventofcode.com/2017/day/15">Dueling Generators&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Create a pair of generators &lt;code>A&lt;/code> and &lt;code>B&lt;/code> where:&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;span class="latex-inline">A_n = 16807 A_{n-1} \mod 2147483647&lt;/span>
&lt;/li>
&lt;li>&lt;span class="latex-inline">B_n = 48271 B_{n-1} \mod 2147483647&lt;/span>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>How many of the first 40 million values have matching values for the low 16 bits of each generator?&lt;/p>
&lt;/blockquote></description></item></channel></rss>