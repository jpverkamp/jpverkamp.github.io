<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Proxies on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/proxies/</link><description>Recent content in Proxies on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 15 Feb 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/programming/topics/proxies/atom.xml" rel="self" type="application/rss+xml"/><item><title>Automatic self-signed HTTPS for local development</title><link>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</link><pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2018/02/15/automatic-self-signed-https-for-local-development/</guid><description>&lt;p&gt;From time to time when doing web development, you need to test something related to HTTPS. In some cases, the application you&amp;rsquo;re writing already supports HTTPS natively and that&amp;rsquo;s no problem. But more often (and probably better, in my opinion) is the case when you have another service (be it an AWS ELB or an nginx layer) that will terminate the HTTPS connection for you so your application doesn&amp;rsquo;t have to know how to speak HTTPS.&lt;/p&gt;
&lt;p&gt;In those cases, how can you test functionality that specifically interacts with HTTPS?&lt;/p&gt;
&lt;p&gt;Today I will show you &lt;code&gt;autohttps&lt;/code&gt;, a thin nginx proxy using Docker and a &lt;a href="https://en.wikipedia.org/wiki/self%20signed%20certificate"&gt;self signed certificate&lt;/a&gt; to automatically create an HTTPS proxy in front of your application.&lt;/p&gt;</description></item><item><title>SSH Config ProxyCommand Tricks</title><link>https://blog.jverkamp.com/2017/12/18/ssh-config-proxycommand-tricks/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/18/ssh-config-proxycommand-tricks/</guid><description>&lt;p&gt;Working in security/operations in the tech industry, I use &lt;a href="https://en.wikipedia.org/wiki/SSH"&gt;SSH&lt;/a&gt; a lot. To various different machines (some with hostnames, some without), using various different users and keys, and often (as was the case in my &lt;a href="https://blog.jverkamp.com/2017/12/13/dynamic-automatic-proxies/"&gt;previous post&lt;/a&gt;) via a &lt;a href="https://en.wikipedia.org/wiki/bastion%20host"&gt;bastion host&lt;/a&gt;. Over the years, I&amp;rsquo;ve collected a number of SSH tricks that make my life easier.&lt;/p&gt;</description></item><item><title>Dynamic Automatic Proxies</title><link>https://blog.jverkamp.com/2017/12/13/dynamic-automatic-proxies/</link><pubDate>Wed, 13 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/13/dynamic-automatic-proxies/</guid><description>&lt;p&gt;On of the advantages of working in computer programming is that I can work from anywhere I have a computer and an internet connection. One of the disadvantages is that many of the resources that I need to do my job are locked to only be accessible within a specific network (albeit with a &lt;a href="https://en.wikipedia.org/wiki/bastion%20host"&gt;bastion host&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I long ago set up my SSH config to create an SSH tunnel and I can proxy many applications through that just by setting the &lt;code&gt;HTTP_PROXY&lt;/code&gt; and/or &lt;code&gt;HTTPS_PROXY&lt;/code&gt; environment variables. The downside of this though is that if I&amp;rsquo;m actually on a &amp;lsquo;safe&amp;rsquo; network, there&amp;rsquo;s no reason to use the bastion host and I would actually be putting extra load on it.&lt;/p&gt;
&lt;p&gt;My goal: write something that would let me automatically proxy applications when I need to but not when I don&amp;rsquo;t.&lt;/p&gt;</description></item></channel></rss>