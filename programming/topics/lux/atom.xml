<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lux on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/lux/</link><description>Recent content in Lux on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/lux/atom.xml" rel="self" type="application/rss+xml"/><item><title>CodeCrafters: Build Myself an Interpreter</title><link>https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/</guid><description>Didn&amp;rsquo;t I just do one of these? Well, yes. Yes I did. But I love building compilers and interpreters, so when I saw this one was in beta (and thus free ðŸ˜‰), I had to try it!
It&amp;rsquo;s directly an implemention of the Lox languages from the Crafting Interpreters website / book (my review), if incomplete. By the end of the lesson, we&amp;rsquo;ll have:
A tokenizer that handles parentheses, braces, operators (single and multiple character), whitespace, identifiers, string literals, numeric literals, and keywords A parser that can take those tokens and build an abstract syntax tree using recursive descent parsing A simple tree walking interpreter for some subset of the language It doesn&amp;rsquo;t handle all of the syntax (yet).</description></item></channel></rss>