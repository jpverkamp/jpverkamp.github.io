<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lexers on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/lexers/</link><description>Recent content in Lexers on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 05 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/programming/topics/lexers/atom.xml" rel="self" type="application/rss+xml"/><item><title>Finish Myself a Grep</title><link>https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/</link><pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/10/05/finish-myself-a-grep/</guid><description>&lt;p&gt;Hey, I said that I would follow up on my post about &lt;a href="https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/"&gt;Building Myself a Grep&lt;/a&gt;&amp;hellip; well here it is!&lt;/p&gt;
&lt;p&gt;And I&amp;rsquo;m actually surprised with myself in how far I actually made it!&lt;/p&gt;
&lt;p&gt;You can see the current state of my code &lt;a href="https://github.com/jpverkamp/jp-grep" target="_blank" rel="noopener"&gt;on Github&lt;/a&gt;. You can install it from that repo (checked out) with &lt;code&gt;cargo install --path .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I mostly worked off the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions" target="_blank" rel="noopener"&gt;MDN documentation&lt;/a&gt;:&lt;/p&gt;
&lt;h2 id="details"&gt;Details&lt;/h2&gt;
&lt;nav id="TableOfContents"&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#details"&gt;Details&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#supported-regex-features"&gt;Supported Regex Features&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#unsupported-regex-features-so-far"&gt;Unsupported Regex Features (so far!)&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#supported-cli-flags"&gt;Supported CLI flags&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#unsupported-cli-flags"&gt;Unsupported CLI flags&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#error-handling"&gt;Error handling&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#expanding-past-codecrafters"&gt;Expanding past CodeCrafters&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#collecting-files"&gt;Collecting files&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#printing-lines"&gt;Printing lines&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
&lt;/nav&gt;

&lt;h2 id="supported-regex-features"&gt;Supported Regex Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Assertions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; for entire patterns&lt;/li&gt;
&lt;li&gt;Parsing look head/behind (not matched)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Character classes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single characters: &lt;code&gt;[abc]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ranges: &lt;code&gt;[a-z]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Negated classes: &lt;code&gt;[^abc]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Wildcards: &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Classes: &lt;code&gt;\d&lt;/code&gt;/&lt;code&gt;\D&lt;/code&gt; for digits, &lt;code&gt;\w&lt;/code&gt;/&lt;code&gt;\W&lt;/code&gt; for &amp;lsquo;words&amp;rsquo;, and &lt;code&gt;\s&lt;/code&gt;/&lt;code&gt;\S&lt;/code&gt; for whitespace&lt;/li&gt;
&lt;li&gt;Escape characters: &lt;code&gt;\t\r\n\v\f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Control characters: &lt;code&gt;\cX&lt;/code&gt; (I&amp;rsquo;ve never used these)&lt;/li&gt;
&lt;li&gt;Hex and unicode literals: &lt;code&gt;\hXX&lt;/code&gt; and &lt;code&gt;\uXXXX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Disjunction: &lt;code&gt;|&lt;/code&gt; (both in capture groups and not)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Groups and back references&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Capture groups: &lt;code&gt;(abc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Named capture groups: &lt;code&gt;(?&amp;lt;name&amp;gt;abc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Non-capturing groups: &lt;code&gt;(?:abc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Flags: &lt;code&gt;(?ims-ims:abc)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Both enabling and disabling&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; but not &lt;code&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Backreferences: &lt;code&gt;\n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Named backreferences: &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quantifiers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; for zero or more&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; for one or more&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; for zero or one&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; for lazy / non-greedy matches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abc{n}&lt;/code&gt; exactly n matches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abc{n,}&lt;/code&gt; at least n matches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abc{,m}&lt;/code&gt; up to m matches&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abc{n,m}&lt;/code&gt; at least n and up to m matches (inclusive)&lt;/li&gt;
&lt;li&gt;Lazy matches for all of those&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of those were fairly straight forward extensions of previous code. In think the most interesting ones were handling the parsing of all the different things that can go in groups (including flags).&lt;/p&gt;
&lt;p&gt;For each of them, you can check my &lt;a href="https://github.com/jpverkamp/jp-grep/commits/main/" target="_blank" rel="noopener"&gt;git commit history&lt;/a&gt; to see how I implemented specific things. It&amp;rsquo;s mostly one commit per feature, but not always.&lt;/p&gt;
&lt;h2 id="unsupported-regex-features-so-far"&gt;Unsupported Regex Features (so far!)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Assertions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Word boundaries (&lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Look ahead/behind (parsed but not matched)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Character classes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[\b]&lt;/code&gt; for backspace characters&lt;/li&gt;
&lt;li&gt;Long unicode format: &lt;code&gt;\u{XXXXX}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Unicode properties: &lt;code&gt;\p{...}&lt;/code&gt;/&lt;code&gt;\P{...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Groups and back references:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; flag / mode: multiline matches&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The look ahead/behind is the one I&amp;rsquo;m most interested in supporting. I don&amp;rsquo;t even think it will be that hard, I just honestly missed it.&lt;/p&gt;
&lt;p&gt;The more interesting one will be the &lt;code&gt;m&lt;/code&gt; flag. Currently, I only match lines, so that will be a decently large restructuring. We&amp;rsquo;ll see.&lt;/p&gt;
&lt;h2 id="supported-cli-flags"&gt;Supported CLI flags&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve made an awful lot of progress on this one too!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ jp-grep --help
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;A custom grep implementation; always behaves as egrep
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Usage: jp-grep &lt;span style="color:#f92672"&gt;[&lt;/span&gt;OPTIONS&lt;span style="color:#f92672"&gt;]&lt;/span&gt; &lt;span style="color:#f92672"&gt;[&lt;/span&gt;PATTERN&lt;span style="color:#f92672"&gt;]&lt;/span&gt; &lt;span style="color:#f92672"&gt;[&lt;/span&gt;PATHS&lt;span style="color:#f92672"&gt;]&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Arguments:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;[&lt;/span&gt;PATTERN&lt;span style="color:#f92672"&gt;]&lt;/span&gt; The regular expression to evaluate; may also be specified with -e
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;[&lt;/span&gt;PATHS&lt;span style="color:#f92672"&gt;]&lt;/span&gt;... Paths to search &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; matches; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; none are provided read from stdin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Options:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -A, --after-context &amp;lt;AFTER_CONTEXT&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Lines of context to print after each match
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -B, --before-context &amp;lt;BEFORE_CONTEXT&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Lines of context to print before each match
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -C, --context &amp;lt;CONTEXT&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Lines to print both before and after
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -c, --count
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Only print the matching count
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -E, --extended-regexp
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Extended regex mode &lt;span style="color:#f92672"&gt;(&lt;/span&gt;egrep&lt;span style="color:#f92672"&gt;)&lt;/span&gt;; this option is ignored &lt;span style="color:#f92672"&gt;(&lt;/span&gt;always true&lt;span style="color:#f92672"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -e, --regexp &amp;lt;ADDITIONAL_PATTERNS&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Additional patterns, will &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; a line &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; any match
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -h, --no-filename
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Never print filenames
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; --help
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Display this help message
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -i, --ignore-case
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Default to &lt;span style="color:#66d9ef"&gt;case&lt;/span&gt; insensitive match
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -n, --line-number
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Print line numbers before matches and context
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -r, --recursive
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Recursively add any directories &lt;span style="color:#f92672"&gt;(&lt;/span&gt;-R also works&lt;span style="color:#f92672"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -v, --invert-match
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Invert the match; only print lines that don&lt;span style="color:#960050;background-color:#1e0010"&gt;&amp;#39;&lt;/span&gt;t match any pattern
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -V, --version
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Print version
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of those, the context flags (&lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;-B&lt;/code&gt;, and &lt;code&gt;-C&lt;/code&gt;) were probably the most tricky, since I basically had to implement a &lt;a href="https://en.wikipedia.org/wiki/circular%20buffer"&gt;circular buffer&lt;/a&gt; for them. I could have just read the entire file into memory, but from the beginning, I didn&amp;rsquo;t want to do that.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-E&lt;/code&gt; is a little silly, since that&amp;rsquo;s the only &lt;code&gt;grep&lt;/code&gt; pattern I support (and the only one I actually use in &lt;code&gt;grep&lt;/code&gt;, so that&amp;rsquo;s fair).&lt;/p&gt;
&lt;p&gt;So far as supporting multiple files, recursive search, and stdin, read the section on &lt;a href="#collecting-files"&gt;collecting files&lt;/a&gt; later.&lt;/p&gt;
&lt;p&gt;So far as printing (handling line numbers and file names), read the section on &lt;a href="#printing-lines"&gt;printing lines&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Overall, pretty fun code.&lt;/p&gt;
&lt;h2 id="unsupported-cli-flags"&gt;Unsupported CLI flags&lt;/h2&gt;
&lt;p&gt;So far, there are a bunch of flags that I don&amp;rsquo;t support for grep. Of those, there are a bunch that I don&amp;rsquo;t intend to support (like built in compression support and properly dealing with symlinks).&lt;/p&gt;
&lt;p&gt;The things that I would still like to support though are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Input options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f file&lt;/code&gt;/&lt;code&gt;--file=file&lt;/code&gt; - Read patterns from file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Output options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--text&lt;/code&gt; - Currently I always have this set; I don&amp;rsquo;t treat binary files differently&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt;/&lt;code&gt;--files-without-match&lt;/code&gt; - only print files that don&amp;rsquo;t match&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;/&lt;code&gt;--only-matching&lt;/code&gt; - only print the matching groups; I have the groups for backreferences, use them!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;File filtering - files to include/exclude (useful with recursive matches):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--exclude pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exclude-dir pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--include pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--include-dir pattern&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That&amp;rsquo;s not too bad, all things consider.&lt;/p&gt;
&lt;h2 id="error-handling"&gt;Error handling&lt;/h2&gt;
&lt;p&gt;One thing that I actually played a bit with this time around was custom error handling in the parser. Rather than just returning &lt;code&gt;&amp;amp;str&lt;/code&gt; all over the place for &lt;code&gt;Err&lt;/code&gt; types, I made my own:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-rust" data-lang="rust"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;pub&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;crate&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;enum&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ParserError&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; RemainingInput,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; UnexpectedEnd,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; InvalidCharacter(&lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;, &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;&amp;#39;static &lt;span style="color:#66d9ef"&gt;str&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; InvalidUnicodeCodePoint(&lt;span style="color:#66d9ef"&gt;u32&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; InvalidRange(&lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; InvalidRepeatRange(&lt;span style="color:#66d9ef"&gt;u32&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;u32&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;impl&lt;/span&gt; std::fmt::Display &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; ParserError {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fmt&lt;/span&gt;(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;self, f: &lt;span style="color:#66d9ef"&gt;&amp;amp;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;mut&lt;/span&gt; std::fmt::Formatter&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style="color:#a6e22e"&gt;std&lt;/span&gt;::fmt::Result {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;match&lt;/span&gt; self {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::RemainingInput &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Unexpected input after parsing&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::UnexpectedEnd &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Unexpected end of input&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::InvalidCharacter(c, expected) &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Invalid character &amp;#39;{}&amp;#39;, expected {}&amp;#34;&lt;/span&gt;, c, expected)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::InvalidUnicodeCodePoint(code_point) &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Invalid unicode code point: {}&amp;#34;&lt;/span&gt;, code_point)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::InvalidRange(start, end) &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Invalid range: {}-{}&amp;#34;&lt;/span&gt;, start, end)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ParserError::InvalidRepeatRange(start, end) &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;write!&lt;/span&gt;(f, &lt;span style="color:#e6db74"&gt;&amp;#34;Invalid range: {}-{}&amp;#34;&lt;/span&gt;, start, end)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;pub&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;crate&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ParserErrorWithPosition&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;pub&lt;/span&gt; position: &lt;span style="color:#66d9ef"&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;pub&lt;/span&gt; error: &lt;span style="color:#a6e22e"&gt;ParserError&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;WithPosition&lt;/code&gt; type also lets me pinpoint exactly where in a pattern I failed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-rust" data-lang="rust"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;jp&lt;span style="color:#f92672"&gt;-&lt;/span&gt;grep &lt;span style="color:#a6e22e"&gt;&amp;#39;this&lt;/span&gt; is some long complicated pattern, &lt;span style="color:#960050;background-color:#1e0010"&gt;\&lt;/span&gt;hXX see&lt;span style="color:#f92672"&gt;?&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Error parsing regex: &lt;span style="color:#a6e22e"&gt;Invalid&lt;/span&gt; character &lt;span style="color:#e6db74"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, expected hex digit
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;|&lt;/span&gt; this is some long complicated pattern, &lt;span style="color:#960050;background-color:#1e0010"&gt;\&lt;/span&gt;hXX see&lt;span style="color:#f92672"&gt;?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;|&lt;/span&gt; &lt;span style="color:#f92672"&gt;^&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That&amp;rsquo;s pretty neat and I hope helpful! &amp;#x1f604;&lt;/p&gt;
&lt;h2 id="expanding-past-codecrafters"&gt;Expanding past CodeCrafters&lt;/h2&gt;
&lt;p&gt;Overall, I&amp;rsquo;m pretty happy with this project. It&amp;rsquo;s got a pretty decent chunk of code, including&amp;hellip;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ jp-grep -c -v -e &lt;span style="color:#e6db74"&gt;&amp;#39;//&amp;#39;&lt;/span&gt; -e &lt;span style="color:#e6db74"&gt;&amp;#39;^\s*$&amp;#39;&lt;/span&gt; **/*.rs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ae81ff"&gt;1241&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&amp;hellip;over 1000 lines of Rust code, including tests but not blank lines or comments. &amp;#x1f604;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll probably pick this up at least once more.&lt;/p&gt;
&lt;p&gt;Now&amp;hellip; will I actually use this? Probably not. But it was certainly interesting to write.&lt;/p&gt;
&lt;p&gt;Other than that, was CodeCrafters actually helpful for this? Middling. It was the kick I needed to actually do it (I&amp;rsquo;ve been meaning to write this for &lt;em&gt;years&lt;/em&gt; at this point) and once I was started, I could finish it. On the other hand, the output format they require was a bit annoying at times, I&amp;rsquo;ve mostly moved away from that.&lt;/p&gt;
&lt;p&gt;Still, worth I think. I&amp;rsquo;ll probably continue to do their free programs. Kafka is up next. Whee servers!&lt;/p&gt;</description></item><item><title>CodeCrafters: Build Myself an Interpreter</title><link>https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/09/04/codecrafters-build-myself-an-interpreter/</guid><description>&lt;p&gt;Didn&amp;rsquo;t I &lt;a href="https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/"&gt;just do one of these&lt;/a&gt;? Well, yes. Yes I did. But I love building &lt;a href="https://blog.jverkamp.com/programming/topics/compilers/"&gt;compilers and interpreters&lt;/a&gt;, so when I saw this one was in beta (and thus free &amp;#x1f609;), I had to try it!&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s directly an implemention of the Lox languages from the &lt;a href="https://craftinginterpreters.com/" target="_blank" rel="noopener"&gt;Crafting Interpreters&lt;/a&gt; website / book (&lt;a href="https://blog.jverkamp.com/2021/06/12/crafting-interpreters/"&gt;my review&lt;/a&gt;), if incomplete. By the end of the lesson, we&amp;rsquo;ll have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href="https://en.wikipedia.org/wiki/tokenizer"&gt;tokenizer&lt;/a&gt; that handles parentheses, braces, operators (single and multiple character), whitespace, identifiers, string literals, numeric literals, and keywords&lt;/li&gt;
&lt;li&gt;A &lt;a href="https://en.wikipedia.org/wiki/parser"&gt;parser&lt;/a&gt; that can take those tokens and build an &lt;a href="https://en.wikipedia.org/wiki/abstract%20syntax%20tree"&gt;abstract syntax tree&lt;/a&gt; using &lt;a href="https://en.wikipedia.org/wiki/recursive%20descent%20parsing"&gt;recursive descent parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A simple &lt;a href="https://en.wikipedia.org/wiki/tree%20walking%20interpreter"&gt;tree walking interpreter&lt;/a&gt; for some subset of the language&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It doesn&amp;rsquo;t handle all of the syntax (yet). In particular, we don&amp;rsquo;t have functions, control statements like &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; or custom &lt;code&gt;class&lt;/code&gt;es. These seem&amp;hellip; kind of important! But it&amp;rsquo;s a start and something I can definitely see myself building more on it.&lt;/p&gt;</description></item><item><title>CodeCrafters: Build Myself a Grep</title><link>https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/</link><pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/08/28/codecrafters-build-myself-a-grep/</guid><description>&lt;p&gt;I recently stumbled across &lt;a href="https://codecrafters.io/" target="_blank" rel="noopener"&gt;CodeCrafters&lt;/a&gt; again&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;. In a nutshell, they give a number of &amp;lsquo;Build Your Own&amp;hellip;&amp;rsquo; courses, each of which will automatically create a repo for you, guide you through solving the program step by step, and provide some feedback on the way.&lt;/p&gt;
&lt;p&gt;On one hand, it&amp;rsquo;s a freemium (one problem a month is free) / paid service. I wish they had tiers. I really think their monthly fee is a bit steep for what they offer (we&amp;rsquo;ll come back to that). But on the other hand, it&amp;rsquo;s a neat tool and I&amp;rsquo;ve been wanting some more larger programming projects to learn more Rust on, so away we go!&lt;/p&gt;
&lt;p&gt;First up, &lt;a href="https://en.wikipedia.org/wiki/grep"&gt;grep&lt;/a&gt;!&lt;/p&gt;</description></item></channel></rss>