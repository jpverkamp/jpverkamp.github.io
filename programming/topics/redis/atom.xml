<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/redis/</link><description>Recent content in Redis on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/redis/atom.xml" rel="self" type="application/rss+xml"/><item><title>Cloning Redis in Rust: RESP [Part 1]</title><link>https://blog.jverkamp.com/2023/01/31/cloning-redis-in-rust-resp-part-1/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2023/01/31/cloning-redis-in-rust-resp-part-1/</guid><description>&lt;p>Recently, I read through &lt;a href="https://blog.jverkamp.com/2023/01/31/build-your-own-redis-with-c/c-/">Build Your Own Redis with C/C++&lt;/a>. C/C++ are ugly, so let&amp;rsquo;s run through it in Rust!&lt;/p>
&lt;p>My goal: implement some large subset of &lt;a href="https://redis.io/">Redis&lt;/a> (both server and client) in Rust. For any features I implement, it should be compatible with Redis off the shelf. I should be able to use their client with my server and their server with my client and it should just work.&lt;/p>
&lt;p>No idea if this is going to work out, but it sounds like an interesting problem!&lt;/p>
&lt;p>First task: &lt;a href="https://redis.io/docs/reference/protocol-spec/">the REdis Serialization Protocol (RESP)&lt;/a>.&lt;/p></description></item><item><title>Directly monitoring Sidekiq in Redis</title><link>https://blog.jverkamp.com/2020/07/14/directly-monitoring-sidekiq-in-redis/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2020/07/14/directly-monitoring-sidekiq-in-redis/</guid><description>&lt;p>Another thing that came up recently: we have many (many) &lt;a href="https://github.com/mperham/sidekiq">sidekiq&lt;/a> queues. Each has their own admin interface, but sometimes you just want all of the information in one place. Of course, you could bookmark all of the pages. Or make a single page with a lot of frames (remember &lt;a href="https://en.wikipedia.org/wiki/HTML%20frames">HTML frames&lt;/a>?). Or use their API. But where&amp;rsquo;s the fun in that? Instead, let&amp;rsquo;s dig straight into the redis backend and see what we can see!&lt;/p></description></item><item><title>Automagically storing Python objects in Redis</title><link>https://blog.jverkamp.com/2015/07/16/automagically-storing-python-objects-in-redis/</link><pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/07/16/automagically-storing-python-objects-in-redis/</guid><description>&lt;p>When you&amp;rsquo;re starting out on a simple web application, eventually&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> you will reach the point where you need to store some form of persistant data. Basically, you have three options&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>:&lt;/p>
&lt;ul>
&lt;li>Store the information in flat files on the file system&lt;/li>
&lt;li>Store the information in a database (&lt;a href="https://www.mysql.com/">MySQL&lt;/a>, &lt;a href="https://www.sqlite.org/">SQLite&lt;/a> etc)&lt;/li>
&lt;li>Store the information in a key/value store (&lt;a href="https://www.mongodb.org/">mongoDB&lt;/a>, &lt;a href="http://redis.io/">reddis&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>There are all manner of pros and cons to each, in particular how easy they are to get started in, how well they fit the data you are using, and how well they will scale horizontally (adding more machines rather than bigger ones).&lt;/p></description></item></channel></rss>