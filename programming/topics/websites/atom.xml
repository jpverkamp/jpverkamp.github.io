<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Websites on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/websites/</link><description>Recent content in Websites on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/websites/atom.xml" rel="self" type="application/rss+xml"/><item><title>SSRF Protection in Rails</title><link>https://blog.jverkamp.com/2020/06/30/ssrf-protection-in-rails/</link><pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2020/06/30/ssrf-protection-in-rails/</guid><description>&lt;p>One of the more subtle bugs that a lot of companies miss is Server Side Request Forgery (SSRF). Like it&amp;rsquo;s cousin CSRF (cross-site request forgery), SSRF involves carefully crafting a request that runs in a way that the original developers didn&amp;rsquo;t expect to do things that shouldn&amp;rsquo;t be done. In the case of CSRF, one site is making a request on behalf of another in a user&amp;rsquo;s browser (cross-site), but in SSRF, a request is being made by a server on behalf of a client, but you can trick it into making a request that wasn&amp;rsquo;t intended.&lt;/p>
&lt;p>For a perhaps more obvious example, consider a website with a service that will render webpages as preview images&amp;ndash;consider sharing links on a social network. A user makes a request such as &lt;code>/render?url=https://www.google.com&lt;/code>. This goes to the server, which will then fetch &lt;a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com&lt;/a>, render the page to a screenshot, and then return that as a thumbnail.&lt;/p>
&lt;p>This seems like rather useful functionality, but what if instead, the user gives the url: &lt;code>/render?url=https://secret-internal-site.company.com&lt;/code>. Normally, &lt;code>company.com&lt;/code> would be an internal only domain that cannot be viewed by users, but in this case&amp;ndash;the server is within the corporate network. Off the server goes, helpfully taking and returning a screenshot. Another option&amp;ndash;if you&amp;rsquo;re hosted on AWS&amp;ndash;is the AWS &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html" target="_blank" rel="noopener">metadata endpoint&lt;/a>: &lt;code>http://169.254.169.254/latest/meta-data/&lt;/code>. All sorts of interesting private things there. Or even more insidious, &lt;code>/render?url=file:///etc/password&lt;/code>. That shouldn&amp;rsquo;t work in most cases, since most libraries know better than to rener &lt;code>file://&lt;/code> protocol URLs, but&amp;hellip; not always!&lt;/p></description></item><item><title>Observation Server</title><link>https://blog.jverkamp.com/2020/06/10/observation-server/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2020/06/10/observation-server/</guid><description>&lt;p>For a number of years now, I&amp;rsquo;ve been writing down my &amp;lsquo;observations&amp;rsquo;. Essentially, it&amp;rsquo;s a semi-structured set of text files that I keep in Dropbox. One for each day, in a folder by month. I record interesting people I see, things I did worth doing, and things my children did which were adorable.&lt;/p>
&lt;p>After a while, I started wanting to look back, so first, I wrote a relatively simple script that would go back through my archives and send me everything I did 1/2/3/4/etc years ago. That worked well enough, but it ended up generating a lot of emails to go through some days. So the second generation is a server that can format those pages and display them as a nice webpage.&lt;/p>
&lt;p>The most interesting part perhaps was dealing with the tarballs that I keep the archives in (they&amp;rsquo;re plain text, so they compress very well). I wanted to keep them compressed, so I had to decompress them in memory on the fly.&lt;/p></description></item><item><title>Configuring Websockets behind an AWS ELB</title><link>https://blog.jverkamp.com/2015/07/20/configuring-websockets-behind-an-aws-elb/</link><pubDate>Mon, 20 Jul 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/07/20/configuring-websockets-behind-an-aws-elb/</guid><description>&lt;p>Recently at work, we were trying to get an application that uses &lt;a href="https://en.wikipedia.org/wiki/websockets">websockets&lt;/a> working on an &lt;a href="https://aws.amazon.com/">AWS&lt;/a> instance behind an &lt;a href="https://aws.amazon.com/elasticloadbalancing/">ELB (load balancer)&lt;/a> and &lt;a href="http://nginx.org/">nginx&lt;/a> on the instance.&lt;/p>
&lt;p>If you&amp;rsquo;re either not using a secure connection or handling the cryptography on the instance (either in nginx or Flask), it works right out of the box. But if you want the ELB to handle TLS termination it doesn&amp;rsquo;t work nearly as well&amp;hellip; Luckily, after a bit of fiddling, I got it working.&lt;/p>
&lt;p>&lt;strong>Update 2018-05-31:&lt;/strong> A much easier solution, [https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/](just use an ALB):&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>WebSocket&lt;/strong> allows you to set up long-standing TCP connections between your client and your server. This is a more efficient alternative to the old-school method which involved HTTP connections that were held open with a “heartbeat” for very long periods of time. WebSocket is great for mobile devices and can be used to deliver stock quotes, sports scores, and other dynamic data while minimizing power consumption. ALB provides native support for WebSocket via the &lt;code>ws://&lt;/code> and &lt;code>wss://&lt;/code> protocols.&lt;/p>
&lt;/blockquote></description></item><item><title>Performance problems with Flask and Docker</title><link>https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/</link><pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/04/03/performance-problems-with-flask-and-docker/</guid><description>&lt;p>I had an interesting problem recently on a project I was working on. It&amp;rsquo;s a simple &lt;a href="http://flask.pocoo.org/">Flask&lt;/a>-based webapp, designed to be deployed to &lt;a href="https://aws.amazon.com/">AWS&lt;/a> using &lt;a href="https://www.docker.com/">Docker&lt;/a>. The application worked just fine when I was running it locally, but as soon as I pushed the docker container&amp;hellip;&lt;/p>
&lt;p>Latency spikes. Bad enough that the application was failing AWS&amp;rsquo;s healthy host checks, cycling in and out of existence&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2015/health-check.png"/>
&lt;/figure></description></item></channel></rss>