<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hashes on jverkamp.com</title><link>https://blog.jverkamp.com/programming/topics/hashes/</link><description>Recent content in Hashes on jverkamp.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://blog.jverkamp.com/programming/topics/hashes/atom.xml" rel="self" type="application/rss+xml"/><item><title>AoC 2017 Day 14: Knot Hash Gridinator</title><link>https://blog.jverkamp.com/2017/12/14/aoc-2017-day-14-knot-hash-gridinator/</link><pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/14/aoc-2017-day-14-knot-hash-gridinator/</guid><description>&lt;h3 id="source-disk-defragmentationhttpadventofcodecom2017day14">Source: &lt;a href="http://adventofcode.com/2017/day/14" target="_blank" rel="noopener">Disk Defragmentation&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Create a 128x128 grid. Generate each row by taking the &lt;a href="https://blog.jverkamp.com/2017/12/10/aoc-2017-day-10-knot-cool/">knot hash&lt;/a> of &lt;code>salt-{index}&lt;/code>. The bits of the hash represent if a tile in the grid is &lt;code>free&lt;/code> (&lt;code>0&lt;/code>) or &lt;code>used&lt;/code> (&lt;code>1&lt;/code>).&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Given your salt as input, how many squares are &lt;code>used&lt;/code>?&lt;/p>
&lt;/blockquote></description></item><item><title>Deterministic Shuffling Using Hashes</title><link>https://blog.jverkamp.com/2017/12/11/deterministic-shuffling-using-hashes/</link><pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/11/deterministic-shuffling-using-hashes/</guid><description>&lt;p>Whenever I create my &lt;a href="https://blog.jverkamp.com/2017/01/01/2017-reading-list/">yearly reading list&lt;/a>, I need a way to order the books. Sure, I could just shuffle them normally, but that leads me to the temptation of cheating and re-shuffling them so that the books I want to read most are first. What I really need is a shuffle that will shuffle the same way every time.&lt;/p>
&lt;p>Enter: hashsort&lt;/p></description></item><item><title>AoC 2017 Day 10: Knot Cool</title><link>https://blog.jverkamp.com/2017/12/10/aoc-2017-day-10-knot-cool/</link><pubDate>Sun, 10 Dec 2017 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2017/12/10/aoc-2017-day-10-knot-cool/</guid><description>&lt;h3 id="source-knot-hashhttpadventofcodecom2017day10">Source: &lt;a href="http://adventofcode.com/2017/day/10" target="_blank" rel="noopener">Knot Hash&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Starting with a list of the numbers from &lt;code>1&lt;/code> to &lt;code>n&lt;/code> and a list of &lt;code>lengths&lt;/code> (as input):&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ol>
&lt;li>Initialize &lt;code>current_position&lt;/code> and &lt;code>skip_size&lt;/code> to &lt;code>0&lt;/code>&lt;/li>
&lt;li>For each &lt;code>length&lt;/code> element in the &lt;code>lengths&lt;/code> list:&lt;/li>
&lt;li>Reverse the first &lt;code>length&lt;/code> elements of the list (starting at &lt;code>current_position&lt;/code>)&lt;/li>
&lt;li>Move forward by &lt;code>length&lt;/code> plus &lt;code>skip_size&lt;/code>&lt;/li>
&lt;li>Increment &lt;code>skip_size&lt;/code> by 1&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;blockquote>
&lt;p>After applying the above algorithm, what is the product of the first two elements in the list (from the original first position, not the &lt;code>current_position&lt;/code>)?&lt;/p>
&lt;/blockquote></description></item><item><title>AoC 2016 Day 17: Md5 Maze</title><link>https://blog.jverkamp.com/2016/12/17/aoc-2016-day-17-md5-maze/</link><pubDate>Sat, 17 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/17/aoc-2016-day-17-md5-maze/</guid><description>&lt;h3 id="source-two-steps-forwardhttpadventofcodecom2016day17">Source: &lt;a href="http://adventofcode.com/2016/day/17" target="_blank" rel="noopener">Two Steps Forward&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Create a 4x4 grid of rooms with doors &lt;code>U&lt;/code>p, &lt;code>D&lt;/code>own, &lt;code>L&lt;/code>eft, and &lt;code>R&lt;/code>ight from each location. To determine if a door is currently open:&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>Calculate &lt;code>MD5(salt + sequence)&lt;/code> where sequence is a string containing any combination of &lt;code>UDLR&lt;/code> depending on how you got to this room&lt;/li>
&lt;li>The first four hex values represent the doors &lt;code>U&lt;/code>p, &lt;code>D&lt;/code>own, &lt;code>L&lt;/code>eft, and &lt;code>R&lt;/code>ight respectively: &lt;code>bcdef&lt;/code> means open; anything else is closed&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Find the shortest path from &lt;code>(0, 0)&lt;/code> to &lt;code>(3, 3)&lt;/code>.&lt;/p>
&lt;/blockquote></description></item><item><title>AoC 2016 Day 14: Bad One Time Pads</title><link>https://blog.jverkamp.com/2016/12/14/aoc-2016-day-14-bad-one-time-pads/</link><pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/14/aoc-2016-day-14-bad-one-time-pads/</guid><description>&lt;h3 id="source-one-time-padhttpadventofcodecom2016day14">Source: &lt;a href="http://adventofcode.com/2016/day/14" target="_blank" rel="noopener">One-Time Pad&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Calculate a series of MD5 hashes (the same as &lt;a href="https://blog.jverkamp.com/2016/12/05/aoc-2016-day-5-password-cracker/">Day 5&lt;/a>). A hash is considered valid if it contains a triple (three characters in a row) and somewhere in the next 1000 hashes there is a quintuple of that same character.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>What index produces the 64th key?&lt;/p>
&lt;/blockquote></description></item><item><title>AoC 2016 Day 5: Password Cracker</title><link>https://blog.jverkamp.com/2016/12/05/aoc-2016-day-5-password-cracker/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/05/aoc-2016-day-5-password-cracker/</guid><description>&lt;h3 id="source-how-about-a-nice-game-of-chesshttpadventofcodecom2016day5">Source: &lt;a href="http://adventofcode.com/2016/day/5" target="_blank" rel="noopener">How About a Nice Game of Chess?&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Generate a series of hashes: MD5(salt + index). For each hash starting with five zeros, write down the sixth character.&lt;/p>
&lt;/blockquote></description></item><item><title>Exploring parallelism in Racket with SHA-512 mining</title><link>https://blog.jverkamp.com/2014/02/16/exploring-parallelism-in-racket-with-sha-512-mining/</link><pubDate>Sun, 16 Feb 2014 14:00:30 +0000</pubDate><guid>https://blog.jverkamp.com/2014/02/16/exploring-parallelism-in-racket-with-sha-512-mining/</guid><description>&lt;p>While I&amp;rsquo;ve been getting a fair few programming exercises from Reddit&amp;rsquo;s &lt;a href="http://www.reddit.com/r/dailyprogrammer">/r/dailyprogrammer&lt;/a>, more recently I&amp;rsquo;ve started following a few other sub-Reddits, such as &lt;a href="http://www.reddit.com/r/programming">/r/programming&lt;/a> and &lt;a href="http://www.reddit.com/r/netsec">/r/netsec&lt;/a>. While browsing the former, I came across this intriguing gem of a problem:Â &lt;a tabindex="1" href="http://www.h11e.com/">HashChallenge: can you find the lowest value SHA-512 hash?&lt;/a>&lt;/p></description></item></channel></rss>