<!doctype html><html><head><title>AoC 2025 Day 12: Knapsackinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.a8e11addf4349ee2ca5045f7f3cbf1febbf2c3a2840be2143ea69539c10f8c7f.js integrity="sha256-qOEa3fQ0nuLKUEX388vx/rvyw6KEC+IUPqaVOcEPjH8=" defer></script><script src=/katex_17296078054267651618.min.4a06464d8d6f8358d8896de62b53b5a89205d335dfd8c5b6b27edd7c039ae9d8.js integrity="sha256-SgZGTY1vg1jYiW3mK1O1qJIF0zXf2MW2sn7dfAOa6dg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.a17078917a4403310cd19178939257b706fb5e1da76167c9f4a6d2123c9d59c4.js integrity="sha256-oXB4kXpEAzEM0ZF4k5JXtwb7Xh2nYWfJ9KbSEjydWcQ=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.7420a1602c62a85d4b50881c1d8ce42f72c049dc2b097d440696425d6e54bb1e.css integrity="sha256-dCChYCxiqF1LUIgcHYzkL3LASdwrCX1EBpZCXW5Uux4="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.61064b3964637440ee1c28e577377fcf238ddc5939020ef8b3c3cae543898111.css integrity="sha256-YQZLOWRjdEDuHCjldzd/zyON3Fk5Ag74s8PK5UOJgRE="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2025 Day 12: Knapsackinator</h1><div class=entry-meta><span class=entry-date>2025-12-12</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/12/03/aoc-2025-day-3-loopinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a></li><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/memoization>Memoization</a></li><li><a href=https://blog.jverkamp.com/2025/12/10/aoc-2025-day-10-linear-algebranator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/parallelism>Parallelism</a></li><li><a href=https://blog.jverkamp.com/2025/12/03/aoc-2025-day-3-loopinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/pruning>Pruning</a></li><li><a href=https://blog.jverkamp.com/2025/12/04/aoc-2025-day-4-fade-awayinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/visualization>Visualization</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2025>Advent of Code 2025</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/12/20/locking-bga-tabs-with-userscripts/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2025/12/11/aoc-2025-day-11-graphinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/12/13/the-mechanical/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-day-12-christmas-tree-farm>Source: <a href=https://adventofcode.com/2025/day/12 target=_blank rel=noopener>Day 12: Christmas Tree Farm</a></h2><p><a href=https://github.com/jpverkamp/advent-of-code/blob/master/2025/src/day12.rs target=_blank rel=noopener>Full solution</a> for today (spoilers!).</p><nav id=TableOfContents><ul><li><a href=#source-day-12-christmas-tree-farm>Source: Day 12: Christmas Tree Farm</a></li><li><a href=#part-1>Part 1</a></li><li><a href=#part-1---its-actually-trivial>Part 1 - It&rsquo;s actually trivial</a></li><li><a href=#rendering>Rendering</a></li><li><a href=#benchmarks>Benchmarks</a></li></ul></nav><h2 id=part-1>Part 1</h2><blockquote><p>Solve the <a href=https://en.wikipedia.org/wiki/knapsack%20problem>knapsack problem</a>.</p><p>&mldr;</p><p>&mldr;</p><p>But really, you are given a set of tiles (which all happen to be some subset of a 3x3) and a set of constraints&ndash;a MxN grid and how many of each tile to place. Count how many constraints are possible.</p><p>Tiles may be rotated and/or flipped.</p></blockquote><p>So, let&rsquo;s just do it.</p><p>First, a tile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Tile</span> {
</span></span><span style=display:flex><span>    id: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Tile {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> value.lines();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> lines
</span></span><span style=display:flex><span>            .next()
</span></span><span style=display:flex><span>            .unwrap()
</span></span><span style=display:flex><span>            .strip_suffix(<span style=color:#e6db74>&#39;:&#39;</span>)
</span></span><span style=display:flex><span>            .unwrap()
</span></span><span style=display:flex><span>            .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>            .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(line) <span style=color:#f92672>=</span> lines.next()
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>line.trim().is_empty()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            height <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> line.chars() {
</span></span><span style=display:flex><span>                data.push(c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> data.len() <span style=color:#f92672>/</span> height;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Tile {
</span></span><span style=display:flex><span>            id,
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            height,
</span></span><span style=display:flex><span>            data,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And some helper methods that can generate variations of the tile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Tile {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rotate_cw</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_data <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#66d9ef>false</span>; self.data.len()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> old_index <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> self.width;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_x <span style=color:#f92672>=</span> self.height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> y;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_y <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_index <span style=color:#f92672>=</span> new_x <span style=color:#f92672>+</span> new_y <span style=color:#f92672>*</span> self.height;
</span></span><span style=display:flex><span>                new_data[new_index] <span style=color:#f92672>=</span> self.data[old_index];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Tile {
</span></span><span style=display:flex><span>            id: <span style=color:#a6e22e>self</span>.id,
</span></span><span style=display:flex><span>            width: <span style=color:#a6e22e>self</span>.height,
</span></span><span style=display:flex><span>            height: <span style=color:#a6e22e>self</span>.width,
</span></span><span style=display:flex><span>            data: <span style=color:#a6e22e>new_data</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>flip_h</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_data <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#66d9ef>false</span>; self.data.len()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> old_index <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> self.width;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_x <span style=color:#f92672>=</span> self.width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> x;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_y <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_index <span style=color:#f92672>=</span> new_x <span style=color:#f92672>+</span> new_y <span style=color:#f92672>*</span> self.width;
</span></span><span style=display:flex><span>                new_data[new_index] <span style=color:#f92672>=</span> self.data[old_index];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Tile {
</span></span><span style=display:flex><span>            id: <span style=color:#a6e22e>self</span>.id,
</span></span><span style=display:flex><span>            width: <span style=color:#a6e22e>self</span>.width,
</span></span><span style=display:flex><span>            height: <span style=color:#a6e22e>self</span>.height,
</span></span><span style=display:flex><span>            data: <span style=color:#a6e22e>new_data</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>variations</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Vec<span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> vars <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> current <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>        vars.push(current.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> rotated <span style=color:#f92672>=</span> current.rotate_cw();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>vars.contains(<span style=color:#f92672>&amp;</span>rotated) {
</span></span><span style=display:flex><span>                vars.push(rotated.clone());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> flipped <span style=color:#f92672>=</span> current.flip_h();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>vars.contains(<span style=color:#f92672>&amp;</span>flipped) {
</span></span><span style=display:flex><span>                vars.push(flipped.clone());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            current <span style=color:#f92672>=</span> current.rotate_cw();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vars
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, we&rsquo;ll write this up as a recursive solver, try to place each block and recur. If we find a solution, we&rsquo;re done. If we don&rsquo;t, backtrack. Eventually, if we try every combination, we know it&rsquo;s impossible. (Which is what makes this an <a href=https://en.wikipedia.org/wiki/NP-complete>NP-complete</a> problem).</p><p>We can optimize a few things:</p><ul><li>Memoize (which because of the next line can be done between problems)</li><li>If we have a complete edge row/column, we can solve a smaller problem without it</li><li>If we have more area in tiles to place than we have area left, immediately return false</li></ul><p>So building that up from the inside out, first we have a function to try to place a tile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tracing::instrument(skip(grid, tile), fields(tile_id = tile.id, x, y), ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_place</span>(grid: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Grid<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;&gt;</span>, tile: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Tile</span>, x: <span style=color:#66d9ef>isize</span>, y: <span style=color:#66d9ef>isize</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> log::<span style=color:#a6e22e>log_enabled!</span>(log::Level::Debug) {
</span></span><span style=display:flex><span>        log::<span style=color:#a6e22e>debug!</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Try place tile:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}  </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>on:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}&#34;</span>,
</span></span><span style=display:flex><span>            stringify_tile(tile),
</span></span><span style=display:flex><span>            stringify_grid(grid)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ty <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>tile.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> tx <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>tile.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> gx <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> tx;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> gy <span style=color:#f92672>=</span> y <span style=color:#f92672>+</span> ty;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> gx <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> gy <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> gx <span style=color:#f92672>&gt;=</span> grid.width() <span style=color:#f92672>||</span> gy <span style=color:#f92672>&gt;=</span> grid.height() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>tile.data[(tx <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#f92672>+</span> (ty <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#f92672>*</span> tile.width] {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> grid_value <span style=color:#f92672>=</span> grid.get(gx, gy).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> grid_value.is_some() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ty <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>tile.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> tx <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>tile.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> gx <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> tx;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> gy <span style=color:#f92672>=</span> y <span style=color:#f92672>+</span> ty;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> tile.data[(tx <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#f92672>+</span> (ty <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#f92672>*</span> tile.width] {
</span></span><span style=display:flex><span>                grid.set(gx, gy, Some(tile.id));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then one that will do the actual recursion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[tracing::instrument(skip(grid, tiles, memo, memo_stats, last_debug), ret)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_place</span>(
</span></span><span style=display:flex><span>    grid: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Grid</span><span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    tiles: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>Tile<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    counts: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    memo: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>(Grid<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;&gt;</span>, Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>), <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>    memo_stats: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>)<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    last_debug: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>Instant<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (grid.clone(), counts.clone());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> log::<span style=color:#a6e22e>log_enabled!</span>(log::Level::Info) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> log::<span style=color:#a6e22e>log_enabled!</span>(log::Level::Debug)
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> last_debug.lock().unwrap().elapsed().as_secs() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            log::<span style=color:#a6e22e>info!</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Current progress [counts: {counts:?}, memo size: {}, hits: {}, misses: {}]:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}&#34;</span>,
</span></span><span style=display:flex><span>                memo.lock().unwrap().len(),
</span></span><span style=display:flex><span>                memo_stats.lock().unwrap().<span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                memo_stats.lock().unwrap().<span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                stringify_grid(grid)
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>last_debug.lock().unwrap() <span style=color:#f92672>=</span> Instant::now();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> memo.lock().unwrap().contains_key(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>        memo_stats.lock().unwrap().<span style=color:#ae81ff>0</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> memo.lock().unwrap()[<span style=color:#f92672>&amp;</span>cache_key];
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        memo_stats.lock().unwrap().<span style=color:#ae81ff>1</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> counts.iter().all(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        memo.lock().unwrap().insert(cache_key, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the sum of tiles we have left is not enough to fill the remaining empty cells, fail early
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> empty_cells <span style=color:#f92672>=</span> grid.iter().filter(<span style=color:#f92672>|</span>(_, _, v)<span style=color:#f92672>|</span> v.is_none()).count();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tiles_left <span style=color:#f92672>=</span> counts
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .zip(tiles.iter())
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>c, t)<span style=color:#f92672>|</span> c <span style=color:#f92672>*</span> t.data.iter().filter(<span style=color:#f92672>|&amp;&amp;</span>b<span style=color:#f92672>|</span> b).count())
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> tiles_left <span style=color:#f92672>&gt;</span> empty_cells {
</span></span><span style=display:flex><span>        memo.lock().unwrap().insert(cache_key, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If an entire edge row or column is full, we can remove it to reduce the problem size
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.width() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).all(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> grid.get(x, <span style=color:#ae81ff>0</span>).unwrap().is_some()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_grid <span style=color:#f92672>=</span> grid.clone();
</span></span><span style=display:flex><span>        new_grid.drop_row(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> can_place(<span style=color:#f92672>&amp;</span>new_grid, tiles, counts, memo, memo_stats, last_debug);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.width() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).all(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> grid.get(x, grid.height() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).unwrap().is_some()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_grid <span style=color:#f92672>=</span> grid.clone();
</span></span><span style=display:flex><span>        new_grid.drop_row(grid.height() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> can_place(<span style=color:#f92672>&amp;</span>new_grid, tiles, counts, memo, memo_stats, last_debug);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.height() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).all(<span style=color:#f92672>|</span>y<span style=color:#f92672>|</span> grid.get(<span style=color:#ae81ff>0</span>, y).unwrap().is_some()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_grid <span style=color:#f92672>=</span> grid.clone();
</span></span><span style=display:flex><span>        new_grid.drop_column(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> can_place(<span style=color:#f92672>&amp;</span>new_grid, tiles, counts, memo, memo_stats, last_debug);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.height() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>).all(<span style=color:#f92672>|</span>y<span style=color:#f92672>|</span> grid.get(grid.width() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y).unwrap().is_some()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_grid <span style=color:#f92672>=</span> grid.clone();
</span></span><span style=display:flex><span>        new_grid.drop_column(grid.width() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> can_place(<span style=color:#f92672>&amp;</span>new_grid, tiles, counts, memo, memo_stats, last_debug);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Always try to place the first tile we have available
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tile_index <span style=color:#f92672>=</span> counts.iter().position(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tile <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>tiles[tile_index];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.height() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>grid.width() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> variation <span style=color:#66d9ef>in</span> tile.variations() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> grid_clone <span style=color:#f92672>=</span> grid.clone();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> try_place(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> grid_clone, <span style=color:#f92672>&amp;</span>variation, x, y) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_counts <span style=color:#f92672>=</span> counts.clone();
</span></span><span style=display:flex><span>                    new_counts[tile_index] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> can_place(
</span></span><span style=display:flex><span>                        <span style=color:#f92672>&amp;</span>grid_clone,
</span></span><span style=display:flex><span>                        tiles,
</span></span><span style=display:flex><span>                        <span style=color:#f92672>&amp;</span>new_counts,
</span></span><span style=display:flex><span>                        memo.clone(),
</span></span><span style=display:flex><span>                        memo_stats.clone(),
</span></span><span style=display:flex><span>                        last_debug.clone(),
</span></span><span style=display:flex><span>                    ) {
</span></span><span style=display:flex><span>                        memo.lock().unwrap().insert(cache_key, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    memo.lock().unwrap().insert(cache_key, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then the main program (with Rayon for good measure):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc::register]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>impl</span> Into<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> tiles <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remaining_input <span style=color:#f92672>=</span> input;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(next_end) <span style=color:#f92672>=</span> remaining_input.find(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tile_str <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>remaining_input[<span style=color:#f92672>..</span>next_end];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tile <span style=color:#f92672>=</span> Tile::from(tile_str);
</span></span><span style=display:flex><span>        tiles.push(tile);
</span></span><span style=display:flex><span>        remaining_input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>remaining_input[next_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> memo <span style=color:#f92672>=</span> Arc::new(Mutex::new(HashMap::default()));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> memo_stats <span style=color:#f92672>=</span> Arc::new(Mutex::new((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    remaining_input
</span></span><span style=display:flex><span>        .lines()
</span></span><span style=display:flex><span>        .enumerate()
</span></span><span style=display:flex><span>        .par_bridge()
</span></span><span style=display:flex><span>        .filter(<span style=color:#f92672>|</span>(line_index, line)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (size, rest) <span style=color:#f92672>=</span> line.split_once(<span style=color:#e6db74>&#34;: &#34;</span>).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> (width, height) <span style=color:#f92672>=</span> size.split_once(<span style=color:#e6db74>&#39;x&#39;</span>).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> width: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> width.parse().unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> height: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> height.parse().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> counts: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> rest.split(<span style=color:#e6db74>&#39; &#39;</span>).map(<span style=color:#f92672>|</span>part<span style=color:#f92672>|</span> part.parse().unwrap()).collect();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> initial_grid <span style=color:#f92672>=</span> Grid::new(width, height, None);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> last_debug <span style=color:#f92672>=</span> Arc::new(Mutex::new(Instant::now()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            can_place(
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>initial_grid,
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tiles,
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>counts,
</span></span><span style=display:flex><span>                memo.clone(),
</span></span><span style=display:flex><span>                memo_stats.clone(),
</span></span><span style=display:flex><span>                last_debug.clone(),
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .count()
</span></span><span style=display:flex><span>        .to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Arc&lt;Mutux&lt;...>></code> allow sharing the cache between threads. There&rsquo;s some cost to locking it, but the ability to run a bunch of these at once outweighs that.</p><p>And that&rsquo;s&mldr; it. It run quickly enough.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ RUST_LOG<span style=color:#f92672>=</span>info just run <span style=color:#ae81ff>12</span> part1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-12-13T18:14:41Z INFO  day12<span style=color:#f92672>]</span> part1 took 80.786759791s
</span></span><span style=display:flex><span><span style=color:#ae81ff>575</span>
</span></span></code></pre></div><p>Actually far more quickly than it should&mldr;</p><h2 id=part-1---its-actually-trivial>Part 1 - It&rsquo;s actually trivial</h2><p>So it turns out there is one more optimization that we were missing:</p><ul><li>If you have enough 3x3 empty spaces large enough to fit all of the tiles, there is a trivial solution (just give them each their own space)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc::register]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1_trivial</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>impl</span> Into<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> tiles <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remaining_input <span style=color:#f92672>=</span> input;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(next_end) <span style=color:#f92672>=</span> remaining_input.find(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tile_str <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>remaining_input[<span style=color:#f92672>..</span>next_end];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tile <span style=color:#f92672>=</span> Tile::from(tile_str);
</span></span><span style=display:flex><span>        tiles.push(tile);
</span></span><span style=display:flex><span>        remaining_input <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>remaining_input[next_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is the case for given input, this won&#39;t generalize to all possible sizes
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert!</span>(
</span></span><span style=display:flex><span>        tiles.iter().all(<span style=color:#f92672>|</span>t<span style=color:#f92672>|</span> t.width <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> t.height <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Only trivial 3x3 tiles supported&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (line_index, line) <span style=color:#66d9ef>in</span> remaining_input.lines().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (size, rest) <span style=color:#f92672>=</span> line.split_once(<span style=color:#e6db74>&#34;: &#34;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (width, height) <span style=color:#f92672>=</span> size.split_once(<span style=color:#e6db74>&#39;x&#39;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> width.parse().unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> height: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> height.parse().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        log::<span style=color:#a6e22e>info!</span>(<span style=color:#e6db74>&#34;Line {line_index}: {width}x{height}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> counts: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> rest.split(<span style=color:#e6db74>&#39; &#39;</span>).map(<span style=color:#f92672>|</span>part<span style=color:#f92672>|</span> part.parse().unwrap()).collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Trivially allowed: all tiles fit into their own 3x3 cell
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> tiles_allowed <span style=color:#f92672>=</span> (width <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>*</span> (height <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> total_tiles_requested: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> counts.iter().sum();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> total_tiles_requested <span style=color:#f92672>&lt;=</span> tiles_allowed {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Trivially impossible: not enough cells to hold the tiles no matter what
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> total_hashes_requested: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> counts
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .zip(tiles.iter())
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(<span style=color:#f92672>&amp;</span>c, t)<span style=color:#f92672>|</span> c <span style=color:#f92672>*</span> t.data.iter().filter(<span style=color:#f92672>|&amp;&amp;</span>b<span style=color:#f92672>|</span> b).count())
</span></span><span style=display:flex><span>            .sum();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> total_hashes_possible <span style=color:#f92672>=</span> width <span style=color:#f92672>*</span> height;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> total_hashes_requested <span style=color:#f92672>&gt;</span> total_hashes_possible {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Required non-trivial check for line </span><span style=color:#e6db74>{line_index}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ just run-and-bench <span style=color:#ae81ff>12</span> part1_trivial
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>575</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>part1_trivial: 159.753Âµs Â± 7.564Âµs <span style=color:#f92672>[</span>min: 146.583Âµs, max: 183.125Âµs, median: 156.875Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Is honestly kind of disappointing for what will end up being the last AOC problem today? (Like previous years, the last day has only 1 part if you&rsquo;ve completed everything else).</p><p>So it goes. We do have pretty pictures yet to do!</p><h2 id=rendering>Rendering</h2><p>Okay, let&rsquo;s render these.</p><p>First, the example where there is a successful solution:</p><p><video style=width:400px;max-width:100% controls src=/embeds/2025/aoc/aoc2025_day12_part1_example2.mp4 title=Title></video></p><p>And the one where there is not:</p><p><video style=width:400px;max-width:100% controls src=/embeds/2025/aoc/aoc2025_day12_part1_example3.mp4 title=Title></video></p><p>That&mldr; is sped up by 1000x. The full video would be almost two <em>days</em> long. Granted, it solves it somewhat quicker than that, but still. That&rsquo;s a good example of just how bad this problem can get.</p><p>So what does our actual input look like?</p><p><video controls src=/embeds/2025/aoc/aoc2025_day12_part1.mp4 title=Title></video></p><p>That&rsquo;s just fun to watch. This isn&rsquo;t my whole input but rather any that have a valid solution in the first 32. Because of the &rsquo;not enough space&rsquo; optimization, any invalid cases are just immediately eliminated.</p><p>You can also play a bit with the algorithm to choose which tile is next. If you use the lowest index, you get the above. If you instead use whichever has the most left to place you get this:</p><p><video controls src=/embeds/2025/aoc/aoc2025_day12_part1_by_most.mp4 title=Title></video></p><p>And if you choose randomly, you might get this:</p><p><video controls src=/embeds/2025/aoc/aoc2025_day12_part1_random.mp4 title=Title></video></p><h2 id=benchmarks>Benchmarks</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --release --bin day12 -- bench part1 --warmup <span style=color:#ae81ff>0</span> --iters <span style=color:#ae81ff>1</span> input/2025/day12.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>part1: 96.430551417s Â± 0ns <span style=color:#f92672>[</span>min: 96.430551417s, max: 96.430551417s, median: 96.430551417s<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ just bench <span style=color:#ae81ff>12</span> part1_trivial
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>part1_trivial: 153.807Âµs Â± 8.791Âµs <span style=color:#f92672>[</span>min: 145.916Âµs, max: 200.459Âµs, median: 150.917Âµs<span style=color:#f92672>]</span>
</span></span></code></pre></div><table><thead><tr><th>Day</th><th>Part</th><th>Solution</th><th>Benchmark</th></tr></thead><tbody><tr><td>12</td><td>1</td><td><code>part1</code></td><td>96.430551417s Â± 0ns</td></tr><tr><td>12</td><td>1</td><td><code>part1_trivial</code></td><td>153.807Âµs Â± 8.791Âµs</td></tr></tbody></table></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>