<!doctype html><html><head><title>Advent of Code 2025 – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Advent of Code 2025</h1><div class=entry-meta><span class=entry-date>2025-12-01</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/04/21/solving-woodworm/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/25/aoc-2024-day-25-christmas-lockpickinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/series/advent-of-code-2025>Advent of Code 2025</a><a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2025/08/16/api-tricks-wikipedia-table-json-api/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/maker/3d-printing/2025-12-01-aquarium-lid-clips/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>It&rsquo;s back! (<a href=https://blog.jverkamp.com/programming/sources/advent-of-code/>Advent of Code</a>)!</p><p>It&rsquo;s been ten years (of advent of code, I haven&rsquo;t done them all (yet)) and oh what a ten years it&rsquo;s been. This time around, there will be only 12 days instead of 25, but honestly, that means I&rsquo;m not working on these right up until Christmas. So I&rsquo;m okay with this.</p><p>Once again, Rust! But this time, I won&rsquo;t be using <code>cargo-aoc</code>, instead I wrote my own proc macros. Mostly to see if I could. &#x1f604; See <a href=#my-very-own-aoc-macros>this section</a> for more information.</p><p>Full solutions will once again be posted to GitHub (including previous years and possibly some I haven&rsquo;t written up yet): <a href=https://github.com/jpverkamp/advent-of-code>jpverkamp/advent-of-code</a></p><p>Here are (or will be) all of my solutions:</p><div class=ranking><h3 class=title>Posts in <a href=/series/advent-of-code-2025/>Advent of Code 2025</a>:</h3><div class=content><ul><li><a href=https://blog.jverkamp.com/2025/12/07/aoc-2025-day-7-laser-splittinator/>AoC 2025 Day 7: Laser Splittinator</a></li><li><a href=https://blog.jverkamp.com/2025/12/06/aoc-2025-day-6-column-operatinator/>AoC 2025 Day 6: Column Operatinator</a></li><li><a href=https://blog.jverkamp.com/2025/12/05/aoc-2025-day-5-range-merginator/>AoC 2025 Day 5: Range Merginator</a></li><li><a href=https://blog.jverkamp.com/2025/12/04/aoc-2025-day-4-fade-awayinator/>AoC 2025 Day 4: Fade Awayinator</a></li><li><a href=https://blog.jverkamp.com/2025/12/03/aoc-2025-day-3-loopinator/>AoC 2025 Day 3: Loopinator</a></li><li><a href=https://blog.jverkamp.com/2025/12/02/aoc-2025-day-2-repeat-repeat-repeatinator/>AoC 2025 Day 2: Repeat Repeat Repeatinator</a></li><li><a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/>AoC 2025 Day 1: Turn Turn Turninator</a></li><li><a href=https://blog.jverkamp.com/2025/12/01/advent-of-code-2025/>Advent of Code 2025</a></li></ul></div></div><p>Here&rsquo;s how long each solution takes to run:</p><table><thead><tr><th>Day</th><th>Part</th><th>Solution</th><th>Benchmark</th></tr></thead><tbody><tr><td>1</td><td>1</td><td><code>part1</code></td><td>215.243µs ± 11.937µs</td></tr><tr><td>1</td><td>2</td><td><code>part2</code></td><td>2.237187ms ± 52.313µs</td></tr><tr><td>1</td><td>2</td><td><code>part2_inline</code></td><td>1.870518ms ± 50.308µs</td></tr><tr><td>2</td><td>1</td><td><code>part1</code></td><td>46.189482ms ± 467.675µs</td></tr><tr><td>2</td><td>1</td><td><code>part1_regex</code></td><td>838.820205ms ± 10.505208ms</td></tr><tr><td>2</td><td>1</td><td><code>part1_intmatch</code></td><td>11.533401ms ± 1.266642ms</td></tr><tr><td>2</td><td>1</td><td><code>part1_intmatch_divrem</code></td><td>9.121032ms ± 85.661µs</td></tr><tr><td>2</td><td>1</td><td><code>part1_chatgpt</code></td><td>650.796µs ± 231.766µs</td></tr><tr><td>2</td><td>2</td><td><code>part2</code></td><td>110.797727ms ± 5.697853ms</td></tr><tr><td>2</td><td>2</td><td><code>part2_intmatch</code></td><td>100.421589ms ± 1.573153ms</td></tr><tr><td>3</td><td>1</td><td><code>part1</code></td><td>1.31203ms ± 23.678µs</td></tr><tr><td>3</td><td>1</td><td><code>part1_max_digits</code></td><td>54.131µs ± 2.798µs</td></tr><tr><td>3</td><td>2</td><td><code>part2</code></td><td>147.712µs ± 5.738µs</td></tr><tr><td>4</td><td>1</td><td><code>part1</code></td><td>107.041µs ± 5.007µs</td></tr><tr><td>4</td><td>2</td><td><code>part2</code></td><td>4.826662ms ± 86.921µs</td></tr><tr><td>4</td><td>2</td><td><code>part2_no_map</code></td><td>1.164075ms ± 33.765µs</td></tr><tr><td>4</td><td>2</td><td><code>part2_floodfill</code></td><td>670.268µs ± 19.006µs</td></tr><tr><td>5</td><td>1</td><td><code>part1</code></td><td>69.969µs ± 2.217µs</td></tr><tr><td>5</td><td>2</td><td><code>part2</code></td><td>261.825µs ± 12.143µs</td></tr><tr><td>5</td><td>2</td><td><code>part2_bruteforce</code></td><td>~43 weeks &#x1f604;</td></tr><tr><td>6</td><td>1</td><td><code>part1</code></td><td>38.877µs ± 3.178µs</td></tr><tr><td>6</td><td>1</td><td><code>part1_grid</code></td><td>39.811µs ± 3.344µs</td></tr><tr><td>6</td><td>2</td><td><code>part2</code></td><td>34.372µs ± 1.887µs</td></tr><tr><td>7</td><td>1</td><td><code>part1</code></td><td>50.033µs ± 3.791µs</td></tr><tr><td>7</td><td>2</td><td><code>part2</code></td><td>45.279µs ± 3.015µs</td></tr></tbody></table><p>And here are my previous year&rsquo;s solutions:</p><ul><li><a href=https://blog.jverkamp.com/2015/12/01/advent-of-code/>Advent of Code 2015</a></li><li><a href=https://blog.jverkamp.com/2018/01/03/advent-of-code-2016/>Advent of Code 2016</a></li><li><a href=https://blog.jverkamp.com/2018/01/08/advent-of-code-2017/>Advent of Code 2017</a></li><li><a href=https://blog.jverkamp.com/2018/12/01/advent-of-code-2018/>Advent of Code 2018</a></li><li><a href=https://blog.jverkamp.com/2021/12/01/advent-of-code-2021/>Advent of Code 2021</a></li><li><a href=https://blog.jverkamp.com/2022/12/01/advent-of-code-2022/>Advent of Code 2022</a></li><li><a href=https://blog.jverkamp.com/2023/12/01/advent-of-code-2023/>Advent of Code 2023</a></li><li><a href=https://blog.jverkamp.com/2024/12/01/advent-of-code-2024/>Advent of Code 2024</a></li></ul><h1 id=my-very-own-aoc-macros>My very own AOC macros</h1><p>I like <code>cargo aoc</code> well enough, but I wanted to see what I could write for myself. And also, I can tune this one as I go (if that comes up). So we have a macro in three parts:</p><h2 id=registering-solutions>Registering solutions</h2><p>First, the macro you use to tag functions as solutions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>register_impl</span>(_attr: <span style=color:#a6e22e>TokenStream</span>, item: <span style=color:#a6e22e>TokenStream</span>) -&gt; <span style=color:#a6e22e>TokenStream</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> func <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse_macro_input!</span>(item <span style=color:#66d9ef>as</span> ItemFn);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> fn_name <span style=color:#f92672>=</span> func.sig.ident.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name_str <span style=color:#f92672>=</span> fn_name.to_string();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> entry_ident: <span style=color:#a6e22e>Ident</span> <span style=color:#f92672>=</span> quote::<span style=color:#a6e22e>format_ident!</span>(<span style=color:#e6db74>&#34;__AOC_ENTRY_{}&#34;</span>, fn_name.to_string().to_uppercase());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> shim_ident: <span style=color:#a6e22e>Ident</span> <span style=color:#f92672>=</span> quote::<span style=color:#a6e22e>format_ident!</span>(<span style=color:#e6db74>&#34;__aoc_shim_{}&#34;</span>, fn_name);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> reg_ident: <span style=color:#a6e22e>Ident</span> <span style=color:#f92672>=</span> quote::<span style=color:#a6e22e>format_ident!</span>(<span style=color:#e6db74>&#34;__aoc_register_{}&#34;</span>, fn_name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name_lit <span style=color:#f92672>=</span> name_str;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expanded <span style=color:#f92672>=</span> <span style=color:#a6e22e>quote!</span> {
</span></span><span style=display:flex><span>        #func
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> #shim_ident(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String { #fn_name(input).into() }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> #entry_ident: <span style=color:#a6e22e>crate</span>::__aoc::Entry <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::Entry { day: <span style=color:#a6e22e>crate</span>::__aoc::<span style=color:#66d9ef>DAY</span>, name: #name_lit, func: #shim_ident };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[::ctor::ctor]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> #reg_ident() { <span style=color:#66d9ef>crate</span>::__aoc::register(<span style=color:#f92672>&amp;</span>#entry_ident); }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TokenStream::from(expanded)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This uses the &lsquo;registry&rsquo; from <code>aoc_main!</code> below, to do basically all the work. But all you have to do is register it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[aoc::register]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>impl</span> Into<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And voila!</p><p>It will automatically pick up the name of the function as the name used to run it in the CLI (coming up&mldr;)</p><h2 id=write-a-main-function-with-cli-params>Write a main function (with CLI params)</h2><p>This is the real meat of the functionality. It takes the registered functions above and builds out a CLI for each day, supporting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/day1 --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: day1 &lt;COMMAND&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  list
</span></span><span style=display:flex><span>  run
</span></span><span style=display:flex><span>  bench
</span></span><span style=display:flex><span>  help   Print this message or the help of the given subcommand<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>  -h, --help  Print help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/day1 run --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage: day1 run <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>NAME<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arguments:
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>NAME<span style=color:#f92672>]</span>   Name of the solution to run <span style=color:#f92672>(</span><span style=color:#66d9ef>if</span> not using --all<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>INPUT<span style=color:#f92672>]</span>  Input path <span style=color:#f92672>(</span>use <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#66d9ef>for</span> stdin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Options:
</span></span><span style=display:flex><span>      --all   Run all registered solutions <span style=color:#66d9ef>for</span> the day
</span></span><span style=display:flex><span>  -h, --help  Print help
</span></span></code></pre></div><p>So you can <code>list</code> possible solutions, <code>run</code> one (or <code>--all</code> of them), or <code>bench</code>mark them. Pretty nice for basically free (after the first writing of course).</p><p>It is a bit inefficient in that this code will be generated for each day&rsquo;s binary, but &#x1f937;. Space is cheap.</p><p>Here it is!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main_impl</span>(input: <span style=color:#a6e22e>TokenStream</span>) -&gt; <span style=color:#a6e22e>TokenStream</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> day_expr <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse_macro_input!</span>(input <span style=color:#66d9ef>as</span> Expr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> day_str <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::expr_to_string(<span style=color:#f92672>&amp;</span>day_expr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expanded <span style=color:#f92672>=</span> <span style=color:#a6e22e>quote!</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>mod</span> __aoc {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>use</span> std::sync::{Mutex, OnceLock};
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>DAY</span>: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> #day_str;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Entry</span> { <span style=color:#66d9ef>pub</span> day: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>str</span>, <span style=color:#66d9ef>pub</span> name: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>str</span>, <span style=color:#66d9ef>pub</span> func: <span style=color:#a6e22e>fn</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RenderEntry</span> { <span style=color:#66d9ef>pub</span> day: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>str</span>, <span style=color:#66d9ef>pub</span> name: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#66d9ef>str</span>, <span style=color:#66d9ef>pub</span> func: <span style=color:#a6e22e>fn</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>REGISTRY</span>: <span style=color:#a6e22e>OnceLock</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static Entry<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>=</span> OnceLock::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>RENDER_REGISTRY</span>: <span style=color:#a6e22e>OnceLock</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static RenderEntry<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>=</span> OnceLock::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>register</span>(e: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>Entry</span>) { <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new())); reg.lock().unwrap().push(e); }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>register_render</span>(e: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>RenderEntry</span>) { <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>RENDER_REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new())); reg.lock().unwrap().push(e); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>entries_for_day</span>(day: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static Entry<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new()));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v: Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static Entry<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> reg.lock().unwrap().iter().copied().filter(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.day <span style=color:#f92672>==</span> day).collect();
</span></span><span style=display:flex><span>                v.sort_by(<span style=color:#f92672>|</span>a,b<span style=color:#f92672>|</span> a.name.cmp(b.name)); v
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>render_entries_for_day</span>(day: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static RenderEntry<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>RENDER_REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new()));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v: Vec<span style=color:#f92672>&lt;&amp;</span>&#39;static RenderEntry<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> reg.lock().unwrap().iter().copied().filter(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.day <span style=color:#f92672>==</span> day).collect();
</span></span><span style=display:flex><span>                v.sort_by(<span style=color:#f92672>|</span>a,b<span style=color:#f92672>|</span> a.name.cmp(b.name)); v
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(day: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>&#39;static Entry<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new()));
</span></span><span style=display:flex><span>                reg.lock().unwrap().iter().copied().find(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.day <span style=color:#f92672>==</span> day <span style=color:#f92672>&amp;&amp;</span> e.name <span style=color:#f92672>==</span> name)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_render</span>(day: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>&#39;static RenderEntry<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> reg <span style=color:#f92672>=</span> <span style=color:#66d9ef>RENDER_REGISTRY</span>.get_or_init(<span style=color:#f92672>||</span> Mutex::new(Vec::new()));
</span></span><span style=display:flex><span>                reg.lock().unwrap().iter().copied().find(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.day <span style=color:#f92672>==</span> day <span style=color:#f92672>&amp;&amp;</span> e.name <span style=color:#f92672>==</span> name)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> tracing_enabled <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;RUST_TRACE&#34;</span>).is_ok();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> tracing_enabled {
</span></span><span style=display:flex><span>                tracing_subscriber::fmt()
</span></span><span style=display:flex><span>                    .pretty()
</span></span><span style=display:flex><span>                    .without_time()
</span></span><span style=display:flex><span>                    .with_max_level(tracing::Level::<span style=color:#66d9ef>DEBUG</span>)
</span></span><span style=display:flex><span>                    .init();
</span></span><span style=display:flex><span>                tracing::<span style=color:#a6e22e>info!</span>(<span style=color:#e6db74>&#34;Tracing enabled&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                env_logger::init();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> day: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> #day_str;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>use</span> clap::{Parser, Subcommand, Args};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[derive(Parser)]</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[command(name = env!(</span><span style=color:#e6db74>&#34;CARGO_PKG_NAME&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cli</span> { <span style=color:#75715e>#[command(subcommand)]</span> command: <span style=color:#a6e22e>Commands</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[derive(Subcommand)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Commands</span> {
</span></span><span style=display:flex><span>                List,
</span></span><span style=display:flex><span>                Render(RenderArgs),
</span></span><span style=display:flex><span>                Run(RunArgs),
</span></span><span style=display:flex><span>                Bench(BenchArgs),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[derive(Args)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RenderArgs</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Run all registered render solutions for the day
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                <span style=color:#75715e>#[arg(long)]</span>
</span></span><span style=display:flex><span>                all: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Name of the render solution to run (if not using --all)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Input path (use &#39;-&#39; for stdin)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                input: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[derive(Args)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RunArgs</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Run all registered solutions for the day
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                <span style=color:#75715e>#[arg(long)]</span>
</span></span><span style=display:flex><span>                all: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Name of the solution to run (if not using --all)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Input path (use &#39;-&#39; for stdin)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                input: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[derive(Args)]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BenchArgs</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Run all registered solutions for the day
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                <span style=color:#75715e>#[arg(long)]</span>
</span></span><span style=display:flex><span>                all: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Name of the solution to bench (if not using --all)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                name: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Input path (use &#39;-&#39; for stdin)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                input: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Number of warmup runs (default: 3)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                <span style=color:#75715e>#[arg(long, default_value_t = 3)]</span>
</span></span><span style=display:flex><span>                warmup: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>/// Number of benchmark iterations (default: 100)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>                <span style=color:#75715e>#[arg(long, default_value_t = 100)]</span>
</span></span><span style=display:flex><span>                iters: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> cli <span style=color:#f92672>=</span> Cli::parse();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> read_input <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>input_path: String<span style=color:#f92672>|</span> -&gt; String {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> input_path <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;-&#34;</span> { <span style=color:#66d9ef>use</span> std::io::Read; <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::new(); std::io::stdin().read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s).expect(<span style=color:#e6db74>&#34;failed to read stdin&#34;</span>); s } <span style=color:#66d9ef>else</span> { std::fs::read_to_string(<span style=color:#f92672>&amp;</span>input_path).unwrap_or_else(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;failed to read </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_path, e)) }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> benchmark <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, func: <span style=color:#a6e22e>fn</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String, input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, warmup: <span style=color:#66d9ef>usize</span>, iters: <span style=color:#66d9ef>usize</span><span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Warmup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>warmup { <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> func(input); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Benchmark
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> times <span style=color:#f92672>=</span> Vec::with_capacity(iters);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>iters {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> std::time::Instant::now();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> func(input);
</span></span><span style=display:flex><span>                    times.push(start.elapsed());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                times.sort();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> min <span style=color:#f92672>=</span> times[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> max <span style=color:#f92672>=</span> times[iters <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> median <span style=color:#f92672>=</span> times[iters <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Compute average and standard deviation (in nanoseconds)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> sum_ns: <span style=color:#66d9ef>u128</span> <span style=color:#f92672>=</span> times.iter().map(<span style=color:#f92672>|</span>d<span style=color:#f92672>|</span> d.as_nanos()).sum();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> avg_ns <span style=color:#f92672>=</span> sum_ns <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>/</span> (iters <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> avg <span style=color:#f92672>=</span> std::time::Duration::from_nanos(avg_ns <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> var_ns <span style=color:#f92672>=</span> times
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>d<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> d.as_nanos() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> diff <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> avg_ns;
</span></span><span style=display:flex><span>                        diff <span style=color:#f92672>*</span> diff
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                    <span style=color:#f92672>/</span> (iters <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> stddev_ns <span style=color:#f92672>=</span> var_ns.sqrt();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> stddev <span style=color:#f92672>=</span> std::time::Duration::from_nanos(stddev_ns <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{name}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{avg:?}</span><span style=color:#e6db74> ± </span><span style=color:#e6db74>{stddev:?}</span><span style=color:#e6db74> [min: </span><span style=color:#e6db74>{min:?}</span><span style=color:#e6db74>, max: </span><span style=color:#e6db74>{max:?}</span><span style=color:#e6db74>, median: </span><span style=color:#e6db74>{median:?}</span><span style=color:#e6db74>]&#34;</span>);
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> cli.command {
</span></span><span style=display:flex><span>                Commands::List <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> entries <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::entries_for_day(day);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> render_entries <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::render_entries_for_day(day);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> entries.is_empty() <span style=color:#f92672>&amp;&amp;</span> render_entries.is_empty() {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;No solutions registered for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, day);
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>entries.is_empty() {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Solutions:&#34;</span>);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> e <span style=color:#66d9ef>in</span> entries { <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e.name); }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>render_entries.is_empty() {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Render:&#34;</span>);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> e <span style=color:#66d9ef>in</span> render_entries { <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e.name); }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Commands::Render(args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> args.all {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(ip) <span style=color:#f92672>=&gt;</span> ip,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                                Some(pos) <span style=color:#f92672>=&gt;</span> pos,
</span></span><span style=display:flex><span>                                None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path for --all. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>);
</span></span><span style=display:flex><span>                                    std::process::exit(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> entries <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::render_entries_for_day(day);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> entries.is_empty() { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No render solutions registered for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, day); std::process::exit(<span style=color:#ae81ff>3</span>); }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> e <span style=color:#66d9ef>in</span> entries { (e.func)(<span style=color:#f92672>&amp;</span>input); }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                            Some(n) <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing solution name. Try &#39;list&#39; to see registered names.&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(i) <span style=color:#f92672>=&gt;</span> i,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>match</span> <span style=color:#66d9ef>crate</span>::__aoc::get_render(day, <span style=color:#f92672>&amp;</span>name) { Some(entry) <span style=color:#f92672>=&gt;</span> { (entry.func)(<span style=color:#f92672>&amp;</span>input); } None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No such render solution: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>. Try &#39;list&#39;.&#34;</span>, name); std::process::exit(<span style=color:#ae81ff>3</span>); } }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Commands::Run(args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> args.all {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// If --all is provided, require an input path. For backward compatibility we
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// accept that callers may have supplied the input as the positional `name`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(ip) <span style=color:#f92672>=&gt;</span> ip,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                                Some(pos) <span style=color:#f92672>=&gt;</span> pos,
</span></span><span style=display:flex><span>                                None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path for --all. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>);
</span></span><span style=display:flex><span>                                    std::process::exit(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> entries <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::entries_for_day(day);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> entries.is_empty() { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No solutions registered for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, day); std::process::exit(<span style=color:#ae81ff>3</span>); }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> e <span style=color:#66d9ef>in</span> entries { <span style=color:#66d9ef>let</span> out <span style=color:#f92672>=</span> (e.func)(<span style=color:#f92672>&amp;</span>input); <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, e.name, out); }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                            Some(n) <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing solution name. Try &#39;list&#39; to see registered names.&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(i) <span style=color:#f92672>=&gt;</span> i,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>match</span> <span style=color:#66d9ef>crate</span>::__aoc::get(day, <span style=color:#f92672>&amp;</span>name) { Some(entry) <span style=color:#f92672>=&gt;</span> { <span style=color:#66d9ef>let</span> out <span style=color:#f92672>=</span> (entry.func)(<span style=color:#f92672>&amp;</span>input); <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, out); } None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No such solution: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>. Try &#39;list&#39;.&#34;</span>, name); std::process::exit(<span style=color:#ae81ff>3</span>); } }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Commands::Bench(args) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Validate iteration count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> args.iters <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;--iters must be &gt;= 1&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> args.all {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// If --all is used, require an input path (positional or via --input)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(ip) <span style=color:#f92672>=&gt;</span> ip,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                                Some(pos) <span style=color:#f92672>=&gt;</span> pos,
</span></span><span style=display:flex><span>                                None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path for --all. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> entries <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::entries_for_day(day);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> entries.is_empty() { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No solutions registered for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, day); std::process::exit(<span style=color:#ae81ff>3</span>); }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> e <span style=color:#66d9ef>in</span> entries { benchmark(e.name, e.func, <span style=color:#f92672>&amp;</span>input, args.warmup, args.iters); }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.name {
</span></span><span style=display:flex><span>                            Some(n) <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing solution name. Try &#39;list&#39; to see registered names.&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> args.input {
</span></span><span style=display:flex><span>                            Some(i) <span style=color:#f92672>=&gt;</span> i,
</span></span><span style=display:flex><span>                            None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;Missing input path. Provide an input path (use &#39;-&#39; for stdin) or --input &lt;FILE&gt;&#34;</span>); std::process::exit(<span style=color:#ae81ff>2</span>); }
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_input(input_path);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>match</span> <span style=color:#66d9ef>crate</span>::__aoc::get(day, <span style=color:#f92672>&amp;</span>name) { Some(entry) <span style=color:#f92672>=&gt;</span> { benchmark(entry.name, entry.func, <span style=color:#f92672>&amp;</span>input, args.warmup, args.iters); } None <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>eprintln!</span>(<span style=color:#e6db74>&#34;No such solution: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>. Try &#39;list&#39;.&#34;</span>, name); std::process::exit(<span style=color:#ae81ff>3</span>); } }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    TokenStream::from(expanded)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yeah. It&rsquo;s a lot.</p><h2 id=tests>Tests</h2><p>And finally, our test macro!</p><p>I thought about using my <a href=https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/ target=_blank rel=noopener>testit</a> framework, but figured I might as well build it in.</p><p>The idea is that you specify the day, an input file, and then you can map as many sets of input functions to expected output as you want. Heck, you could even have multiple input files for smaller test cases if you wanted!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>aoc::<span style=color:#a6e22e>test!</span>(file <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;input/2025/day1.txt&#34;</span>, [part1] <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;1055&#34;</span>, [part2, part2_inline] <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;6386&#34;</span>);
</span></span></code></pre></div><p>Or:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>aoc::<span style=color:#a6e22e>test!</span>(text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L68
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L30
</span></span></span><span style=display:flex><span><span style=color:#e6db74>R48
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L5
</span></span></span><span style=display:flex><span><span style=color:#e6db74>R60
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L55
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L99
</span></span></span><span style=display:flex><span><span style=color:#e6db74>R14
</span></span></span><span style=display:flex><span><span style=color:#e6db74>L82&#34;</span>, [part1] <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;3&#34;</span>, [part2, part2_inline] <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;6&#34;</span>);
</span></span></code></pre></div><p>That&rsquo;s pretty fun.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_impl</span>(input: <span style=color:#a6e22e>TokenStream</span>) -&gt; <span style=color:#a6e22e>TokenStream</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Custom parser for new test macro syntax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestCase</span> {
</span></span><span style=display:flex><span>        solutions: Vec<span style=color:#f92672>&lt;</span>Expr<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        expected: <span style=color:#a6e22e>LitStr</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>InputSpec</span> {
</span></span><span style=display:flex><span>        File(LitStr),
</span></span><span style=display:flex><span>        Text(LitStr),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestInput</span> {
</span></span><span style=display:flex><span>        input_spec: <span style=color:#a6e22e>InputSpec</span>,
</span></span><span style=display:flex><span>        cases: Vec<span style=color:#f92672>&lt;</span>TestCase<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> Parse <span style=color:#66d9ef>for</span> TestInput {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(input: <span style=color:#a6e22e>ParseStream</span>) -&gt; <span style=color:#a6e22e>syn</span>::Result<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Accept either `file = &#34;path&#34;` or `text = &#34;...&#34;` here, or the legacy bare string literal (file path).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> input_spec <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> input.peek(syn::Ident) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> ident: <span style=color:#a6e22e>syn</span>::Ident <span style=color:#f92672>=</span> input.parse()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                input.parse::<span style=color:#f92672>&lt;</span>syn::<span style=color:#a6e22e>Token!</span>[<span style=color:#f92672>=</span>]<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>LitStr</span> <span style=color:#f92672>=</span> input.parse()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> ident.to_string().as_str() {
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;file&#34;</span> <span style=color:#f92672>=&gt;</span> InputSpec::File(val),
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;text&#34;</span> <span style=color:#f92672>=&gt;</span> InputSpec::Text(val),
</span></span><span style=display:flex><span>                    other <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> Err(syn::Error::new_spanned(
</span></span><span style=display:flex><span>                            ident,
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;expected `file` or `text`, got `</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>`&#34;</span>, other),
</span></span><span style=display:flex><span>                        ));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Legacy form: just a string literal which is treated as a file path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>LitStr</span> <span style=color:#f92672>=</span> input.parse()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                InputSpec::File(val)
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cases <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>input.is_empty() {
</span></span><span style=display:flex><span>                input.parse::<span style=color:#f92672>&lt;</span>syn::<span style=color:#a6e22e>Token!</span>[,]<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Parse [solution1, solution2, ...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> content;
</span></span><span style=display:flex><span>                syn::<span style=color:#a6e22e>bracketed!</span>(content <span style=color:#66d9ef>in</span> input);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> solutions: Vec<span style=color:#f92672>&lt;</span>Expr<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> content
</span></span><span style=display:flex><span>                    .parse_terminated(Expr::parse, syn::<span style=color:#a6e22e>Token!</span>[,])<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    .into_iter()
</span></span><span style=display:flex><span>                    .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                input.parse::<span style=color:#f92672>&lt;</span>syn::<span style=color:#a6e22e>Token!</span>[<span style=color:#f92672>=&gt;</span>]<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> expected: <span style=color:#a6e22e>LitStr</span> <span style=color:#f92672>=</span> input.parse()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                cases.push(TestCase {
</span></span><span style=display:flex><span>                    solutions,
</span></span><span style=display:flex><span>                    expected,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Ok(TestInput { input_spec, cases })
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> test_input <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse_macro_input!</span>(input <span style=color:#66d9ef>as</span> TestInput);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input_spec <span style=color:#f92672>=</span> test_input.input_spec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Build a unique source tag based on input type and content/path to avoid name collisions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>short_hash</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> std::hash::{Hash, Hasher};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> h <span style=color:#f92672>=</span> std::collections::hash_map::DefaultHasher::new();
</span></span><span style=display:flex><span>        s.hash(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> h);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> h.finish();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:x}</span><span style=color:#e6db74>&#34;</span>, v)[<span style=color:#f92672>..</span><span style=color:#ae81ff>8</span>].to_string()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> source_tag_str <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>&amp;</span>input_spec {
</span></span><span style=display:flex><span>        InputSpec::File(p) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> p.value();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> hash <span style=color:#f92672>=</span> short_hash(<span style=color:#f92672>&amp;</span>path);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Take last component for readability
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> last <span style=color:#f92672>=</span> path.rsplit(<span style=color:#e6db74>&#39;/&#39;</span>).next().unwrap_or(<span style=color:#f92672>&amp;</span>path);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> sanitized: String <span style=color:#f92672>=</span> last
</span></span><span style=display:flex><span>                .chars()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> c.is_ascii_alphanumeric() { c } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#39;_&#39;</span> })
</span></span><span style=display:flex><span>                .collect();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;file_</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, sanitized, hash)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        InputSpec::Text(t) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> text <span style=color:#f92672>=</span> t.value();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> hash <span style=color:#f92672>=</span> short_hash(<span style=color:#f92672>&amp;</span>text);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>format!</span>(<span style=color:#e6db74>&#34;text_</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, hash)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Precompute the input binding tokens (same for all cases in this macro invocation)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> input_binding <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>&amp;</span>input_spec {
</span></span><span style=display:flex><span>        InputSpec::File(p) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p_lit <span style=color:#f92672>=</span> p.clone();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>quote!</span> { <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> std::fs::read_to_string(#p_lit).unwrap_or_else(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;failed to read </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, #p_lit, e)); }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        InputSpec::Text(t) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> t_lit <span style=color:#f92672>=</span> t.clone();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>quote!</span> { <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> #t_lit.to_string(); }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Generate test functions; include case and solution indices for full uniqueness.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> test_functions: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> test_input
</span></span><span style=display:flex><span>        .cases
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .flat_map(<span style=color:#f92672>|</span>test_case<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> expected <span style=color:#f92672>=</span> test_case.expected.value();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> source_tag_str <span style=color:#f92672>=</span> source_tag_str.clone();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> input_binding_outer <span style=color:#f92672>=</span> input_binding.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            test_case
</span></span><span style=display:flex><span>                .solutions
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#66d9ef>move</span> <span style=color:#f92672>|</span>solution_expr<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> name_str <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::expr_to_string(solution_expr);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> test_name <span style=color:#f92672>=</span> quote::<span style=color:#a6e22e>format_ident!</span>(<span style=color:#e6db74>&#34;test_{}_{}&#34;</span>, source_tag_str, name_str);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> name_lit <span style=color:#f92672>=</span> name_str.clone();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> expected_lit <span style=color:#f92672>=</span> expected.clone();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> input_binding_clone <span style=color:#f92672>=</span> input_binding_outer.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>quote!</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>fn</span> #test_name() {
</span></span><span style=display:flex><span>                            #input_binding_clone
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> entry <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::__aoc::get(<span style=color:#66d9ef>crate</span>::__aoc::<span style=color:#66d9ef>DAY</span>, #name_lit)
</span></span><span style=display:flex><span>                                .unwrap_or_else(<span style=color:#f92672>||</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;solution </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> not found&#34;</span>, #name_lit));
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> (entry.func)(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>assert_eq!</span>(result, #expected_lit, <span style=color:#e6db74>&#34;test failed for {}&#34;</span>, #name_lit);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> expanded <span style=color:#f92672>=</span> <span style=color:#a6e22e>quote!</span> {
</span></span><span style=display:flex><span>        #(#test_functions)<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TokenStream::from(expanded)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Originally, I didn&rsquo;t support both files and text, but in a lot of Advent of Code problems, you are given a small test case which it&rsquo;s useful to solve first. I did have to add the hashes though, since otherwise we&rsquo;ll generate the same name twice. Now you have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>running <span style=color:#ae81ff>6</span> tests
</span></span><span style=display:flex><span>test test_day1_text_f9cee729_part1 ... ok
</span></span><span style=display:flex><span>test test_day1_text_f9cee729_part2_inline ... ok
</span></span><span style=display:flex><span>test test_day1_text_f9cee729_part2 ... ok
</span></span><span style=display:flex><span>test test_day1_file_day1_txt_71e8dd21_part1 ... ok
</span></span><span style=display:flex><span>test test_day1_file_day1_txt_71e8dd21_part2_inline ... ok
</span></span><span style=display:flex><span>test test_day1_file_day1_txt_71e8dd21_part2 ... ok
</span></span></code></pre></div><p>Which is pretty nice, IMO.</p><p>On to <a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/>day 1</a>!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>