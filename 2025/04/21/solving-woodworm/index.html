<!doctype html><html><head><title>Solving Woodworm â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.a8e11addf4349ee2ca5045f7f3cbf1febbf2c3a2840be2143ea69539c10f8c7f.js integrity="sha256-qOEa3fQ0nuLKUEX388vx/rvyw6KEC+IUPqaVOcEPjH8=" defer></script><script src=/katex_17296078054267651618.min.4a06464d8d6f8358d8896de62b53b5a89205d335dfd8c5b6b27edd7c039ae9d8.js integrity="sha256-SgZGTY1vg1jYiW3mK1O1qJIF0zXf2MW2sn7dfAOa6dg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.a17078917a4403310cd19178939257b706fb5e1da76167c9f4a6d2123c9d59c4.js integrity="sha256-oXB4kXpEAzEM0ZF4k5JXtwb7Xh2nYWfJ9KbSEjydWcQ=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.7420a1602c62a85d4b50881c1d8ce42f72c049dc2b097d440696425d6e54bb1e.css integrity="sha256-dCChYCxiqF1LUIgcHYzkL3LASdwrCX1EBpZCXW5Uux4="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.61064b3964637440ee1c28e577377fcf238ddc5939020ef8b3c3cae543898111.css integrity="sha256-YQZLOWRjdEDuHCjldzd/zyON3Fk5Ag74s8PK5UOJgRE="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Solving Woodworm</h1><div class=entry-meta><span class=entry-date>2025-04-21</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2025/12/01/advent-of-code-2025/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2025/12/01/aoc-2025-day-1-turn-turn-turninator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2025/12/03/aoc-2025-day-3-loopinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a></li><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2025/02/19/a-quick-mitmproxy-setup/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/05/29/parsing-pem-certificates-asn.1-in-javascript/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2025/04/19/a-fistful-of-charms/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/04/25/severance-season-1/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Woodworm is a cute little <a href=https://www.lexaloffle.com/pico-8.php target=_blank rel=noopener>PICO-8</a> puzzle game about a cute little worm&mldr; that eats wood. You can play it for free right now <a href=https://spratt.itch.io/woodworm target=_blank rel=noopener>right here</a>!</p><p>The goal is to turn this:</p><p><img src=level-1.png alt="Level 1, before solving"></p><p>Into this:</p><p><img src=level-1-solved.png alt="Level 1, after solving"></p><p>There are a few rules to keep in mind:</p><ul><li><p>The block (and the worm) are affected by gravity</p></li><li><p>The block can be split by into multiple pieces by eating it completely apart</p><p><img src=gravity.png alt="Demonstrating gravity"></p></li><li><p>The worm can crawl up the side of blocks, so long as two (consecutive) segments of the worm are touching walls</p><p><img src=climbing.png alt="Demonstrating climbing"></p></li></ul><p>And that&rsquo;s really it.</p><p>So let&rsquo;s solve it!</p><nav id=TableOfContents><ul><li><a href=#representing-state>Representing state</a></li><li><a href=#step>Step</a></li><li><a href=#impl-state><code>impl State</code></a><ul><li><a href=#next_states><code>next_states</code></a></li><li><a href=#is_solved><code>is_solved</code></a></li><li><a href=#is_valid><code>is_valid</code></a></li><li><a href=#heuristic><code>heuristic</code></a></li></ul></li><li><a href=#optimization>Optimization</a></li><li><a href=#final-remarks>Final remarks</a></li></ul></nav><h2 id=representing-state>Representing state</h2><p>Okay, first, what global data do we have? The map:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Global</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Map settings
</span></span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    cells: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Global {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> global <span style=color:#f92672>=</span> Global::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> input.lines() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> line.trim().is_empty() <span style=color:#f92672>||</span> line.starts_with(<span style=color:#e6db74>&#34;//&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> line.chars();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            global.height <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> chars {
</span></span><span style=display:flex><span>                width <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span> {
</span></span><span style=display:flex><span>                    global.cells.push(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    global.cells.push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> global.width <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                global.width <span style=color:#f92672>=</span> width;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> global.width <span style=color:#f92672>!=</span> width {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Map width mismatch: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> != </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, global.width, width);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        global
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m specifically storing it as a <code>Vec&lt;bool></code> with indexing this time, although a <code>HashSet</code> of <code>Point</code> could also work&ndash;but I&rsquo;ve seen how poorly hashing can be for performance.</p><p>Next, the local state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    worm: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    blocks: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For this one, we&rsquo;re going to keep a <code>Vec</code> of the current points making up the worm. This is potentially suboptimal, since (apparently) the worm is always exactly 3 points long, so I really should have used a <code>[Point; 3]</code> to avoid allocations. But I&rsquo;m already doing far more with the <code>blocks</code>.</p><p>Speaking of which, <code>blocks</code> was originally another <code>Vec&lt;bool></code>, but once I realized you could (and would need to) split blocks, <code>Vec</code> it became.</p><p>To create a <code>Local</code> from the <code>Global</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Global {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>make_local</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start at the lower left 3 in length
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> worm <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[
</span></span><span style=display:flex><span>            Point {
</span></span><span style=display:flex><span>                x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>self</span>.height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            Point {
</span></span><span style=display:flex><span>                x: <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>self</span>.height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            Point {
</span></span><span style=display:flex><span>                x: <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>self</span>.height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a single initial block
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> block <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.height {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.width {
</span></span><span style=display:flex><span>                block.push(Point { x, y });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> blocks <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[block];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Local { worm, blocks }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a little interesting, since the blocks can only ever be in the <code>width x height</code> original grid, but the worm itself can go around that fairly freely. There&rsquo;s not much point in it going more than $$length = 3$$ units away, but still, I actually kind of like this solution.</p><h2 id=step>Step</h2><p>Okay, next up, the actual heart of the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(<span style=color:#f92672>&amp;</span>self, d: <span style=color:#a6e22e>Direction</span>, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The new head of the worm cannot go more than worm length out of bounds
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// And cannot eat through the floor at all
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> new_head <span style=color:#f92672>=</span> self.worm[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> d.into();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> worm_len <span style=color:#f92672>=</span> self.worm.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_head.x <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>worm_len
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> new_head.x <span style=color:#f92672>&gt;=</span> global.width <span style=color:#f92672>+</span> worm_len
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> new_head.y <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>worm_len
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> new_head.y <span style=color:#f92672>&gt;=</span> global.height
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;Out of bounds&#34;</span>.to_string());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Cannot double back
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.worm.contains(<span style=color:#f92672>&amp;</span>new_head) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;Cannot double back&#34;</span>.to_string());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, update state:
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// Worms moves, active cells are eaten, gravity is applied
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_blocks <span style=color:#f92672>=</span> self.blocks.clone();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_worm <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[new_head];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Move the worm
</span></span></span><span style=display:flex><span>        new_worm.extend(self.worm.iter().take(self.worm.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).cloned());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Eat a chunk from a block (if possible)
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> eat_index <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, b) <span style=color:#66d9ef>in</span> new_blocks.iter_mut().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> b.contains(<span style=color:#f92672>&amp;</span>new_head) {
</span></span><span style=display:flex><span>                eat_index <span style=color:#f92672>=</span> Some(i);
</span></span><span style=display:flex><span>                b.retain(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> p <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>new_head);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we did, potentially split that block
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(i) <span style=color:#f92672>=</span> eat_index {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>new_blocks[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> b.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If it was empty, just remove it
</span></span></span><span style=display:flex><span>                new_blocks.remove(i);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If you can&#39;t reach all points from any remaining point, split the block
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#66d9ef>false</span>; b.len()];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stack <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[b[<span style=color:#ae81ff>0</span>]];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(p) <span style=color:#f92672>=</span> stack.pop() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(i) <span style=color:#f92672>=</span> b.iter().position(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>visited[i] {
</span></span><span style=display:flex><span>                            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> n <span style=color:#66d9ef>in</span> p.neighbors() {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> n <span style=color:#f92672>!=</span> new_head
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>&amp;&amp;</span> b.contains(<span style=color:#f92672>&amp;</span>n)
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[b.iter().position(<span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> x <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>n).unwrap()]
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                    stack.push(n);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> visited.iter().any(<span style=color:#f92672>|&amp;</span>x<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>x) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> (b1, b2) <span style=color:#f92672>=</span> b
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .enumerate()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|</span>(_, p)<span style=color:#f92672>|</span> new_head <span style=color:#f92672>!=</span> <span style=color:#f92672>**</span>p)
</span></span><span style=display:flex><span>                        .partition_map(<span style=color:#f92672>|</span>(i, p)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> visited[i] {
</span></span><span style=display:flex><span>                                Either::Left(<span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>                            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                Either::Right(<span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    new_blocks.remove(i);
</span></span><span style=display:flex><span>                    new_blocks.push(b1);
</span></span><span style=display:flex><span>                    new_blocks.push(b2);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>&#39;falling</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Apply gravity to worm
</span></span></span><span style=display:flex><span>            <span style=color:#a6e22e>&#39;worm_falling</span>: {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If any point is directly above a block or the ground, supported
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> new_worm.iter().any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> down <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into();
</span></span><span style=display:flex><span>                    down.y <span style=color:#f92672>&gt;=</span> global.height <span style=color:#f92672>||</span> new_blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>down))
</span></span><span style=display:flex><span>                }) {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Worm is supported directly&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> &#39;worm_falling;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If two adjacent segments are supported on the sides, supported
</span></span></span><span style=display:flex><span>                <span style=color:#75715e>// TODO: Is this the actual condition?
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> new_worm.windows(<span style=color:#ae81ff>2</span>).any(<span style=color:#f92672>|</span>w<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> left0 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> Direction::Left.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> right0 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> Direction::Right.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> left1 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> Direction::Left.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> right1 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> Direction::Right.into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    (new_blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>left0))
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> new_blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>right0)))
</span></span><span style=display:flex><span>                        <span style=color:#f92672>&amp;&amp;</span> (new_blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>left1))
</span></span><span style=display:flex><span>                            <span style=color:#f92672>||</span> new_blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>right1)))
</span></span><span style=display:flex><span>                }) {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Worm is supported on the sides&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> &#39;worm_falling;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we passed all other conditions, still falling, update worm and continue loop
</span></span></span><span style=display:flex><span>                tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Worm is falling&#34;</span>);
</span></span><span style=display:flex><span>                new_worm
</span></span><span style=display:flex><span>                    .iter_mut()
</span></span><span style=display:flex><span>                    .for_each(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> &#39;falling;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Apply gravity to blocks
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (i, b) <span style=color:#66d9ef>in</span> new_blocks.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>&#39;block_falling</span>: {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Supported by the ground
</span></span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> b.iter().any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> p.y <span style=color:#f92672>&gt;=</span> global.height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                        tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Block {i} is supported by the ground&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;block_falling;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Supported by the worm
</span></span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> b.iter()
</span></span><span style=display:flex><span>                        .any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> new_worm.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into())))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Block {i} is supported by the worm&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;block_falling;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Supported by another block
</span></span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((j, _)) <span style=color:#f92672>=</span> new_blocks.iter().enumerate().find(<span style=color:#f92672>|</span>(j, b2)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        i <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>j
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> b.iter().any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> down <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into();
</span></span><span style=display:flex><span>                                b2.contains(<span style=color:#f92672>&amp;</span>down)
</span></span><span style=display:flex><span>                            })
</span></span><span style=display:flex><span>                    }) {
</span></span><span style=display:flex><span>                        tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Block {i} is supported by block {j}&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;block_falling;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If the worm was solely supported by this block by the sides, it falls too
</span></span></span><span style=display:flex><span>                    <span style=color:#75715e>// If it was supported under by this block this will be handled next loop
</span></span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> new_worm.windows(<span style=color:#ae81ff>2</span>).any(<span style=color:#f92672>|</span>w<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> left0 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> Direction::Left.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> right0 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> Direction::Right.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> left1 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> Direction::Left.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> right1 <span style=color:#f92672>=</span> w[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> Direction::Right.into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        (b.contains(<span style=color:#f92672>&amp;</span>left0) <span style=color:#f92672>||</span> b.contains(<span style=color:#f92672>&amp;</span>right0))
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> (b.contains(<span style=color:#f92672>&amp;</span>left1) <span style=color:#f92672>||</span> b.contains(<span style=color:#f92672>&amp;</span>right1))
</span></span><span style=display:flex><span>                    }) {
</span></span><span style=display:flex><span>                        tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Worm might be slide falling due to block {i}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> new_worm.iter().any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> down <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into();
</span></span><span style=display:flex><span>                            self.blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>down))
</span></span><span style=display:flex><span>                        }) {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Another block is directly supporting the worm
</span></span></span><span style=display:flex><span>                            tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;^ Just kidding, worm is directly supported&#34;</span>);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>false</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// TODO: Another block is side supporting the worm
</span></span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Otherwise, fall with the block
</span></span></span><span style=display:flex><span>                            tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;^ Yes, it&#39;s falling&#34;</span>);
</span></span><span style=display:flex><span>                            new_worm
</span></span><span style=display:flex><span>                                .iter_mut()
</span></span><span style=display:flex><span>                                .for_each(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into());
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we made it to this point, the block is falling
</span></span></span><span style=display:flex><span>                    <span style=color:#75715e>// Update it and continue falling
</span></span></span><span style=display:flex><span>                    <span style=color:#75715e>// This may have allowed the worm to fall
</span></span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Block {i} ({b:?}) is falling&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> new_blocks[i].iter_mut() {
</span></span><span style=display:flex><span>                        <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Direction::Down.into();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span> &#39;falling;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we made it out of both loops, we&#39;re done with gravity
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> &#39;falling;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we made it all the way here, we have a valid state
</span></span></span><span style=display:flex><span>        Ok(Local {
</span></span><span style=display:flex><span>            worm: <span style=color:#a6e22e>new_worm</span>,
</span></span><span style=display:flex><span>            blocks: <span style=color:#a6e22e>new_blocks</span>,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This returns <code>Result</code> so that I can use it to generate <code>next_states</code>: if you have <code>Ok</code> that&rsquo;s a new state, but <code>Err</code> is not.</p><p>First, update the worm (error if we double back or go out of bounds).</p><p>After that, remove a bit from any block that we run into.</p><p>After that, we have the first interesting bit of logic: removing empty blocks and potentially splitting blocks if we crawled through them. <code>partition_map</code> (from <code><a href=https://docs.rs/itertools/latest/itertools/>itertools</a></code>
) is nice!</p><p>And then finally, the most complicated bit: falling. To handle this:</p><ul><li>Loop forever (until everything stops falling)<ul><li>Check if the worm is supported:<ul><li>If any segment is on the ground, it is supported</li><li>If any segment is directly above a block, it is supported</li><li>If any two (consecutive) segments are supported on the sides, the worm is supported. This was the trickiest, but a great reason to use the <code>windows</code> function</li></ul></li><li>If all of those conditions fail, the worm drops and restart the main loop</li><li>Otherwise, for each block, check if it&rsquo;s supported:<ul><li>If a block is on the ground, it is supported</li><li>If any chunk of the block is directly above a <em>different</em> block, it is supported<ul><li>Note: This doesn&rsquo;t cover interlocked blocks, but this didn&rsquo;t happen in any of the levels here</li></ul></li><li>If any chunk is above the worm, it is supported</li><li>Otherwise, the block falls:<ul><li>Update the block</li><li>Check if this block was solely supporting the worm by the sides: if so, the worm also needs to move (this was an edge case that one of the levels <em>did</em> need!)</li><li>Restart the main loop</li></ul></li></ul></li></ul></li></ul><p>That took a minute to get all of the smallest cases!</p><p>But that&rsquo;s actually it! Simulation!</p><h2 id=impl-state><code>impl State</code></h2><p>Okay. Now, like always, we need to implement <code>State</code>.</p><h3 id=next_states><code>next_states</code></h3><p>This one is pretty straight forward, exactly because of how I implemented <code>Local</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), fields(self = %self))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, Direction, Local)<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_states <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> self.step(d, global) {
</span></span><span style=display:flex><span>                Ok(new_state) <span style=color:#f92672>=&gt;</span> next_states.push((<span style=color:#ae81ff>1</span>, d, new_state)),
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>debug!</span>(<span style=color:#e6db74>&#34;Invalid step in direction {:?}: {}&#34;</span>, d, e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we have any new states, return them
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>next_states.is_empty() {
</span></span><span style=display:flex><span>            Some(next_states)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m actually tempted to refactor the solver itself to make it so that <code>Local</code> must have a <code>fn step(&amp;self, step: &amp;S, global: &amp;Global) -> Result&lt;Local, _></code> sort of function on whatever the step <code>S</code> type is.</p><p>Another day.</p><h3 id=is_solved><code>is_solved</code></h3><p>So <code>Global</code> has a <code>Vec&lt;bool></code> and <code>Local</code> has <code>Vec&lt;Vec&lt;Point>></code>. How do we know when the puzzle <code>is_solved</code>?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(global), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solved</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> local_cells <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#66d9ef>false</span>; global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> b <span style=color:#66d9ef>in</span> self.blocks.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> b.iter() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> (p.y <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> p.x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                local_cells[index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        global.cells <span style=color:#f92672>==</span> local_cells
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That is probably room for optimization, since I have to mostly recalculate that every frame. Worth some benchmarking, I think.</p><h3 id=is_valid><code>is_valid</code></h3><p>Initially, this was just <code>true</code>. Any state we generated was valid, but eventually I realized that it <em>was</em> possible to cut out large swathes of the solution space:</p><p><img src=invalid.png alt="Demonstrate an invalid state"></p><p>It&rsquo;s possible for each chunk of wood to fall down, but it&rsquo;s never possible for them to go upwards. So in this case, the far left row is impossible, since there are no chunks that are still in the right place to match the left side of the shape.</p><p>In code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(global), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Blocks can only fall straight down, if any column doesn&#39;t have enough
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// This is measured top down since chunks can never go up or side to side
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> chunk_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> target_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.blocks.iter().any(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.contains(<span style=color:#f92672>&amp;</span>Point { x, y })) {
</span></span><span style=display:flex><span>                    chunk_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> global.cells[(y <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>] {
</span></span><span style=display:flex><span>                    target_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> chunk_count <span style=color:#f92672>&lt;</span> target_count {
</span></span><span style=display:flex><span>                    tracing::<span style=color:#a6e22e>debug!</span>(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Not enough blocks in column {}: {} &lt; {}&#34;</span>,
</span></span><span style=display:flex><span>                        x,
</span></span><span style=display:flex><span>                        chunk_count,
</span></span><span style=display:flex><span>                        target_count
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=heuristic><code>heuristic</code></h3><p>This was originally also 0, but eventually I decided that &lsquo;how close we are to the solution&rsquo; would be a good choice:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, Direction<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>heuristic</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The number of chunks not in the correct position
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> local_cells <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[<span style=color:#66d9ef>false</span>; global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> b <span style=color:#66d9ef>in</span> self.blocks.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> b.iter() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> (p.y <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> p.x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                local_cells[index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> heuristic <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i, <span style=color:#f92672>&amp;</span>cell) <span style=color:#66d9ef>in</span> local_cells.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                x: (i <span style=color:#f92672>%</span> global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                y: (i <span style=color:#f92672>/</span> global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cell <span style=color:#f92672>!=</span> global.cells[i] {
</span></span><span style=display:flex><span>                heuristic <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        heuristic
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it! Solved.</p><h2 id=optimization>Optimization</h2><p>Okay, let&rsquo;s see where we&rsquo;re spending time:</p><img width=800 src=flamegraph.svg alt="A flamegraph of woodworm"><p>(<a target=_black href=flamegraph.svg>Open in a new tab</a>)</p><p>It is interesting that we&rsquo;re spending almost as much time on <code>is_valid</code> as we are on <code>step</code>. But this is why you can&rsquo;t just use one form of profiling:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Without is_valid</span>
</span></span><span style=display:flex><span>~/Projects/rust-solvers jp@venus <span style=color:#f92672>{</span>git main<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ cat data/woodworm/13-tv.txt | RUST_LOG<span style=color:#f92672>=</span>debug cargo run --release --bin woodworm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:06:10Z DEBUG woodworm<span style=color:#f92672>]</span> Solver&lt;time<span style=color:#f92672>=</span>7.913953, checked<span style=color:#f92672>=</span>666530, queue<span style=color:#f92672>=</span>817834, invalid<span style=color:#f92672>=</span>0, time_pruned<span style=color:#f92672>=</span>452361&gt;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:06:10Z INFO  woodworm<span style=color:#f92672>]</span> 6x8
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ...111111...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...110011...
</span></span><span style=display:flex><span>    .....00**...
</span></span><span style=display:flex><span>    ....2222â˜º...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:06:10Z INFO  woodworm<span style=color:#f92672>]</span> Path: <span style=color:#f92672>[</span>Right, Up, Right, Right, Up, Up, Left, Up, Up, Up, Right, Right, Right, Down, Down, Down, Left, Down, Down, Right, Right, Down<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Sequence: RURRU ULUUU RRRDD DLDDR RD
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># With is_valid</span>
</span></span><span style=display:flex><span>$ cat data/woodworm/13-tv.txt | RUST_LOG<span style=color:#f92672>=</span>debug cargo run --release --bin woodworm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:07:10Z DEBUG woodworm<span style=color:#f92672>]</span> Solver&lt;time<span style=color:#f92672>=</span>1.1491113, checked<span style=color:#f92672>=</span>91799, queue<span style=color:#f92672>=</span>34983, invalid<span style=color:#f92672>=</span>79485, time_pruned<span style=color:#f92672>=</span>62063&gt;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:07:10Z INFO  woodworm<span style=color:#f92672>]</span> 6x8
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ............
</span></span><span style=display:flex><span>    ...111111...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...1....1...
</span></span><span style=display:flex><span>    ...110011...
</span></span><span style=display:flex><span>    .....00**...
</span></span><span style=display:flex><span>    ....2222â˜º...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2025-04-21T20:07:10Z INFO  woodworm<span style=color:#f92672>]</span> Path: <span style=color:#f92672>[</span>Right, Up, Right, Right, Up, Up, Left, Up, Up, Up, Right, Right, Right, Down, Down, Down, Left, Down, Down, Right, Right, Down<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>Sequence: RURRU ULUUU RRRDD DLDDR RD
</span></span></code></pre></div><p>7.9 seconds versus 1.1 seconds.</p><p>That means that:</p><table><thead><tr><th></th><th>Without</th><th>With</th></tr></thead><tbody><tr><td>Time</td><td>7.91s</td><td>1.15s</td></tr><tr><td>Checked</td><td>666,530</td><td>91,799</td></tr><tr><td>Queued</td><td>817,834</td><td>34,983</td></tr><tr><td>Invalid</td><td>0</td><td>79,485</td></tr></tbody></table><p>So we ran ~4x faster and examined roughly ~1/7 as many states by tossing out 80k states that were invalid. &lsquo;But wait&mldr;&rsquo; you might say &rsquo;those don&rsquo;t add up&mldr;&rsquo; That&rsquo;s because for each state that is declared <code>invalid</code>, we can toss <em>any</em> states that we would have generated from that state as well. That&rsquo;s also why we had significantly less states in the <code>With</code> queue.</p><p>Optimization!</p><h2 id=final-remarks>Final remarks</h2><p>In any case, this isn&rsquo;t nearly as complicated a puzzle game as those I&rsquo;ve solved in the past, but it was still a lot of fun!</p><p>One thing I would feel remiss if I didn&rsquo;t mention:</p><p><img src=solved.png alt="Showing which levels are solved"></p><p>I still haven&rsquo;t managed to solve the last 3 (and there were 4 that took more than 10k seconds). They just get too big for the search (as it is) to find the correct solutions. Which is a lot of fun. Can I write a better heuristic? A better validity or state checker?</p><p>Is it possible that I&rsquo;m actually completely missing a rule of the game?</p><p>Could be!</p><p>But for now, I think this is enough.</p><p>Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>