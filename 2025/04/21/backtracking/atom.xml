<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backtracking on jverkamp.com</title><link>https://blog.jverkamp.com/2025/04/21/backtracking/</link><description>Recent content in Backtracking on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 21 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/2025/04/21/backtracking/atom.xml" rel="self" type="application/rss+xml"/><item><title>Solving Woodworm</title><link>https://blog.jverkamp.com/2025/04/21/solving-woodworm/</link><pubDate>Mon, 21 Apr 2025 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2025/04/21/solving-woodworm/</guid><description>&lt;p>Woodworm is a cute little &lt;a href="https://www.lexaloffle.com/pico-8.php" target="_blank" rel="noopener">PICO-8&lt;/a> puzzle game about a cute little worm&amp;hellip; that eats wood. You can play it for free right now &lt;a href="https://spratt.itch.io/woodworm" target="_blank" rel="noopener">right here&lt;/a>!&lt;/p>
&lt;p>The goal is to turn this:&lt;/p>
&lt;p>&lt;img src="level-1.png" alt="Level 1, before solving">&lt;/p>
&lt;p>Into this:&lt;/p>
&lt;p>&lt;img src="level-1-solved.png" alt="Level 1, after solving">&lt;/p>
&lt;p>There are a few rules to keep in mind:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The block (and the worm) are affected by gravity&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The block can be split by into multiple pieces by eating it completely apart&lt;/p>
&lt;p>&lt;img src="gravity.png" alt="Demonstrating gravity">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The worm can crawl up the side of blocks, so long as two (consecutive) segments of the worm are touching walls&lt;/p>
&lt;p>&lt;img src="climbing.png" alt="Demonstrating climbing">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>And that&amp;rsquo;s really it.&lt;/p>
&lt;p>So let&amp;rsquo;s solve it!&lt;/p></description></item><item><title>Freshly (Frosted) Solved</title><link>https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/</link><pubDate>Thu, 23 Jan 2025 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2025/01/23/freshly-frosted-solved/</guid><description>&lt;p>And so it begins.&lt;/p>
&lt;p>&lt;a href="https://store.steampowered.com/app/1070790/Freshly_Frosted/" target="_blank" rel="noopener">Freshly Frosted&lt;/a>&lt;/p>
&lt;p>It&amp;rsquo;s a cute little puzzle game about making a donut factory.&lt;/p>
&lt;p>It&amp;rsquo;s a lot like &lt;a href="https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/">Solving Cosmic Express&lt;/a> in that it&amp;rsquo;s a &amp;lsquo;puzzle on rails&amp;rsquo;, you are basically routing around the grid from source to target. In the way, we have to go to certain tiles in a certain order (in this case, to apply toppings to our donuts).&lt;/p>
&lt;p>&lt;img src="01-01.png" alt="The first level">&lt;/p>
&lt;p>Let&amp;rsquo;s do it!&lt;/p></description></item><item><title>AoC 2024 Day 19: Regexinator</title><link>https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/</link><pubDate>Thu, 19 Dec 2024 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/</guid><description>&lt;h2 id="source-day-19-linen-layout">Source: &lt;a href="https://adventofcode.com/2024/day/19" target="_blank" rel="noopener">Day 19: Linen Layout&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day19.rs" target="_blank" rel="noopener">Full solution&lt;/a> for today (spoilers!).&lt;/p>
&lt;nav id="TableOfContents">
 &lt;ul>
 &lt;li>&lt;a href="#source-day-19-linen-layout">Source: &lt;a href="https://adventofcode.com/2024/day/19">Day 19: Linen Layout&lt;/a>&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#part-1">Part 1&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#lets-write-it-ourselves-backtracking">Let&amp;rsquo;s write it ourselves: Backtracking&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#optimization-1-simplified-backtracking">Optimization 1: Simplified backtracking&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#optimization-2-memoization">Optimization 2: Memoization&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#part-2">Part 2&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#benchmarks">Benchmarks&lt;/a>&lt;/li>
 &lt;/ul>
&lt;/nav>

&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a comma delimited list of substrings and a list of strings, count how many of the latter strings can be made up of any (repeating) combination of the former.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2024 Day 17: Virtual Machininator</title><link>https://blog.jverkamp.com/2024/12/17/aoc-2024-day-17-virtual-machininator/</link><pubDate>Tue, 17 Dec 2024 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2024/12/17/aoc-2024-day-17-virtual-machininator/</guid><description>&lt;h2 id="source-day-17-chronospatial-computer">Source: &lt;a href="https://adventofcode.com/2024/day/17" target="_blank" rel="noopener">Day 17: Chronospatial Computer&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day17.rs" target="_blank" rel="noopener">Full solution&lt;/a> for today (spoilers!).&lt;/p>
&lt;nav id="TableOfContents">
 &lt;ul>
 &lt;li>&lt;a href="#source-day-17-chronospatial-computer">Source: &lt;a href="https://adventofcode.com/2024/day/17">Day 17: Chronospatial Computer&lt;/a>&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#part-1">Part 1&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#instructions">Instructions&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#parameter-specification">Parameter specification&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#unit-tests">Unit tests&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#part-2">Part 2&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#so-what-is-our-program-actually-doing">So what is our program actually doing?&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#psuedo-code-hash">Psuedo-code hash&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#whats-actually-changing">What&amp;rsquo;s actually changing?&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#zero-guarantees">Zero guarantees&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#the-actual-answer">The actual answer&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#benchmarks">Benchmarks&lt;/a>&lt;/li>
 &lt;/ul>
&lt;/nav>

&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Implement a virtual machine. The machine will have 3 unbounded signed registers, 8 opcodes (see below), a variable parameter scheme (see below that). You will be given the initial values of the 3 registers and a program. Find the final output.&lt;/p>&lt;/blockquote>
&lt;h3 id="instructions">Instructions&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Opcode&lt;/th>
 &lt;th>Instruction&lt;/th>
 &lt;th>Description&lt;/th>
 &lt;th>Notes&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>0&lt;/td>
 &lt;td>&lt;code>adv reg/val&lt;/code>&lt;/td>
 &lt;td>&lt;code>A = A &amp;gt;&amp;gt; OP&lt;/code>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>&lt;code>bxl val&lt;/code>&lt;/td>
 &lt;td>&lt;code>B = B ^ OP&lt;/code>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>&lt;code>bst reg/val&lt;/code>&lt;/td>
 &lt;td>&lt;code>B = OP &amp;amp; 0b111&lt;/code>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>&lt;code>jnz val&lt;/code>&lt;/td>
 &lt;td>If &lt;code>a =/= 0&lt;/code>, jump to &lt;code>LIT&lt;/code>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4&lt;/td>
 &lt;td>&lt;code>bxc ignore&lt;/code>&lt;/td>
 &lt;td>&lt;code>B = B ^ C&lt;/code>&lt;/td>
 &lt;td>Still takes param, but ignores it&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5&lt;/td>
 &lt;td>&lt;code>out reg/val&lt;/code>&lt;/td>
 &lt;td>Output &lt;code>b&lt;/code>&lt;/td>
 &lt;td>Only outputs lowest 3 bits&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6&lt;/td>
 &lt;td>&lt;code>bdv reg/val&lt;/code>&lt;/td>
 &lt;td>&lt;code>B = A &amp;gt;&amp;gt; OP&lt;/code>&lt;/td>
 &lt;td>Same as &lt;code>adv&lt;/code> but writes to &lt;code>b&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>7&lt;/td>
 &lt;td>&lt;code>cdv reg/val&lt;/code>&lt;/td>
 &lt;td>&lt;code>C = A &amp;gt;&amp;gt; OP&lt;/code>&lt;/td>
 &lt;td>Same as &lt;code>adv&lt;/code> but writes to &lt;code>c&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="parameter-specification">Parameter specification&lt;/h3>
&lt;p>For instructions that can take &lt;code>reg/val&lt;/code>, &lt;code>0&lt;/code> to &lt;code>3&lt;/code> (inclusive) are treated as literal values, &lt;code>4&lt;/code> is register &lt;code>A&lt;/code>, &lt;code>5&lt;/code> is &lt;code>B&lt;/code>, &lt;code>6&lt;/code>, is &lt;code>C&lt;/code>, and &lt;code>7&lt;/code> is an error (should never happen).&lt;/p>
&lt;p>For instructions that only take &lt;code>val&lt;/code>, it&amp;rsquo;s always a literal value in the range &lt;code>0&lt;/code> to &lt;code>7&lt;/code> (inclusive).&lt;/p></description></item><item><title>AoC 2024 Day 7: Mathinator</title><link>https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/</link><pubDate>Sat, 07 Dec 2024 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2024/12/07/aoc-2024-day-7-mathinator/</guid><description>&lt;h2 id="source-day-7-bridge-repair">Source: &lt;a href="https://adventofcode.com/2024/day/7" target="_blank" rel="noopener">Day 7: Bridge Repair&lt;/a>&lt;/h2>
&lt;p>&lt;a href="https://github.com/jpverkamp/advent-of-code/blob/master/2024/src/day7.rs" target="_blank" rel="noopener">Full solution&lt;/a> for today (spoilers!).&lt;/p>
&lt;nav id="TableOfContents">
 &lt;ul>
 &lt;li>&lt;a href="#source-day-7-bridge-repair">Source: &lt;a href="https://adventofcode.com/2024/day/7">Day 7: Bridge Repair&lt;/a>&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#part-1">Part 1&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#optimization-attempt-1-queue">Optimization (attempt) 1: Queue&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#part-2">Part 2&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#a-cleaner-way-of-looking-at-it-opset">A &amp;lsquo;cleaner&amp;rsquo; way of looking at it: &lt;code>OpSet&lt;/code>&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#benchmarks">Benchmarks&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#future-work">Future work&lt;/a>&lt;/li>
 &lt;/ul>
&lt;/nav>

&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a result and a list of numbers, determine if any combination of addition (&lt;code>+&lt;/code>) and/or multiplication (&lt;code>*&lt;/code>) using all the given numbers in order can return the result. Ignore order of operations.&lt;/p>&lt;/blockquote></description></item><item><title>Solving Cosmic Express</title><link>https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/</link><pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/</guid><description>&lt;p>Another &lt;a href="https://blog.jverkamp.com/series/rust-solvers/">Rust Solvers&lt;/a> puzzle: &lt;a href="https://store.steampowered.com/app/583270/Cosmic_Express/" target="_blank" rel="noopener">Cosmic Express&lt;/a>. Basically, it&amp;rsquo;s a routefinding puzzle. You have a train that needs a track from entrance to exit, picking up and dropping off cargo on the way.&lt;/p>
&lt;p>It&amp;rsquo;s actual a relatively simple puzzle, so far as things go, but one thing that&amp;rsquo;s interesting from a solving perspective is that branching paths &lt;em>really&lt;/em> don&amp;rsquo;t work great with my solver code. Paths just have a crazy branching factor when compared to (for example) &lt;a href="https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/">playing one of a handful of cards&lt;/a>.&lt;/p>
&lt;p>But it&amp;rsquo;s still an interesting puzzle!&lt;/p></description></item><item><title>The Golf (Peaks) of Solving</title><link>https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/</link><pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/06/17/the-golf-peaks-of-solving/</guid><description>&lt;p>Another day (week? month?), another puzzle game.&lt;/p>
&lt;p>This time around, we&amp;rsquo;re going to solve &lt;a href="https://store.steampowered.com/app/923260/Golf_Peaks/" target="_blank" rel="noopener">Golf Peaks&lt;/a>. I picked this up a while ago on iOS, but only recently on Steam. It&amp;rsquo;s a cute little puzzle game themed around minigolf.&lt;/p>
&lt;p>&lt;img src="1.7-slopes.png" alt="">&lt;/p>
&lt;p>Basically, you&amp;rsquo;re on a grid and you have to get the ball (in the bottom in that screenshot above) to the flag (currently at the top). You have a set list of moves you can take, styled as cards&amp;ndash;all of which either move a certain number of tiles in a specific direction or possibly jump into the air (and fly over obstacles).&lt;/p>
&lt;p>It gets more complicated from there, but hopefully you have the basic idea. &amp;#x1f604;&lt;/p></description></item><item><title>Solving Sokobond</title><link>https://blog.jverkamp.com/2024/04/06/solving-sokobond/</link><pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/04/06/solving-sokobond/</guid><description>&lt;p>Another solver that I&amp;rsquo;ve been working on, after &lt;a href="https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/">A Good Snowman Is Hard To &amp;hellip; Solve?&lt;/a>. This time, we have &lt;a href="https://store.steampowered.com/app/290260/Sokobond/" target="_blank" rel="noopener">Sokobond&lt;/a>! It&amp;rsquo;s a &lt;a href="https://en.wikipedia.org/wiki/Sokobon">Sokobon&lt;/a>&amp;hellip; but with chemical bonds! Yeah, that&amp;rsquo;s a really good title.&lt;/p>
&lt;p>The basic idea is you have a field of elements with (chemical accurate) free electrons):&lt;/p>
&lt;p>&lt;img src="basic-image.png" alt="A basic level">&lt;/p>
&lt;p>Here we have 4 hydrogens (1 bond each) and a carbon (4 bonds). It should seem pretty obvious that the carbon should end up with a hydrogen on each end. The one last bit of interest: the element with the dashed border is the one we actually control, that will never change.&lt;/p>
&lt;p>This eventually gets more complicated, adding:&lt;/p>
&lt;ul>
&lt;li>Modifiers that are placed on the map between squares:
&lt;ul>
&lt;li>One that strengthens bonds, turning a single bond into double into triple&lt;/li>
&lt;li>One that weakens bonds, turning triple to double to single or breaking single bonds&lt;/li>
&lt;li>One that rotates bonds as you move by it&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>More elements, eventually hydrogen (1), oxygen (2), nitrogen (3), carbon (4), and helium (0)&lt;/li>
&lt;li>Solutions that require forming multiple elements at the same time&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s a pretty neat puzzle game with 144 levels of increasing difficulty. Perfect to solve.&lt;/p>
&lt;hr></description></item><item><title>A Good Snowman Is Hard To ... Solve?</title><link>https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/</link><pubDate>Thu, 28 Mar 2024 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2024/03/28/a-good-snowman-is-hard-to-...-solve/</guid><description>&lt;p>I enjoy puzzle games. I especially enjoy letting computers solve them for me &amp;#x1f604;. Once upon a time, I set up a &lt;a href="https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/">framework for solving random things&lt;/a>. Let&amp;rsquo;s solve some more.&lt;/p>
&lt;p>Today: &lt;a href="https://store.steampowered.com/app/316610/A_Good_Snowman_Is_Hard_To_Build/" target="_blank" rel="noopener">A Good Snowman Is Hard To Build&lt;/a>&lt;/p>
&lt;p>It&amp;rsquo;s a &lt;a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban&lt;/a> about making snowmen! You can push snowballs of three sizes around, collecting snow if you roll over it. You can push smaller snowballs onto bigger ones, stacking them. Or back off, in order to get around one another.&lt;/p>
&lt;p>And that&amp;rsquo;s really it.&lt;/p>
&lt;p>There are some interesting twists (multiple snowmen, the ability to leave and re-enter levels, and even a whole second &amp;lsquo;hard mode&amp;rsquo;), but at a basic level, it&amp;rsquo;s just pushing.&lt;/p></description></item><item><title>AoC 2022 Day 24: Blizzinator</title><link>https://blog.jverkamp.com/2022/12/24/aoc-2022-day-24-blizzinator/</link><pubDate>Sat, 24 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/24/aoc-2022-day-24-blizzinator/</guid><description>&lt;h2 id="source-blizzard-basin">Source: &lt;a href="https://adventofcode.com/2022/day/24" target="_blank" rel="noopener">Blizzard Basin&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a map with a series of moving walls (that wrap when the hit the edges of the simulation), calculate the fastest route from the top left to the bottom right.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 23: Elf Scattinator</title><link>https://blog.jverkamp.com/2022/12/23/aoc-2022-day-23-elf-scattinator/</link><pubDate>Fri, 23 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/23/aoc-2022-day-23-elf-scattinator/</guid><description>&lt;h2 id="source-unstable-diffusion">Source: &lt;a href="https://adventofcode.com/2022/day/23" target="_blank" rel="noopener">Unstable Diffusion&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Implement a &lt;a href="https://en.wikipedia.org/wiki/cellular%20automaton">cellular automaton&lt;/a> with the following rules:&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>If you have no neighbors, don&amp;rsquo;t move (&lt;em>important, I forgot this one for a while&lt;/em>)&lt;/li>
&lt;li>Otherwise:
&lt;ul>
&lt;li>Calculate a potential move:
&lt;ul>
&lt;li>If you have no neighbors to the north, move north&lt;/li>
&lt;li>If not, check likewise for south, then west, than east&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If no other agent is moving to the same space, move to your potential move&lt;/li>
&lt;li>Otherwise, don&amp;rsquo;t move&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>On each frame, rotate the order the directions are checked in (&lt;code>NSWE&lt;/code>, &lt;code>SWEN&lt;/code>, &lt;code>WENS&lt;/code>, &lt;code>ENSW&lt;/code>, &lt;code>NSWE&lt;/code>, &amp;hellip;)&lt;/li>
&lt;/ul></description></item><item><title>AoC 2022 Day 19: Blueprintinator</title><link>https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/</link><pubDate>Mon, 19 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/</guid><description>&lt;h2 id="source-not-enough-minerals">Source: &lt;a href="https://adventofcode.com/2022/day/19" target="_blank" rel="noopener">Not Enough Minerals&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a series of given a series of &lt;code>blueprints&lt;/code>, each of which gives instructions for how to build a single &lt;code>robot&lt;/code> from a collection of &lt;code>materials&lt;/code> that in turn will produce one of a given &lt;code>material&lt;/code> per turn, determine the best order of builds to maximize your &lt;code>geode&lt;/code> (the most valuable &lt;code>material&lt;/code>) production for each &lt;code>blueprint&lt;/code> given a time limit of &lt;code>24 minutes&lt;/code>.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 16: Pressurinator</title><link>https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/</link><pubDate>Fri, 16 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/</guid><description>&lt;h2 id="source-proboscidea-volcanium">Source: &lt;a href="https://adventofcode.com/2022/day/16" target="_blank" rel="noopener">Proboscidea Volcanium&lt;/a>&lt;/h2>
&lt;nav id="TableOfContents">
 &lt;ul>
 &lt;li>&lt;a href="#source-proboscidea-volcanium">Source: &lt;a href="https://adventofcode.com/2022/day/16">Proboscidea Volcanium&lt;/a>&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#part-1">Part 1&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#optimized-version-with-multiple-steps-and-no-repeats">Optimized version with multiple steps and no-repeats&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#the-actual-code">The actual code&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#attempted-to-solve-via-30-steps-of-all-possibilities">Attempted to solve via 30 steps of all possibilities&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#a-priority-queue-edit-2-dec-20">A Priority Queue (Edit 2, Dec 20)&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#part-2">Part 2&lt;/a>
 &lt;ul>
 &lt;li>&lt;a href="#simulating-n-agents">Simulating &lt;em>n&lt;/em> agents&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#new-multi-agent-code-with-one-agent">New multi-agent code with one agent&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#checking-with-multiple-agents">Checking with multiple agents&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#problems-with-memory-">Problems with memory (?)&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#improving-memory-usage">Improving memory usage&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#improving-runtime">Improving runtime&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#to-be-continued">To be continued&amp;hellip;&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#let-it-run-edit-dec-20">Let it run! (Edit, Dec 20)&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#queues-to-the-rescue-edit-3-dec-20">Queues to the rescue (Edit 3, Dec 20)&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#optimization-remaining_best_case-edit-4-dec-21">Optimization: &lt;code>remaining_best_case&lt;/code> (Edit 4, Dec 21)&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#optimization-seen_skip-edit-4-dec-21">Optimization: &lt;code>seen_skip&lt;/code> (Edit 4, Dec 21)&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#threading">Threading&lt;/a>&lt;/li>
 &lt;/ul>
 &lt;/li>
 &lt;li>&lt;a href="#graphviz-visualizations">Graphviz visualizations&lt;/a>&lt;/li>
 &lt;li>&lt;a href="#performance">Performance&lt;/a>&lt;/li>
 &lt;/ul>
&lt;/nav>

&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a graph of nodes, some of which have a &lt;code>pressure&lt;/code> (per tick output value) and an agent that can move through the graph and activate specific nodes (so that they output their per tick value every future tick), what is the maximum total output possible in 30 steps?&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 15: Beaconator</title><link>https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/</link><pubDate>Thu, 15 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/</guid><description>&lt;h2 id="source-beacon-exclusion-zone">Source: &lt;a href="https://adventofcode.com/2022/day/15" target="_blank" rel="noopener">Beacon Exclusion Zone&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>There are a collections of &lt;code>Sensor&lt;/code>s and &lt;code>Beacon&lt;/code>s. As input, you are given the &lt;code>Beacon&lt;/code> closest to each &lt;code>Sensor&lt;/code> (using &lt;a href="https://en.wikipedia.org/wiki/Manhattan%20Distance">Manhattan Distance&lt;/a>). If a &lt;code>Beacon&lt;/code> is not closest to any sensor, it will not appear in this list. Calculate how many points in the given row (&lt;code>y=2000000&lt;/code>) cannot contain a &lt;code>Beacon&lt;/code>.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 14: Sandinator</title><link>https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/</link><pubDate>Wed, 14 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/</guid><description>&lt;h2 id="source-regolith-reservoir">Source: &lt;a href="https://adventofcode.com/2022/day/14" target="_blank" rel="noopener">Regolith Reservoir&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a series of walls as input, run a &lt;a href="https://en.wikipedia.org/wiki/falling%20sand">falling sand&lt;/a> simulation until any new sand falls of the map. Count how many grains of sand we end up with.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 12: Climbiantor</title><link>https://blog.jverkamp.com/2022/12/12/aoc-2022-day-12-climbiantor/</link><pubDate>Mon, 12 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/12/aoc-2022-day-12-climbiantor/</guid><description>&lt;h2 id="source-hill-climbing-algorithm">Source: &lt;a href="https://adventofcode.com/2022/day/12" target="_blank" rel="noopener">Hill Climbing Algorithm&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a height map, find the shortest path between two points such that the path can descend any distance but can only climb by a maximum of 1.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2022 Day 8: Treetopinator</title><link>https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/</link><pubDate>Thu, 08 Dec 2022 00:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/</guid><description>&lt;h2 id="source-treetop-tree-house">Source: &lt;a href="https://adventofcode.com/2022/day/8" target="_blank" rel="noopener">Treetop Tree House&lt;/a>&lt;/h2>
&lt;h2 id="part-1">Part 1&lt;/h2>
&lt;blockquote>
&lt;p>Given a grid of numbers, count how many of these numbers have a direct path in any cardinal direction to the edge of the grid.&lt;/p>&lt;/blockquote></description></item><item><title>Stateful Solvers and Iterators</title><link>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/16/stateful-solvers-and-iterators/</guid><description>&lt;p>&lt;a href="programming/languages/rust/">Rust&lt;/a>, yet again! Let&amp;rsquo;s take what we did last time with &lt;a href="https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/">Solving Sudoku (again)&lt;/a> and improve the code structure a bit more.&lt;/p>
&lt;p>Goals:&lt;/p>
&lt;ul>
&lt;li>Create a &amp;lsquo;Solver&amp;rsquo; struct that can maintain state (such as how many states we&amp;rsquo;ve visited, how much time we&amp;rsquo;ve spent)&lt;/li>
&lt;li>Track the above stats&lt;/li>
&lt;li>Turn the &amp;lsquo;Solver&amp;rsquo; into an iterator which will iterate through given solutions (a single call will give the first solution or you can run through the iterator to get all of them)&lt;/li>
&lt;/ul>
&lt;p>If you&amp;rsquo;d like to follow along, I&amp;rsquo;ve started uploading the code here: &lt;a href="https://github.com/jpverkamp/rust-solvers" target="_blank" rel="noopener">https://github.com/jpverkamp/rust-solvers&lt;/a>&lt;/p></description></item><item><title>Solving Sudoku (again)</title><link>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2022/10/04/solving-sudoku-again/</guid><description>&lt;p>More &lt;a href="programming/languages/rust/">Rust&lt;/a>! This time, I want to go back to my post on &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/">A Generic Brute Force Backtracking Solver&lt;/a>. For one, because I&amp;rsquo;m learning Rust. For two, because there is a crate specifically for &lt;code>&lt;a href="https://docs.rs/im/latest/im/">im&lt;/a>&lt;/code>
mutable data structures. And for three, because I expect it will be much faster. We shall see!&lt;/p></description></item><item><title>Solving Snakebird</title><link>https://blog.jverkamp.com/2021/08/18/solving-snakebird/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2021/08/18/solving-snakebird/</guid><description>&lt;p>&lt;a href="https://store.steampowered.com/app/357300/Snakebird/" target="_blank" rel="noopener">Snakebird!&lt;/a>&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2021/snakebird-0.png">
&lt;/figure>

&lt;p>A cute little puzzle game, where you move around snake(birds). Move any number of snakes around the level, eating fruit, and getting to the exit. The main gotchas are that you have gravity to content with&amp;ndash;your snake will easily fall off the edge of the world&amp;ndash;and each time you eat a fruit, your snake gets bigger. This can help get longer to get into hard to reach places or it can cause trouble when you trap yourself in corners.&lt;/p>
&lt;p>Let&amp;rsquo;s use the new &lt;a href="2021-08-17-immutable.js-solvers">immutable.js solver&lt;/a> to solve these problems!&lt;/p></description></item><item><title>Immutable.js Solvers</title><link>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/</guid><description>&lt;p>A bit ago I wrote about writing a &lt;a href="https://blog.jverkamp.com/2021/06/25/a-generic-brute-force-backtracking-solver/">generic brute force solver&lt;/a> (wow, was that really two months ago?). It got &amp;hellip; complicate. Mostly, because every time I wrote a &lt;code>step&lt;/code> function, I had to be careful to undo the same. Wouldn&amp;rsquo;t it be nice if we could just write a step function and get backtracking for &amp;lsquo;free&amp;rsquo;?&lt;/p>
&lt;p>Well, with immutability you can!&lt;/p></description></item><item><title>AoC 2016 Day 24: Venti</title><link>https://blog.jverkamp.com/2016/12/24/aoc-2016-day-24-venti/</link><pubDate>Sat, 24 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/24/aoc-2016-day-24-venti/</guid><description>&lt;h3 id="source-air-duct-spelunking">Source: &lt;a href="http://adventofcode.com/2016/day/24" target="_blank" rel="noopener">Air Duct Spelunking&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Given a map of the form:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;pre tabindex="0">&lt;code>&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>###########
#0.1&amp;hellip;..2#
#.#######.#
#4&amp;hellip;&amp;hellip;.3#
###########&lt;/p>
&lt;pre tabindex="0">&lt;code>
&amp;gt; Find the shortest route to visit each of the points, starting at `0`.





First, we want to take the map that we were given and simplify it. We know that we want to visit all of the points, so lets take the original map and turn it just into a map of distances between any two named points.

```python
walls = set()
name_to_point = {}
point_to_name = {}

# Load the input file into a set of walls and the location of points of interest
for y, line in enumerate(fileinput.input(args.files)):
 for x, c in enumerate(line.strip()):
 if c.isdigit():
 name_to_point[int(c)] = (x, y)
 point_to_name[(x, y)] = int(c)

 elif c == &amp;#39;#&amp;#39;:
 walls.add((x, y))

# Dynamically fill a distance map to a given point
def distances_to(name):
 to_scan = queue.Queue()
 to_scan.put((name_to_point[name], 0))

 scanned = set()

 result = {}

 while not to_scan.empty():
 point, distance = to_scan.get()

 if point in point_to_name:
 name = point_to_name[point]
 if name not in result:
 result[name] = distance

 if point in scanned:
 continue
 else:
 scanned.add(point)

 x, y = point
 for xd, yd in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
 neighbor = (x + xd, y + yd)
 if neighbor not in walls:
 to_scan.put((neighbor, distance + 1))

 return result

distances = {
 name: distances_to(name)
 for name in name_to_point
}
names = list(sorted(name_to_point.keys()))
&lt;/code>&lt;/pre>&lt;p>The first part loads the map and the second part will flood fill out from each point. This will find the minimum distance from each named point to the given one, somewhat simplifying the problem.&lt;/p></description></item><item><title>AoC 2016 Day 17: Md5 Maze</title><link>https://blog.jverkamp.com/2016/12/17/aoc-2016-day-17-md5-maze/</link><pubDate>Sat, 17 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/17/aoc-2016-day-17-md5-maze/</guid><description>&lt;h3 id="source-two-steps-forward">Source: &lt;a href="http://adventofcode.com/2016/day/17" target="_blank" rel="noopener">Two Steps Forward&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Create a 4x4 grid of rooms with doors &lt;code>U&lt;/code>p, &lt;code>D&lt;/code>own, &lt;code>L&lt;/code>eft, and &lt;code>R&lt;/code>ight from each location. To determine if a door is currently open:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>Calculate &lt;code>MD5(salt + sequence)&lt;/code> where sequence is a string containing any combination of &lt;code>UDLR&lt;/code> depending on how you got to this room&lt;/li>
&lt;li>The first four hex values represent the doors &lt;code>U&lt;/code>p, &lt;code>D&lt;/code>own, &lt;code>L&lt;/code>eft, and &lt;code>R&lt;/code>ight respectively: &lt;code>bcdef&lt;/code> means open; anything else is closed&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;blockquote>
&lt;p>Find the shortest path from &lt;code>(0, 0)&lt;/code> to &lt;code>(3, 3)&lt;/code>.&lt;/p>&lt;/blockquote></description></item><item><title>AoC 2016 Day 11: Radiation Avoider</title><link>https://blog.jverkamp.com/2016/12/11/aoc-2016-day-11-radiation-avoider/</link><pubDate>Sun, 11 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2016/12/11/aoc-2016-day-11-radiation-avoider/</guid><description>&lt;h3 id="source-radioisotope-thermoelectric-generators">Source: &lt;a href="http://adventofcode.com/2016/day/11" target="_blank" rel="noopener">Radioisotope Thermoelectric Generators&lt;/a>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>Part 1:&lt;/strong> Input will be a list of the following form:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>The first floor contains a hydrogen-compatible microchip and a lithium-compatible microchip.&lt;/li>
&lt;li>The second floor contains a hydrogen generator.&lt;/li>
&lt;li>The third floor contains a lithium generator.&lt;/li>
&lt;li>The fourth floor contains nothing relevant.&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;blockquote>
&lt;p>You have an elevator that can move exactly 1 or 2 items. You can only leave a microchip on a floor with a non-matching generator if a matching generator is also present.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Move all items to the top (4th) floor.&lt;/p>&lt;/blockquote></description></item><item><title>Takuzu solver</title><link>https://blog.jverkamp.com/2015/10/29/takuzu-solver/</link><pubDate>Thu, 29 Oct 2015 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2015/10/29/takuzu-solver/</guid><description>&lt;p>Based on a &lt;a href="">/r/dailyprogrammer&lt;/a> puzzle: &lt;a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver&lt;/a>.&lt;/p>
&lt;p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:&lt;/p>
&lt;ul>
&lt;li>You cannot have more than three of the same number in a line&lt;/li>
&lt;li>Each column must have an equal number of 0s and 1s&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/li>
&lt;li>No two rows or no two columns can be identical&lt;/li>
&lt;/ul>
&lt;p>Thus, if you have a puzzle like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>0.01.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0....1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>..00..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>..00..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1....0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10.0.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>One valid solution (most puzzles should have only a single valid answer, but that doesn&amp;rsquo;t always seem to be the case):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>010101
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>001101
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>110010
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>010011
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>101100
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>101010
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s do it!&lt;/p></description></item><item><title>Tile Puzzle</title><link>https://blog.jverkamp.com/2014/10/28/tile-puzzle/</link><pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2014/10/28/tile-puzzle/</guid><description>&lt;p>It&amp;rsquo;s been a while&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, but I&amp;rsquo;m back. Today&amp;rsquo;s post is inspired by a post from /r/dailyprogrammer almost a month ago now: &lt;a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle&lt;/a>. Basically, we&amp;rsquo;re going to solve puzzles like this:&lt;/p>
&lt;p>&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2014/unsolved-3x3.png">
&lt;/figure>

&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2014/solved-3x3.png">
&lt;/figure>
&lt;/p>
&lt;p>If you look carefully, the tiles are the same between the two, although they might be rotated.&lt;/p></description></item><item><title>Chess Puzzles: Knight's Tour</title><link>https://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/</link><pubDate>Thu, 04 Sep 2014 20:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/</guid><description>&lt;p>Onwards and upwards! For today&amp;rsquo;s chess puzzle, let&amp;rsquo;s take a first crack at the &lt;a href="https://en.wikipedia.org/wiki/Knight%e2%80%99s%20Tour">Knight’s Tour&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2014/tour-5-solution.gif">
&lt;/figure></description></item><item><title>Chess Puzzles: N Queens</title><link>https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/</link><pubDate>Wed, 03 Sep 2014 20:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/</guid><description>&lt;p>After two weeks, it seems only right that we actually get around to a real chess puzzle. First on the list: &lt;a href="https://en.wikipedia.org/wiki/the%20eight%20queens%20puzzle">Eight queens puzzle&lt;/a>.&lt;/p>
&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2014/8-queens-solution.png">
&lt;/figure>

&lt;p>Specifically, how do you place n queens on an n by n chess board such that no pair of queens can attack one another?&lt;/p></description></item><item><title>Cracker Barrel Peg Game</title><link>https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/</link><pubDate>Sat, 05 Jul 2014 09:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/</guid><description>&lt;p>Ever been to &lt;a href="http://www.crackerbarrel.com/">Cracker Barrel&lt;/a>? Remember that &lt;a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game&lt;/a>? It seems that rather a few people are interested in how to solve it: &lt;a href="https://www.google.com/?q=cracker+barrel+peg+game">Google&lt;/a>. Let&amp;rsquo;s do that.&lt;/p></description></item><item><title>Trigonometric Triangle Trouble</title><link>https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/</link><pubDate>Fri, 02 May 2014 14:00:26 +0000</pubDate><guid>https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/</guid><description>&lt;p>&lt;a href="http://www.reddit.com/r/dailyprogrammer/comments/24hr25/522014_challenge_160_hard_trigonometric_triangle/" target="_blank" rel="noopener">Yesterday&amp;rsquo;s post&lt;/a> at &lt;a href="http://www.reddit.com/r/dailyprogrammer/" target="_blank" rel="noopener">/r/dailyprogrammer&lt;/a> managed to pique my interest&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;blockquote>
&lt;p>A triangle on a flat plane is described by its angles and side lengths, and you don&amp;rsquo;t need all of the angles and side lengths to work out everything about the triangle. (This is the same as last time.) However, this time, the triangle will not necessarily have a right angle. This is where more trigonometry comes in. Break out your trig again, people.&lt;/p>&lt;/blockquote></description></item><item><title>Path to philosophy</title><link>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</link><pubDate>Thu, 28 Mar 2013 14:00:05 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/28/path-to-philosophy/</guid><description>&lt;p>Yesterday, &lt;a title="Daily programmer sub-reddit" href="http://www.reddit.com/r/dailyprogrammer/">the daily programmer Subreddit&lt;/a> had &lt;a title="[03/27/13] Challenge #121 [Intermediate] Path to Philosophy" href="http://www.reddit.com/r/dailyprogrammer/comments/1b3ka1/032713_challenge_121_intermediate_path_to/">a post that&lt;/a> mirrored a problem I&amp;rsquo;ve often seen before: the idea that if you follow first links ((With some caveats)) on &lt;a href="https://en.wikipedia.org/wiki/Main%20Page">Wikipedia&lt;/a>, you eventually end with &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>. For example, if you follow the first links from &lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a>, you get the following path:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Molecule">Molecule&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Atom">Atom&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Matter">Matter&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Rest%20Mass">Rest Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Invariant%20Mass">Invariant Mass&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Energy">Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Kinetic%20Energy">Kinetic Energy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Physics">Physics&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Natural%20Philosophy">Natural Philosophy&lt;/a> → &lt;a href="https://en.wikipedia.org/wiki/Philosophy">Philosophy&lt;/a>&lt;/p>&lt;/blockquote></description></item><item><title>Chopping words</title><link>https://blog.jverkamp.com/2012/10/15/chopping-words/</link><pubDate>Mon, 15 Oct 2012 14:00:13 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/15/chopping-words/</guid><description>&lt;p>&lt;a title="Programming Praxis: Chopping Words" href="http://programmingpraxis.com/2012/07/03/chopping-words/">One more challenge&lt;/a> from Programming Praxis&amp;rsquo; &lt;a title="Programming Praxis: Themes: Word Games" href="http://programmingpraxis.com/contents/themes/#Word Games">Word Games&lt;/a> today (there are only a few left!). This time we have the challenge of cutting off bits of words, one letter at a time, such that each step is still a word.&lt;/p>
&lt;p>The example given in their post is &lt;code>planet → plane → plan → pan → an → a&lt;/code>, although surely many such examples exist.&lt;/p></description></item><item><title>Dodgson’s Doublets</title><link>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</link><pubDate>Sun, 14 Oct 2012 14:00:20 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</guid><description>&lt;p>Today we have &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt" target="_blank" rel="noopener">doublets source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt" target="_blank" rel="noopener">dictionary source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt" target="_blank" rel="noopener">queue source code&lt;/a>.&lt;/p>
&lt;p>Using the same source code as the previous two posts (&lt;a href="https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/">here&lt;/a> and &lt;a href="https://blog.jverkamp.com/2012/10/13/word-cubes/">here&lt;/a>, described originally &lt;a href="https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/">here&lt;/a>) for the dictionary, the code is a pretty straight forward case of using &lt;a href="https://en.wikipedia.org/wiki/recursion">recursion&lt;/a> to do &lt;a href="https://en.wikipedia.org/wiki/backtracking">backtracking&lt;/a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; find the path between two words, changing one letters at a time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; use call/cc to bail out when we find an answer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">direct-doublet&lt;/span> dict src dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">call/cc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">λ&lt;/span> (&lt;span style="color:#a6e22e">exit&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([src (&lt;span style="color:#a6e22e">string-upcase&lt;/span> src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [dst (&lt;span style="color:#a6e22e">string-upcase&lt;/span> dst)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; loop down possible solutions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>loop ([current src] [words (list src)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; when we find one, bail out entirely&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(equal? current dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> (reverse words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; try all possible values&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">for*/list&lt;/span> ([i (string-length src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [c &lt;span style="color:#e6db74">&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([next (&lt;span style="color:#a6e22e">string-set&lt;/span> current i c)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">when&lt;/span> (&lt;span style="color:#66d9ef">and &lt;/span>(not (member next words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">contains?&lt;/span> dict next))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">loop&lt;/span> next (cons next words))))))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> &lt;span style="color:#66d9ef">#f&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, I&amp;rsquo;m using a neat trick I last used on the post about &lt;a href="https://blog.jverkamp.com/2012/08/27/4sum/">4SUM&lt;/a> where &lt;code>call/cc&lt;/code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it&amp;rsquo;s a simple matter of using &lt;code>for*&lt;/code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we&amp;rsquo;ve seen before in this path), keep going. Eventually, we&amp;rsquo;ll find a solution and can bail out. On the off chance that we don&amp;rsquo;t, return &lt;code>#f&lt;/code>.&lt;/p></description></item><item><title>n-queens in 18 lines of code</title><link>https://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code/</link><pubDate>Mon, 24 Sep 2012 14:00:23 +0000</pubDate><guid>https://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code/</guid><description>&lt;p>One of the rites of passage for computer scientists it seems is to solve the &lt;a href="https://en.wikipedia.org/wiki/N-queens">Eight Queens Problem&lt;/a>&amp;ndash;where you must place 8 queens on a chessboard so that no pair of queens is attacking each other. Even better is when you can expand that to the n-queens problem with n queens on an n by n chessboard. After finding it again in older posts on both &lt;a href="http://programmingpraxis.com/2010/06/11/n-queens/" title="Programming Praxis: N-Queens">Programming Praxis&lt;/a> and &lt;a href="http://www.datagenetics.com/blog/august42012/index.html" title="DataGenetics: Eight Queens">DataGenetics&lt;/a>, I decided to go ahead and take a crack at it and I think the solution is pretty straight forward.&lt;/p></description></item></channel></rss>