<!doctype html><html><head><title>Freshly (Frosted) Solved – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Freshly (Frosted) Solved</h1><div class=entry-meta><span class=entry-date>2025-01-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/25/aoc-2024-day-25-christmas-lockpickinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/12/13/aoc-2024-day-13-cramerinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a></li><li><a href=https://blog.jverkamp.com/2024/12/19/aoc-2024-day-19-regexinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a></li><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/generators>Generators</a></li><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/puzzles>Puzzles</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/ class=previous-link></a><a class=taxonomy-value href=/series/rust-solvers>Rust Solvers</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2024/12/25/aoc-2024-day-25-christmas-lockpickinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/02/05/webcrypto-sha-256-hmac/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2025/01/21/arcane-season-2/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2025/01/25/doctor-who-season-2/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>And so it begins.</p><p><a href=https://store.steampowered.com/app/1070790/Freshly_Frosted/ target=_blank rel=noopener>Freshly Frosted</a></p><p>It&rsquo;s a cute little puzzle game about making a donut factory.</p><p>It&rsquo;s a lot like <a href=https://blog.jverkamp.com/2024/09/02/solving-cosmic-express/>Solving Cosmic Express</a> in that it&rsquo;s a &lsquo;puzzle on rails&rsquo;, you are basically routing around the grid from source to target. In the way, we have to go to certain tiles in a certain order (in this case, to apply toppings to our donuts).</p><p><img src=01-01.png alt="The first level"></p><p>Let&rsquo;s do it!</p><p>The first section (starting with <a href=#basic-layout>Basic layout</a>) is the final state of the solution. If you jump down to <a href=#interesting-challenges-and-rewrites>Interesting challenges and rewrites</a>, that is more of a step by step walkthrough of what changed over time.</p><p>If you&rsquo;d just like to see the entire source, <a href=https://github.com/jpverkamp/rust-solvers/blob/877c8b933df5a7f85bbde3315e879d44181ea186/src/bin/freshly-frosted.rs target=_blank rel=noopener>here</a> is the binary as of the writing of this post. I probably won&rsquo;t change too much from this point, except running some more tests and cleaning up.</p><nav id=TableOfContents><ul><li><a href=#basic-layout>Basic layout</a><ul><li><a href=#global-state><code>Global</code> state</a></li><li><a href=#parsing-levels>Parsing levels</a></li><li><a href=#parsing-entity>Parsing <code>Entity</code></a></li><li><a href=#entity-entitykind-and-toppings><code>Entity</code>, <code>EntityKind</code>, and <code>Toppings</code></a></li><li><a href=#local-state><code>Local</code> state</a></li><li><a href=#simulation-first-pass>Simulation: First pass</a></li><li><a href=#simulation-tickwise>Simulation: <code>tickwise</code></a></li><li><a href=#implementing-state>Implementing <code>State</code></a></li></ul></li><li><a href=#overview>Overview</a></li><li><a href=#interesting-challenges-and-rewrites>Interesting challenges and rewrites</a><ul><li><a href=#initial-solution>Initial solution</a></li><li><a href=#global-targets>Global targets</a></li><li><a href=#allow-merging--loop-detection>Allow merging / Loop detection</a></li><li><a href=#simulate-cache>Simulate cache</a></li><li><a href=#hints-preset-belts-also-used-for-world-8>Hints (Preset belts; also used for World 8)</a></li><li><a href=#starting-splitters>Starting splitters</a></li><li><a href=#tickwise>Tickwise</a></li><li><a href=#bumpers--improved-loop-detection><code>Bumpers</code> + Improved loop detection</a></li><li><a href=#tickwise-rewrite>Tickwise rewrite</a></li><li><a href=#allow-invalid-deliveries><code>:allow-invalid-deliveries</code></a></li><li><a href=#loop-treshold><code>:loop-treshold</code></a></li><li><a href=#teleporters>Teleporters</a></li><li><a href=#parallelism--moving-simulation-caches>Parallelism / Moving simulation caches</a></li><li><a href=#refactoring-can_enter-and-can_exit>Refactoring <code>can_enter</code> and <code>can_exit</code></a></li><li><a href=#crossovers>Crossovers</a></li><li><a href=#fix-the-merge-tiebreaker>Fix the merge tiebreaker</a></li><li><a href=#1many-teleporter>1:Many <code>Teleporter</code></a></li><li><a href=#simulate-loop-isnt-an-err><code>simulate</code> loop isn&rsquo;t an <code>Err</code></a></li><li><a href=#anysource>AnySource</a></li><li><a href=#toppings-rewrite>Toppings rewrite</a></li><li><a href=#end-state>End state</a></li></ul></li><li><a href=#debugging-and-testing>Debugging and Testing</a><ul><li><a href=#testing-with-macros>Testing (with macros!)</a></li><li><a href=#stepping-through-solutions>Stepping through solutions</a></li></ul></li></ul></nav><h2 id=basic-layout>Basic layout</h2><p>First, our basic layout. Like all of the <a href=https://blog.jverkamp.com/series/rust-solvers/>Rust Solvers</a>, we&rsquo;ll need a <code>Global</code> state that is shared throughout the solver and a smaller <code>Local</code> state that we need to be able to <code>Hash</code> and <code>Clone</code> in order to implement our search function.</p><h3 id=global-state><code>Global</code> state</h3><p>First, the <code>Global</code> state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Global</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Map settings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    width: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    height: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    targets: Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Toppings<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Map entities etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    entities: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Entity<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    initial_belts: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    teleporter_outs: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Flags that change behavior for specific puzzles
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    use_tickwise: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    allow_invalid_deliveries: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    loop_threshold: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Local caches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    simulate_cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, Vec<span style=color:#f92672>&lt;</span>(Point, Toppings)<span style=color:#f92672>&gt;&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>    simulate_tickwise_cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, SimulateTickwiseResult<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This&mldr; certainly grew over time. The <code>width</code>, <code>height</code>, <code>targets</code>, and <code>entities</code> were in there right from the beginning. <code>width</code> and <code>height</code> should be obvious.</p><p><code>targets</code> has a funny signature though. This isn&rsquo;t actually the <code>targets</code> on the map, those are <code>entities</code>. This instead is for later puzzles where you have only one <code>Target</code> on the map and have to deliver a specific list of donuts to it. So if it&rsquo;s <code>None</code>, this isn&rsquo;t a requirement. But if it&rsquo;s <code>Some</code>, you have to deliver a specific list. The internal a <code>Option&lt;Toppings></code> is mostly to match the type of current donuts, but really shouldn&rsquo;t have been done that way.</p><p><code>entities</code> is a list of all <code>Entities</code> on the level, with <code>None</code> for empty spaces.</p><p><code>initial_belts</code> was initially for <a href=#stepping-through-solutions>stepping through solutions</a>, but World 8 actually use these as part of the puzzles!</p><p>The next three are flags, see the sections on <a href=#simulation-tickwise>tickwise simulation</a>, <a href=#allow-invalid-deliveries>invalid deliveries</a>, or <a href=#loop-treshold>allowing loops</a> for more details.</p><p>Finally, the simulation caches. Originally, this was a single global <code>static</code>, then it was two, then I realized <em>that</em> was what was breaking my tests&mldr; and I <a href=#parallelism--moving-simulation-caches>moved it inline</a>. Yay <a href=https://en.wikipedia.org/wiki/interior%20mutability>interior mutability</a>!</p><p>So why cache? Because of how I <a href=#implementing-state>implemented State</a>, I will call <code>simulate</code> on <code>Local</code> (plus <code>Global</code>) multiple times for the same <code>Local</code>. It&rsquo;s <em>expensive</em>, so it&rsquo;s cheaper to <code>Hash</code> this state and store this result rather than doing it more than once.</p><p>It&rsquo;s a lot, but this is designed to only be cloned a few times at most, so we can put mostly arbitrary things in here. It builds up over time.</p><h3 id=parsing-levels>Parsing levels</h3><p>Just like the <code>struct</code>, the format for this grew throughout the solving of this. At the very beginning, it was pretty straight forward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>.   .   .   .   .
</span></span><span style=display:flex><span>+&gt;  .   .   .   -&gt;
</span></span><span style=display:flex><span>.   .   .   .   .
</span></span></code></pre></div><p>I&rsquo;ll get more into it in <a href=#parsing-entity>a bit</a>, but <code>.</code> is empty space, <code>+</code> is a <code>Source</code>, <code>-</code> is a <code>Target</code>, and <code>></code> indicates that the <code>Source</code> / <code>Target</code> want belts moving to the <code>Right</code>.</p><p>But they got <em>quite</em> a bit more complicated as we went on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>:targets 7 7
</span></span><span style=display:flex><span>:tickwise
</span></span><span style=display:flex><span>.   .   .   .   .   .   -^7
</span></span><span style=display:flex><span>+^  .   .   .   .   .   .
</span></span><span style=display:flex><span>+v  .   b&gt;3 .   .   .   .
</span></span><span style=display:flex><span>.   *   .   .   .   .   .
</span></span><span style=display:flex><span>.   .   .   .   *   .   .
</span></span><span style=display:flex><span>.   2&lt;  .   1&lt;  .   4&lt;  .
</span></span><span style=display:flex><span>.   .   .   .   .   .   .
</span></span></code></pre></div><p>The <code>:</code> lines at the top are flags that tell us (in this case) that we have specific <code>global.targets</code> that we need to meet and that we want to use the <a href=#simulation-tickwise><code>tickwise</code></a> simulator (instead of the faster <a href=#simulation-first-pass>default</a> one).</p><p>Then we still have empty space, but we also have <code>Bumpers</code> (<code>b</code>), a <code>Crossover</code> (<code>*</code>), Toppers (start with <code>1</code>, <code>2</code>, <code>4</code>, or <code>f</code>; see the <a href=#toppings-rewrite>toppings rewrite</a> for why), and a <code>Target</code> with a required type (<code>-^7</code>; <code>Target</code> going <code>Up</code> that needs <code>1</code> + <code>2</code> + <code>4</code> = <code>7</code>).</p><p>So how do we load all that?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Global {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> global <span style=color:#f92672>=</span> Global::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> input.lines() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> line_width <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> line.trim();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> line.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#39;:&#39;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;:target&#34;</span>) {
</span></span><span style=display:flex><span>                    global.targets <span style=color:#f92672>=</span> Some(
</span></span><span style=display:flex><span>                        line.split_whitespace()
</span></span><span style=display:flex><span>                            .skip(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                            .map(<span style=color:#f92672>|</span>t<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> t <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;F&#34;</span> <span style=color:#f92672>||</span> t <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;f&#34;</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>return</span> Some(Toppings::Cherries);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> t.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                                    .expect(<span style=color:#e6db74>&#34;Invalid target, must be numeric&#34;</span>)
</span></span><span style=display:flex><span>                                    .into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>match</span> v {
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> Some(Toppings::None),
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> Some(Toppings::Frosting),
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> Some(Toppings::Sprinkles),
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>7</span> <span style=color:#f92672>=&gt;</span> Some(Toppings::WhippedCream),
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>15</span> <span style=color:#f92672>=&gt;</span> Some(Toppings::Cherries),
</span></span><span style=display:flex><span>                                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid target: </span><span style=color:#e6db74>{t}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            })
</span></span><span style=display:flex><span>                            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;:comment&#34;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Not stored, just do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;:tickwise&#34;</span>) {
</span></span><span style=display:flex><span>                    global.use_tickwise <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;:allow-invalid-deliveries&#34;</span>) {
</span></span><span style=display:flex><span>                    global.allow_invalid_deliveries <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> line.starts_with(<span style=color:#e6db74>&#34;:loop-threshold&#34;</span>) {
</span></span><span style=display:flex><span>                    global.loop_threshold <span style=color:#f92672>=</span> Some(
</span></span><span style=display:flex><span>                        line.split_whitespace()
</span></span><span style=display:flex><span>                            .skip(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                            .next()
</span></span><span style=display:flex><span>                            .expect(<span style=color:#e6db74>&#34;Missing loop threshold&#34;</span>)
</span></span><span style=display:flex><span>                            .parse()
</span></span><span style=display:flex><span>                            .expect(<span style=color:#e6db74>&#34;Invalid loop threshold&#34;</span>),
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    panic!(<span style=color:#e6db74>&#34;Invalid/unknown flag: </span><span style=color:#e6db74>{line}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> part <span style=color:#66d9ef>in</span> line.split_whitespace() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> belt <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> entity <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                line_width <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> part <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;.&#34;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(found_belt) <span style=color:#f92672>=</span> Direction::try_from(part) {
</span></span><span style=display:flex><span>                    belt <span style=color:#f92672>=</span> Some(found_belt);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    entity <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> Entity::try_from(part) {
</span></span><span style=display:flex><span>                        Ok(entity) <span style=color:#f92672>=&gt;</span> Some(entity),
</span></span><span style=display:flex><span>                        Err(e) <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Invalid entity: </span><span style=color:#e6db74>{e}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                assert!(<span style=color:#f92672>!</span>(entity.is_some() <span style=color:#f92672>&amp;&amp;</span> belt.is_some()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                global.initial_belts.push(belt);
</span></span><span style=display:flex><span>                global.entities.push(entity);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            global.width <span style=color:#f92672>=</span> global.width.max(line_width);
</span></span><span style=display:flex><span>            global.height <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Teleporter validity check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> teleporter_in_ids <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>            .entities
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterIn(id),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> e
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Some(<span style=color:#f92672>*</span>id)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        teleporter_in_ids.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> teleporter_out_ids <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>            .entities
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterOut(id),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> e
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Some(<span style=color:#f92672>*</span>id)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        teleporter_out_ids.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Store the teleporter outs by ID for easy access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> teleporter_outs <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>            .entities
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>(index, e)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterOut(id),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> e
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Some((
</span></span><span style=display:flex><span>                        id,
</span></span><span style=display:flex><span>                        Point {
</span></span><span style=display:flex><span>                            x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                            y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                        },
</span></span><span style=display:flex><span>                    ))
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        teleporter_outs.sort_by_key(<span style=color:#f92672>|</span>(id, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Collapse that from (id, point) to vec&lt;vec&lt;point&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        global.teleporter_outs <span style=color:#f92672>=</span> teleporter_outs
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .chunk_by(<span style=color:#f92672>|</span>(id, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>id)
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(_id, group)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                group.map(<span style=color:#f92672>|</span>(_, p)<span style=color:#f92672>|</span> p).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        global
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The core of it is pretty simple, but we do have a few big stages:</p><ul><li>First, parse any flags. I&rsquo;ll go through this <a href=#interesting-challenges-and-rewrites>later</a>, but we have:<ul><li><code>:target</code> - A list of donuts we need to make regardless of what <code>Targets</code> we have</li><li><code>:comment</code> - Comments. They don&rsquo;t actually do anything.</li><li><code>:allow-invalid-deliveries</code> - Only ended up used in 06/08; see <a href=#allow-invalid-deliveries>this section</a> below</li><li><code>:loop-threshold</code> - Allows loop detection; thought I&rsquo;d need it for levels with bumperts, but didn&rsquo;t end up needing it, see <a href=#loop-treshold>this section</a></li></ul></li></ul><p>After that, we loop through each line (skipping empty lines) and load each <code>entity</code></p><h3 id=parsing-entity>Parsing <code>Entity</code></h3><p>From there, we need to go one level deeper, to parsing each specific kind of <code>Entity</code>. I&rsquo;m actually fairly proud of this code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Entity {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> String;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> value.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;Entity cannot be empty&#34;</span>.to_owned());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>top</span>(c: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Toppings, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            Ok(c.into())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>dir</span>(c: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Direction, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            Ok(Direction::try_from(c).map_err(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> format!(<span style=color:#e6db74>&#34;Invalid direction: </span><span style=color:#e6db74>{c}</span><span style=color:#e6db74>&#34;</span>))<span style=color:#f92672>?</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> value.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>().as_slice() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A wall (doesn&#39;t actually have facing 😄)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;#&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Block,
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>Direction</span>::Up,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A source of new donuts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;+&#39;</span>, facing] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Source,
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;+&#39;</span>, facing, <span style=color:#e6db74>&#39;?&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::AnySource,
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A target for donuts, first without any toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;-&#39;</span>, facing] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Target(Some(Toppings::None)),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Doesn&#39;t matter what toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;-&#39;</span>, facing, <span style=color:#e6db74>&#39;?&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Target(None),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Now with specific requested toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;-&#39;</span>, facing, topping] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Target(Some(top(topping)<span style=color:#f92672>?</span>)),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A topping machine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[topping, facing] <span style=color:#66d9ef>if</span> topping.is_ascii_digit() <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Topper(top(topping)<span style=color:#f92672>?</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A splitter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;X&#39;</span>, facing] <span style=color:#f92672>|</span> <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;x&#39;</span>, facing] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Splitter,
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A bumper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;b&#39;</span>, facing, topping] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Bumper(top(topping)<span style=color:#f92672>?</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Teleporters (in doesn&#39;t currently have a facing)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;T&#39;</span>, <span style=color:#e6db74>&#39;-&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterIn(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>Direction</span>::default(),
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;T&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, facing] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterOut(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;U&#39;</span>, <span style=color:#e6db74>&#39;-&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterIn(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>Direction</span>::default(),
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;U&#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, facing] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterOut(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>dir</span>(facing)<span style=color:#f92672>?</span>,
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Crossovers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;*&#39;</span>] <span style=color:#f92672>=&gt;</span> Ok(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Crossover,
</span></span><span style=display:flex><span>                facing: <span style=color:#a6e22e>Direction</span>::default(),
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Something we don&#39;t know how to parse
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            _ <span style=color:#f92672>=&gt;</span> Err(format!(<span style=color:#e6db74>&#34;Invalid entity: </span><span style=color:#e6db74>{value}</span><span style=color:#e6db74>&#34;</span>)),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s a <code>match</code> again 1-3 character that can define any kind of <code>Entity</code>. The variables are always a facing (<code>Direction</code>) or <code>Toppings</code>. So each time I added a new <code>EntityKind</code>, I just had to add another match here (this is the one that wouldn&rsquo;t warn me about exhaustive matching).</p><h3 id=entity-entitykind-and-toppings><code>Entity</code>, <code>EntityKind</code>, and <code>Toppings</code></h3><p><code>entities</code> is a list of anything that can be on the map that doesn&rsquo;t actually change in state (anything but the <code>belts</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Entity</span> {
</span></span><span style=display:flex><span>    kind: <span style=color:#a6e22e>EntityKind</span>,
</span></span><span style=display:flex><span>    facing: <span style=color:#a6e22e>Direction</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>EntityKind</span> {
</span></span><span style=display:flex><span>    Block,
</span></span><span style=display:flex><span>    Source,
</span></span><span style=display:flex><span>    AnySource,
</span></span><span style=display:flex><span>    Target(Option<span style=color:#f92672>&lt;</span>Toppings<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    Topper(Toppings),
</span></span><span style=display:flex><span>    Splitter,
</span></span><span style=display:flex><span>    Bumper(Toppings),
</span></span><span style=display:flex><span>    TeleporterIn(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    TeleporterOut(<span style=color:#66d9ef>usize</span>),
</span></span><span style=display:flex><span>    Crossover,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, PartialOrd, Ord)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Toppings</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[default]</span>
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>    Frosting,
</span></span><span style=display:flex><span>    Sprinkles,
</span></span><span style=display:flex><span>    WhippedCream,
</span></span><span style=display:flex><span>    Cherries,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ll go through these in the <a href=#interesting-challenges-and-rewrites>interesting challenges</a> section later, but roughly in order of introduction:</p><ul><li><p>World 1:</p><ul><li><code>Source</code> - Where un-topped donuts come from</li><li><code>Target</code> - Where donuts are delivered to; if <code>None</code> any donut can go there, otherwise the <code>Toppings</code> must match</li><li><code>Topper</code> - Apply the given <code>Toppings</code> to any donut in front of it</li></ul></li><li><p>World 2: Introduces multiple <code>Source</code> and <code>Target</code> on the same level</p></li><li><p>World 3: Nothing new, just more complicated levels</p></li><li><p>World 4: Introduce merging; this isn&rsquo;t an <code>EntityKind</code> but represents two belts or <code>Entities</code> moving onto the same point</p></li><li><p>World 5: Clarifies that <code>Toppers</code> will ignore donuts sent to them out of order</p></li><li><p>World 6: Introduce <code>Splitter</code> - Send donuts left/right/left/right (alternating)</p></li><li><p>World 7: Introduces <code>Bumper</code> - If the <code>Toppings</code> match, push the donut in front of it away</p></li><li><p>World 8: Introduces preset belts</p></li><li><p>World 9: Introduces <code>TeleporterIn</code>/<code>Out</code> - Teleport from an <code>In</code> to an <code>Out</code></p></li><li><p>World 10: Introduces <code>Crossover</code> - Allow paths to cross, but you must alternate between horizontal and vertical</p></li><li><p>World 11: Now you can have multiple <code>TeleporterOut</code> for each <code>TeleporterIn</code> and donuts are copied to all of then</p></li><li><p>World 12: Introduces <code>AnySource</code> - Create random donuts from among all 5 possible kinds</p></li></ul><p>Also&mldr; this is <em>not</em> how I did <code>Toppings</code> for <em>entirely</em> too long. I didn&rsquo;t realize that you could only have those 5 kinds, I thought you might be able to introduce any combination at some point (like <code>Frosting</code> and <code>Cherries</code> but not <code>Sprinkles</code>). But that was never the case.</p><h3 id=local-state><code>Local</code> state</h3><p>Now that we have all that, we have the <code>Local</code> state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Local</span> {
</span></span><span style=display:flex><span>    belts: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Direction<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After all that mess above&mldr; this seems rather easy. 😄</p><p>It&rsquo;s <code>None</code> if you don&rsquo;t have a belt, otherwise, the belt goes in the direction specified. That&rsquo;s it, nothing changed for these throughout the entire puzzle, which I appreciated. And which also meant that we did have a very static way of representing these as a known length <code>Vec</code>. I could have used a slice, but the length depends on the size of the <code>Global</code>. So it goes.</p><h3 id=simulation-first-pass>Simulation: First pass</h3><p>Okay, I&rsquo;d like to get to the <a href=#implementing-state>root of the algorithm</a>, but before that, we have to actually write out simulation. I didn&rsquo;t actually do this the entire time, but eventually it just made sense!</p><p>I actually ended up writing two different simulators. The first one doesn&rsquo;t actually simulate the puzzle the same way you&rsquo;d see it. Instead, it will follow a single donut at a time, applying whatever changes are necessary on each state.</p><p>We do get some interesting cases:</p><ul><li>multiple spawners mean we have to simulate multiple donuts</li><li>splitters and teleporters with multiple exits will effectively &lsquo;split&rsquo; the donut into 2.</li></ul><p>But other than that, it&rsquo;s just a series of steps:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulate</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(Point, Toppings)<span style=color:#f92672>&gt;</span>, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check the cache first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(cached) <span style=color:#f92672>=</span> global.simulate_cache.borrow().get(self) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Ok(cached.clone());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> step_tracing_enabled <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;FRESHLY_FROSTED_STEP_TRACE&#34;</span>).is_ok();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> donuts <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> complete_donuts <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Now we actually have to simulate each source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> visited <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> Toppings::all() {
</span></span><span style=display:flex><span>            visited.push(vec![<span style=color:#66d9ef>false</span>; global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// First, find the sources:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> (y <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> toppings <span style=color:#f92672>=</span> Toppings::None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Start a source here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Source,
</span></span><span style=display:flex><span>                    facing,
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> global.entities[index]
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    donuts.push((p, toppings, facing, visited.clone()));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// AnySource starts one for each type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::AnySource,
</span></span><span style=display:flex><span>                    facing,
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> global.entities[index]
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> topping <span style=color:#66d9ef>in</span> Toppings::all() {
</span></span><span style=display:flex><span>                        donuts.push((p, topping, facing, visited.clone()));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Now, until we&#39;ve simulated all of the donuts, simulate each
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>&#39;each_donut</span>: <span style=color:#a6e22e>while</span> <span style=color:#66d9ef>let</span> Some((<span style=color:#66d9ef>mut</span> p, <span style=color:#66d9ef>mut</span> toppings, initial_facing, <span style=color:#66d9ef>mut</span> visited)) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            donuts.pop()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> span <span style=color:#f92672>=</span> tracing::debug_span!(<span style=color:#e6db74>&#34;Simulating donut&#34;</span>, p <span style=color:#f92672>=</span> <span style=color:#f92672>?</span>p, t <span style=color:#f92672>=</span> <span style=color:#f92672>?</span>toppings, f <span style=color:#f92672>=</span> <span style=color:#f92672>?</span>initial_facing);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> _enter <span style=color:#f92672>=</span> span.enter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> initial_facing.into();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Err(format!(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Donut started at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> but immediately went out of bounds&#34;</span>
</span></span><span style=display:flex><span>                ));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            visited[toppings.index()][p.index(global.width)] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> crossover_direction <span style=color:#f92672>=</span> initial_facing;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>&#39;simulation_tick</span>: <span style=color:#a6e22e>while</span> <span style=color:#f92672>!</span>matches!(
</span></span><span style=display:flex><span>                global.entities[p.index(global.width)],
</span></span><span style=display:flex><span>                Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Target(_),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>            ) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> step_tracing_enabled {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(format!(<span style=color:#e6db74>&#34;Attempted to move out of bounds at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If there is a topper adjacent to us, apply it&#39;s topping
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> top_d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>-</span> top_d.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Topper(new_toppings),
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> top_d <span style=color:#f92672>==</span> facing <span style=color:#f92672>&amp;&amp;</span> toppings.can_apply(new_toppings) {
</span></span><span style=display:flex><span>                            tracing::debug!(
</span></span><span style=display:flex><span>                                <span style=color:#e6db74>&#34;Adding topping {new_toppings:?} from {p2:?} / {facing:?}&#34;</span>
</span></span><span style=display:flex><span>                            );
</span></span><span style=display:flex><span>                            toppings <span style=color:#f92672>=</span> new_toppings;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we&#39;re adjacent to a matching bumper, bump
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// TODO: Assume that the space we move onto is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> bump_d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>-</span> bump_d.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Bumper(bump_toppings),
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> bump_d <span style=color:#f92672>==</span> facing <span style=color:#f92672>&amp;&amp;</span> toppings <span style=color:#f92672>==</span> bump_toppings {
</span></span><span style=display:flex><span>                            crossover_direction <span style=color:#f92672>=</span> bump_d;
</span></span><span style=display:flex><span>                            p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> bump_d.into();
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span> &#39;simulation_tick;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Otherwise, apply entities we are on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>match</span> entity.kind {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Should never move out of any of these
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        EntityKind::Block
</span></span><span style=display:flex><span>                        <span style=color:#f92672>|</span> EntityKind::Source
</span></span><span style=display:flex><span>                        <span style=color:#f92672>|</span> EntityKind::AnySource
</span></span><span style=display:flex><span>                        <span style=color:#f92672>|</span> EntityKind::Target(_)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>|</span> EntityKind::Topper(_)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>|</span> EntityKind::Bumper(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Err(format!(<span style=color:#e6db74>&#34;Donut at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> tried to move from a </span><span style=color:#e6db74>{entity:?}</span><span style=color:#e6db74>&#34;</span>,));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        EntityKind::Splitter <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Queue the two new donuts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            donuts.push((p, toppings, entity.facing.turn_left(), visited.clone()));
</span></span><span style=display:flex><span>                            donuts.push((p, toppings, entity.facing.turn_right(), visited.clone()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Do not simulate this path any more
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#66d9ef>continue</span> &#39;each_donut;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        EntityKind::TeleporterIn(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Queue one new point for each teleporter out
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span>p_out <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>global.teleporter_outs[id] {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                                    kind: <span style=color:#a6e22e>EntityKind</span>::TeleporterOut(_),
</span></span><span style=display:flex><span>                                    facing
</span></span><span style=display:flex><span>                                }) <span style=color:#f92672>=</span> global.entities[p_out.index(global.width)]
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                    donuts.push((p_out, toppings, facing, visited.clone()));
</span></span><span style=display:flex><span>                                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>return</span> Err(format!(
</span></span><span style=display:flex><span>                                        <span style=color:#e6db74>&#34;Teleporter in at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> tried to move to a non-teleporter out&#34;</span>,
</span></span><span style=display:flex><span>                                    ));
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Do not follow this path any more
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#66d9ef>continue</span> &#39;each_donut;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        EntityKind::TeleporterOut(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// TODO: This doesn&#39;t check can_enter on the next space; assuming that&#39;s not a problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            crossover_direction <span style=color:#f92672>=</span> entity.facing;
</span></span><span style=display:flex><span>                            p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> entity.facing.into();
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span> &#39;simulation_tick;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        EntityKind::Crossover <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// TODO: This doesn&#39;t check can_enter on the next space; assuming that&#39;s not a problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> crossover_direction.into();
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span> &#39;simulation_tick;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we&#39;re on a belt, move along it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(belt) <span style=color:#f92672>=</span> self.belts[p.index(global.width)] {
</span></span><span style=display:flex><span>                    p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> belt.into();
</span></span><span style=display:flex><span>                    crossover_direction <span style=color:#f92672>=</span> belt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Some entities cannot be run into at all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Some require that you are moving the right direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>entity.can_enter(belt) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Err(format!(
</span></span><span style=display:flex><span>                                <span style=color:#e6db74>&#34;Donut at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> tried to move </span><span style=color:#e6db74>{belt:?}</span><span style=color:#e6db74> onto a </span><span style=color:#e6db74>{entity:?}</span><span style=color:#e6db74> but couldn&#39;t&#34;</span>,
</span></span><span style=display:flex><span>                            ));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// Ran off the end of a belt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> visited[toppings.index()][p.index(global.width)] {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> donuts.is_empty() {
</span></span><span style=display:flex><span>                        tracing::info!(<span style=color:#e6db74>&#34;Loop detected at {p:?}, on the last donut&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;each_donut;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        tracing::info!(<span style=color:#e6db74>&#34;Loop detected at {p:?}, but there are more donuts&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;each_donut;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    visited[toppings.index()][p.index(global.width)] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            complete_donuts.push((p, toppings));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Cache the result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        global
</span></span><span style=display:flex><span>            .simulate_cache
</span></span><span style=display:flex><span>            .borrow_mut()
</span></span><span style=display:flex><span>            .insert(self.clone(), complete_donuts.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(complete_donuts)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I hope it&rsquo;s well commented, but here are a few key points:</p><p><code>visited</code> is a <code>Vec</code> of <code>Vec</code> that stores if we&rsquo;ve already seen each point (for each simulated <code>donut</code>); this handles loop detection - originally, this was a single <code>Vec</code> for each point, but once things got complicated (with <code>Splitters</code> and <code>Bumpers</code>), we needed to be able to check if we saw <em>this kind of donut</em> at each point</p><p>Finding the sources just goes through the map and finds each <code>Source</code>. I could easily pre-calculate this and probably should, but this works well enough. For <code>AnySource</code> (in world 12), we do need to spawn one donut for each kind. For this simulation I completely ignore that they can be in any order. For the most part, it doesn&rsquo;t matter.</p><p>Then, the main simulation loop: <code>each_donut</code>. We keep track of the current <code>p: Point</code> the donut is at and the <code>toppings</code> it current has. The <code>initial_facing</code> we don&rsquo;t track, since donuts don&rsquo;t <em>themselves</em> have a facing, that mostly comes from the component they are sitting on. This we do store in the queue though, since <code>Splitters</code> make two donuts facing in opposite directions and we need some way to tell them apart.</p><p>Within that loop, we&rsquo;re going to have an inner loop that runs each <code>simulate_tick</code> until we hit a <code>Target</code> or an empty space (we&rsquo;ll come back to that).</p><p>Then, we have <code>step_tracing_enabled</code>, which is entirely debugging (see <a href=#stepping-through-solutions>here</a>). It&rsquo;s behind a flag since this is doing some wacky string things and is thus expensive to calculate each frame if I&rsquo;m not debugging.</p><p>Within the tick, we apply in order:</p><ul><li>Adjacent <code>Toppers</code> (that <code>can_apply</code> their <code>Toppings</code>)</li><li><code>Bumpers</code> which are evaluated before <code>belts</code>, since if they apply, you <em>cannot</em> pass them (this could have been in the next <code>match</code>)</li><li>Other entities: <code>Splitters</code> and <code>Teleporters</code> actually spawn new donuts (two for <code>Splitters</code> and one or more for <code>Teleporters</code>) and stop the current simulation! This actually does clone <code>visited</code>, since we only want a single &rsquo;lineage&rsquo; of simulated donuts to do loop detection; if donuts from two different sources hit the same point, that&rsquo;s actually expected</li><li>Belts, the main case!</li><li>Loop detection using <code>visited</code></li></ul><p>If we successfully exit the <code>while</code> loop, we record that we finished simulating a donut. Once the queue is empty, we return this whole list!</p><p>That code took a while to get right. And then again and again as I added more features!</p><h3 id=simulation-tickwise>Simulation: <code>tickwise</code></h3><p>Unfortunately&mldr; for some levels (particular those involving merging timing), this just&mldr; didn&rsquo;t work. There are some cases that we need to actually simulate ever single donut on the board, thus the second <code>tickwise</code> simulation.</p><p>The main reason I didn&rsquo;t switch over to this entirely though is that it is probably an order of magnitude slower than the <a href=#simulation-first-pass>first simulation</a>. So when possible, I use the other.</p><p>Here&rsquo;s how this one works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulate_tickwise</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Result<span style=color:#f92672>&lt;</span>SimulateTickwiseResult, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check the cache first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(cached) <span style=color:#f92672>=</span> global.simulate_tickwise_cache.borrow().get(self) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Ok(cached.clone());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vec_size <span style=color:#f92672>=</span> global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CrossoverState</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[default]</span>
</span></span><span style=display:flex><span>            Open,
</span></span><span style=display:flex><span>            Occupied(Direction),
</span></span><span style=display:flex><span>            OpenHorizontal,
</span></span><span style=display:flex><span>            OpenVertical,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TileState</span> {
</span></span><span style=display:flex><span>            toppings: Option<span style=color:#f92672>&lt;</span>Toppings<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            source: Option<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            waiting_time: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            split_next_right: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>            crossover_state: <span style=color:#a6e22e>CrossoverState</span>,
</span></span><span style=display:flex><span>            any_source_state: <span style=color:#a6e22e>Toppings</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Eq, Hash)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Update</span> {
</span></span><span style=display:flex><span>            move_from: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>            move_to: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>            toppings: <span style=color:#a6e22e>Toppings</span>,
</span></span><span style=display:flex><span>            source: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> vec![TileState::default(); vec_size];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> deliveries <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> states_seen <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        macro_rules<span style=color:#f92672>!</span> state_at {
</span></span><span style=display:flex><span>            (<span style=color:#75715e>$p</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                state[<span style=color:#75715e>$p</span>.index(global.width)]
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We have a very expensive tracing option; so don&#39;t calculate it if we&#39;re not going to print it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> tracing_enabled <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;FRESHLY_FROSTED_TRACE&#34;</span>).is_ok();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> step_tracing_enabled <span style=color:#f92672>=</span> std::env::var(<span style=color:#e6db74>&#34;FRESHLY_FROSTED_STEP_TRACE&#34;</span>).is_ok();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Advance the simulation one tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>&#39;tick</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> updates <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> max_waiting_time <span style=color:#f92672>=</span> state.iter().map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.waiting_time).max().unwrap_or(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This shouldn&#39;t generally happen; but if it does we have an infinite loop so don&#39;t hang
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> max_waiting_time <span style=color:#f92672>&gt;</span> global.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>*</span> global.height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>                panic!(<span style=color:#e6db74>&#34;Waiting time exceeded maximum&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Debugging ticking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> tracing_enabled {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cache which exact states we&#39;ve seen; break once we see the same more than once (or a set threshold of times)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(count) <span style=color:#f92672>=</span> states_seen.get(<span style=color:#f92672>&amp;</span>state) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> threshold <span style=color:#f92672>=</span> global.loop_threshold.unwrap_or(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>count <span style=color:#f92672>&gt;=</span> threshold {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Loop detected (threshold={threshold}), breaking&#34;</span>);
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Deliveries are: {deliveries:?}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> &#39;tick;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            states_seen
</span></span><span style=display:flex><span>                .entry(state.clone())
</span></span><span style=display:flex><span>                .and_modify(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>e <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                .or_insert(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Calculate all requested updates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>&#39;next_point</span>: <span style=color:#a6e22e>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Create a potential update for sources
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Source,
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        updates.push(Update {
</span></span><span style=display:flex><span>                            move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                            move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> facing.into(),
</span></span><span style=display:flex><span>                            toppings: <span style=color:#a6e22e>Toppings</span>::None,
</span></span><span style=display:flex><span>                            source: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;next_point;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// AnySources update sequentially 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::AnySource,
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> next_toppings <span style=color:#f92672>=</span> state_at!(p).any_source_state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        updates.push(Update {
</span></span><span style=display:flex><span>                            move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                            move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> facing.into(),
</span></span><span style=display:flex><span>                            toppings: <span style=color:#a6e22e>next_toppings</span>,
</span></span><span style=display:flex><span>                            source: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        state_at!(p).any_source_state <span style=color:#f92672>=</span> next_toppings.any_source_next();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;next_point;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// No updates for spaces that do not have a donut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> state_at!(p).toppings.is_none() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we are trying to update on an empty space, stop the simulation here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> self.is_empty(global, p) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;tick;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Bumpers take priority over belts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: Can you push into a merge situation? Then we&#39;d need both.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: Assume there&#39;s only one bumper per space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>-</span> d.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                            kind: <span style=color:#a6e22e>EntityKind</span>::Bumper(bumper_toppings),
</span></span><span style=display:flex><span>                            facing,
</span></span><span style=display:flex><span>                        }) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)]
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> facing <span style=color:#f92672>==</span> d <span style=color:#f92672>&amp;&amp;</span> bumper_toppings <span style=color:#f92672>==</span> state_at!(p).toppings.unwrap() {
</span></span><span style=display:flex><span>                                tracing::debug!(<span style=color:#e6db74>&#34;Bumper at {p2:?} with facing {d:?} and toppings {bumper_toppings:?}&#34;</span>);
</span></span><span style=display:flex><span>                                updates.push(Update {
</span></span><span style=display:flex><span>                                    move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                    move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> d.into(),
</span></span><span style=display:flex><span>                                    toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                    source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                });
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span> &#39;next_point;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Belts are easy!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(belt) <span style=color:#f92672>=</span> self.belts[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// We have to be able to move onto that space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> belt.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> Err(format!(<span style=color:#e6db74>&#34;Attempted to move out of bounds at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// We have to be able to move onto the next entity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)] {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>entity.can_enter(belt) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>return</span> Err(format!(
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;Donut at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> tried to move </span><span style=color:#e6db74>{belt:?}</span><span style=color:#e6db74> onto a </span><span style=color:#e6db74>{entity:?}</span><span style=color:#e6db74> but couldn&#39;t&#34;</span>,
</span></span><span style=display:flex><span>                                ));
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// If we make it this far, this is a valid potential move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        updates.push(Update {
</span></span><span style=display:flex><span>                            move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                            move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> belt.into(),
</span></span><span style=display:flex><span>                            toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                            source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span> &#39;next_point;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Any entities we could be standing on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// We should never have moved onto invalid ones (see above)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>match</span> entity.kind {
</span></span><span style=display:flex><span>                            EntityKind::Block <span style=color:#f92672>|</span> EntityKind::Topper(_) <span style=color:#f92672>|</span> EntityKind::Bumper(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                unreachable!(<span style=color:#e6db74>&#34;Donut at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> is on a </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, entity.kind);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Try to create a (potential) new donut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::Source <span style=color:#f92672>|</span> EntityKind::AnySource <span style=color:#f92672>=&gt;</span> unreachable!(<span style=color:#e6db74>&#34;Sources are handled earlier&#34;</span>),
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// If we&#39;re on a target, matching done/not error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::Target(toppings) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> toppings.is_none()
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>||</span> state_at!(p).toppings.unwrap() <span style=color:#f92672>==</span> toppings.unwrap()
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>||</span> global.allow_invalid_deliveries
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                    deliveries.entry(p).or_insert_with(HashSet::new).insert((
</span></span><span style=display:flex><span>                                        state_at!(p).source.unwrap(),
</span></span><span style=display:flex><span>                                        state_at!(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                    ));
</span></span><span style=display:flex><span>                                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>return</span> Err(format!(
</span></span><span style=display:flex><span>                                        <span style=color:#e6db74>&#34;Donut at </span><span style=color:#e6db74>{p:?}</span><span style=color:#e6db74> is on a target with the wrong toppings&#34;</span>
</span></span><span style=display:flex><span>                                    ));
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Splitters try to move in the next direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::Splitter <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> state_at!(p).split_next_right {
</span></span><span style=display:flex><span>                                    updates.push(Update {
</span></span><span style=display:flex><span>                                        move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                        move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> entity.facing.turn_right().into(),
</span></span><span style=display:flex><span>                                        toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                        source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                    });
</span></span><span style=display:flex><span>                                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                    updates.push(Update {
</span></span><span style=display:flex><span>                                        move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                        move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> entity.facing.turn_left().into(),
</span></span><span style=display:flex><span>                                        toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                        source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                    });
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Teleporter in tries to move to each of the teleporter outs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#75715e>// If we have an in, we have an out (according to the loading function)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::TeleporterIn(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                global.teleporter_outs[id].iter().for_each(<span style=color:#f92672>|&amp;</span>p_out<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                                    updates.push(Update {
</span></span><span style=display:flex><span>                                        move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                        move_to: <span style=color:#a6e22e>p_out</span>,
</span></span><span style=display:flex><span>                                        toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                        source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                    })
</span></span><span style=display:flex><span>                                })
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Teleporter out basically acts like a source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::TeleporterOut(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                updates.push(Update {
</span></span><span style=display:flex><span>                                    move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                    move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> entity.facing.into(),
</span></span><span style=display:flex><span>                                    toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                    source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                });
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Crossovers keep going in the same direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            EntityKind::Crossover <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> state_at!(p).crossover_state {
</span></span><span style=display:flex><span>                                CrossoverState::Open
</span></span><span style=display:flex><span>                                <span style=color:#f92672>|</span> CrossoverState::OpenHorizontal
</span></span><span style=display:flex><span>                                <span style=color:#f92672>|</span> CrossoverState::OpenVertical <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    unreachable!(<span style=color:#e6db74>&#34;Donuts should not be able to move out of non-occupied crossovers&#34;</span>)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                CrossoverState::Occupied(d) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                    updates.push(Update {
</span></span><span style=display:flex><span>                                        move_from: <span style=color:#a6e22e>p</span>,
</span></span><span style=display:flex><span>                                        move_to: <span style=color:#a6e22e>p</span> <span style=color:#f92672>+</span> d.into(),
</span></span><span style=display:flex><span>                                        toppings: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                        source: <span style=color:#a6e22e>state_at</span><span style=color:#f92672>!</span>(p).source.unwrap(),
</span></span><span style=display:flex><span>                                    });
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            },
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Okay, now for any update that has multiple choices, we have to choose one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Choose the one that has the largest waiting_time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Then we have to increment the waiting time for the rest and wind back any updates depending on those
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> will_update <span style=color:#f92672>=</span> vec![<span style=color:#66d9ef>true</span>; updates.len()];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> updates <span style=color:#f92672>=</span> updates
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .enumerate()
</span></span><span style=display:flex><span>                        .filter(<span style=color:#f92672>|</span>(_, u)<span style=color:#f92672>|</span> u.move_to <span style=color:#f92672>==</span> p)
</span></span><span style=display:flex><span>                        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Special case: if we are moving onto a crossover at most one is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// TODO: This assumes we don&#39;t have both up and down in when openvertical in the same tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity { kind: <span style=color:#a6e22e>EntityKind</span>::Crossover, <span style=color:#f92672>..</span> }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> updates.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (index, update) <span style=color:#66d9ef>in</span> updates.iter() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> d: <span style=color:#a6e22e>Direction</span> <span style=color:#f92672>=</span> (p <span style=color:#f92672>-</span> update.move_from).try_into().expect(<span style=color:#e6db74>&#34;Moved onto a crossover with a non-adjacent move&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> failed <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> state_at!(p).crossover_state {
</span></span><span style=display:flex><span>                                CrossoverState::Occupied(_) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                                CrossoverState::OpenHorizontal <span style=color:#f92672>=&gt;</span> d <span style=color:#f92672>==</span> Direction::Up <span style=color:#f92672>||</span> d <span style=color:#f92672>==</span> Direction::Down,
</span></span><span style=display:flex><span>                                CrossoverState::OpenVertical <span style=color:#f92672>=&gt;</span> d <span style=color:#f92672>==</span> Direction::Left <span style=color:#f92672>||</span> d <span style=color:#f92672>==</span> Direction::Right,
</span></span><span style=display:flex><span>                                _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>                            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> failed {
</span></span><span style=display:flex><span>                                will_update[<span style=color:#f92672>*</span>index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Otherwise, if there are zero or 1 updates to this point, it&#39;s fine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> updates.len() <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Sort, the longest waiting will end up first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// On ties, the most frosted donut goes first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    updates.sort_by(<span style=color:#f92672>|</span>(_, a), (_, b)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        state_at!(b.move_from)
</span></span><span style=display:flex><span>                            .waiting_time
</span></span><span style=display:flex><span>                            .cmp(<span style=color:#f92672>&amp;</span>state_at!(a.move_from).waiting_time)
</span></span><span style=display:flex><span>                            .then_with(<span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                                state_at!(b.move_from)
</span></span><span style=display:flex><span>                                    .toppings
</span></span><span style=display:flex><span>                                    .unwrap_or(Toppings::None)
</span></span><span style=display:flex><span>                                    .cmp(<span style=color:#f92672>&amp;</span>state_at!(a.move_from).toppings.unwrap_or(Toppings::None))
</span></span><span style=display:flex><span>                            })
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// The waiting time for the source of the one that moves is 0&#39;ed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// The rest incremented
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    state[updates[<span style=color:#ae81ff>0</span>].<span style=color:#ae81ff>1.</span>move_from.index(global.width)].waiting_time <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (_, u) <span style=color:#66d9ef>in</span> updates.iter().skip(<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                        state[u.move_from.index(global.width)].waiting_time <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// All the rest of them are flagged as not updating
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>for</span> (index, _) <span style=color:#66d9ef>in</span> updates.iter().skip(<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                        will_update[<span style=color:#f92672>*</span>index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Now propagate that backwards
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>&#39;still_did_not_updating</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (i, ui) <span style=color:#66d9ef>in</span> updates.iter().enumerate() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (j, uj) <span style=color:#66d9ef>in</span> updates.iter().enumerate() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>!=</span> j <span style=color:#f92672>&amp;&amp;</span> will_update[i] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>will_update[j] <span style=color:#f92672>&amp;&amp;</span> ui.move_to <span style=color:#f92672>==</span> uj.move_from
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            will_update[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span> &#39;still_did_not_updating;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we make it through the loops without updating anything, we&#39;re done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Now apply each update that is still in the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// First, remove from the source to make space for the destinations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (i, u) <span style=color:#66d9ef>in</span> updates.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> will_update[i] {
</span></span><span style=display:flex><span>                    state_at!(u.move_from).toppings <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>                    state_at!(u.move_from).source <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Moving from a splitter means it toggles
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// This updates the flag for everything, even non-splitters, but we never read it otherwise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    state_at!(u.move_from).split_next_right <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>!</span>state_at!(u.move_from).split_next_right;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// When we move out of a crossover, it toggles the state depending on how we did
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Crossover,
</span></span><span style=display:flex><span>                        <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[u.move_from.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> d: <span style=color:#a6e22e>Direction</span> <span style=color:#f92672>=</span> (u.move_to <span style=color:#f92672>-</span> u.move_from)
</span></span><span style=display:flex><span>                            .try_into()
</span></span><span style=display:flex><span>                            .expect(<span style=color:#e6db74>&#34;Moved out of a crossover with a non-adjacent move&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        state_at!(u.move_from).crossover_state <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> d {
</span></span><span style=display:flex><span>                            Direction::Up <span style=color:#f92672>|</span> Direction::Down <span style=color:#f92672>=&gt;</span> CrossoverState::OpenHorizontal,
</span></span><span style=display:flex><span>                            Direction::Left <span style=color:#f92672>|</span> Direction::Right <span style=color:#f92672>=&gt;</span> CrossoverState::OpenVertical,
</span></span><span style=display:flex><span>                        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;Moved out of a crossover at {u:?} with direction {d:?}&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// And then set each destination
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (i, u) <span style=color:#66d9ef>in</span> updates.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> will_update[i] {
</span></span><span style=display:flex><span>                    state_at!(u.move_to).toppings <span style=color:#f92672>=</span> Some(u.toppings);
</span></span><span style=display:flex><span>                    state_at!(u.move_to).source <span style=color:#f92672>=</span> Some(u.source);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Moving to a splitter does *not* toggle it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we move into a crossover, toggle it&#39;s mode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Crossover,
</span></span><span style=display:flex><span>                        <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[u.move_to.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> (u.move_to <span style=color:#f92672>-</span> u.move_from)
</span></span><span style=display:flex><span>                            .try_into()
</span></span><span style=display:flex><span>                            .expect(<span style=color:#e6db74>&#34;Moved into a crossover with a non-adjacent move&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        state_at!(u.move_to).crossover_state <span style=color:#f92672>=</span> CrossoverState::Occupied(d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;Moved into a crossover at {u:?} with direction {d:?}&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Finally, apply toppers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Topper(new_topping),
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> facing.into();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(state) <span style=color:#f92672>=</span> state.get_mut(p2.index(global.width)) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(current_toppings) <span style=color:#f92672>=</span> state.toppings {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> current_toppings.can_apply(new_topping) {
</span></span><span style=display:flex><span>                                    state.toppings <span style=color:#f92672>=</span> Some(new_topping)
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// At the end, extra donuts are any on an empty space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> extras <span style=color:#f92672>=</span> state
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>(index, s)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self.is_empty(global, p) <span style=color:#f92672>&amp;&amp;</span> s.toppings.is_some() {
</span></span><span style=display:flex><span>                    Some((p, s.toppings.unwrap()))
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> SimulateTickwiseResult { deliveries, extras };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Cache the result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        global
</span></span><span style=display:flex><span>            .simulate_tickwise_cache
</span></span><span style=display:flex><span>            .borrow_mut()
</span></span><span style=display:flex><span>            .insert(self.clone(), result.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(result)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That is so much more code. You can see why it might take longer.</p><p>The basic idea for this one is that we are <em>actually</em> going to run the entire simulation. First, we calculate a list of all updates that we want to apply. Then, we check for incompatible updates (caused by merging and <code>Crossovers</code>) and remove those. Then, we apply the rest of the updates and run another tick.</p><p>We do have three additional structs here:</p><p><code>TileState</code> is the state of the map and donuts on it. We create a single <code>Vec</code> of these at the beginning of the state and then re-use it for the entire simulation to avoid allocations. Within that, we have:</p><ul><li><code>toppings</code>: Represents a donut, <code>None</code> if there isn&rsquo;t one here</li><li><code>source</code>: Represents the <code>Source</code> a donut came from (both for loop detection and <code>is_solved</code> checks (each <code>Source</code> must deliver at least once))</li><li><code>waiting_time</code>: When two belts merge, the one that has been waiting longer goes first; this tracks that</li><li><code>split_next_right</code>: Handles state for <code>Splitters</code> alternating</li><li><code>crossover_state</code>: Is the 4 states that a <code>Crossover</code> can be in: <code>Open</code> only at the start when any donut can enter it, <code>Occupied</code> when a donut is passing through and <code>OpenHorizontal</code> / <code>OpenVertical</code> to implement the alternating that these require</li></ul><p>Then we also have <code>Update</code> which will be a list of all the donuts that want to update. This one we <em>do</em> re-allocate for, which is probably suboptimal. But I didn&rsquo;t benchmark it.</p><p>On to the simulation:</p><p>For each <code>tick</code>, we need to calculate a list of <code>updates</code>.</p><p>We have an internal cache <code>states_seen</code> that tracks loop detection. In this simulation, the entire state needs to be the same (so <code>Splitters</code> the same way, <code>CrossOvers</code> the same, etc) to be declared a loop</p><p>Within that, the kinds of <code>updates</code> are (evaluated for each point on the map):</p><ul><li><code>Sources</code> and <code>AnySources</code> spawn new donuts; the later just cycles through rather than doing it randomly, I want this to be deterministic (I could have used a <a href=https://en.wikipedia.org/wiki/pseudorandom%20number%20generator>pseudorandom number generator</a> with a known seed, but didn&rsquo;t bother).</li><li><code>Bumpers</code> bump; this has to be first since the update for a <code>belt</code> won&rsquo;t be generated then</li><li><code>belts</code> just move along the belt</li><li><code>Splitters</code> queue a different update depending on <code>split_next_right</code></li><li><code>Teleporters</code> make an update that jumps across the map</li><li><code>CrossOvers</code> only update they are occupied (going into a crossover is handled later)</li></ul><p>In addition, <code>Targets</code> directly remove their donut. This isn&rsquo;t an <code>update</code> since it&rsquo;s impossible for a collision to happen <em>on</em> the <code>Target</code>.</p><p>Then, we have to figure out which updates to apply: <code>will_update</code>.</p><p>First, we handle <code>Crossover</code>. These are close to <code>merges</code> but we don&rsquo;t choose on timing, but rather by the state of the <code>CrossOver</code>.</p><p>Then for merges, if there are two <code>updates</code> going to the same spot: The oldest one goes first and all the rest wait (incrementing their own timer). If there&rsquo;s a tie, the donut with the most <code>Toppings</code> goes first. If there&rsquo;s still a tie&mldr; well that didn&rsquo;t actually end up mattering, so because of the order we generated updates it will go left to right, top to bottom.</p><p>Now actually actually <em>apply</em> these updates. This is done in two passes so we don&rsquo;t need to double buffer. First, we remove the donut from the <code>move_from</code> location (this is why the <code>Update</code> stores what kind of donut it is); then we loop again adding them in the <code>move_to</code>.</p><p>Finally, apply <code>toppers</code> and advance!</p><p>After the simulation is done; we can return. In this case, I return separately any <code>extras</code> (donuts that aren&rsquo;t delivered, we&rsquo;ll use this in <a href=#next_states><code>next_states</code></a>) and <code>deliveries</code> (used for <a href=#is_solved><code>is_solved</code></a>).</p><h3 id=implementing-state>Implementing <code>State</code></h3><p>Okay, we have two simulations.</p><p>To actually use our solver, we&rsquo;re going to need to actually <code>impl State</code> over <code>Global</code> for <code>Local</code> (I&rsquo;m not using <code>Step</code> this time around).</p><h4 id=next_states><code>next_states</code></h4><p>These actually end up fairly straight forward based on our previous simulation functions.</p><p>To get next states:</p><ul><li>get a list of the current states of donuts</li><li>for each (until we find one with next states; only return states for one)<ul><li>try each direction (checking if we can exit / enter entities in that direction)</li></ul></li><li>if we returned at least one possible belt, add it and return those as new states</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), fields(belts = %self))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next_states</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>i64</span>, (), Local)<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> donuts <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> global.use_tickwise {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> self.simulate_tickwise(global) {
</span></span><span style=display:flex><span>                Ok(tickwise_result) <span style=color:#f92672>=&gt;</span> tickwise_result.extras,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Simulation failed: {e}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> self.simulate(global) {
</span></span><span style=display:flex><span>                Ok(donuts) <span style=color:#f92672>=&gt;</span> donuts,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Simulation failed: {e}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        donuts.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find the first empty point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (p, _) <span style=color:#66d9ef>in</span> donuts {
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;Checking for expansion at {p:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.is_empty(global, p) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;Expanding new_state at {p:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This is necessary in the (rare, only 6/8 so far) case that one expansion is invalid now but will become valid after another state is added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> maybe_next_states <span style=color:#f92672>=</span> Direction::all()
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .flat_map(<span style=color:#f92672>|&amp;</span>d<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>entity.can_exit(d) {
</span></span><span style=display:flex><span>                            tracing::debug!(<span style=color:#e6db74>&#34;^ Cannot exit {entity:?} going {d:?}&#34;</span>);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> d.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> global.in_bounds(p2) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)] {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>entity.can_enter(d) {
</span></span><span style=display:flex><span>                                tracing::debug!(<span style=color:#e6db74>&#34;^ Cannot enter {entity:?} going {d:?}&#34;</span>);
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;^ Expanding {d:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_state <span style=color:#f92672>=</span> self.clone();
</span></span><span style=display:flex><span>                        new_state.belts[p.index(global.width)] <span style=color:#f92672>=</span> Some(d);
</span></span><span style=display:flex><span>                        Some((<span style=color:#ae81ff>1</span>, (), new_state))
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        None
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>maybe_next_states.is_empty() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(maybe_next_states);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it! I had a lot of that simulation code inlined for a long while, but after I got the second simulation it just got too long so I refactored.</p><h4 id=is_valid><code>is_valid</code></h4><p>Similarly, <code>is_valid</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), fields(belts = %self), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_valid</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> global.use_tickwise {
</span></span><span style=display:flex><span>            self.simulate_tickwise(global).is_ok()
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> donuts <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.simulate(global) {
</span></span><span style=display:flex><span>                Ok(donuts) <span style=color:#f92672>=&gt;</span> donuts,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Simulation failed: {e}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;Simulation result: {donuts:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> target_points <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>                .entities
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .enumerate()
</span></span><span style=display:flex><span>                .filter_map(<span style=color:#f92672>|</span>(index, entity)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Target(_),
</span></span><span style=display:flex><span>                        <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> entity
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Some(Point {
</span></span><span style=display:flex><span>                            x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                            y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                        })
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        None
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Each current donut must be either on a target or be able to reach one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tracing::debug!(<span style=color:#e6db74>&#34;Checking reachability&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (donut_p, toppings) <span style=color:#66d9ef>in</span> donuts.iter() {
</span></span><span style=display:flex><span>                tracing::debug!(<span style=color:#e6db74>&#34;Checking donut at {donut_p:?} with toppings {toppings:?}&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>target_points
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .any(<span style=color:#f92672>|</span>target_p<span style=color:#f92672>|</span> self.is_reachable(global, <span style=color:#f92672>*</span>donut_p, <span style=color:#f92672>*</span>target_p))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We cannot have an over filled simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// For example, if we need 1 plain donut, we cannot have frosting on all the donuts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> donut_types <span style=color:#f92672>=</span> donuts
</span></span><span style=display:flex><span>                .into_iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>(_, toppings)<span style=color:#f92672>|</span> Some(toppings))
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>            donut_types.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> target_donuts <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>                .entities
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .filter_map(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> e {
</span></span><span style=display:flex><span>                    Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Target(toppings),
</span></span><span style=display:flex><span>                        <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=&gt;</span> Some(<span style=color:#f92672>*</span>toppings),
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>            target_donuts.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We can&#39;t do this comparison if we have any &#39;any&#39; targets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> target_donuts.iter().all(<span style=color:#f92672>|</span>t<span style=color:#f92672>|</span> t.is_some()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// This comparison also doesn&#39;t work if we have fewer targets than dummies (world 4: merge)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> donut_types.len() <span style=color:#f92672>==</span> target_donuts.len() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Because they&#39;re sorted, this means have at least one donut with too many toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> donut_types <span style=color:#f92672>&gt;</span> target_donuts {
</span></span><span style=display:flex><span>                        tracing::debug!(
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;Not possible. Got {donut_types:?} but needed {target_donuts:?}&#34;</span>
</span></span><span style=display:flex><span>                        );
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// But if we have a target in the globals, we must (also?) match that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(target_donuts) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>global.targets {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>&amp;</span>donut_types <span style=color:#f92672>&gt;</span> target_donuts {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Not possible against global types. Got {donut_types:?} but needed {target_donuts:?}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I don&rsquo;t actually do must checking with the <code>tickwise</code> simulation, since that will <code>Err</code> on most cases. But I do make sure to check a few more in the original simulation. The main check here is <code>is_reachable</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Is it at all possible to get from src to dst with the current belt configuration?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Use empty points, allowed to step on targets, and can follow belts + splitters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[tracing::instrument(skip(self, global), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_reachable</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>, src: <span style=color:#a6e22e>Point</span>, dst: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> src <span style=color:#f92672>==</span> dst {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pathfinding::prelude::bfs(
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>src,
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we&#39;re on a teleporter, step out of it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(entity) <span style=color:#f92672>=</span> global.entities[p.index(global.width)] {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>match</span> entity.kind {
</span></span><span style=display:flex><span>                        EntityKind::TeleporterIn(id) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> global.teleporter_outs[id].clone();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        EntityKind::TeleporterOut(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> vec![<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> entity.facing.into()];
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Otherwise, try each direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> neighbors <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we&#39;re expanding along a belt, we have to follow the belt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(belt_direction) <span style=color:#f92672>=</span> self.belts[p.index(global.width)] {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> belt_direction <span style=color:#f92672>!=</span> d {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Don&#39;t expand the bfs out of bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Trying to leave a point in a way we&#39;re not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> global.entities[p.index(global.width)].is_some_and(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>e.can_exit(d)) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Otherwise, we can always step onto empty space or a belt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> self.is_empty(global, p2) <span style=color:#f92672>||</span> self.belts[p2.index(global.width)].is_some() {
</span></span><span style=display:flex><span>                        neighbors.push(p2);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// And if we&#39;re stepping onto an entity that allows it, that&#39;s fine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> global.entities[p2.index(global.width)].is_some_and(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.can_enter(d)) {
</span></span><span style=display:flex><span>                        neighbors.push(p2);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Also account for bumpers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> Direction::all() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> d.into();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p2) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If we&#39;re looking at a bumper pointing at us, include being bumped backwards
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Bumper(_),
</span></span><span style=display:flex><span>                        facing,
</span></span><span style=display:flex><span>                    }) <span style=color:#f92672>=</span> global.entities[p2.index(global.width)]
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> facing <span style=color:#f92672>==</span> d.flip() {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>let</span> p3 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>-</span> d.into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>global.in_bounds(p3) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> self.is_empty(global, p3)
</span></span><span style=display:flex><span>                                <span style=color:#f92672>||</span> self.belts[p3.index(global.width)].is_some()
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                neighbors.push(p3);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> global.entities[p3.index(global.width)]
</span></span><span style=display:flex><span>                                .is_some_and(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> e.can_enter(d))
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                neighbors.push(p3);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                neighbors
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>==</span> dst,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .is_some()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It amuses me somewhat to process that using <code>pathfinding</code> since we&rsquo;re implementing A* ourselves. But it works.</p><p>Other than that, we also check if we&rsquo;ve applied too many toppings and that&rsquo;s about it. Mostly, we don&rsquo;t generate invalid states in the first place.</p><h4 id=is_solved><code>is_solved</code></h4><p>Okay, this got a bit longer as we went. I seem to be saying that a lot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[tracing::instrument(skip(self, global), fields(belts = %self), ret)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_solved</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> global.use_tickwise {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> simulation_result <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.simulate_tickwise(global) {
</span></span><span style=display:flex><span>                Ok(simulation_result) <span style=color:#f92672>=&gt;</span> simulation_result,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Simulation failed: {e}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;Simulation result: {simulation_result:#?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re allowing invalid deliveries, it&#39;s still not solved if there are any that don&#39;t match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> global.allow_invalid_deliveries {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (dst, donuts) <span style=color:#66d9ef>in</span> simulation_result.deliveries.iter() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (_, toppings) <span style=color:#66d9ef>in</span> donuts.iter() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>match</span> global.entities[dst.index(global.width)] {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// Each destination must be none or matching
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            Some(Entity {
</span></span><span style=display:flex><span>                                kind: <span style=color:#a6e22e>EntityKind</span>::Target(target_toppings),
</span></span><span style=display:flex><span>                                <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                            }) <span style=color:#66d9ef>if</span> target_toppings.is_none()
</span></span><span style=display:flex><span>                                <span style=color:#f92672>||</span> <span style=color:#f92672>*</span>toppings <span style=color:#f92672>==</span> target_toppings.unwrap() <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// If not, this is not a valid solution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                                tracing::debug!(
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#34;Invalid delivery at {dst:?} with toppings {toppings:?}&#34;</span>
</span></span><span style=display:flex><span>                                );
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// All sources must have been delivered from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> all_delivered_from <span style=color:#f92672>=</span> simulation_result
</span></span><span style=display:flex><span>                .deliveries
</span></span><span style=display:flex><span>                .values()
</span></span><span style=display:flex><span>                .flatten()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>(p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>HashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (index, entity) <span style=color:#66d9ef>in</span> global.entities.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Source <span style=color:#f92672>|</span> EntityKind::AnySource,
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> entity
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>all_delivered_from.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;Source at {p:?} was not delivered from&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// All targets must have been delivered to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (index, entity) <span style=color:#66d9ef>in</span> global.entities.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Target(_),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> entity
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>simulation_result.deliveries.contains_key(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;Target at {p:?} was not delivered to&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If a global target list is set, check that the donuts match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(global_targets) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>global.targets {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// For this check, a single source delivering to multiple targets counts as a single donut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// That&#39;s why we HashSet first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> all_delivered_donuts <span style=color:#f92672>=</span> simulation_result
</span></span><span style=display:flex><span>                    .deliveries
</span></span><span style=display:flex><span>                    .values()
</span></span><span style=display:flex><span>                    .flatten()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>pt<span style=color:#f92672>|</span> pt)
</span></span><span style=display:flex><span>                    .collect::<span style=color:#f92672>&lt;</span>HashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>                    .into_iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>(_, t)<span style=color:#f92672>|</span> Some(<span style=color:#f92672>*</span>t))
</span></span><span style=display:flex><span>                    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                all_delivered_donuts.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>&amp;</span>all_delivered_donuts <span style=color:#f92672>!=</span> global_targets {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Invalid solution, types don&#39;t match. Got {all_delivered_donuts:?} but needed {global_targets:?}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We passed all conditions, we&#39;re SOLVED!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Simulate the current state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tracing::debug!(<span style=color:#e6db74>&#34;Running simulation&#34;</span>);
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}&#34;</span>, self.stringify(global));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> donuts <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.simulate(global) {
</span></span><span style=display:flex><span>                Ok(donuts) <span style=color:#f92672>=&gt;</span> donuts,
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Simulation failed: {e}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            tracing::debug!(<span style=color:#e6db74>&#34;Simulation result: {donuts:?}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Each target must have at least one donut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (index, entity) <span style=color:#66d9ef>in</span> global.entities.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Target(_),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> entity
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>donuts.iter().any(<span style=color:#f92672>|</span>(donut_p, _)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>donut_p <span style=color:#f92672>==</span> p) {
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;No donut delivered to {p:?}&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Each donut must end at a matching target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// A non-target accepts any donut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (donuts_p, toppings) <span style=color:#66d9ef>in</span> donuts.iter() {
</span></span><span style=display:flex><span>                tracing::debug!(<span style=color:#e6db74>&#34;Checking donut at {donuts_p:?} with toppings {toppings:?}&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> global.entities[donuts_p.index(global.width)] {
</span></span><span style=display:flex><span>                    Some(Entity {
</span></span><span style=display:flex><span>                        kind: <span style=color:#a6e22e>EntityKind</span>::Target(target_toppings),
</span></span><span style=display:flex><span>                        <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                    }) <span style=color:#66d9ef>if</span> target_toppings.is_none() <span style=color:#f92672>||</span> <span style=color:#f92672>*</span>toppings <span style=color:#f92672>==</span> target_toppings.unwrap() <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        tracing::debug!(<span style=color:#e6db74>&#34;Invalid solution, donut at {donuts_p:?} with toppings {toppings:?} isn&#39;t at a matching target&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we have a toppings array, match that as well/instead
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// The check above already checks that they&#39;re all at targets, this just checks types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(target_donuts) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>global.targets {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> donut_types <span style=color:#f92672>=</span> donuts.iter().map(<span style=color:#f92672>|</span>(_, t)<span style=color:#f92672>|</span> Some(<span style=color:#f92672>*</span>t)).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>                donut_types.sort();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>&amp;</span>donut_types <span style=color:#f92672>!=</span> target_donuts {
</span></span><span style=display:flex><span>                    tracing::debug!(<span style=color:#e6db74>&#34;Invalid solution, types don&#39;t match. Got {donut_types:?} but needed {target_donuts:?}&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because <code>simulate</code> returns just a single <code>Vec</code> of final states and <code>simulate_tickwise</code> returns <code>deliveries</code> and <code>extras</code> separately, these overlap less. But it works out well enough.</p><h4 id=heuristic><code>heuristic</code></h4><p>For the heuristic, I actually only use the <code>simulate</code> solver:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> State<span style=color:#f92672>&lt;</span>Global, ()<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Local {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>heuristic</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: This uses the non-tickwise solver in both modes, is this okay?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// For each donut, the distance to the nearest reachable target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> donuts <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> self.simulate(global) {
</span></span><span style=display:flex><span>            Ok(donuts) <span style=color:#f92672>=&gt;</span> donuts,
</span></span><span style=display:flex><span>            Err(_) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> target_points <span style=color:#f92672>=</span> global
</span></span><span style=display:flex><span>            .entities
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .enumerate()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>(index, entity)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                    kind: <span style=color:#a6e22e>EntityKind</span>::Target(_),
</span></span><span style=display:flex><span>                    <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>                }) <span style=color:#f92672>=</span> entity
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Some(Point {
</span></span><span style=display:flex><span>                        x: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>%</span> global.width,
</span></span><span style=display:flex><span>                        y: <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> <span style=color:#f92672>/</span> global.width,
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        donuts
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(donut_p, _)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                target_points
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .filter(<span style=color:#f92672>|</span>target_p<span style=color:#f92672>|</span> self.is_reachable(global, <span style=color:#f92672>*</span>donut_p, <span style=color:#f92672>**</span>target_p))
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>target_p<span style=color:#f92672>|</span> donut_p.manhattan_distance(<span style=color:#f92672>*</span>target_p))
</span></span><span style=display:flex><span>                    .min()
</span></span><span style=display:flex><span>                    .unwrap_or(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>i64</span>
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .sum()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I could definitely have used <code>extras</code> on <code>simulate_tickwise</code>, especially since this means that I&rsquo;m running both simulations for each state (I wonder if that&rsquo;s one reason it&rsquo;s so much slower&mldr;) but it works well enough.</p><h2 id=overview>Overview</h2><p>And that&rsquo;s it! Simulate, implement <code>State</code>, and type up all the levels. There are a 12 worlds of 12 each, which is just gross. I enjoyed it!</p><h2 id=interesting-challenges-and-rewrites>Interesting challenges and rewrites</h2><p>Okay, that&rsquo;s the higher level solution as it stands. If you&rsquo;d rather read through the solutions state by state (with more a focus on what changed), this is the section for you!</p><h3 id=initial-solution>Initial solution</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/a97d12cd9e71058151706215932aea9b33856d7e target=_blank rel=noopener>Commit</a></li></ul><p>And so it begins! This is the first commit to <code>freshly-frosted.rs</code> which sets everything up.</p><p>We already have <code>Entity</code> and <code>EntityKind</code> with <code>TryFrom&lt;&amp;str></code> exactly the same as it ended up (just with only a handful of <code>Entities</code>).</p><p><code>Global</code> only has <code>width</code>, <code>height</code>, and <code>entities</code>.</p><p>Otherwise, we have:</p><ul><li><code>is_valid</code> is <code>true</code>; this is always handled by <code>next_states</code> or <code>is_solved</code>, so we don&rsquo;t cut out <em>any</em> invalid states</li><li><code>is_solved</code> requires a belt pointing at each <code>Target</code></li><li>Simulation is only done in <code>is_solved</code> and is inline</li><li><code>next_states</code> finds &lsquo;heads&rsquo; (a source or belt pointing at empty space) and then expands one of them; the checks to &lsquo;can expand&rsquo; are longer than they ended up</li><li><code>heuristic</code> is <code>0</code></li></ul><p>All that being said though&mldr; it works great for the entire first world of levels! So a good place to start.</p><h3 id=global-targets>Global targets</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/fc27ff068968040fde0c4c5f7250f9eebd119c94 target=_blank rel=noopener>Commit</a></li></ul><p>This is where we first learn that the <code>Targets</code> on the board are not always the set of <code>Targets</code> that we need to deliver to: we can have <code>Targets</code> that take anything and a global list in the corner.</p><p><img src=03-03-global-target.png alt="Screenshot of undefined targets and global targets in the corner"></p><p>Note the three <code>Targets</code> down the middle don&rsquo;t list what you need to deliver anymore. And at least in this one we have 3 <code>Targets</code> and need to deliver 3 (top left), but that&rsquo;s not even always the case.</p><p>So now, we need <code>Target</code> to have <code>Option&lt;Toppings></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>enum EntityKind {
</span></span><span style=display:flex><span>    Block,
</span></span><span style=display:flex><span>    Source,
</span></span><span style=display:flex><span><span style=color:#f92672>-   Target(Toppings),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+   Target(Option&lt;Toppings&gt;),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>    Topper(Toppings),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With a <code>->?</code> style <code>Entity</code> to signify we don&rsquo;t know (or care) what it can accept.</p><p>At this point we have our first flag, but rather than <code>:targets</code>, we use <code>#targets</code>&mldr; but it turns out I also used <code>#</code> for walls, which I bumped into later.</p><p>This also changes how we check <code>is_solved</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-        // Because they&#39;re sorted, this means have at least one donut with too many toppings
</span></span></span><span style=display:flex><span><span style=color:#f92672>-       if donut_types &gt; target_donuts {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-           tracing::debug!(&#34;Donuts are too many. lol.&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-           return false;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-       }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+       // We can&#39;t do this comparison if we have any &#39;any&#39; targets
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       if target_donuts.iter().all(|t| t.is_some()) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+           // Because they&#39;re sorted, this means have at least one donut with too many toppings
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+           if donut_types &gt; target_donuts {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+               tracing::debug!(&#34;Not possible. Got {donut_types:?} but needed {target_donuts:?}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+               return false;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+           }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       // But if we have a target in the globals, we must (also?) match that
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       if let Some(target_donuts) = &amp;global.targets {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+           if &amp;donut_types &gt; target_donuts {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+               tracing::debug!(&#34;Not possible against global types. Got {donut_types:?} but needed {target_donuts:?}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+               return false;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+           }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       }
</span></span></span></code></pre></div><p>Straight forward enough and this gets us through World 2.</p><h3 id=allow-merging--loop-detection>Allow merging / Loop detection</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/222b7a4a2dc1181efcc40af51022f614cf8c98bc target=_blank rel=noopener>Commit</a></li></ul><p><img src=04-01-merge.png alt="Screenshot of a merger"></p><p>And then there was merging.</p><p>This one ended up taking a few iterations to get right, but at the beginning (with the original simulation) it wasn&rsquo;t actually a matter of implementing merging, but rather generating states where belts could point at each other (rather than always pointing at empty spaces or targets).</p><p>This in turn&mldr; mean that we had to handle loop detection!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                    let mut visited = vec![false; global.width as usize * global.height as usize];
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     p = p + facing.into();
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                    visited[p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>                     while !matches!(
</span></span><span style=display:flex><span>                         global.entities[p.index(global.width)],
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                         } else {
</span></span><span style=display:flex><span>                             break; // Ran off the end of a belt
</span></span><span style=display:flex><span>                         }
</span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        // Error on loops
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        if visited[p.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            return Err(format!(&#34;Loop detected at {p:?}&#34;));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            visited[p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     }
</span></span></code></pre></div><p>Otherwise who knows how long we might keep adding new states. <a href=https://en.wikipedia.org/wiki/Infinite%20loop>FOREVER</a>?</p><h3 id=simulate-cache>Simulate cache</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/749da9787b8d8cda0edd78e0c635394c2aeb5bf4 target=_blank rel=noopener>Commit</a></li></ul><p>On change that I first implemented around here as a cache for the simulation. If I see a single set of belts, I never have to simulate it more than once.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -1,4 +1,4 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>-use std::io::Read;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+use std::{collections::HashMap, io::Read, sync::{LazyLock, Mutex}};
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span> use bitmask_enum::bitmask;
</span></span><span style=display:flex><span> use solver::{Direction, Point, Solver, State};
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -187,8 +187,15 @@ impl Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+static SIMULATE_CACHE: LazyLock&lt;Mutex&lt;HashMap&lt;Local, Vec&lt;(Point, Toppings)&gt;&gt;&gt;&gt; = LazyLock::new(|| Mutex::new(HashMap::new()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> impl Local {
</span></span><span style=display:flex><span>     fn simulate(&amp;self, global: &amp;Global) -&gt; Result&lt;Vec&lt;(Point, Toppings)&gt;, String&gt; {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+        // Check the cache first
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        if let Some(cached) = SIMULATE_CACHE.lock().unwrap().get(self) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Ok(cached.clone());
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         let mut donuts = vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         // Now we actually have to simulate each source
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -270,6 +277,9 @@ impl Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             }
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+        // Cache the result
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        SIMULATE_CACHE.lock().unwrap().insert(self.clone(), donuts.clone());
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         Ok(donuts)
</span></span><span style=display:flex><span>     }
</span></span></code></pre></div><p>That&rsquo;s the entirety of it.</p><p>You might notice one oddity there&mldr; why in the world am I implementing that as a <code>static</code>? Well, that&rsquo;s going to bite me (when it comes to <a href=#testing-with-macros>testing</a>) and I don&rsquo;t fix it until <a href=#parallelism--moving-simulation-caches>much later</a>. But for the most part, this worked&mldr;</p><p>And I totally forgot/didn&rsquo;t make the connection to what interior mutability actually <em>means</em>. I&rsquo;m more traditionally used to a more functional mindset where immutable means <em>immutable</em>. But in the case of Rust, if you have a <code>&amp;Global</code> with a <code>Rc&lt;RefCell&lt;Thing>></code> on it&mldr; you can get a mutable (runtime checked) reference to <code>Thing</code>.</p><p>So it goes. This does work (mostly) and did save me a decent bit of performance!</p><h3 id=hints-preset-belts-also-used-for-world-8>Hints (Preset belts; also used for World 8)</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/288d95ae06d271dd5fa4598eacd96ab950d96718 target=_blank rel=noopener>Commit</a></li></ul><p>Okay, next up wasn&rsquo;t actually part of a puzzle, but rather a way of making sure that the simulation worked as intended. Initial belts!</p><p>This means that we can actually fill out part of a solution (like via the in game hint system)</p><p><img src=04-07-hint.png alt="Screenshot of the hint system"></p><p>Which I might encode as this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>:targets 0 1 1 1 3 7
</span></span><span style=display:flex><span>.   .   .   .   .   .   .   .   .   .   .   .   .   .
</span></span><span style=display:flex><span>.   1&lt;  +&gt;  &gt;   v   1&lt;  +&gt;  &gt;   ^   2&lt;  -&lt;? .   .   +&lt;
</span></span><span style=display:flex><span>.   &lt;   .   .   .   .   .   .   .   .   .   .   .   .
</span></span><span style=display:flex><span>+&gt;  ^   .   -&gt;3 2&gt;  .   .   +&lt;  1&gt;  .   .   +&lt;  4&gt;  .
</span></span><span style=display:flex><span>.   .   .   .   .   .   .   .   .   .   .   .   .   .
</span></span></code></pre></div><p>This is our second change to <code>Global</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -103,6 +104,7 @@ impl From&lt;&amp;str&gt; for Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     height: isize,
</span></span><span style=display:flex><span>     entities: Vec&lt;Option&lt;Entity&gt;&gt;,
</span></span><span style=display:flex><span>     targets: Option&lt;Vec&lt;Option&lt;Toppings&gt;&gt;&gt;,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    initial_belts: Vec&lt;Option&lt;Direction&gt;&gt;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>}
</span></span></code></pre></div><p>Other than that, it&rsquo;s mostly actually in loading:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -124,19 +126,25 @@ impl From&lt;&amp;str&gt; for Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             let mut line_width = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             for part in line.split_whitespace() {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                let mut belt = None;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                let mut entity = None;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 line_width += 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                 if part == &#34;.&#34; {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    entities.push(None);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    continue;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    // Do nothing
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                } else if let Ok(found_belt) = Direction::try_from(part) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    belt = Some(found_belt);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    entity = match Entity::try_from(part) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        Ok(entity) =&gt; Some(entity),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        Err(e) =&gt; panic!(&#34;Invalid entity: {e}&#34;),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    };
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-                let entity = match Entity::try_from(part) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    Ok(entity) =&gt; entity,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    Err(e) =&gt; panic!(&#34;Invalid entity: {e}&#34;),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                };
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                assert!(!(entity.is_some() &amp;&amp; belt.is_some()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>-                entities.push(Some(entity));
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                initial_belts.push(belt);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                entities.push(entity);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             }
</span></span></code></pre></div><p>And when creating the <code>Local</code> state, clone that initial state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span> impl Global {
</span></span><span style=display:flex><span>     fn make_local(&amp;self) -&gt; Local {
</span></span><span style=display:flex><span>         Local {
</span></span><span style=display:flex><span><span style=color:#f92672>-            belts: vec![None; self.width as usize * self.height as usize],
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            belts: self.initial_belts.clone(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>It&rsquo;s fun when a change only impacts loading and still has a fairly big impact.</p><h3 id=starting-splitters>Starting splitters</h3><ul><li>Commits: <a href=https://github.com/jpverkamp/rust-solvers/commit/b43c051bbdb10a8884a03ccfc92222b4b011e687 target=_blank rel=noopener>1</a> <a href=https://github.com/jpverkamp/rust-solvers/commit/bd9769133215e037989c3605264e1a08583aa965 target=_blank rel=noopener>2</a> <a href=https://github.com/jpverkamp/rust-solvers/commit/4b45320c8e330e95aa96cfc1de9ac0097ae95d26 target=_blank rel=noopener>3</a></li></ul><p>Okay, now we&rsquo;re actually back to a new <code>Entity</code> we need to implement: <code>Splitters</code>. In this case, they have one input and two outputs: 90° clockwise and counterclockwise / left and right of the input. It will always alternate between the two, sending one donut left, then one right, then left, etc.</p><p><img src=06-08-order-matters.png alt="Screenshot showing splitters"></p><p>For the most part, we can keep ignoring the details of our current implementation and just replace the one donut we&rsquo;re simulating now (by <code>continue 'each_donut</code>) with two new ones (<code>donuts.push</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                // If we are at a splitter, split the donut
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    kind: EntityKind::Splitter,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    facing,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }) = global.entities[p.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    // TODO: Check if we came into the splitter the wrong way?
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    // Queue the two new donuts
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    donuts.push((p, toppings, facing.turn_left(), visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    donuts.push((p, toppings, facing.turn_right(), visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    // Do not simulate this path any more
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    continue &#39;each_donut;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span></code></pre></div><p>Unfortunately, that doesn&rsquo;t work for every level&mldr;</p><p><img src=06-08-order-matters.png alt="Screenshot showing a level where splitter ordering matters"></p><p>In this one, we&rsquo;re merging a belt of Frosted donuts with a belt of Plain/None&mldr; and you have to make sure that they are delivered in alternating order with Frosted first. Man this one took a while to get right.</p><h3 id=tickwise>Tickwise</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/9f664d3f779d6a7e50b4c96e5b49fd44dda556ca target=_blank rel=noopener>Commit</a></li></ul><p>So here&rsquo;s one of our first big changes: the introduction of <code>simulate_tickwise</code>, which I talked about <a href=#simulation-tickwise>above</a>. This also doubles my <a href=#simulate-cache>previous issues</a>&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+static SIMULATE_TICKWISE_CACHE: LazyLock&lt;Mutex&lt;HashMap&lt;Local, SimulateTickwiseResult&gt;&gt;&gt; =
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    LazyLock::new(|| Mutex::new(HashMap::new()));
</span></span></span></code></pre></div><p>But so it goes.</p><p>One interesting difference is that, while this is simulating <code>tickwise</code>, it&rsquo;s not actually the same algorithm as I ended up with. Instead of finding all of the potential updates and then resolving merges, I find a space that needs to be updated (that has room to move into) and update it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+            // Look for a space that can be updated
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            // This is always a destination space, find a donut that can be put there
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;find_update: loop {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                for x in 0..global.width {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    for y in 0..global.height {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        let p = Point { x, y };
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        // Only update each point once
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        if state_at!(p).updated {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            continue;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        // If the spot is occupied, skip it
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        if state_at!(p).toppings.is_some() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            continue;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        // Find the potential donuts that can move into this space
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        let mut potential_donuts = vec![];
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        for d in Direction::all() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            let p_from = p - d.into();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            if !global.in_bounds(p_from) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                continue;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span></code></pre></div><p>Unfortunately&mldr; this doesn&rsquo;t work. If we have a completely full loop, this will never find a postition that can be updated. And with <a href=#bumpers--improved-loop-detection>bumpers</a>&mldr; we can have that case, since the only way out of the loop could be a bumper.</p><p>But it worked for then.</p><h3 id=bumpers--improved-loop-detection><code>Bumpers</code> + Improved loop detection</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/be265d473d8ae68f4a5c4d4e1ccba54dcc0471e5 target=_blank rel=noopener>Commit</a></li></ul><p>Okay, time for another, <code>EntityKind::Bumper(Toppings)</code>:</p><p><img src=07-02-bumpers.png alt="Screenshot showing bumpers"></p><p>Whenever the <em>matching</em> donut passes it, push away.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-                            // TODO: Bumpers
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            // A bumper two spaces away matching a donut on a belt one tile away
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            let p_bumper = p_from - d.into();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            if global.in_bounds(p_bumper) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    kind: EntityKind::Bumper(bumper_toppings),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    facing,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }) = global.entities[p_bumper.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    if facing == d {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        if let Some(toppings) = state_at!(p_from).toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                            if toppings == bumper_toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                                potential_donuts.push((p_from, toppings, d));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         }
</span></span></code></pre></div><p>This add another level of complication to our simulation, since we specifically have puzzles where you might have bumpers pushing different types of donuts onto different branches that later merge together.</p><p>Currently <code>visited</code> will detect that as a loop, which doesn&rsquo;t work out too well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>         // Now we actually have to simulate each source
</span></span><span style=display:flex><span><span style=color:#f92672>-        let visited = vec![false; global.width as usize * global.height as usize];
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        let mut visited = vec![];
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        for _ in 0..(Toppings::all_flags().bits + 1) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            visited.push(vec![false; global.width as usize * global.height as usize]);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-            visited[p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            visited[toppings.bits][p.index(global.width)] = true;
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                 // Error on loops
</span></span><span style=display:flex><span><span style=color:#f92672>-                if visited[p.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                if visited[toppings.bits][p.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     return Err(format!(&#34;Loop detected at {p:?}&#34;));
</span></span><span style=display:flex><span>                 } else {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    visited[p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    visited[toppings.bits][p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 }
</span></span><span style=display:flex><span>             }
</span></span></code></pre></div><p>It does cost a bit more memory (~16), but it&rsquo;s more correct, so that seems a fair enough trade.</p><p>Except&mldr; we&rsquo;re still assuming that any combination of <code>Toppings</code> could be valid, which turns out not true. Eventually we&rsquo;ll <a href=#toppings-rewrite>fix that</a>&mldr;</p><h3 id=tickwise-rewrite>Tickwise rewrite</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/52f0cf27acb865bea2e7cd9cd554c84dbfe9c3b2 target=_blank rel=noopener>Commit</a></li></ul><p>Here&rsquo;s the bumper fix for the issue mentioned at the end of <a href=#tickwise>tickwise</a>&mldr; which actually ended up being an entire rewrite, switching over to the state <a href=#simulation-tickwise>described above</a>. I won&rsquo;t go back into details here, but I did end up liking this one a lot better when I got to it&mldr;</p><h3 id=allow-invalid-deliveries><code>:allow-invalid-deliveries</code></h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/5de97c956ca52b343fea484f76702a6fe141d605 target=_blank rel=noopener>Commit</a></li></ul><p>Oh, level 6/8&mldr;</p><p><img src=06-08-order-matters.png alt="Screenshot showing a level where splitter ordering matters"></p><p>This is the only one that has that problem&mldr; where you very specifically have to solve the problem in order. We solved this with the <code>tickwise</code> solver, but unfortunately that only works for <code>is_solved</code> (so if we supply all of the belts as <a href=#hints-preset-belts-also-used-for-world-8>hints</a> it will work, but not for <code>next_states</code>.</p><p>The problem is the two belts leading into the merge and the one to the right of it. Because as soon as the exit + either entrace is set up, it will try to deliver to both with the same kind of donut&ndash;which is currently invalid. But as soon as the second belt is hooked up, we&rsquo;re fine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -500,6 +490,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             EntityKind::Target(toppings) =&gt; {
</span></span><span style=display:flex><span>                                 if toppings.is_none()
</span></span><span style=display:flex><span>                                     || state_at!(p).toppings.unwrap() == toppings.unwrap()
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    || global.allow_invalid_deliveries
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                 {
</span></span><span style=display:flex><span>                                     deliveries.entry(p).or_insert_with(HashSet::new).insert((
</span></span><span style=display:flex><span>                                         state_at!(p).source.unwrap(),
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1011,6 +1002,27 @@ impl State&lt;Global, ()&gt; for Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             };
</span></span><span style=display:flex><span>             tracing::debug!(&#34;Simulation result: {simulation_result:#?}&#34;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+            // If we&#39;re allowing invalid deliveries, it&#39;s still not solved if there are any that don&#39;t match
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            if global.allow_invalid_deliveries {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                for (dst, donuts) in simulation_result.deliveries.iter() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    for (_, toppings) in donuts.iter() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        match global.entities[dst.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Each destination must be none or matching
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                kind: EntityKind::Target(target_toppings),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                ..
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }) if target_toppings.is_none() || *toppings == target_toppings.unwrap() =&gt; {}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // If not, this is not a valid solution
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            _ =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                tracing::debug!(&#34;Invalid delivery at {dst:?} with toppings {toppings:?}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                return false;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }
</span></span></span></code></pre></div><p>This&mldr; I&rsquo;m not proud of. It does solve this one puzzle, but it feels hacky and we never do need it for any other level.</p><p>So it goes though, that&rsquo;s why it&rsquo;s a flag.</p><h3 id=loop-treshold><code>:loop-treshold</code></h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/6506159d59daf004e31a2d10498197230939fd87 target=_blank rel=noopener>Commit</a></li></ul><p>Speaking of flags, there are a few levels where you end up getting loops that bail early. This was the first attempt to fix that, moving from a <code>HashSet</code> to a <code>HashMap</code> (as a counter) for loop detection:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -272,7 +282,7 @@ impl Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         let mut state = vec![TileState::default(); vec_size];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         let mut deliveries = HashMap::new();
</span></span><span style=display:flex><span><span style=color:#f92672>-        let mut states_seen = HashSet::new();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        let mut states_seen = HashMap::new();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>         macro_rules! state_at {
</span></span><span style=display:flex><span>             ($p:expr) =&gt; {
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -384,14 +400,16 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 }
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-            // Cache which exact states we&#39;ve seen; break once we see the same more than once
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            // TODO: This is expensive..
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            // TODO: Loops with bumpers can mess with this
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            if !states_seen.insert(state.clone()) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                tracing::debug!(&#34;Loop detected, breaking&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                tracing::debug!(&#34;Deliveries are: {deliveries:?}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                break &#39;tick;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            // Cache which exact states we&#39;ve seen; break once we see the same more than once (or a set threshold of times)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            if let Some(count) = states_seen.get(&amp;state) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                let threshold = global.loop_threshold.unwrap_or(1);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if *count &gt;= threshold {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    tracing::debug!(&#34;Loop detected (threshold={threshold}), breaking&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    tracing::debug!(&#34;Deliveries are: {deliveries:?}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    break &#39;tick;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             }
</span></span><span style=display:flex><span><span style=color:#a6e22e>+            states_seen.entry(state.clone()).and_modify(|e| *e += 1).or_insert(1);
</span></span></span></code></pre></div><p>Unfortunately, this didn&rsquo;t actually end up solving it at all, which I suppose makes sense&mldr;</p><p>The simulation is entirely deterministic. If you are in a given state (so long as that state includes <em>everthing</em>, like state of splitters and merge wait times), then you will always generate exactly the same next state for it. And if you have a loop, you&rsquo;ll always come back to this state, there is no way out of it.</p><p>No matter how high you set <code>loop_threshold</code>, this will never change which levels I can actually solve.</p><p>It was interesting enough code to leave for debugging though.</p><h3 id=teleporters>Teleporters</h3><ul><li>Commits: <a href=https://github.com/jpverkamp/rust-solvers/commit/4f321945e131b3e4a2c9c3e0ad6a45b77bdf067c target=_blank rel=noopener>1</a>, <a href=https://github.com/jpverkamp/rust-solvers/commit/2fcf1cd8eaf89a1e3b86834274af5237f47bedb3 target=_blank rel=noopener>2</a>, <a href=https://github.com/jpverkamp/rust-solvers/commit/d21bbcb743e406df35d6d9c394e6d30dbacb8aa5 target=_blank rel=noopener>3</a></li></ul><p>Next <code>Entity</code>: Teleporters!</p><p>Actually, it&rsquo;s two <code>Entities</code>, <code>TeleporterIn</code>, which you can come into from any direction and a <code>TeleporterOut</code> which you always leave in the same way (like a <code>Source</code>):</p><p><img src=09-01-teleporters.png alt="Screenshot showing teleporters"></p><p>Okay, a lot of this is storing the teleporters on our <code>Global</code> state so we don&rsquo;t have to find them every tick of every frame (why didn&rsquo;t I do this for <code>Sources</code>?):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>struct Global {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    // Map settings
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     width: isize,
</span></span><span style=display:flex><span>     height: isize,
</span></span><span style=display:flex><span><span style=color:#f92672>-    entities: Vec&lt;Option&lt;Entity&gt;&gt;,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>     targets: Option&lt;Vec&lt;Option&lt;Toppings&gt;&gt;&gt;,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    // Map entities etc
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    entities: Vec&lt;Option&lt;Entity&gt;&gt;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     initial_belts: Vec&lt;Option&lt;Direction&gt;&gt;,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    teleporter_in: Option&lt;Point&gt;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    teleporter_out: Option&lt;Point&gt;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    // Flags that change behavior for specific puzzles
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     use_tickwise: bool,
</span></span><span style=display:flex><span>     allow_invalid_deliveries: bool,
</span></span><span style=display:flex><span>     loop_threshold: Option&lt;usize&gt;,
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -204,6 +211,34 @@ impl From&lt;&amp;str&gt; for Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             global.height += 1;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+        // Store teleporters
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        for (index, entity) in global.entities.iter().enumerate() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                ..
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }) = entity
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                global.teleporter_in = Some(Point {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    x: index as isize % global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    y: index as isize / global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                });
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterOut,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                ..
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }) = entity
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                global.teleporter_out = Some(Point {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    x: index as isize % global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    y: index as isize / global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                });
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        if global.teleporter_in.is_none() ^ global.teleporter_out.is_none() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            panic!(&#34;Teleporters must be both present or neither present&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span></code></pre></div><p>And then implement it for both <code>simulate</code> functions. First for <code>simulate_tickwise</code>, generate an update moving into or out of the <code>Teleporter</code> same as ever (you can merge just after them and that failure to merge can propgate back through the <code>Teleporter</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                            // Teleporter in tries to move to the teleporter out
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // If we have an in, we have an out (according to the loading function)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            EntityKind::TeleporterIn =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_to: global.teleporter_out.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Teleporter out basically acts like a source
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            EntityKind::TeleporterOut =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_to: p + entity.facing.into(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    source: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                });
</span></span></span></code></pre></div><p>And for <code>simulate</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                // If we&#39;re on a teleporter in, apply it
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    kind: EntityKind::TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    ..
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }) = global.entities[p.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    p = global.teleporter_out.unwrap();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    continue;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                // A teleporter out just moves
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    kind: EntityKind::TeleporterOut,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    facing,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }) = global.entities[p.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    p = p + facing.into();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    continue;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span></code></pre></div><p>And that works great!</p><p>Until I realize that when I went looking through the puzzles for multiple teleporters&mldr; I totally missed that we could have that:</p><p><img src=09-09-multiple-teleporters.png alt="Screenshot showing teleporters"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -23,8 +23,8 @@ enum EntityKind {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     Topper(Toppings),
</span></span><span style=display:flex><span>     Splitter,
</span></span><span style=display:flex><span>     Bumper(Toppings),
</span></span><span style=display:flex><span><span style=color:#f92672>-    TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    TeleporterOut,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    TeleporterIn(usize),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    TeleporterOut(usize),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -99,11 +99,20 @@ impl TryFrom&lt;&amp;str&gt; for Entity {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>             // Teleporters (in doesn&#39;t currently have a facing)
</span></span><span style=display:flex><span>             &amp;[&#39;T&#39;, &#39;-&#39;] =&gt; Ok(Entity {
</span></span><span style=display:flex><span><span style=color:#f92672>-                kind: EntityKind::TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterIn(0),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 facing: Direction::default(),
</span></span><span style=display:flex><span>             }),
</span></span><span style=display:flex><span>             &amp;[&#39;T&#39;, &#39;+&#39;, facing] =&gt; Ok(Entity {
</span></span><span style=display:flex><span><span style=color:#f92672>-                kind: EntityKind::TeleporterOut,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterOut(0),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                facing: dir(facing)?,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &amp;[&#39;U&#39;, &#39;-&#39;] =&gt; Ok(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterIn(1),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                facing: Direction::default(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            }),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &amp;[&#39;U&#39;, &#39;+&#39;, facing] =&gt; Ok(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                kind: EntityKind::TeleporterOut(1),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 facing: dir(facing)?,
</span></span><span style=display:flex><span>             }),
</span></span></code></pre></div><p>I really could have (should have) made that flexible enough to parse and arbitrary number of teleporters, but I just used <code>U</code> for the second color. The rest of the code doesn&rsquo;t care how many we have though!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -123,8 +132,7 @@ struct Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     // Map entities etc
</span></span><span style=display:flex><span>     entities: Vec&lt;Option&lt;Entity&gt;&gt;,
</span></span><span style=display:flex><span>     initial_belts: Vec&lt;Option&lt;Direction&gt;&gt;,
</span></span><span style=display:flex><span><span style=color:#f92672>-    teleporter_in: Option&lt;Point&gt;,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    teleporter_out: Option&lt;Point&gt;,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    teleporter_outs: Vec&lt;Point&gt;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>     // Flags that change behavior for specific puzzles
</span></span><span style=display:flex><span>     use_tickwise: bool,
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -211,33 +219,63 @@ impl From&lt;&amp;str&gt; for Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             global.height += 1;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-        // Store teleporters
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        for (index, entity) in global.entities.iter().enumerate() {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                kind: EntityKind::TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                ..
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            }) = entity
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                global.teleporter_in = Some(Point {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    x: index as isize % global.width,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    y: index as isize / global.width,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                });
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        // Teleporter validity check
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        let mut teleporter_in_ids = global
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .entities
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .iter()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .filter_map(|e| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity { kind: EntityKind::TeleporterIn(id), .. }) = e {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    Some(*id)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    None
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .collect::&lt;Vec&lt;_&gt;&gt;();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        teleporter_in_ids.sort();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>-            if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                kind: EntityKind::TeleporterOut,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                ..
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            }) = entity
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                global.teleporter_out = Some(Point {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    x: index as isize % global.width,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    y: index as isize / global.width,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                });
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if global.teleporter_in.is_none() ^ global.teleporter_out.is_none() {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            panic!(&#34;Teleporters must be both present or neither present&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        let mut teleporter_out_ids = global
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .entities
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .iter()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .filter_map(|e| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity { kind: EntityKind::TeleporterOut(id), .. }) = e {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    Some(*id)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    None
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .collect::&lt;Vec&lt;_&gt;&gt;();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        teleporter_out_ids.sort();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        // Teleporters must be defined in order (so no 1 without 0)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        assert_eq!(teleporter_in_ids, (0..teleporter_in_ids.len()).collect::&lt;Vec&lt;_&gt;&gt;(), &#34;Teleporter in IDs not in order&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        // There must be exactly one out for every in
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        assert_eq!(teleporter_in_ids, teleporter_out_ids, &#34;Mismatched teleporters&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        // There cannot be any duplicates in either list
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        // This seems like a silly way to do it 😄
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        assert_eq!(teleporter_in_ids.len(), teleporter_in_ids.iter().collect::&lt;HashSet&lt;_&gt;&gt;().len(), &#34;Duplicate teleporter in&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        assert_eq!(teleporter_out_ids.len(), teleporter_out_ids.iter().collect::&lt;HashSet&lt;_&gt;&gt;().len(), &#34;Duplicate teleporter out&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        // Store the teleporter outs by ID for easy access
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        let mut teleporter_outs = global
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .entities
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .iter()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .enumerate()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .filter_map(|(index, e)| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity { kind: EntityKind::TeleporterOut(id), .. }) = e {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    Some((id, Point {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        x: index as isize % global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        y: index as isize / global.width,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    None
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            .collect::&lt;Vec&lt;_&gt;&gt;();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        teleporter_outs.sort_by_key(|(id, _)| *id);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        global.teleporter_outs = teleporter_outs.into_iter().map(|(_, p)| p).collect();
</span></span></span></code></pre></div><p>And I went ahead and put some error handling when I typed something wrong when putting in a level. In the simulation, the changes are fairly minimal:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -597,16 +635,16 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             }
</span></span><span style=display:flex><span>                             // Teleporter in tries to move to the teleporter out
</span></span><span style=display:flex><span>                             // If we have an in, we have an out (according to the loading function)
</span></span><span style=display:flex><span><span style=color:#f92672>-                            EntityKind::TeleporterIn =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            EntityKind::TeleporterIn(id) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                 updates.push(Update {
</span></span><span style=display:flex><span>                                     move_from: p,
</span></span><span style=display:flex><span><span style=color:#f92672>-                                    move_to: global.teleporter_out.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                    move_to: global.teleporter_outs[id],
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                     toppings: state_at!(p).toppings.unwrap(),
</span></span><span style=display:flex><span>                                     source: state_at!(p).source.unwrap(),
</span></span><span style=display:flex><span>                                 })
</span></span><span style=display:flex><span>                             }
</span></span><span style=display:flex><span>                             // Teleporter out basically acts like a source
</span></span><span style=display:flex><span><span style=color:#f92672>-                            EntityKind::TeleporterOut =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            EntityKind::TeleporterOut(_) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                 updates.push(Update {
</span></span><span style=display:flex><span>                                     move_from: p,
</span></span><span style=display:flex><span>                                     move_to: p + entity.facing.into(),
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -875,17 +913,17 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                 // If we&#39;re on a teleporter in, apply it
</span></span><span style=display:flex><span>                 if let Some(Entity {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    kind: EntityKind::TeleporterIn,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    kind: EntityKind::TeleporterIn(id),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     ..
</span></span><span style=display:flex><span>                 }) = global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>                 {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    p = global.teleporter_out.unwrap();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    p = global.teleporter_outs[id];
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     continue;
</span></span><span style=display:flex><span>                 }
</span></span></code></pre></div><h3 id=parallelism--moving-simulation-caches>Parallelism / Moving simulation caches</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/4497edd6ad153a0ee5f1e03ae4d3224217184275 target=_blank rel=noopener>Commit</a></li></ul><p>As mentioned&mldr; I can&rsquo;t believe this one took me so long to do&mldr;</p><p>Basically, I was having problems with inconsistent <a href=#testing-with-macros>tests</a>. Sometimes they would succeed, sometimes fail. And that did <em>not</em> make sense&ndash;as mentioned everything should be deterministic!</p><p>Well&mldr; do you remember these lines?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>SIMULATE_CACHE</span>: <span style=color:#a6e22e>LazyLock</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, Vec<span style=color:#f92672>&lt;</span>(Point, Toppings)<span style=color:#f92672>&gt;&gt;&gt;&gt;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    LazyLock::new(<span style=color:#f92672>||</span> Mutex::new(HashMap::new()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>SIMULATE_TICKWISE_CACHE</span>: <span style=color:#a6e22e>LazyLock</span><span style=color:#f92672>&lt;</span>Mutex<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, SimulateTickwiseResult<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    LazyLock::new(<span style=color:#f92672>||</span> Mutex::new(HashMap::new()));
</span></span></code></pre></div><p>It turns out that <code>cargo test</code> will run tests in the same thread/context, so those two <code>HashMap</code> were being shared between tests. And because I keyed the cache (at least the first) <em>entirely</em> on the <code>Local</code> state (just the belts), any two maps that were the same size would be sharing (and colliding in the cache). Specifically:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>test_next_states! {
</span></span><span style=display:flex><span>    bumper,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   bv0 .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    +&gt;  &gt;   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>,
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        ((<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>), [Left, Right, Up]),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_next_states! {
</span></span><span style=display:flex><span>    non_matching_bumper,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   bv1 .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    +&gt;  &gt;   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>,
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        ((<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>), [Up, Down, Left]),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ll explain the macros <a href=#testing-with-macros>later</a>, but suffice it to say, one of these should be applying the <code>Bumper</code> and the other should not, but almost always, they would return the same value (generally, <code>non_matching_bumper</code> would be the one to fail)&mldr;</p><p>And the fix is <em>so easy</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>@@</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>7</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>5</span> <span style=color:#f92672>@@</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>use</span> std::{
</span></span><span style=display:flex><span><span style=color:#f92672>-</span>    collections::{HashMap, HashSet},
</span></span><span style=display:flex><span><span style=color:#f92672>-</span>    io::Read,
</span></span><span style=display:flex><span><span style=color:#f92672>-</span>    sync::{LazyLock, Mutex},
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>    cell::RefCell, collections::{HashMap, HashSet}, io::Read, rc::Rc
</span></span><span style=display:flex><span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>use</span> bitmask_enum::bitmask;
</span></span><span style=display:flex><span><span style=color:#f92672>@@</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>138</span>,<span style=color:#ae81ff>6</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>136</span>,<span style=color:#ae81ff>10</span> <span style=color:#f92672>@@</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Global</span> {
</span></span><span style=display:flex><span>     use_tickwise: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>     allow_invalid_deliveries: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>     loop_threshold: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>    <span style=color:#75715e>// Local caches
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>+</span>    simulate_cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, Vec<span style=color:#f92672>&lt;</span>(Point, Toppings)<span style=color:#f92672>&gt;&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>    simulate_tickwise_cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>Local, SimulateTickwiseResult<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>impl</span> Global {
</span></span><span style=display:flex><span><span style=color:#f92672>@@</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>342</span>,<span style=color:#ae81ff>7</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>344</span>,<span style=color:#ae81ff>7</span> <span style=color:#f92672>@@</span> <span style=color:#66d9ef>impl</span> Local {
</span></span><span style=display:flex><span>     <span style=color:#75715e>#[tracing::instrument(skip(self, global), ret)]</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulate_tickwise</span>(<span style=color:#f92672>&amp;</span>self, global: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Global</span>) -&gt; Result<span style=color:#f92672>&lt;</span>SimulateTickwiseResult, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Check the cache first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>-</span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(cached) <span style=color:#f92672>=</span> <span style=color:#66d9ef>SIMULATE_TICKWISE_CACHE</span>.lock().unwrap().get(self) {
</span></span><span style=display:flex><span><span style=color:#f92672>+</span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(cached) <span style=color:#f92672>=</span> global.simulate_tickwise_cache.borrow().get(self) {
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>return</span> Ok(cached.clone());
</span></span><span style=display:flex><span>         }
</span></span></code></pre></div><p>A <code>Global</code> <em>is</em> unique to a single run and with <a href=https://en.wikipedia.org/wiki/interior%20mutability>interior mutability</a> via <code>RefCell</code>, I <em>can</em> mutate the cache in a <code>Global</code> without having a mutable reference to <code>Global</code> (so long as I&rsquo;m not otherwise doing screwy things with lifetimes).</p><p>Sigh.</p><p>But now I know! And now my tests work!</p><h3 id=refactoring-can_enter-and-can_exit>Refactoring <code>can_enter</code> and <code>can_exit</code></h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/317f04d655680c3c6fddead97955c0da916056c3 target=_blank rel=noopener>Commit</a></li></ul><p>For a while, I&rsquo;ve had duplicated code between <code>simulate</code> and <code>simulate_tickwise</code>, specifically dealing with when I can walk onto / off of certain <code>Entities</code>. In another case of &lsquo;why didn&rsquo;t I do this a long time ago&rsquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Entity {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_enter</span>(self, dir: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.kind {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can never enter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::Block
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Source
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Topper(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Bumper(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::TeleporterOut(_) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can only enter if we&#39;re going the right direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::Target(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Splitter <span style=color:#f92672>=&gt;</span> self.facing <span style=color:#f92672>==</span> dir,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can always enter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::TeleporterIn(_)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>can_exit</span>(self, dir: <span style=color:#a6e22e>Direction</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.kind {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can never exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::Block
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Topper(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Bumper(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::TeleporterIn(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Target(_)  <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Can only exit if we&#39;re going the right direction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::TeleporterOut(_)
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> EntityKind::Source <span style=color:#f92672>=&gt;</span> self.facing <span style=color:#f92672>==</span> dir,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Splitters do their own thing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EntityKind::Splitter <span style=color:#f92672>=&gt;</span> self.facing.turn_left() <span style=color:#f92672>==</span> dir <span style=color:#f92672>||</span> self.facing.turn_right() <span style=color:#f92672>==</span> dir,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Much more centralized and easier to use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-                        // Some entities cannot be moved onto (at all or in a specific direction)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                        // We have to be able to move onto the next entity
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         if let Some(entity) = global.entities[p2.index(global.width)] {
</span></span><span style=display:flex><span><span style=color:#f92672>-                            match entity.kind {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                EntityKind::Block
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                | EntityKind::Source
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                | EntityKind::Topper(_)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                | EntityKind::Bumper(_)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                | EntityKind::TeleporterOut(_) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            if !entity.can_enter(belt) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                     return Err(format!(
</span></span><span style=display:flex><span><span style=color:#f92672>-                                        &#34;Donut at {p:?} tried to move onto a {:?}&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                        entity.kind
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    ));
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                EntityKind::Target(_) | EntityKind::Splitter =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    if entity.facing != belt {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                        return Err(format!(&#34;Donut at {p:?} tried to move onto a {:?} facing the wrong way&#34;, entity.kind));
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                EntityKind::TeleporterIn(_) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    // No facing, we can always move onto this
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                    &#34;Donut at {p:?} tried to move {belt:?} onto a {entity:?} but couldn&#39;t&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                ));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             }
</span></span><span style=display:flex><span>                         }
</span></span></code></pre></div><h3 id=crossovers>Crossovers</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/25c6e1604872c9d95464470d52c9e8ffb3947079 target=_blank rel=noopener>Commit</a></li><li><a href=https://github.com/jpverkamp/rust-solvers/commit/b97839017cf2aeb82407e814e19029f3c6b1a5fb target=_blank rel=noopener>Fix commit</a></li></ul><p>Okay, next up, <code>Crossovers</code>. These allow two belts to cross one another. There are a couple ways that I could picture these working. Either like both at once (over and under) or merges (take turns)&mldr; but that&rsquo;s not how they work at all!</p><p>Before you use a <code>Crossover</code>, it looks like this:</p><p><img src=10-01-crossover.png alt="Screenshot showing a Open Crossover"></p><p>But as soon as a donut crosses it&mldr;</p><p><img src=10-01-crossover-used.png alt="Screenshot showing a Open Crossover"></p><p>Note the walls at the top and bottom. Basically, the first donut through a <code>Crossover</code> can go either way, but after that they must alternate. One going vertically and the next horizontally or vice versa.</p><p>This made implementation &mldr; interesting?</p><p>Here, for example is my initial <code>tickwise</code> implementation of a <code>Crossover</code> treating it like a merger:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -394,6 +398,7 @@ impl Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         struct TileState {
</span></span><span style=display:flex><span>             toppings: Option&lt;Toppings&gt;,
</span></span><span style=display:flex><span>             source: Option&lt;Point&gt;,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+            last_move: Direction,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             waiting_time: usize,
</span></span><span style=display:flex><span>             split_next_right: bool,
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -606,7 +611,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         // We have to be able to move onto the next entity
</span></span><span style=display:flex><span>                         if let Some(entity) = global.entities[p2.index(global.width)] {
</span></span><span style=display:flex><span>                             if !entity.can_enter(belt) {
</span></span><span style=display:flex><span><span style=color:#f92672>-                                    return Err(format!(
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                return Err(format!(
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                     &#34;Donut at {p:?} tried to move {belt:?} onto a {entity:?} but couldn&#39;t&#34;,
</span></span><span style=display:flex><span>                                 ));
</span></span><span style=display:flex><span>                             }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -684,6 +689,15 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                     source: state_at!(p).source.unwrap(),
</span></span><span style=display:flex><span>                                 });
</span></span><span style=display:flex><span>                             }
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Crossovers keep going in the same direction
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            EntityKind::Crossover =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    move_to: p + state_at!(p).last_move.into(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                });
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         }
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -769,6 +783,13 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     state_at!(u.move_to).toppings = Some(u.toppings);
</span></span><span style=display:flex><span>                     state_at!(u.move_to).source = Some(u.source);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                    match (u.move_to - u.move_from).try_into() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        Ok(d) =&gt; state_at!(u.move_to).last_move = d,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        Err(e) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            tracing::warn!(&#34;Invalid last_move update: {u:?}, error: {e}&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span></code></pre></div><p>Not much too it. And for the basic levels, it works. But after 2-3 you start getting a lot of more interesting timing issues. It gets&mldr; a bit more complicated after that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -394,13 +425,22 @@ impl Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>         let vec_size = global.width as usize * global.height as usize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+        #[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        enum CrossoverState {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            #[default]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Open,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Occupied(Direction),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            OpenHorizontal,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            OpenVertical,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         #[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]
</span></span><span style=display:flex><span>         struct TileState {
</span></span><span style=display:flex><span>             toppings: Option&lt;Toppings&gt;,
</span></span><span style=display:flex><span>             source: Option&lt;Point&gt;,
</span></span><span style=display:flex><span><span style=color:#f92672>-            last_move: Direction,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>             waiting_time: usize,
</span></span><span style=display:flex><span>             split_next_right: bool,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+            crossover_state: CrossoverState,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -690,19 +748,63 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 });
</span></span><span style=display:flex><span>                             }
</span></span><span style=display:flex><span>                             // Crossovers keep going in the same direction
</span></span><span style=display:flex><span><span style=color:#f92672>-                            EntityKind::Crossover =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    move_to: p + state_at!(p).last_move.into(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                });
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            EntityKind::Crossover =&gt; match state_at!(p).crossover_state {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                CrossoverState::Open
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                | CrossoverState::OpenHorizontal
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                | CrossoverState::OpenVertical =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    unreachable!(&#34;Donuts should not be able to move out of non-occupied crossovers&#34;)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                CrossoverState::Occupied(d) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        move_to: p + d.into(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    });
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            },
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         }
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+            // Filter out any updates that are moving the wrong way into/through crossovers
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            tracing::debug!(&#34;Before filter: {}&#34;, updates.len());
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            let updates = updates
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                .into_iter()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                .filter(|u| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        kind: EntityKind::Crossover,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        ..
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }) = global.entities[u.move_to.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        let d: Direction = match (u.move_to - u.move_from).try_into() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            Ok(d) =&gt; d,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            Err(_) =&gt; return false,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        };
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        match state_at!(u.move_to).crossover_state {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Open crossovers can always be moved into
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            CrossoverState::Open =&gt; true,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Occupied can never be moved into
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            CrossoverState::Occupied(_) =&gt; false,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Open horizontal/vertical must be moved into the correct way
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            CrossoverState::OpenHorizontal =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                d == Direction::Left || d == Direction::Right
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            CrossoverState::OpenVertical =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                d == Direction::Up || d == Direction::Down
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                .collect::&lt;Vec&lt;_&gt;&gt;();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            tracing::debug!(&#34;After filter: {}&#34;, updates.len());
</span></span></span></code></pre></div><p>And that&rsquo;s <em>still</em> not actually correct. This does handle the directionality of <code>Crossovers</code> but causes some other issues down the line for a level or two. But this is the basic idea (at least for <code>tickwise</code>): Each tile (with a <code>Crossover</code>) now has to also track what state it&rsquo;s in.</p><p>That also means that I can&rsquo;t actually use this implementation for the non-tickwise simulation, since it has no ability for different lines of donuts to interact. So even if we have the simplest case of two lines crossing&mldr;</p><p><img src=10-01-crossover.png alt="Screenshot showing a Open Crossover"></p><p>&mldr;we can&rsquo;t actually enforce that. So <code>simulate</code> still uses the &rsquo;technically incorrect but works for some levels&rsquo; version that you can just cross either way. Woot. Any levels that require the more specific behavior get the <code>:tickwise</code> flag.</p><p>That &mldr; was a fun one.</p><h3 id=fix-the-merge-tiebreaker>Fix the merge tiebreaker</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/ab583552db2e63f3e3a0296088b14b13f4d7363a target=_blank rel=noopener>Commit</a></li></ul><p>There are only a handlful of levels that this matters on (6/8, oh you crazy level you), but I did finally figure out how to correctly handle ties in merges:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                     // Sort, the longest waiting will end up first
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                    // On ties, the most frosted donut goes first
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     updates.sort_by(|(_, a), (_, b)| {
</span></span><span style=display:flex><span>                         state_at!(b.move_from)
</span></span><span style=display:flex><span>                             .waiting_time
</span></span><span style=display:flex><span>                             .cmp(&amp;state_at!(a.move_from).waiting_time)
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                            .then_with(|| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                state_at!(b.move_from)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .toppings
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .unwrap_or(Toppings::none())
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .bits
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .cmp(&amp;state_at!(a.move_from).toppings.unwrap_or(Toppings::none()).bits)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     });
</span></span></code></pre></div><p>We&rsquo;re still taking the longest waiting first, but once that has moved, we use the most toppings next, not some arbitrary choice (whatever we added first).</p><p>This is the first time I used the <code>thing.cmp(other).then_with(...)</code> API. That&rsquo;s a neat and fairly elegant way to do it.</p><h3 id=1many-teleporter>1:Many <code>Teleporter</code></h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/359216aa19672b03cfc541d3f0f4f430922cae76 target=_blank rel=noopener>Commit</a></li></ul><p>And you thought we were done with <code>Teleporters</code>.</p><p><img src=11-01-cloning.png alt="Screenshot showing a 1 to many teleporter and cloning behavior"></p><p>Yup. One donut comes in&mldr; two come out!</p><p><a href=https://en.wikipedia.org/wiki/Many%20worlds%20theory>Many worlds theory</a>?</p><p>In any case, this actually ends up being fairly straight forward to implement for both <code>simulate</code> because it actually resembles a <code>Splitter</code>.</p><p>For <code>simulate_tickwise</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-                            // Teleporter in tries to move to the teleporter out
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            // Teleporter in tries to move to each of the teleporter outs
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             // If we have an in, we have an out (according to the loading function)
</span></span><span style=display:flex><span><span style=color:#f92672>-                            EntityKind::TeleporterIn(id) =&gt; updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                move_to: global.teleporter_outs[id],
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            }),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            EntityKind::TeleporterIn(id) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                global.teleporter_outs[id].iter().for_each(|&amp;p_out| {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        move_to: p_out,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        toppings: state_at!(p).toppings.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        source: state_at!(p).source.unwrap(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                })
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            },
</span></span></span></code></pre></div><p>For <code>simulate</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -1112,8 +1099,23 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             continue &#39;each_donut;
</span></span><span style=display:flex><span>                         }
</span></span><span style=display:flex><span>                         EntityKind::TeleporterIn(id) =&gt; {
</span></span><span style=display:flex><span><span style=color:#f92672>-                            p = global.teleporter_outs[id];
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            continue &#39;simulation_tick;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            // Queue one new point for each teleporter out
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            for &amp;p_out in &amp;global.teleporter_outs[id] {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    kind: EntityKind::TeleporterOut(_),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    facing
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }) = global.entities[p_out.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    donuts.push((p_out, toppings, facing, visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    return Err(format!(
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                        &#34;Teleporter in at {p:?} tried to move to a non-teleporter out&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    ));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            // Do not follow this path any more
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            continue &#39;each_donut;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         }
</span></span></code></pre></div><p>Quick fix!</p><h3 id=simulate-loop-isnt-an-err><code>simulate</code> loop isn&rsquo;t an <code>Err</code></h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/27012336cd734e37892b8da687283ba9d5fd62a7 target=_blank rel=noopener>Commit</a></li></ul><p>This is actually another one of those that mostly worked&mldr; but shouldn&rsquo;t have.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                 if visited[toppings.bits][p.index(global.width)] {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    return Err(format!(&#34;Loop detected at {p:?}&#34;));
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    if donuts.is_empty() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        return Err(format!(&#34;Loop detected at {p:?}&#34;));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        tracing::warn!(&#34;Loop detected at {p:?}, but there are more donuts&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        continue &#39;each_donut;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span></code></pre></div><p>This is in the <code>simulate</code> source. As soon as we detected a loop on any branch, we would immediately bail out of the entire simulation, but that just means we don&rsquo;t need to simulate that loop any more (and it doesn&rsquo;t count as either <code>extras</code> or <code>deliveries</code>)&mldr;</p><p>But even that wasn&rsquo;t complete:</p><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/d458a0ce8aac2ec63a2d363f24cc42d89814f4e6 target=_blank rel=noopener>Commit</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                 if visited[toppings.bits][p.index(global.width)] {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                    tracing::info!(&#34;Loop detected at {p:?}, but there are more donuts&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     if donuts.is_empty() {
</span></span><span style=display:flex><span><span style=color:#f92672>-                        return Err(format!(&#34;Loop detected at {p:?}&#34;));
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                        break &#39;each_donut;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     } else {
</span></span><span style=display:flex><span><span style=color:#f92672>-                        tracing::warn!(&#34;Loop detected at {p:?}, but there are more donuts&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>                         continue &#39;each_donut;
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 } else {
</span></span></code></pre></div><p>It turns out, that&rsquo;s true <em>even</em> if everything is still looping. It&rsquo;s <em>okay to have donuts that are never delivered</em>, just so long as you make all of the deliveries on some other branch!</p><h3 id=anysource>AnySource</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/a29c095c0be2ab9d1b05afd5ceae9806a49ae1a2 target=_blank rel=noopener>Commit</a></li></ul><p>And finally we have world 12:</p><p><img src=12-01-anysource.png alt="Screenshot showing sources that deliver anything"></p><p>That&mldr; doesn&rsquo;t actually look any different?</p><p>Well, it turns out that for level 12, any <code>Source</code> is a new kind: <code>AnySource</code>. It doesn&rsquo;t deliver unfrosted donuts, but rather <em>any</em> of the five kinds of donuts we&rsquo;ve seen before (<a href=#toppings-rewrite>foreshadowing?</a>).</p><p>This took some fixing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+impl Toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn any_source_next(&amp;self) -&gt; Toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        if self.is_none() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Toppings::Frosting;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        } else if self.contains(Toppings::Cherries) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Toppings::none();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        } else if self.contains(Toppings::WhippedCream) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Toppings::Frosting | Toppings::Sprinkles | Toppings::WhippedCream | Toppings::Cherries;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        } else if self.contains(Toppings::Sprinkles) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Toppings::Frosting | Toppings::Sprinkles | Toppings::WhippedCream;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        } else if self.contains(Toppings::Frosting) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            return Toppings::Frosting | Toppings::Sprinkles;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        } else {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            unreachable!(&#34;Invalid state&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
</span></span><span style=display:flex><span> enum EntityKind {
</span></span><span style=display:flex><span>     Block,
</span></span><span style=display:flex><span>     Source,
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    AnySource,
</span></span></span></code></pre></div><p>Mostly, the <code>any_source_next</code> will loop through the possibilities, but getting that order was kind of annoying (<a href=#toppings-rewrite>foreshadowing!</a>).</p><p>For <code>simulate_tickwise</code>, we have to track one more piece of <code>state</code>: <code>any_source_state</code>. Then each time we spawn one, we spawn the next one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                    // AnySources update sequentially
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        kind: EntityKind::AnySource,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        facing,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }) = global.entities[p.index(global.width)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        let next_toppings = state_at!(p).any_source_state;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        updates.push(Update {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            move_from: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            move_to: p + facing.into(),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            toppings: next_toppings,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            source: p,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        });
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        state_at!(p).any_source_state = next_toppings.any_source_next();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        continue &#39;next_point;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span></code></pre></div><p>For simulate, we just create five donuts, one of each kind:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+                // AnySource starts one for each type
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                if let Some(Entity {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    kind: EntityKind::AnySource,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    facing,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }) = global.entities[index]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    let mut any_source_state = Toppings::none();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    loop {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        donuts.push((p, any_source_state, facing, visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        any_source_state = any_source_state.any_source_next();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        if any_source_state == Toppings::none() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                            break;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                }
</span></span></span></code></pre></div><p>And that mostly works, but man that was ugly&mldr;</p><h3 id=toppings-rewrite>Toppings rewrite</h3><ul><li><a href=https://github.com/jpverkamp/rust-solvers/commit/24ae2b85830fe672ed296e3b979bf9fc709e7717 target=_blank rel=noopener>Commit</a></li></ul><p>So&mldr; I finally got around to fixing <code>Toppings</code>. I originally did mention that I thought we could have any type&mldr; but that was never true. We only ever care about the top&mldr; topping?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-use bitmask_enum::bitmask;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span> use itertools::Itertools;
</span></span><span style=display:flex><span> use solver::{Direction, Point, Solver, State};
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-#[bitmask]
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, PartialOrd, Ord)]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> enum Toppings {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    #[default]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    None,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     Frosting,
</span></span><span style=display:flex><span>     Sprinkles,
</span></span><span style=display:flex><span>     WhippedCream,
</span></span><span style=display:flex><span>     Cherries,
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-impl Default for Toppings {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    fn default() -&gt; Self {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        Self::none()
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+impl Toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn any_source_next(&amp;self) -&gt; Toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        match self {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::None =&gt; Toppings::Frosting,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Frosting =&gt; Toppings::Sprinkles,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Sprinkles =&gt; Toppings::WhippedCream,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::WhippedCream =&gt; Toppings::Cherries,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Cherries =&gt; Toppings::None,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+impl From&lt;char&gt; for Toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn from(c: char) -&gt; Self {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        match c {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;0&#39; =&gt; Toppings::None,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;1&#39; =&gt; Toppings::Frosting,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;2&#39; | &#39;3&#39; =&gt; Toppings::Sprinkles,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;4&#39; | &#39;7&#39; =&gt; Toppings::WhippedCream,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            &#39;8&#39; | &#39;F&#39; | &#39;f&#39; =&gt; Toppings::Cherries,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            _ =&gt; panic!(&#34;Invalid topping: {c}&#34;),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> impl Toppings {
</span></span><span style=display:flex><span><span style=color:#f92672>-    fn any_source_next(&amp;self) -&gt; Toppings {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if self.is_none() {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            return Toppings::Frosting;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        } else if self.contains(Toppings::Cherries) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            return Toppings::none();
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        } else if self.contains(Toppings::WhippedCream) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            return Toppings::Frosting | Toppings::Sprinkles | Toppings::WhippedCream | Toppings::Cherries;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        } else if self.contains(Toppings::Sprinkles) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            return Toppings::Frosting | Toppings::Sprinkles | Toppings::WhippedCream;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        } else if self.contains(Toppings::Frosting) {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            return Toppings::Frosting | Toppings::Sprinkles;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        } else {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            unreachable!(&#34;Invalid state&#34;);
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    fn can_apply(&amp;self, other: Toppings) -&gt; bool {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        matches!(
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            (self, other),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            (Toppings::None, Toppings::Frosting)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            | (Toppings::Frosting, Toppings::Sprinkles)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            | (Toppings::Sprinkles, Toppings::WhippedCream)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            | (Toppings::WhippedCream, Toppings::Cherries)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        )
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn to_char(&amp;self) -&gt; char {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        match self {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::None =&gt; &#39;0&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Frosting =&gt; &#39;1&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Sprinkles =&gt; &#39;2&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::WhippedCream =&gt; &#39;4&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Cherries =&gt; &#39;8&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn all() -&gt; Vec&lt;Toppings&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        vec![
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::None,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Frosting,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Sprinkles,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::WhippedCream,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Cherries,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        ]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fn index(&amp;self) -&gt; usize {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        match self {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::None =&gt; 0,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Frosting =&gt; 1,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Sprinkles =&gt; 2,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::WhippedCream =&gt; 3,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            Toppings::Cherries =&gt; 4,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -70,8 +114,7 @@ impl TryFrom&lt;&amp;str&gt; for Entity {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>         fn top(c: char) -&gt; Result&lt;Toppings, String&gt; {
</span></span><span style=display:flex><span><span style=color:#f92672>-            let v = c.to_digit(16).ok_or(format!(&#34;Invalid topping: {c}&#34;))? as usize;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            Ok(v.into())
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            Ok(c.into())
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>         fn dir(c: char) -&gt; Result&lt;Direction, String&gt; {
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -97,7 +140,7 @@ impl TryFrom&lt;&amp;str&gt; for Entity {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>             // A target for donuts, first without any toppings
</span></span><span style=display:flex><span>             &amp;[&#39;-&#39;, facing] =&gt; Ok(Entity {
</span></span><span style=display:flex><span><span style=color:#f92672>-                kind: EntityKind::Target(Some(Toppings::none())),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                kind: EntityKind::Target(Some(Toppings::None)),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 facing: dir(facing)?,
</span></span><span style=display:flex><span>             }),
</span></span><span style=display:flex><span>             // Doesn&#39;t matter what toppings
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -250,11 +293,22 @@ impl From&lt;&amp;str&gt; for Global {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         line.split_whitespace()
</span></span><span style=display:flex><span>                             .skip(1)
</span></span><span style=display:flex><span>                             .map(|t| {
</span></span><span style=display:flex><span><span style=color:#f92672>-                                Some(
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    t.parse::&lt;usize&gt;()
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                        .expect(&#34;Invalid target, must be numeric&#34;)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                        .into(),
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                )
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                if t == &#34;F&#34; || t == &#34;f&#34; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    return Some(Toppings::Cherries);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                let v = t.parse::&lt;usize&gt;()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .expect(&#34;Invalid target, must be numeric&#34;)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .into();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                match v {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    0 =&gt; Some(Toppings::None),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    1 =&gt; Some(Toppings::Frosting),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    3 =&gt; Some(Toppings::Sprinkles),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    7 =&gt; Some(Toppings::WhippedCream),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    15 =&gt; Some(Toppings::Cherries),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    _ =&gt; panic!(&#34;Invalid target: {t}&#34;),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             })
</span></span><span style=display:flex><span>                             .collect::&lt;Vec&lt;_&gt;&gt;(),
</span></span><span style=display:flex><span>                     );
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -512,8 +566,7 @@ impl Local {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             // Map 2 shows the wait times (only for donuts)
</span></span><span style=display:flex><span>                             let p = Point { x, y };
</span></span><span style=display:flex><span>                             if let Some(toppings) = state_at!(p).toppings {
</span></span><span style=display:flex><span><span style=color:#f92672>-                                maps[1][p.index(global.width + 1)] =
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    toppings.bits.to_string().chars().next().unwrap();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                maps[1][p.index(global.width + 1)] = toppings.to_char();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span>                                 maps[2][p.index(global.width + 1)] = state_at!(p)
</span></span><span style=display:flex><span>                                     .waiting_time
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -633,7 +686,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         updates.push(Update {
</span></span><span style=display:flex><span>                             move_from: p,
</span></span><span style=display:flex><span>                             move_to: p + facing.into(),
</span></span><span style=display:flex><span><span style=color:#f92672>-                            toppings: Toppings::none(),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            toppings: Toppings::None,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             source: p,
</span></span><span style=display:flex><span>                         });
</span></span><span style=display:flex><span>                         continue &#39;next_point;
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -861,9 +914,8 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             .then_with(|| {
</span></span><span style=display:flex><span>                                 state_at!(b.move_from)
</span></span><span style=display:flex><span>                                     .toppings
</span></span><span style=display:flex><span><span style=color:#f92672>-                                    .unwrap_or(Toppings::none())
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    .bits
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    .cmp(&amp;state_at!(a.move_from).toppings.unwrap_or(Toppings::none()).bits)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                                    .unwrap_or(Toppings::None)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    .cmp(&amp;state_at!(a.move_from).toppings.unwrap_or(Toppings::None))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             })
</span></span><span style=display:flex><span>                     });
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -961,7 +1013,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     let p = Point { x, y };
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                     if let Some(Entity {
</span></span><span style=display:flex><span><span style=color:#f92672>-                        kind: EntityKind::Topper(topping),
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                        kind: EntityKind::Topper(new_topping),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         facing,
</span></span><span style=display:flex><span>                     }) = global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>                     {
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -971,11 +1023,9 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                         if let Some(state) = state.get_mut(p2.index(global.width)) {
</span></span><span style=display:flex><span><span style=color:#f92672>-                            if let Some(toppings) = state.toppings {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                // We have to have exactly all previous toppings; if so apply the new one
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                let must_have = Toppings::from(topping.bits() - 1);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                if toppings &amp; must_have == must_have {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                    state.toppings = Some(toppings | topping);
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            if let Some(current_toppings) = state.toppings {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                if current_toppings.can_apply(new_topping) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                    state.toppings = Some(new_topping)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                 }
</span></span><span style=display:flex><span>                             }
</span></span><span style=display:flex><span>                         }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1027,7 +1077,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>         // Now we actually have to simulate each source
</span></span><span style=display:flex><span>         let mut visited = vec![];
</span></span><span style=display:flex><span><span style=color:#f92672>-        for _ in 0..(Toppings::all_flags().bits + 1) {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        for _ in Toppings::all() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             visited.push(vec![false; global.width as usize * global.height as usize]);
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1036,7 +1086,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             for y in 0..global.height {
</span></span><span style=display:flex><span>                 let index = (y * global.width + x) as usize;
</span></span><span style=display:flex><span>                 let p = Point { x, y };
</span></span><span style=display:flex><span><span style=color:#f92672>-                let toppings = Toppings::none();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                let toppings = Toppings::None;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span>                 // Start a source here
</span></span><span style=display:flex><span>                 if let Some(Entity {
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1053,14 +1103,8 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     facing,
</span></span><span style=display:flex><span>                 }) = global.entities[index]
</span></span><span style=display:flex><span>                 {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    let mut any_source_state = Toppings::none();
</span></span></span><span style=display:flex><span><span style=color:#f92672>-
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                    loop {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                        donuts.push((p, any_source_state, facing, visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                        any_source_state = any_source_state.any_source_next();
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                        if any_source_state == Toppings::none() {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            break;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                        }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    for topping in Toppings::all() {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                        donuts.push((p, topping, facing, visited.clone()));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     }
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1080,7 +1124,7 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 ));
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-            visited[toppings.bits][p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            visited[toppings.index()][p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             let mut crossover_direction = initial_facing;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>             &#39;simulation_tick: while !matches!(
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1100,12 +1144,12 @@ Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     let mut maps = vec![inital_map.clone()];
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                     // The active donut
</span></span><span style=display:flex><span><span style=color:#f92672>-                    maps[0][p.index(global.width + 1)] = toppings.bits.to_string().chars().next().unwrap();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    maps[0][p.index(global.width + 1)] = toppings.to_char();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span>                     // All queued donuts
</span></span><span style=display:flex><span>                     for donut in donuts.iter() {
</span></span><span style=display:flex><span>                         maps.push(inital_map.clone());
</span></span><span style=display:flex><span><span style=color:#f92672>-                        maps.last_mut().unwrap()[donut.0.index(global.width + 1)] = donut.1.bits().to_string().chars().next().unwrap();
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                        maps.last_mut().unwrap()[donut.0.index(global.width + 1)] = donut.1.to_char();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                     // Convert each map into a string
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1151,25 +1195,11 @@ Delivered: {complete_donuts:?}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         facing,
</span></span><span style=display:flex><span>                     }) = global.entities[p2.index(global.width)]
</span></span><span style=display:flex><span>                     {
</span></span><span style=display:flex><span><span style=color:#f92672>-                        if top_d == facing {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            // Only add the toppings if we have all previous stoppings, otherwise ignore it
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            // I feel like this was frowned upon before 4/6, but so it goess bits set to add a new one
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            assert!(new_toppings.bits().count_ones() == 1);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            let must_have = Toppings::from(new_toppings.bits() - 1);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            if toppings &amp; must_have != must_have {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                continue;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            // Already applied, not an error but we don&#39;t want to trace it
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            if toppings | new_toppings == toppings {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                                continue;
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            }
</span></span></span><span style=display:flex><span><span style=color:#f92672>-
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                            // Add the new topping!
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                        if top_d == facing &amp;&amp; toppings.can_apply(new_toppings) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                             tracing::debug!(
</span></span><span style=display:flex><span>                                 &#34;Adding topping {new_toppings:?} from {p2:?} / {facing:?}&#34;
</span></span><span style=display:flex><span>                             );
</span></span><span style=display:flex><span><span style=color:#f92672>-                            toppings |= new_toppings;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                            toppings = new_toppings;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                         }
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1267,7 +1297,7 @@ Delivered: {complete_donuts:?}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     break; // Ran off the end of a belt
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-                if visited[toppings.bits][p.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                if visited[toppings.index()][p.index(global.width)] {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                     if donuts.is_empty() {
</span></span><span style=display:flex><span>                         tracing::info!(&#34;Loop detected at {p:?}, on the last donut&#34;);
</span></span><span style=display:flex><span>                         break &#39;each_donut;
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -1276,7 +1306,7 @@ Delivered: {complete_donuts:?}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         continue &#39;each_donut;
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 } else {
</span></span><span style=display:flex><span><span style=color:#f92672>-                    visited[toppings.bits][p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                    visited[toppings.index()][p.index(global.width)] = true;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                 }
</span></span><span style=display:flex><span>             }
</span></span></code></pre></div><p>&mldr; yeah. I could have done that a while ago. But better late (last?) than never?</p><h3 id=end-state>End state</h3><p>And&mldr; that&rsquo;s it. We&rsquo;ve solved all 12 worlds! Only a few more bits to handle:</p><h2 id=debugging-and-testing>Debugging and Testing</h2><h3 id=testing-with-macros>Testing (with macros!)</h3><p>First, testing! Once I got around to rewriting next states generation to use <code>simulate</code> / <code>simulate_tickwise</code>, I had a number of cases that weren&rsquo;t consistent between the two&mldr;</p><p>But we can test that!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>test_next_states! {
</span></span><span style=display:flex><span>    source,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    +&gt;  .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>,
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        ((<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>), [Up, Down, Right]),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_next_states! {
</span></span><span style=display:flex><span>    single_belt,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    +&gt;  ^   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .   .   .
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>,
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        ((<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>), [Up, Down, Left, Right]),
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Macros!</p><p>Basically, I want to provide just a map, a point where <code>next_states</code> should look and the possible directions&mldr; without having to rewrite all the boilerplate over and over again. I could wrap it into a function, but this is &mldr; even better? Even better!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> test_next_states_inner {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$source</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$expected_states</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initial stringify
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> global <span style=color:#f92672>=</span> Global::from(<span style=color:#75715e>$source</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> local <span style=color:#f92672>=</span> global.make_local();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> failures <span style=color:#f92672>=</span> vec![];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> local.next_states(<span style=color:#f92672>&amp;</span>global) {
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> failures.push(<span style=color:#e6db74>&#34;No next states found&#34;</span>.to_owned()),
</span></span><span style=display:flex><span>            Some(next_states) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> expected_len <span style=color:#f92672>=</span> <span style=color:#75715e>$expected_states</span>
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>(_, ds)<span style=color:#f92672>|</span> ds.len())
</span></span><span style=display:flex><span>                    .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> next_states.len() <span style=color:#f92672>!=</span> expected_len {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> next_states_stringy <span style=color:#f92672>=</span> next_states
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|</span>(_, _, state)<span style=color:#f92672>|</span> state.stringify(<span style=color:#f92672>&amp;</span>global))
</span></span><span style=display:flex><span>                        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>()
</span></span><span style=display:flex><span>                        .join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    failures.push(format!(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Expected </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> state(s), got </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                        expected_len,
</span></span><span style=display:flex><span>                        next_states.len(),
</span></span><span style=display:flex><span>                        next_states_stringy
</span></span><span style=display:flex><span>                    ));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> ((x, y), ds) <span style=color:#66d9ef>in</span> <span style=color:#75715e>$expected_states</span>.iter() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> i <span style=color:#f92672>=</span> (y <span style=color:#f92672>*</span> global.width <span style=color:#f92672>+</span> x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> d <span style=color:#66d9ef>in</span> ds.iter() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>next_states
</span></span><span style=display:flex><span>                            .iter()
</span></span><span style=display:flex><span>                            .any(<span style=color:#f92672>|</span>(_, _, state)<span style=color:#f92672>|</span> state.belts[i].is_some_and(<span style=color:#f92672>|</span>bd<span style=color:#f92672>|</span> bd <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>d))
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            failures.push(format!(
</span></span><span style=display:flex><span>                                <span style=color:#e6db74>&#34;(</span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{y}</span><span style=color:#e6db74>) + </span><span style=color:#e6db74>{d:?}</span><span style=color:#e6db74> not found&#34;</span>,
</span></span><span style=display:flex><span>                                x <span style=color:#f92672>=</span> x,
</span></span><span style=display:flex><span>                                y <span style=color:#f92672>=</span> y,
</span></span><span style=display:flex><span>                                d <span style=color:#f92672>=</span> d
</span></span><span style=display:flex><span>                            ));
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>failures.is_empty() {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;Failures:&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> failure <span style=color:#66d9ef>in</span> failures {
</span></span><span style=display:flex><span>                println!(<span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, failure);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;Simulate results: </span><span style=color:#e6db74>{:#?}</span><span style=color:#e6db74>&#34;</span>, local.simulate(<span style=color:#f92672>&amp;</span>global));
</span></span><span style=display:flex><span>            println!(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Tickwise simulate results: </span><span style=color:#e6db74>{:#?}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                local.simulate_tickwise(<span style=color:#f92672>&amp;</span>global)
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            panic!();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> test_next_states {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$name</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$source</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$expected_states</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        paste::paste! {
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span>test_next_states_ <span style=color:#75715e>$name</span><span style=color:#f92672>&gt;</span>] () {
</span></span><span style=display:flex><span>                test_next_states_inner!(<span style=color:#75715e>$name</span>, <span style=color:#75715e>$source</span>, <span style=color:#75715e>$expected_states</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> [<span style=color:#f92672>&lt;</span>test_next_states_tickwise_ <span style=color:#75715e>$name</span><span style=color:#f92672>&gt;</span>] () {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> source <span style=color:#f92672>=</span> format!(<span style=color:#e6db74>&#34;:tickwise</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#75715e>$source</span>);
</span></span><span style=display:flex><span>                test_next_states_inner!(<span style=color:#75715e>$name</span>, source.as_str(), <span style=color:#75715e>$expected_states</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I don&rsquo;t know, I just think macros are neat. You really do need <code><a href=https://docs.rs//latest//><code></code></a></code>
though to generate multiple names. Other than that, we have testing for each new <code>Entity</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo test freshly_frosted_tests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>20</span> tests
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_bumper_loop ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_splitter_left ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_single_belt ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_non_matching_bumper ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_source ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_bumper_double_loop ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_teleporter ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_bumper ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_splitter_right ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_crossover ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_bumper ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_crossover ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_non_matching_bumper ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_single_belt ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_source ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_splitter_left ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_bumper_loop ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_splitter_right ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_teleporter ... ok
</span></span><span style=display:flex><span>test freshly_frosted_tests::test_next_states_tickwise_bumper_double_loop ... ok
</span></span></code></pre></div><p>Well&mldr; I got most of them?</p><h3 id=stepping-through-solutions>Stepping through solutions</h3><p>One thing that I ended up having to quite a lot (for both simulate functions) was stepping through the answers, making sure I could see the state of the function at any times. So I wrote some fairly neat (in my opinion) code to render that.</p><p>For example, if I have the (solved) version of</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ export FRESHLY_FROSTED_TRACE<span style=color:#f92672>=</span>true; export FRESHLY_FROSTED_STEP_TRACE<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> INFO freshly_frosted: Initial state:
</span></span><span style=display:flex><span>↓←+↓←
</span></span><span style=display:flex><span>↓╦→*↑
</span></span><span style=display:flex><span>↓↓*←-
</span></span><span style=display:flex><span>→*↑╣↑
</span></span><span style=display:flex><span>╠→→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: <span style=color:#f92672>===</span> Starting tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>Deliveries: <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>States seen: <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>max: 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Max waiting time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Maps <span style=color:#f92672>(</span>belts, toppings, waiting times, splitters<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>↓←+↓←   .....   .....   .....   .....
</span></span><span style=display:flex><span>↓╦→*↑   .....   .....   .....   ...*.
</span></span><span style=display:flex><span>↓↓*←-   .....   .....   .....   ..*..
</span></span><span style=display:flex><span>→*↑╣↑   .....   .....   .....   .*...
</span></span><span style=display:flex><span>╠→→→↑   .....   .....   .....   .....
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: <span style=color:#f92672>===</span> Starting tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>Deliveries: <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>States seen: <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>max: 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Max waiting time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Maps <span style=color:#f92672>(</span>belts, toppings, waiting times, splitters<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>↓←+↓←   .0...   .0...   .....   .....
</span></span><span style=display:flex><span>↓╦→*↑   .....   .....   .....   ...*.
</span></span><span style=display:flex><span>↓↓*←-   .....   .....   .....   ..*..
</span></span><span style=display:flex><span>→*↑╣↑   .....   .....   .....   .*...
</span></span><span style=display:flex><span>╠→→→↑   .....   .....   .....   .....
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... skipping to the end ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: Moved out of a crossover at Update <span style=color:#f92672>{</span> move_from: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>, move_to: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span>, toppings: Frosting, source: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span> with direction Up
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: <span style=color:#f92672>===</span> Starting tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>Deliveries: <span style=color:#f92672>{</span>Point <span style=color:#f92672>{</span> x: 4, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>: <span style=color:#f92672>{(</span>Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span>, WhippedCream<span style=color:#f92672>)}}</span>
</span></span><span style=display:flex><span>States seen: <span style=color:#ae81ff>51</span> <span style=color:#f92672>(</span>max: 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Max waiting time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Maps <span style=color:#f92672>(</span>belts, toppings, waiting times, splitters<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>↓←+↓←   00...   00...   .....   .....
</span></span><span style=display:flex><span>↓╦→*↑   0.1..   0.0..   .....   ...-.
</span></span><span style=display:flex><span>↓↓*←-   0...4   0...0   .....   ..-..
</span></span><span style=display:flex><span>→*↑╣↑   0...4   0...0   .....   .|...
</span></span><span style=display:flex><span>╠→→→↑   .....   .....   .....   .....
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: Moved into a crossover at Update <span style=color:#f92672>{</span> move_from: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span>, move_to: Point <span style=color:#f92672>{</span> x: 3, y: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span>, toppings: Frosting, source: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span> with direction Right
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: <span style=color:#f92672>===</span> Starting tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>Deliveries: <span style=color:#f92672>{</span>Point <span style=color:#f92672>{</span> x: 4, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>: <span style=color:#f92672>{(</span>Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span>, WhippedCream<span style=color:#f92672>)}}</span>
</span></span><span style=display:flex><span>States seen: <span style=color:#ae81ff>52</span> <span style=color:#f92672>(</span>max: 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Max waiting time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Maps <span style=color:#f92672>(</span>belts, toppings, waiting times, splitters<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>↓←+↓←   00...   00...   .....   .....
</span></span><span style=display:flex><span>↓╦→*↑   0..1.   0..0.   .....   ...&gt;.
</span></span><span style=display:flex><span>↓↓*←-   0...4   0...0   .....   ..-..
</span></span><span style=display:flex><span>→*↑╣↑   0....   0....   .....   .|...
</span></span><span style=display:flex><span>╠→→→↑   .....   .....   .....   .....
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: Loop detected <span style=color:#f92672>(</span>threshold<span style=color:#f92672>=</span>1<span style=color:#f92672>)</span>, breaking
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: Deliveries are: <span style=color:#f92672>{</span>Point <span style=color:#f92672>{</span> x: 4, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>: <span style=color:#f92672>{(</span>Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span>, WhippedCream<span style=color:#f92672>)}}</span>
</span></span><span style=display:flex><span> INFO is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>:simulate_tickwise: freshly_frosted: <span style=color:#66d9ef>return</span><span style=color:#f92672>=</span>Ok<span style=color:#f92672>(</span>SimulateTickwiseResult <span style=color:#f92672>{</span> deliveries: <span style=color:#f92672>{</span>Point <span style=color:#f92672>{</span> x: 4, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>: <span style=color:#f92672>{(</span>Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span>, WhippedCream<span style=color:#f92672>)}}</span>, extras: <span style=color:#f92672>[]</span> <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>: freshly_frosted: Simulation result: SimulateTickwiseResult <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    deliveries: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Point <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            x: 4,
</span></span><span style=display:flex><span>            y: 2,
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                Point <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    x: 2,
</span></span><span style=display:flex><span>                    y: 0,
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>                WhippedCream,
</span></span><span style=display:flex><span>            <span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>    extras: <span style=color:#f92672>[]</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> INFO is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓←.↓←↓.→.↑↓↓.←.→.↑.↑.→→→↑<span style=color:#f92672>}</span>: freshly_frosted: <span style=color:#66d9ef>return</span><span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>↓←+↓←
</span></span><span style=display:flex><span>↓╦→*↑
</span></span><span style=display:flex><span>↓↓*←-
</span></span><span style=display:flex><span>→*↑╣↑
</span></span><span style=display:flex><span>╠→→→↑
</span></span></code></pre></div><p>As mentioned, we have the entire map there in five parts across (I didn&rsquo;t update the comment): First the original map, then the current toppings, then how long we&rsquo;ve been waiting, then the state of any splitters (none in this level) and crossovers.</p><p>The implementation of that&mldr; I think was pretty interesting.</p><p>Basically, I generate the initial map (as chars), copy it for the five maps, set each character, combine each into a string, split on lines, and then combine each line down the list:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Debugging ticking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> tracing_enabled <span style=color:#f92672>&amp;&amp;</span> step_tracing_enabled {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> initial_map <span style=color:#f92672>=</span> self.stringify(global).chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> maps <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        initial_map.clone(), <span style=color:#75715e>// Map 0: Default
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        initial_map.clone(), <span style=color:#75715e>// Map 1: Current toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        initial_map.clone(), <span style=color:#75715e>// Map 2: Waiting times
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        initial_map.clone(), <span style=color:#75715e>// Map 3: Splitters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        initial_map.clone(), <span style=color:#75715e>// Map 4: Crossovers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.width {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map 0 does nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map 1 shows the toppings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Map 2 shows the wait times (only for donuts)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(toppings) <span style=color:#f92672>=</span> state_at!(p).toppings {
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>1</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> toppings.to_char();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>2</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> state_at!(p)
</span></span><span style=display:flex><span>                    .waiting_time
</span></span><span style=display:flex><span>                    .to_string()
</span></span><span style=display:flex><span>                    .chars()
</span></span><span style=display:flex><span>                    .next()
</span></span><span style=display:flex><span>                    .unwrap();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>1</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>2</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map 3 shows current splitter state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Splitter,
</span></span><span style=display:flex><span>                <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>            }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> state_at!(p).split_next_right {
</span></span><span style=display:flex><span>                    maps[<span style=color:#ae81ff>3</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;R&#39;</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    maps[<span style=color:#ae81ff>3</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;L&#39;</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>3</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map 4 shows current crossover state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(Entity {
</span></span><span style=display:flex><span>                kind: <span style=color:#a6e22e>EntityKind</span>::Crossover,
</span></span><span style=display:flex><span>                <span style=color:#f92672>..</span>
</span></span><span style=display:flex><span>            }) <span style=color:#f92672>=</span> global.entities[p.index(global.width)]
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>4</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> state_at!(p).crossover_state
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    CrossoverState::Open <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;*&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::Occupied(Direction::Up) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;^&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::Occupied(Direction::Down) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;v&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::Occupied(Direction::Left) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;&lt;&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::Occupied(Direction::Right) <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;&gt;&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::OpenHorizontal <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;-&#39;</span>,
</span></span><span style=display:flex><span>                    CrossoverState::OpenVertical <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;|&#39;</span>,
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                maps[<span style=color:#ae81ff>4</span>][p.index(global.width <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We want to render them side by side
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert into a string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> maps <span style=color:#f92672>=</span> maps
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.iter().collect::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>())
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert into a list of lines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> maps <span style=color:#f92672>=</span> maps
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> m.split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>())
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Combine them line by line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> final_map <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>global.height {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> map <span style=color:#66d9ef>in</span> maps.iter() {
</span></span><span style=display:flex><span>            final_map.push_str(map[y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>]);
</span></span><span style=display:flex><span>            final_map.push_str(<span style=color:#e6db74>&#34;   &#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        final_map.push(<span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cache_size <span style=color:#f92672>=</span> states_seen.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> max_cache_value <span style=color:#f92672>=</span> states_seen.values().max().unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tracing::debug!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>=== Starting tick ===
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Deliveries: {deliveries:?}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>States seen: {cache_size} (max: {max_cache_value})
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Max waiting time: {max_waiting_time}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Maps (belts, toppings, waiting times, splitters):
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{final_map}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s a reason I guarded that by an environment variable. 😄</p><p>I have the same for non-tickwise simulations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat data/freshly-frosted/11-winter-snow/04-solved.txt | RUST_LOG<span style=color:#f92672>=</span>debug cargo run --release --bin freshly-frosted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> INFO freshly_frosted: Initial state:
</span></span><span style=display:flex><span>↓+◐↓..
</span></span><span style=display:flex><span>↓←←←↓←
</span></span><span style=display:flex><span>↓╩○◓-↑
</span></span><span style=display:flex><span>→→↑→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓..↓..↓←←←↓←↓....↑→→↑→→↑<span style=color:#f92672>}</span>: freshly_frosted: Running simulation
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓..↓..↓←←←↓←↓....↑→→↑→→↑<span style=color:#f92672>}</span>: freshly_frosted:
</span></span><span style=display:flex><span>↓+◐↓..
</span></span><span style=display:flex><span>↓←←←↓←
</span></span><span style=display:flex><span>↓╩○◓-↑
</span></span><span style=display:flex><span>→→↑→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓..↓..↓←←←↓←↓....↑→→↑→→↑<span style=color:#f92672>}</span>:simulate:Simulating donut<span style=color:#f92672>{</span>p<span style=color:#f92672>=</span>Point <span style=color:#f92672>{</span> x: 1, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span> t<span style=color:#f92672>=</span>None f<span style=color:#f92672>=</span>Left<span style=color:#f92672>}</span>: freshly_frosted: <span style=color:#f92672>===</span> Tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>0+◐↓..
</span></span><span style=display:flex><span>↓←←←↓←
</span></span><span style=display:flex><span>↓╩○◓-↑
</span></span><span style=display:flex><span>→→↑→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... snip ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓..↓..↓←←←↓←↓....↑→→↑→→↑<span style=color:#f92672>}</span>:simulate:Simulating donut<span style=color:#f92672>{</span>p<span style=color:#f92672>=</span>Point <span style=color:#f92672>{</span> x: 1, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span> t<span style=color:#f92672>=</span>None f<span style=color:#f92672>=</span>Left<span style=color:#f92672>}</span>: freshly_frosted: <span style=color:#f92672>===</span> Tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>↓+◐↓..
</span></span><span style=display:flex><span>↓←←←↓←
</span></span><span style=display:flex><span>↓╩0◓-↑
</span></span><span style=display:flex><span>→→↑→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Point: Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Toppings: None
</span></span><span style=display:flex><span>Facing: Up
</span></span><span style=display:flex><span>Queue: <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>Delivered: <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEBUG is_solved<span style=color:#f92672>{</span>belts<span style=color:#f92672>=</span>↓..↓..↓←←←↓←↓....↑→→↑→→↑<span style=color:#f92672>}</span>:simulate:Simulating donut<span style=color:#f92672>{</span>p<span style=color:#f92672>=</span>Point <span style=color:#f92672>{</span> x: 3, y: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span> t<span style=color:#f92672>=</span>None f<span style=color:#f92672>=</span>Down<span style=color:#f92672>}</span>: freshly_frosted: <span style=color:#f92672>===</span> Tick <span style=color:#f92672>===</span>
</span></span><span style=display:flex><span>↓+◐↓..   ↓+0↓..
</span></span><span style=display:flex><span>↓←←←↓←   ↓←←←↓←
</span></span><span style=display:flex><span>↓╩○◓-↑   ↓╩○◓-↑
</span></span><span style=display:flex><span>→→↑0→↑   →→↑→→↑
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Point: Point <span style=color:#f92672>{</span> x: 3, y: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Toppings: None
</span></span><span style=display:flex><span>Facing: Down
</span></span><span style=display:flex><span>Queue: <span style=color:#f92672>[(</span>Point <span style=color:#f92672>{</span> x: 2, y: <span style=color:#ae81ff>0</span> <span style=color:#f92672>}</span>, None, Right<span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>Delivered: <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... snip ...</span>
</span></span></code></pre></div><p>This time, we don&rsquo;t have as much state to track (since we instead branch on things like <code>Splitter</code> and mostly ignore <code>Crossover</code>).</p><p>Instead, we have one map for each currently queued state. So in that last state tehre, we go through a teleporter and now we have two: one in the bottom center and the other top center.</p><p>Pretty cool!</p><p>And that&rsquo;s it. Freshly Frosted. Solved.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>