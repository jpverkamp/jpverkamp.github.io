<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-09-17T09:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>Invader Fractals</title><link href="http://blog.jverkamp.com/2014/09/17/invader-fractals" /><id>urn:uuid:15d5a345-5571-4706-dc96-ad512081f006</id><updated>2014-09-17T09:00:00Z</updated><summary type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<!--more-->
<p>Specifically, here's the algorithm that we want to use to build an invader fractal:</p>
<ol>
    <li>Generate an invader</li>
    <li>Within that image:
        <ul>
            <li>For each white pixel, stop</li>
            <li>For each black pixel, recur with a smaller invader</li>
        </ul>
    </li>
    <li>Once the invader is small enough, stop recurring</li>
</ol>
<p>Sounds straight forward enough, but what does that look like in code?</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal depth)
  (let loop ([depth depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= depth 1)
                #t
                (loop (- depth 1)))
            #f)))))</code></pre>
<p>That's actually a lot more concise than I first expected. In the end, we get exactly that nice nested structure we're looking for:</p>
<pre class="scheme"><code>&gt; (make-invader-fractal 2)
'#(#(#f #f #f #f #f #f #f)
   #(#f
     #(#(#f #f #f #f #f #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #t #f #f)
       #(#f #t #t #f #f #t #f)
       #(#f #f #f #f #t #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #f #f #f))
     #f
     #(#(#f #f #f #f #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #t #t #f #f #f)
       #(#f #f #f #t #t #f #f)
       #(#f #f #t #t #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #f #f #f #f #f))
     #f
...
     #f
     #f
     #f)
   #(#f #f #f #f #f #f #f))
&gt;</code></pre>
<p>We could probably do away with representing the margins (the outermost layer is always going to be <code>#f</code>), but at the moment it makes the code easier to reason about.</p>
<p>Okay, next we need the rendering function:</p>
<pre class="scheme"><code>; Render an invader fractal as defined above
; Crop off the margin on the outmost layer
; Final size will be 5*7^{depth-1}
(define (render-invader-fractal fi)
  (define depth
    (let loop ([fi fi])
      (cond
        [(boolean? fi) 0]
        [else
         (+ 1 (for*/fold ([deepest 0]) ([col (in-vector fi)]
                                        [el (in-vector col)])
                (max (loop el) deepest)))])))

  (define size (expt 7 depth))

  (flomap-&gt;bitmap
   (flomap-crop
    (build-flomap*
     1 size size
     (Î» (x y)
       (let loop ([t 0] [l 0] [s size] [fi fi])
         (cond
           [(eq? fi #t) '#(0.0)]
           [(eq? fi #f) '#(1.0)]
           [else
            ; xi and yi are the points within the current level invader
            (define xi (quotient (* 7 (- x l)) s))
            (define yi (quotient (* 7 (- y t)) s))
            (loop (+ t (* yi (/ s 7)))
                  (+ l (* xi (/ s 7)))
                  (/ s 7)
                  (vector-ref (vector-ref fi xi) yi))]))))
    (* size 5/7)
    (* size 5/7)
    1/2
    1/2)))</code></pre>
<p>Unfortunately, that first bit is a little bit hacky. Since we've split apart the functions that create and render this fractal, we don't know how large of an image to make. Still, it's quick enough to calculate. Then, we get into actually making the image. It's much the same as the code in <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. We recur down, keeping two different sets of coordinates: image coorcinates <code>x</code>, <code>y</code>, <code>t</code>, <code>l</code>, and <code>s</code> and then coordinates within the current level <code>xi</code> and <code>yi</code>. There is a lot of dividing and multiplying by that <a href="https://en.wikipedia.org/wiki/magic_number">magic number</a>, but os it goes.</p>
<p>And that's really it. There's a call to <code><a href="http://docs.racket-lang.org/search/index.html?q=flomap-crop">flomap-crop</a></code>, but that's just to cut off the outermost margin (since it will (1) always be empty and (2) the second level's margin will still include some spacing). So how does it look?</p>
<pre class="scheme"><code> &gt; (render-invader-fractal (make-invader-fractal 3)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<p>That's about it. One more trick that I want to do though is to make these reproducable. That we can do some neat tricks with zooming in:</p>
<pre class="scheme"><code>(define-syntax-rule (with-seed seed body* ...)
  (parameterize ([current-pseudo-random-generator
                  (make-pseudo-random-generator)])
    (random-seed seed)
    body* ...))

(define (invader-fractal i depth)
  (with-seed i
    (render-invader-fractal (make-invader-fractal depth))))</code></pre>
<p>Because we reset the random seed at the beginning of the calculate and always generate the random numbers from top to bottom, we ned up with some neat effects. The top level with the same seed is always the same shape:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 8675309 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png" /></a> <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>:)</p>
<p>Unfortunately, the lower levels aren't the same pattern, since we're generating the images using a <a href="https://en.wikipedia.org/wiki/depth_first search">depth first search</a> rather than the <a href="https://en.wikipedia.org/wiki/breadth_first search">breadth first search</a>. More specifically, we're generating the invaders in this order:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png" /></a></p>
<p>In that case, the ordering is: generate the image for the given level, then the first subimage, then the first subimage of that. Generating the <em>depth first</em> as it were. What we want instead is to generate generate the top level, then all of the next level, then all of the next level, more like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png" /></a></p>
<p>Unfortunately, that doesn't work out well in our specific code, since we're working recursively, working with a <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">stack</a> (implicitly via function calls). To do a breadth first search, we would need instead to create a explicit <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">queue</a>, which would require some fairly major refactoring.</p>
<p>There's another option though:</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal/seeded seed depth)
  (define (mod-random-seed! i)
    (random-seed (+ 1 (remainder i 2147483646))))

  (mod-random-seed! seed)
  (let loop ([d depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= d 1)
                #t
                (begin
                  (mod-random-seed! (+ (* (- depth d) 49) (* x 7) y seed))
                  (loop (- d 1))))
            #f)))))

(define (invader-fractal seed depth)
  (render-invader-fractal (make-invader-fractal/seeded seed depth)))</code></pre>
<p>With the addition of <code>mod-random-seed!</code>, we can set the seed at each level. And we've got the amusing notion of non-random random seeds. :) But since they're generated as a function of the current <code>depth</code> and <code>x</code> and <code>y</code> coordinates of the parent image, we'll always get the same images at each level:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 42 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png" /></a></p>
<p>Now that's what I was looking for. :)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/invader-fractals.rkt">invader-fractals.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>
<p>Challenge: Make fractal invaders from invader fractals. Maybe later... O:)</p>]]></content></entry><entry><title>Fractal Invaders</title><link href="http://blog.jverkamp.com/2014/09/16/fractal-invaders" /><id>urn:uuid:3af088a6-d121-00ae-e2c8-a557bb1c42b3</id><updated>2014-09-16T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<!--more-->
<p>But before we get to that image, let's start with where I was Sunday. We had something that looked like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png" /></a></p>
<p>That was my first take at a fractal invader algorithm, and in that case there really wasn't anything to do with fractals at all. The basic algorithm for that was simple:</p>
<ol>
  <li>Choose a random location and size for an invader</li>
  <li>If the new invader does not collide with any previous invader, place it</li>
  <li>Go to step 1</li>
</ol>
<p>If we failed 100 times in a row to place an invader, we made the assumption that the space was empty and bailed out. It actually worked well enough. You got to see a bunch of invaders of different sizes, all together on the map. Unfortunately though, it didn't work particularly well for filling the entire space, which is really what I was after. (If you'd like you can see the code for that on GitHub in Sunday's code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a>).</p>
<p>After that though, I took a step back. How can we actually fill the space? More specifically, how can we use recursion / fractals to efficiently fill the space? Well, what we really need is actually really similar to another previous post of mine: <a href="http://blog.jverkamp.com/2014/05/28/quadtree-image-compression">Quadtree image compression</a>.</p>
<p>Basically, here's the new algorithm:</p>
<ol>
  <li>Given a rectangular region, choose a random location and size for an invader</li>
  <li>Recursively divide the remaining space into four sections: one above, one to the right, one below, and one to the left of the new invader</li>
  <li>If any region is small enough for only a single invader, place it and stop (base case)</li>
  <li>For each other region, start again at step 1</li>
</ol>
<p>The main odd step there is step 2 above. How can we split a region into five subregions (the center being square) like that? Well, we could do something like this:</p>
<pre class="text"><code>      | R
      | i
 Top  | g
______| h
   |  | t
 L |__|____
 e |
 f | Bottom
 t |</code></pre>
<p>Making sure that you have all of the regions set up exactly right gets a little bit complicated, but if you draw a nice diagram, it should be fairly straight forward to make sure that you always generate this structure. And that's exactly what we have here:</p>
<pre class="scheme"><code>(struct rect (t l w h) #:transparent)
(struct node (bounds value-bounds value children) #:transparent)

; Create the recursive fractal structure
(define (made-fractal width height random-node)
  (let loop ([t 0] [l 0] [w width] [h height])
    (cond
      ; The next node is too small, do not place it
      [(or (&lt;= w 0) (&lt;= h 0) (&gt;= t height) (&gt;= l width))
       #f]
      ; Create a child node; recur four times as so:
      ;  T  |
      ; __  |
      ;   XX R
      ; L XX__
      ;   |
      ;   | B
      [else
       (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
       (define x (if (= w s)         0 (random (- w s))))
       (define y (if (= h s)         0 (random (- h s))))
       (node (rect t       l       w h) ; Bounds of this node
             (rect (+ t y) (+ l x) s s) ; Bounds of the value within this node
             (random-node)              ; The value of this node
             (list (loop t         l         (+ x s)   y        )
                   (loop t         (+ l x s) (- w x s) (+ y s)  )
                   (loop (+ t y s) (+ l x)   (- w x)   (- h y s))
                   (loop (+ t y)   l         x         (- h y)  )))])))</code></pre>
<p>Essentially, we want to create a nested structure made out of <code>node</code> structs. For each node, we have two bounding boxes, one for the entire recursive structure and one just for the central image (which in turn defines the four children). Then we have a value which I've already parameterized here as the <code>random-node</code> parameter and finally four children (ordered top, right, bottom, left, although it really doesn't matter).</p>
<p>What's neat about this is that the exact same code could theoretically be used for other structures. Say if we wanted 8 children for each of the orthagonal or diagonal directions. Just add more to the <code>node-children</code> list.</p>
<p>There are a few edge cases to watch out for that I did spend rather a while working out. For example, the base case deals with cases where either <code>w</code> or <code>h</code> is less than zero, but it also deals when we go off the right or bottom edge of the region. Likewise, we have to check if we only have exactly 1 square left in either width or height (which would mean we cannot generate an interesting random size) or if we only have exactly enough room for one shape.</p>
<p>After that, it's just a matter of getting the parameters right for the recursive calls. Let's try one out:</p>
<pre class="scheme"><code>&gt; (make-fractal 4 3 (const #t))
(node
 (rect 0 0 4 3)
 (rect 0 0 3 3)
 #t
 (list
  #f
  (node
   (rect 0 3 1 3)
   (rect 1 3 1 1)
   #t
   (list
    (node (rect 0 3 1 1) (rect 0 3 1 1) #t '(#f #f #f #f))
    #f
    (node (rect 2 3 1 1) (rect 2 3 1 1) #t '(#f #f #f #f))
    #f))
  #f
  #f))</code></pre>
<p>If you take each of those in order, you have the regions:</p>
<pre class="text"><code>AAAB
AAAC
AAAD</code></pre>
<p>So we generated a 3x3 region first and then filled in the rest with 1x1s. Of course that's not very nice to visualize. Let's make something a little prettier:</p>
<pre class="scheme"><code>(define (in? bounds x y)
  (match-define (rect t l w h) bounds)
  (and (&lt;= l x (+ l w -1))
       (&lt;= t y (+ t h -1))))

; Render a fractal image
(define (fractal-image
         width height
         #:random-color [random-color (thunk (vector (random) (random) (random)))])

  (define root (make-fractal width height random-color))

  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (Î» (x y)
      (let loop ([node root])
        (cond
          [(in? (node-value-bounds node) x y) (node-value node)]
          [else
           (for*/first ([child (in-list (node-children node))]
                        #:when (and child (in? (node-bounds child) x y)))
             (loop child))]))))))</code></pre>
<p>That's surprisingly simple, but then again most of the work was already done in setting up the structure. The most complicated bit here is that we have two different usages of the <code>in?</code> function:</p>
<ul>
  <li><code>(in? (node-value-bounds node) x y)</code> - checks if the current point is in the current node's value box (the inner box); if that's the case, this is our base case</li>
  <li><code>(in? (node-bounds child) x y)</code> - if this is true for any of the child node's outer box; if that's true we know that our value is somewhere in that subtree</li>
</ul>
<p>That's all we need to make some pretty neat images, just changing how we generate colors:</p>
<pre class="scheme"><code>&gt; (fractal-image 200 200)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200 #:random-color (thunk (let ([g (random)]) (vector g g g))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200
                 #:random-color (thunk
                                  (case (random 3)
                                    [(0) (vector (random) 0 0)]
                                    [(1) (vector 0 (random) 0)]
                                    [(2) (vector 0 0 (random))])))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png" /></a></p>
<p>Which, honestly, would be a pretty neat post all by itself. But wasn't the entire point of this to made a fractal out of the <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">procedural invaders</a>?</p>
<pre class="scheme"><code>; Render a fractal image made of invaders!
(define (fractal-invaders width height #:highlights? [highlights? #f])
  (define (random-invader)
    (flomap-add-margin
     (if highlights?
         (procedural-invader/highlight (random 524288))
         (procedural-invader (random 32768)))
     1))

  (define root (make-fractal (quotient width 7)
                             (quotient height 7)
                             random-invader))

  (flomap-&gt;bitmap
   (build-flomap*
    (if highlights? 3 1) width height
    (Î» (x y)
      ; Correct for coordinates within the node
      (define nx (quotient x 7))
      (define ny (quotient y 7))

      (let loop ([n root])
        (cond
          [(in? (node-value-bounds n) nx ny)
           ; Calculate coordinates within the image
           (match-define (node _ (rect t l s _) img _) n)
           (define ix (quotient (- x (* 7 l)) s))
           (define iy (quotient (- y (* 7 t)) s))
           (flomap-ref* img ix iy)]
          [else
           (or
            (for*/first ([child (in-list (node-children n))]
                         #:when (and child (in? (node-bounds child) nx ny)))
              (loop child))
            (if highlights? '#(1 1 1) '#(1)))]))))))</code></pre>
<p>Okay, this code isn't quite as nice. Mostly, that's because of a simplifying requirement that I started with: we're going to be working with a grid where each 'pixel' is a single minimal size invader. With a 1 pixel margin, that means that our minimum image size is 7x7 (thus the 7s scattered throughout the code).</p>
<p>Unfortunately, that does make our base case a little more complicated, since we're working with two different coordinate systems: image coordinates <code>x</code> and <code>y</code> and fractal coordinates <code>nx</code> and <code>ny</code>. Still, add in some offsets by 7 and a bit of padding down at the end (for images not divisible by 7) and off we go:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<p>It also works great for larger images:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png" /></a></p>
<p>It even supports highlights:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png" /></a></p>
<p>Now that's what I'm talking about. Unfortunately, the process is still somewhat random:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png" /></a></p>
<p>Sometimes the first random image is a little on the annoyingly large size. Off the top of my head, there are two ways to deal with it: either add an option parameter that controls the maximum size of a block or just keep generating images until you get what you are looking for.</p>
<p>Guess which solution I prefer? :)</p>
<pre class="scheme"><code>(define (fractal-invaders ... #:maximum-invader-size [max-size #f])
  ...
  (define root
    (make-fractal
     (quotient width 7)
     (quotient height 7)
     random-invader
     #:maximum-block-size (and max-size (/ max-size 7))))
  ...)

(define (make-fractal width height random-node #:maximum-block-size [max-size #f])
  ...
      [else
       (define s
         (let loop ()
           (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
           (cond
             [(or (not max-size) (&lt; s max-size)) s]
             [else (loop)])))
       ...])</code></pre>
<p>Simple!</p>
<pre class="scheme"><code>&gt; (fractal-invaders 400 200 #:highlights? #t #:maximum-invader-size 25)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png" /></a></p>
<p>Beautiful!</p>
<p>I wonder what other sort of images I could make with a fractal space filling algorithm like this? O:)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/fractal-invaders.rkt">fractal-invaders.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>]]></content></entry><entry><title>Look and Say</title><link href="http://blog.jverkamp.com/2014/09/15/look-and-say" /><id>urn:uuid:eac2659f-3660-3f5e-9ba1-540308c23093</id><updated>2014-09-15T00:00:00Z</updated><summary type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
<!--more-->
<p>Originally, my interest in this came from a video on the excellent YouTube video series <a href="https://www.youtube.com/user/numberphile">Numberphile</a>:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/ea7lJkEhytA" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>Yes, that is <a href="https://en.wikipedia.org/wiki/John_Conway">John Conway</a> of <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. It's well worth the watch.</p>
<p>Then this morning, /r/dailyprogrammer has a post: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ggy30/9152014_challenge180_easy_looknsay/">Challenge #180 [Easy] Look'n'Say</a>. Seems like it's about time. :)</p>
<p>So how do we do it? Well, essentially we're going to want a function that can recur down a list of, collecting groups of like numbers. So in the sequence <code>111221</code>, we want to collect that into <code>111 22 1</code>. Then we know how long each sequence is, <code>31 22 11</code>, which is the next number in the sequence. How's that look in code?</p>
<pre class="scheme"><code>; Create a look and see list by combining repeated values into count+number
; For example: 111221 becomes 3 1s, 2 2s, 1 1 =&gt; 312211
(define (look-and-say ls)
  (apply
   append
   (let count ([ls (rest ls)] [i 1] [v (first ls)])
     (cond
       [(null? ls)
        (list (list i v))]
       [(equal? (first ls) v)
        (count (rest ls) (+ i 1) v)]
       [else
        (list* (list i v) (count (rest ls) 1 (first ls)))]))))</code></pre>
<p>The counting function will recur down the list, collecting the current count (<code>i</code>) and value (<code>v</code>) as we go. Within that recursion, there are three cases. In the first case (<code>(null? ls)</code>), we've reached the end. This makes sure that we output the last sequence. In the second (<code>(equal? (first ls) v)</code>), we have a matching number, so increment the current sequence. In the last (<code>else</code>), the number do not match. Output the current count and start a new sequence.</p>
<p>Let's try it out:</p>
<pre class="scheme"><code>&gt; (look-and-say '(1))
'(1 1)
&gt; (look-and-say '(1 1))
'(2 1)
&gt; (look-and-say '(2 1))
'(1 2 1 1)
&gt; (look-and-say '(1 2 1 1))
'(1 1 1 2 2 1)</code></pre>
<p>Looks good. It's annoying to have to keep calling it like that though. What I'd really like to see is a Racket <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence">sequence</a></code>. Luckily, this is exactly the sort of thing we can make with <code><a href="http://docs.racket-lang.org/search/index.html?q=make-do-sequence">make-do-sequence</a></code>:</p>
<pre class="scheme"><code>; Make an infinite sequence that generates look-and-see lists
; Use the current look-and-say list itself as both the key and value
(define (in-look-and-say [ls '(1)])
  (make-do-sequence
   (thunk
    (values
     identity       ; Current
     look-and-say   ; Next
     ls             ; Initial
     (const #t)     ; Continue from this key/value/pair
     (const #t)
     (const #t)))))</code></pre>
<p>We're going to use the sequence itself as the 'count', which makes the first few arguments easy enough. Basically, we use <code>identity</code> to return the current value, and <code>look-and-say</code> (the function we just defined above) as the <code>next</code> function. The last three are easy as well. Since we want an infinite sequence: just always return <code>#t</code>. Done.</p>
<p>Given this, we can generate as long a seqence as we want:</p>
<pre class="scheme"><code>; Take the first chunk off of a sequence
(define (look-and-say* ls i)
  (for/list ([ls (in-look-and-say ls)]
             [_  (in-range i)])
    ls))</code></pre>
<p>Nice. :)</p>
<p>Or we can plot some interesting information about them, say the length:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say length '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png" /></a></p>
<p>Or the maximum value:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say (curry apply max) '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png" /></a></p>
<p>It's interesting how it never gets beyond 3 up to 50 steps along the sequence. Unfortunately</p>
<p>Last thing last, pretty pictures!</p>
<pre class="scheme"><code>; Render a look and say sequence to a bitmap, stretching rows to the entire width
; Note: Values are clamped to between 0.0 and 1.0 before conversion. *rolls eyes*
(define (render-look-and-say ls bound)
  ; Precalculate the image data; figuring out what dimenions will we need from that
  (define ls* (look-and-say* ls bound))
  (define height (length ls*))
  (define width (length (last ls*)))

  ; Precalculated list of colors that are defined to be more visually distinct
  (define colors
    '#(#(1.00 0.70 0.00) #(0.50 0.24 0.46) #(1.00 0.41 0.00) #(0.65 0.74 0.84) #(0.75 0.00 0.12)
       #(0.80 0.63 0.38) #(0.50 0.44 0.40) #(0.00 0.49 0.20) #(0.96 0.46 0.55) #(0.00 0.32 0.54)
       #(1.00 0.48 0.36) #(0.32 0.21 0.48) #(1.00 0.55 0.00) #(0.70 0.16 0.32) #(0.95 0.78 0.00)
       #(0.50 0.09 0.05) #(0.57 0.66 0.00) #(0.35 0.20 0.08) #(0.94 0.23 0.07) #(0.14 0.17 0.09)))

  ; Generate the image, three channels are RGB
  ; Note: 4 channels is ARGB, not RGBA *rolls eyes again*
  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (Î» (x y)
      ; Pull out the correct row for the data, normalize entries to 'stretch' over the entire row
      (define row (list-ref ls* y))
      (define row-width (length row))
      (define index (quotient (* x row-width) width))
      (displayln `(,x ,y ,index ,(list-ref row index) ,row))

      (vector-ref colors (list-ref row index))))))</code></pre>
<p>That will encode each iteration into a line of the resulting image and each different value into its own color. Something like this:</p>
<pre class="scheme"><code> &gt; (scale-to 200 200 (render-look-and-say '(1) 20)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png" /></a></p>
<p>Neat how there's a nice line right down the center. Although that makes sense, given that there are always an even number of values. On thing that I want to check out is those divisions that the video was talking about where two parts of a sequence can diverge and never interact again. Those would be fairly straight forward to find even, just 'tag' each part of the sequence with where it came from. Perhaps another day.</p>
<p>As always, code on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/look-and-say.rkt">look-and-say.rkt</a></p>
<p>As a side note, here's a neat trick:</p>
<pre class="scheme"><code>; Create a look and say sequence with regular expressions instead of lists
(define (look-and-say/regex str)
  (regexp-replace*
   #px"(.)(\\1*)"
   str
   (Î» (match block repeat) (~a (string-length match) block))))</code></pre>
<p>Regular expressions for the win! Of course, it's an order of magnitude slower than the list version, but it's still neat.</p>]]></content></entry><entry><title>Procedural Invaders</title><link href="http://blog.jverkamp.com/2014/09/14/procedural-invaders" /><id>urn:uuid:41ac4ba4-e097-9023-3504-488ff41b9a68</id><updated>2014-09-14T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<!--more-->
<p>Despite the fact that it's scaled up, on the lowest level we actually have a 5x5 grid of pixels. In addition, it's mirrored to make it symmetrical, so (counting the non-mirrored center row), we actually only have 15 pixels:</p>
<pre class="text"><code>+----+----+----+----+----+
|  1 |  6 | 11 |  6 |  1 |
+----+----+----+----+----+
|  2 |  7 | 12 |  7 |  2 |
+----+----+----+----+----+
|  3 |  8 | 13 |  8 |  3 |
+----+----+----+----+----+
|  4 |  9 | 14 |  9 |  4 |
+----+----+----+----+----+
|  5 | 10 | 15 | 10 |  5 |
+----+----+----+----+----+</code></pre>
<p>Represent those 15 pixels as a 15 bit number. For example, the above image, we have bits 2, 4, 6, 7, 8, 10, 13, and 15 set, so we have the number:</p>
<pre class="scheme"><code>&gt; #b010101110100101
11173</code></pre>
<p>Given that there are over 32 thousand 15 bit numbers (<span>\(2^{15}=32768\)</span>), that's a lot of invaders. So how do we generate them?</p>
<pre class="scheme"><code>; Create a symmetric 5x5 image similar to a space invader with this bit pattern
; 0 5 10 5 0
; 1 6 11 6 1
; 2 7 12 7 2
; 3 8 13 8 3
; 4 9 14 9 4
(define (procedural-invader i)
  (define bits
    (for/vector ([c (in-string (~a (number-&gt;string i 2) #:width 15 #:pad-string "0" #:align 'right))])
      (eq? c #\1)))

  (build-flomap*
   1 5 5
   (Î» (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (vector-ref bits i) '#(1.0) '#(0.0)))))</code></pre>
<p>There are really two parts here. First we covert the given integer into a vector of <code>#t</code> / <code>#f</code>. There are certainly far faster ways to do this (<code>bitwise-and</code> with the correct bit for example), but given that the size is set and small, this is good enough for the time being.</p>
<p>After that, we take those bits and use <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code> to create a 5x5 image where <code>#t</code> is white and <code>#f</code> is black. Shiny. Now unfortunately Dr. Racket will not display flomaps directly inline, but if we convert them to bitmaps it will:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (procedural-invader 11173))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png" /></a></p>
<p>Oof. Tiny. Let's make it bigger:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png" /></a></p>
<p>Well that's not what I was looking for. The problem is that flomaps by default are designed for interpolated values. So that if you have a black pixel right next to a white pixel, you can actually ask for the 'pixel' halfway between the two, getting a gray value. But in this case, that's not what we want. We want sharp (<a href="https://en.wikipedia.org/wiki/nearest_neighbor">nearest neighbor</a>) scaling:</p>
<pre class="scheme"><code>; Resize a flomap using nearest-neighbors to preserve sharp edges
(define (flomap-resize/nn img new-width [new-height new-width])
  (match-define (flomap _ components old-width old-height) img)

  (build-flomap*
   components new-width new-height
   (Î» (new-x new-y)
     (flomap-ref* img
                  (floor (* old-width (/ new-x new-width)))
                  (floor (* old-height (/ new-y new-height)))))))</code></pre>
<p>Same as before, we are creating a new image. But this time, we covert the old coordinate system to the new and throw away any of the decimal part, getting an exact answer. That way we never interpolate:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize/nn (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<p>Nice and sharp. That's exactly what we were looking for.</p>
<p>For the base of the problem, that's pretty much it. But we're not quite done. What if we want to make a nice display mode so that we can see a bunch of them at once?</p>
<pre class="scheme"><code>; Generate a demo shee\t of procedural invaders
(define (demo [rows 5] [cols rows] #:image-size [image-size 20] #:margins [margins 5])
  (define images
    (for/list ([row (in-range rows)])
      (for/list ([col (in-range cols)])
        (define r (random 32768))
        (define img (procedural-invader r))
        (flomap-&gt;bitmap (flomap-add-margin (flomap-resize/nn img image-size) margins)))))

  (cond
    [(and (= rows 1) (= cols 1))
     (caar images)]
    [(= rows 1)
     (car (map (curry apply beside) images))]
    [(= cols 1)
     (apply above (map car images))]
    [else
     (apply above (map (curry apply beside) images))]))</code></pre>
<p>That way we can make nice mixed sheets of the things:</p>
<pre class="scheme"><code> &gt; (demo) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png" /></a></p>
<p>Pop quiz: Find two identical invaders. What is the likelihood of that happening? Well using the same math as in <a href="http://blog.jverkamp.com/2012/10/01/the-birthday-paradox">The Birthday Paradox</a>, the chance of no duplicates is:</p>
<div>$$ B(n, x) = 1 - \prod_{i=1}^{(n-1)}(1-\frac{i}{x}) $$</div>
<p>Where <span>\(n\)</span> is the number of generated invaders and <span>\(x = 15^{2} = 32768\)</span> is the total number of possible invaders.</p>
<p>Specifically, for the 5x5 case:</p>
<div>$$B(25, 32768)
= 1 - \prod_{i=1}^{(25-1)}(1-\frac{i}{32768})
\approx 9.1\%$$</div>
<p>And for the 80x40 case:</p>
<div>$$B(3200, 32768)
= 1 - \prod_{i=1}^{(3200-1)}(1-\frac{i}{32768})
\approx 100\%$$</div>
<p>So it's (almost certainly) there... you just have to find it. :)</p>
<p>Okay, what else can we do with these things? Well, at the moment, they're a little bit bland. Let's add a few bits to the generation and spice them up a bit with highlights. Specifically, let's choose one of the 15 bits to be red instead of black or white. In order to do that (choose 1 of 15), we need 4 bits (with one left over). SOmething like this should work:</p>
<pre class="scheme"><code>; Create a procedural invader as above, but highlight the point specified by four highest bits
(define (procedural-invader/highlight i)
  (define highlight (bitwise-and i #b1111))
  (define img-w/o-highlight (procedural-invader (arithmetic-shift i -4)))

  (build-flomap*
   3 5 5
   (Î» (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (= highlight i)
         '#(1.0 0.0 0.0)
         (make-vector 3 (flomap-ref img-w/o-highlight 0 x y))))))</code></pre>
<p>Basically, we pull off the lowest four bits with a <a href="https://en.wikipedia.org/wiki/bitmask">bitmask</a> for the highlight then shift all the rest down and pass off to the original <code>procedural-invader</code> function. Then we build a new image from that, mostly copying but taking a single pixel and making it red. Adding an argument so that our <code>demo</code> function can handle highlighting:</p>
<pre class="scheme"><code> &gt; (demo #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png" /></a></p>
<p>Ooh. That's starting to look like a game. Perhaps I'll revist these for the next <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>...</p>
<p>What else can we do with these? Well, take the <a href="http://www.complexification.net/gallery/machines/invaderfractal/">post I was inspired by</a>. In that case, they fill up a space with procedural invaders of different sizes. That would be neat to check out. I've started implementing something...</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png" /></a></p>
<p>But it's not quite right yet. Perhaps next time...</p>
<p>If you'd like to check out the entire code for today's post, as always, it's available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a></p>]]></content></entry><entry><title>Chess Puzzles: Knight's Tour</title><link href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour" /><id>urn:uuid:7b068d00-2bb7-61fb-e0d8-045306814067</id><updated>2014-09-04T20:00:00Z</updated><summary type="html"><![CDATA[<p>Onwards and upwards! For today's chess puzzle, let's take a first crack at the <a href="https://en.wikipedia.org/wiki/Knight's_Tour">Knight's Tour</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Onwards and upwards! For today's chess puzzle, let's take a first crack at the <a href="https://en.wikipedia.org/wiki/Knight's_Tour">Knight's Tour</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
<!--more-->
<p>As with <a href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens">N Queens</a>, the problem is simply stated:</p>
<blockquote>A knight's tour is a sequence of moves of a knight on a chessboard such that the knight visits every square only once.</blockquote>
<p>And once again, we can get a solution working relatively well using <a href="https://en.wikipedia.org/wiki/backtracking">backtracking</a>:</p>
<pre class="scheme"><code>(define-piece Knight (move 1 (leaper 1 2)))
(define-piece Visited '())

; Solve a knights tour on a given board
(define (knights-tour width [height width])
  ; Create a new empty board
  (define b (make-board width height #:pieces (list Knight Visited)))

  ; A board is completed if there are no empty squares
  ; All squares are either the Knight or Visited
  (define (completed? b)
    (not (for*/first ([x (in-range width)]
                      [y (in-range height)]
                      #:when (not (board-ref b (pt x y))))
           #t)))

  ; Move the knight from the given point to each possible next point in turn
  ; Return a list of valid moves to finish the tour if such a list exists, #f otherwise
  (define (move-knight b p)
    (cond
      ; Done, we have a tour and there are no more valid moves necessary
      [(completed? b) '()]
      ; Otherwise, try all possible moves from this point
      ; Since all pieces are the same color, moves from is only empty tiles
      [else
       (for*/first ([next (in-list (moves-from b p))]
                    [recur (in-value (let* ([b (board-move b p next)]
                                            [b (board-set b p '(Black Visited))])
                                       (move-knight b next)))]
                    #:when recur)
         (cons p recur))]))

  ; Try each possible initial location until we find one that works
  (for*/first ([x (in-range width)]
               [y (in-range height)]
               [solution (in-value
                           (move-knight
                             (board-set b (pt x y) '(Black Knight))
                             (pt x y)))]
               #:when solution)
    solution))</code></pre>
<p>Basically, there are three interesting pieces here: <code>completed?</code>, <code>move-knight</code>, and the <code>for*/first</code> initial loop.</p>
<p>First, how can a tour be <code>completed?</code> If all of the locations on the board are filled. We get around this with the psuedo-piece: <code>Visited</code>. It fills up the board as we continue to move our knight around. Technically, I could have just filled the board with knights, but I like how visited lets us visualize things.</p>
<p>Next, <code>move-knight</code>. This is the core of the algorithm. As it states, we are building up a list of moves recursively. So the base case (when the board is completed) return the empty list <code>'()</code>. Otherwise, we're going to use <code><a href="http://docs.racket-lang.org/search/index.html?q=for*/first">for*/first</a></code> to find the first move which recursively solves the problem (or <code>#f</code> if none does). The use of <code><a href="http://docs.racket-lang.org/search/index.html?q=in-value">in-value</a></code> is a trick I picked up <a href="https://groups.google.com/forum/#!topic/racket-users/p2S6F3FAiU0">from the mailing list</a> for using an 'expensive' value in a <code>#:when</code> clause and body without having to recalculate it.</p>
<p>Finally, we loop across all of the starting states. It doesn't matter in the case of closed tours (where the start and end points match and thus any point can be a start point), but on some boards not every starting location is valid.</p>
<p>So now we can solve a tour:</p>
<pre class="scheme"><code>&gt; (knights-tour 5)
(list
 (pt 0 0) (pt 1 2) (pt 0 4) (pt 2 3) (pt 3 1)
 (pt 1 0) (pt 0 2) (pt 1 4) (pt 2 2) (pt 4 3)
 (pt 2 4) (pt 0 3) (pt 1 1) (pt 3 0) (pt 4 2)
 (pt 3 4) (pt 1 3) (pt 0 1) (pt 2 0) (pt 4 1)
 (pt 3 3) (pt 2 1) (pt 4 0) (pt 3 2))</code></pre>
<p>Whee! Okay, what does that actually look like? Let's animate it!</p>
<pre class="scheme"><code>(current-glyphs (hash 'Knight "â"
                      'Visited "â"))

; Render a knights tour into an animation
(define (knights-tour/animate-solution width [height width])
  (define tour (knights-tour width height)

  ; Create an initial board
  (define board (make-board width height #:pieces (list Knight Visited)))

  ; Prerender the board once so we know how large of a scene to create
  (define r (render board #:player-colors (const "black")))
  (define render-width (send r get-width))
  (define render-height (send r get-height))

  ; Animate the tour, rendering each frame once
  (big-bang tour
    [on-tick cdr]
    [to-draw (Î» (tour)
               (place-image
                (render (if (null? tour)
                            board
                            (board-set board (car tour) '(Black Knight))))
                (/ render-width 2)
                (/ render-height 2)
                (empty-scene render-width render-height)))]
    [stop-when null?]
    [record? #t]))</code></pre>
<pre class="scheme"><code> &gt; (knights-tour/animate-solution 5) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-5-solution.gif" /></a></p>
<p>Shiny.</p>
<p>Okay, so that's all well and good for normal boards. What if instead you want a board with holes in it / a non-regular board?</p>
<p>Simple! We'll just add a third type of piece <code>Invalid</code> and pre-populate the board with those:</p>
<pre class="scheme"><code>(current-glyphs (hash 'Knight "â"
                      'Invalid "â"
                      'Visited "â"))

(define-piece Knight (move 1 (leaper 1 2)))
(define-piece Invalid '())
(define-piece Visited '())

; Solve a knights tour on a given board (optionally with some pieces removed)
(define (knights-tour width [height width] #:removed [removed '()])
  ; Create a new board (potentially removing some pieces)
  (define b
    (for/fold ([b (make-board width height
                    #:pieces (list Knight Invalid Visited))])
              ([p (in-list removed)])
      (board-set b p '(Black Invalid))))

  ...)</code></pre>
<p>All the rest of the code stays the same. Pretty nice eh? Let's try an example:</p>
<pre class="scheme"><code>&gt; (knights-tour/animate-solution 4
    #:removed (list (pt 1 0) (pt 0 2) (pt 0 3) (pt 2 3) (pt 3 3)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-solution.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-solution.gif" /></a></p>
<p>Hmm, that's all well and code showing off the final tour. But what if we want to see the search in progress? Let's put in a <code><a href="http://docs.racket-lang.org/search/index.html?q=generator">generator</a></code> again so we can animate this. This time around though, I'm actually going to fold the generator code into the main method rather than duplicating a bunch of code.</p>
<pre class="scheme"><code>(define (knights-tour width [height width] #:generator? [generator? #f])
  (define g
    (generator ()
      ...

      (define (move-knight b p)
        (when generator?
          (yield b p))

        ...)))

  (if generator? g (g)))</code></pre>
<p>In this case, we create the <code>generator</code> no matter what. But we only call <code>yield</code> if we actually specify it to the function. This way we can see each step of our simultion as we go. If we don't want the generator, we immediately call it as we're returning, forcing it to return a value: the implicit <code>yield</code> at the end of the function.</p>
<p>So with this, we have enough that we can animate the search space:</p>
<pre class="scheme"><code>; Render the search for a knights tour into an animation
(define (knights-tour/animate-search width [height width] #:removed [removed '()])
  ; Create an initial board including the missing tiles
  (define board
    (for/fold ([b (make-board width height #:pieces (list Knight Invalid Visited))])
              ([p (in-list removed)])
      (board-set b p '(Black Invalid))))

  ; Prerender the board once so we know how large of a scene to create
  (define r (render board #:player-colors (const "black")))
  (define render-width (send r get-width))
  (define render-height (send r get-height))

  ; Set the last board, which will be updated on each yield
  (define last-board board)
  (define last-point (pt 0 0))
  (define g (knights-tour width height #:removed removed #:generator? #t))

  ; Animate the tour, rendering each frame once
  ; Stop when the generator returns 1 value
  (big-bang #t
    [on-tick
     (Î» (running?)
       (and running?
            (with-handlers ([exn? (const #f)])
              (define-values (board point) (g))
              (set! last-board board)
              (set! last-point point)
              #t)))]
    [to-draw
     (Î» (_)
       (place-image
        (render last-board)
        (/ render-width 2)
        (/ render-height 2)
        (empty-scene render-width render-height)))]
    [stop-when (negate identity)]
    [record? #t]))</code></pre>
<p>And in action:</p>
<pre class="scheme"><code>&gt; (knights-tour/animate-search 4
     #:removed (list (pt 1 0) (pt 0 2) (pt 0 3) (pt 2 3) (pt 3 3)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-search.gif"><img src="http://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/tour-4-limited-search.gif" /></a></p>
<p>Sweet!</p>
<p>That's about all for today. If you were following along though, you might have noticed one very important omission...</p>
<p>It doesn't work on 8x8 boards.</p>
<p>Well, that's not strictly speaking true. It will work. If you wait long enough, you will eventually get a solution, but it's going to be a <em>very</em> long wait. So looks like we'll need a follow looking for a better solution<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span></p>
<p>That's for another time though. If you'd like to see the entire code, you can do so in the <a href="https://github.com/jpverkamp/chess-puzzles">chess-puzzles</a> repo on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles/blob/master/puzzles/knights-tour.rkt">knights-tour.rkt</a>. Check it out!</p>]]></content></entry><entry><title>Chess Puzzles: N Queens</title><link href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens" /><id>urn:uuid:ca36a36d-8baa-c760-8b5a-2162fcfa5a9c</id><updated>2014-09-03T20:00:00Z</updated><summary type="html"><![CDATA[<p>After two weeks, it seems only right that we actually get around to a real chess puzzle. First on the list: <a href="https://en.wikipedia.org/wiki/Eight_queens puzzle">the eight queens puzzle</a>.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Specifically, how do you place n queens on an n by n chess board such that no pair of queens can attack one another?</p>
]]></summary><content type="html"><![CDATA[<p>After two weeks, it seems only right that we actually get around to a real chess puzzle. First on the list: <a href="https://en.wikipedia.org/wiki/Eight_queens puzzle">the eight queens puzzle</a>.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Specifically, how do you place n queens on an n by n chess board such that no pair of queens can attack one another?</p>
<!--more-->
<p>Those of you paying attention may think this problem looks <a href="http://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code">awfully familiar</a>. Turns out I've already done this one. But not with my new <a href="http://blog.jverkamp.com/category/programming/by-topic/chess">chess library</a>! So let's do it again:</p>
<p>Basically, the idea is simple. Start in the first row and column, placing a queen:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-1.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-1.png" /></a></p>
<p>Next, move down to the second row, first column:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-2.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-3.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-4.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-4.png" /></a></p>
<p>We cannot place a queen there since it can attack the first. Try the second column ... Still doesn't work, since it can attack diagonally. Try the third... Bam. Placed. Head down to the third row and start over in the first column.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-5.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-step-5.png" /></a></p>
<p>Keep on keeping on. Eventually though, you'll run into a row when you can't place a queen. What do you do then?</p>
<p><a href="https://en.wikipedia.org/wiki/Backtracking">Backtrack!</a></p>
<p>Specifically, go back one row and remove that queen. Start over from one column to the right of where it was. If there's no where else to place that queen, back up another column, over and over until you finally find where you can place one.</p>
<p>Sounds crazy, keeping track of all that state (how many queens we've removed and which), but this is where the magic of recursion comes in. We can actually use the call stack to handle all of this backtracking for us!</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(define (queens n)
  ; Create a new nxn board
  (current-board-size n)
  (define-piece Queen (move 'n '*))
  (define b (make-board n #:pieces (hash 'Queen Queen)))

  ; Try to place a queen in each row
  (let place-queen ([board b] [x 0] [y 0])
    (cond
      ; Done with all of the rows, we have a valid configuration
      [(&gt;= y n) board]
      ; Done with the current row, if we haven't placed a queen yet, bail out
      [(&gt;= x n) #f]
      ; Otherwise, try to place the queen at this location
      ; Use the row as the player ID so they can all attack one another
      [else
       (define new-board (board-set board (pt x y) `(,y Queen)))
       (cond
         ; We attack a current queen, try the next square on the old board
         [(for/first ([target-pt (moves-from new-board (pt x y))]
                      #:when (board-ref new-board target-pt))
            #t)
          (place-queen board (+ x 1) y)]
         ; We do not attack anything (yet), try this solution
         ; If that fails, fall through (or short circuits)
         [else
          (or (place-queen new-board 0 (+ y 1))
              (place-queen board     (+ x 1) y))])])))</code></pre>
<p>The interesting parts of the solution are at the beginning (when we set up the intial board using our new library) and the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code> section. That's what's checking out attacks. In this case, <code>for/first</code> will return <code>#t</code> if any <code>#:when</code> is true, <code>#f</code> if none of them are. This works with our framework (as the code mentions) because we're setting each queen to a different player so they can all attack one another.</p>
<pre class="scheme"><code> &gt; (render (queens 8)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens-solution.png" /></a></p>
<p>Nice!</p>
<p>Even bigger?</p>
<pre class="scheme"><code> &gt; (render (queens 13)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/13-queens.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/13-queens.png" /></a></p>
<pre class="scheme"><code> &gt; (render (queens 25) #:tile-size 12) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/25-queens.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/25-queens.png" /></a></p>
<p>(That one took a little while.)</p>
<p>Okay, so that's all well and good. But what if we don't want just one solution. What if we want all of them? Well, it turns out, that's actually not that much harder. We just need to slightly tweak how we recur. Instead of a board or <code>#f</code>, we need to return a list of possible solutions. That way we can <code>append</code> instead of <code>or</code>:</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(define (queens n #:all? [generate-all? #f])
  ...

      ; Done with all of the rows, we have a valid configuration
      [(&gt;= y n) (if generate-all? (list board) board)]
      ; Done with the current row, if we haven't placed a queen yet, bail out
      [(&gt;= x n) (if generate-all? (list)       #f)]

      ...

         ; We do not attack anything (yet), try this solution
         ; If that fails, fall through (or short circuits)
         ; If we're generating all solutions, do both
         ; (we cannot do ((if generate-all? append or) ...) because or is a macro
         [generate-all?
          (append (place-queen new-board 0 (+ y 1))
                  (place-queen board     (+ x 1) y))]

         ...)</code></pre>
<p>That way, we could get all of the 6x6 solutions in one go:</p>
<pre class="scheme"><code>&gt; (map (Î» (b) (render b #:player-colors (const "black")))
       (queens 6 #:all? #t))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-1.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-2.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-3.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-4.png"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/6-queens-4.png" /></a></p>
<p>Or determine how many queens that there are for each puzzle size:</p>
<pre class="scheme"><code>&gt; (for/list ([n (in-range 1 11)])
    (list n (length (queens n #:all? #t))))
'((1 1) (2 0) (3 0) (4 2) (5 10) (6 4) (7 40) (8 92) (9 352) (10 724))</code></pre>
<p>That matches up perfectly with sequence <a href="https://oeis.org/A000170">A000170</a> on <a href="https://en.wikipedia.org/wiki/OEIS">OEIS</a>, which must mean we're doing something right. Shiny!</p>
<p>One final trick, what if we want to animate these things? Well, for that we're going to use the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/generator">racket/generator</a></code> module. I've used it before, and although the performance isn't <em>great</em>, it's certainly the easiest way to get what we want. Really, we only need two changes:</p>
<pre class="scheme"><code>; Try to place n queens on an nxn chessboard such that none are threatened
(require racket/generator)
(define (queens-generator n #:all? [generate-all? #f])
  (generator ()
    ...

    ; Try to place a queen in each row
    (let place-queen ([board b] [x 0] [y 0])
      (yield board x y)
      (cond
        ...</code></pre>
<p>That way, if we create a generator and keep calling it, it will return each board state including the backtracking. It's a little more complicated to turn it into a nice animation, once again using the excellent <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> function:</p>
<pre class="scheme"><code>; Use the queens generator to render an n-queens problem
(require 2htdp/image 2htdp/universe)
(define (queens-animate n #:all? [generate-all? #f])
  (define g (queens-generator n #:all? generate-all?))

  (define-values (last-board last-x last-y) (g))
  (define done? #f)

  (define r (render last-board #:player-colors (const "black")))
  (define w (send r get-width))
  (define h (send r get-height))

  (big-bang (void)
    [stop-when (Î» (_) done?)]
    [on-tick
     (Î» (_)
       (with-handlers ([exn? (thunk* (set! done? #t))])
         (define-values (board x y) (g))
         (set! last-board board)
         (set! last-x x)
         (set! last-y y)))]
    [to-draw
     (Î» (_)
       (place-image
        (render last-board
                #:player-colors (const "black")
                #:highlights (hash (pt last-x last-y) "green"))
        (/ w 2)
        (/ h 2)
        (empty-scene w h)))]
    [record? #t]))</code></pre>
<p>The <code><a href="http://docs.racket-lang.org/search/index.html?q=with-handlers">with-handlers</a></code> is a little ugly, but it's designed to deal with the fact that we don't return multiple values on the last call, since generators by default return the last (return) value of a function at the end. But if we wanted to make that return x and y as well, things might just get ugly, seeing as how we'd have to change all of the recursive calls. No thank you.</p>
<p>It's certainly pretty to watch though:</p>
<pre class="scheme"><code> &gt; (queens-animate 4) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens.gif"><img src="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/8-queens.gif" /></a></p>
<p>You can see the backtracking anytime the green box jumps back and suddenly one or more of the previously place queens vanishes. It would be even neater if it could show the branching solutions, but that's a challenge for another day.</p>
<p>And that's it. A bit more in detail than <a href="http://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code">last time</a>, but I think it was a lot of fun. The code is available in my <a href="https://github.com/jpverkamp/chess-puzzles">chess-puzzles</a> repo on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles/blob/master/puzzles/queens.rkt">queens.rkt</a>. Check it out!</p>]]></content></entry><entry><title>Chess Puzzles 2: Board?</title><link href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board" /><id>urn:uuid:6d64e14c-c731-a12d-4a38-7070fa6e6e9e</id><updated>2014-08-28T20:00:00Z</updated><summary type="html"><![CDATA[<p>Now that we've got <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a> out of the way, back to chess! <a href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving">Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p>
<ul>
    <li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li>
    <li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href="https://en.wikipedia.org/wiki/fairy_chess">fairy chess</a> pieces)</li>
</ul>
<p>I think that's about enough for the moment. Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Now that we've got <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a> out of the way, back to chess! <a href="http://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving">Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p>
<ul>
    <li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li>
    <li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href="https://en.wikipedia.org/wiki/fairy_chess">fairy chess</a> pieces)</li>
</ul>
<p>I think that's about enough for the moment. Let's do it!</p>
<!--more-->
<p>First things first, let's create a representation of the board. We'll start with only regular grids, although theoretically it should be possible to define arbitrary connections. That would mess somewhat with the move definitions we have, so let's not.</p>
<p>First, the board:</p>
<pre class="scheme"><code>; Stored as a vector of vectors where every element is either:
; (player, piece) if there is a piece there
; #f if empty
(struct board (pieces data) #:transparent)</code></pre>
<p>So what we should have is something like this:</p>
<pre class="scheme"><code>(define (make-standard-board)
  (board (hash 'Rook   Rook
               'Knight Knight
               'Bishop Bishop
               'Queen  Queen
               'King   King
               'Pawn   Pawn)
         '#(#((Black Rook) (Black Knight) (Black Bishop) (Black Queen)
              (Black King) (Black Bishop) (Black Knight) (Black Rook))
            #((Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn)
              (Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn))
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #(#f #f #f #f #f #f #f #f)
            #((White Pawn) (White Pawn) (White Pawn) (White Pawn)
              (White Pawn) (White Pawn) (White Pawn) (White Pawn))
            #((White Rook) (White Knight) (White Bishop) (White Queen)
              (White King) (White Bishop) (White Knight) (White Rook)))))</code></pre>
<p>Vectors will allow both <code>O(1)</code> reading of elements, but also a nice way of doing mutation. I'm just going to go right out now and say that I'll allow mutating the board, although I might make a non-mutable version that copies if I have a chance<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>.</p>
<p>Next, a getter and a sanity check (which should make it cleaner to generate moves):</p>
<pre class="scheme"><code>; Test if a point is on the given board
(define (on-board? b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (and (&lt;= 0 x (- (vector-length (vector-ref data 0)) 1))
       (&lt;= 0 y (- (vector-length data) 1))))

; Get the current player/piece at a square
(define (board-ref b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (cond
    [(on-board? b p)
     (vector-ref (vector-ref data y) x)]
    [else
     #f]))</code></pre>
<p>And finally, a setter. In this case, it doesn't make sense to just set a single piece (except in set up I guess?)<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>. So instead, we will allow movement, overwriting whatever is at the target square:</p>
<pre class="scheme"><code>; Move a piece from one square to another, overwriting whatever is in the destination square
(define (board-move! b src dst)
  (match-define (board pieces data) b)
  (match-define (pt src-x src-y) src)
  (match-define (pt dst-x dst-y) dst)
  (define piece (board-ref data src))
  (vector-set! (vector-ref data dst-y) dst-x piece)
  (vector-set! (vector-ref data src-y) src-x #f))</code></pre>
<p>And that's about all we need for the board representation. Let's check out rendering next, since it should (theoretically) make debugging the move list generation much better.</p>
<p>First, let's generalize the tile for a piece to a <code>glyph</code>:</p>
<pre class="scheme"><code>; The hash associating piece names with glyphs
(define current-glyphs (make-parameter #f))

; A single glyph containing a string and the rotation (default to upright)
(struct glyph (character rotation) #:transparent)
(define (make-glyph character [rotation 0])
  (glyph (~a character) rotation))

; Render a single character with some sanity checking for different types
(define (render-glyph/pict g tile-size)
  (cond
    [(glyph? g)
     (match-define (glyph character rotation) g)
     (rotate (text character 'default (* 3/4 tile-size)) rotation)]
    [else
     (render-glyph/pict (make-glyph g) tile-size)]))</code></pre>
<p>This way, we can specify characters in several different ways. We can pass just about anything directly and use the <code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code> function to 'string' it. Or we can pass both the former and a rotation. That will let us do things like an inverted knight being the representation for the nightrider, etc.</p>
<p>One thing that amuses me entirely too much about this?</p>
<pre class="scheme"><code>(define (set-standard-glyphs)
  (current-glyphs (hash 'Rook   "â"
                        'Knight "â"
                        'Bishop "â"
                        'Queen  "â"
                        'King   "â"
                        'Pawn   "â")))</code></pre>
<p>Those are unicode characters for the chess symbols. Nice. :)</p>
<p>Okay, so we have a way to represent a single tile, what do we have to do to render all of them? Well, as often before, we can use the <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code> library:</p>
<pre class="scheme"><code>; Render a board to a pict with the given tile size
(define (render/pict b #:tile-size [tile-size 20])
  ; Sanity check and unpack, we don't care about the actual pieces at this point
  (when (not (current-glyphs))
    (error 'render/pict "must specify (current-glyphs) as a hash of name -&gt; glyph"))
  (match-define (board _ board-data) b)

  ; Render each tile into a list of lists
  (define tiles
    (for/list ([row-index (in-naturals)]
               [row       (in-vector board-data)])
      (for/list ([col-index (in-naturals)]
                 [col       (in-vector row)])
        ; Get the background tile
        ; TODO: Parameterize the tile colors
        ; TODO: Figure out how to do borders
        (define tile-color
          (cond
            [(even? (+ row-index col-index))
             "LightGray"]
            [else
             "DarkGray"]))
        (define tile (colorize (filled-rectangle 20 20) tile-color))

        (cond
          ; If there is a piece here, render the piece, colorize based on the player,
          ; and overlay on the tile
          [col
           (match-define (list player piece) col)
           (define glyph
             (render-glyph/pict (hash-ref (current-glyphs) piece) tile-size))
           (cc-superimpose tile (colorize glyph (~a player)))]
          ; If not, just return the empty tile
          [else
           tile]))))

  ; Smash together all the lists of lists
  (apply vc-append
         (for/list ([row (in-list tiles)])
           (apply hc-append row))))</code></pre>
<p>Okay, that looks like a lot, but most of it is comments. Basically, we loop over the board (the pair of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/list">for/list</a></code>), building nested lists. Then, for each tile, we determine if we're on a white or black square (light and dark gray so that the white and black actually stand out). After that, we get the string from the <code>glyph</code> and render it as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code>. There's one thing I haven't done yet: support strings of multiple characters. Essentially, I would scale horizontally to make it be the correct width. Good enough for now though.</p>
<p>So how does it work? Well combine <code>make-standard-board</code> and <code>render/pict</code>:</p>
<pre class="scheme"><code>&gt; (render/pict (make-standard-board))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/initial-board.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/initial-board.png" /></a></p>
<p>Fair enough. But to visualize, what we really want is an ability to show off certain squares. So let's add a <code>#:highlight</code> keyword parameter of a hash of points to colors to color them specially. Something like this:</p>
<pre class="scheme"><code>; Render a board to a pict with the given tile size
(define (render/pict b #:tile-size [tile-size 20] #:highlights [special-tiles (hash)])
  ...

  ; Get the background tile
  ; TODO: Parameterize the tile colors
  ; TODO: Figure out how to do borders
  (define tile-color
    (cond
      [(hash-ref special-tiles (pt col-index row-index) #f)
       =&gt; identity]
      [(even? (+ row-index col-index))
       "LightGray"]
      [else
       "DarkGray"]))

  ...)</code></pre>
<p>This way, we can highlight any square we want:</p>
<pre class="scheme"><code>&gt; (render/pict (make-standard-board)
               #:highlights (hash (pt 2 2) "green"
                                  (pt 5 2) "green"
                                  (pt 2 4) "red"
                                  (pt 3 5) "red"
                                  (pt 4 5) "red"
                                  (pt 5 4) "red"))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/highlights.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/highlights.png" /></a></p>
<p>(Remember that indices are 0-based)</p>
<p>Shiny!</p>
<p>Okay, that's enough to test. Let's work on a function to determine moves. We want something like this:</p>
<pre class="scheme"><code>; Return a list of moves that a piece can make on the given board given it's origin point
(define (moves-from b origin #:initial [initial #f])
  ...)</code></pre>
<p>We'll have a flag if the piece is on the initial turn, otherwise we pull everything out (like which player we're dealing with) from the piece on the board:</p>
<pre class="scheme"><code>...
(cond
  [(board-ref b origin)
   =&gt; (Î» (ls)
        (match-define (list player name) ls)
        (match-define (piece _ moves) (hash-ref pieces name))

        ; White has inverse moves since they're moving 'up'
        ; TODO: Generalize to more players
        ; TODO: This moves the wrong way if you have 'left only' pieces
        (define player-multiplier
          (case player
            [(BLACK Black black)  1]
            [(WHITE White white) -1]
            [else     1]))

...</code></pre>
<p>This is the case when we have a piece (if not, the location is <code>#f</code>). If we have that, we unpack the piece and then determine which player we have. For the black player, we're moving down on the board / up in the y-coordinate, so the numbers are correct. Otherwise, we'll multiply moves my negative one. This has the effect of reflecting the moves. Unfortunately, it's on both axes, but at least with any piece I've seen, that doesn't actually matter.</p>
<p>Next, we're going to take the move sequences we generated last time and filter each one so that we only include the moves from that sequence that are viable. For that, we first need to find the <code>first-target</code>--the first piece that we would hit if moving along this path.</p>
<pre class="scheme"><code>...
(define move-sublists
 (for*/list ([move-seq (in-list moves)])
   (match-define (move-sequence tags original-offset*) move-seq)
   (define offset* (map (Î» (offset) (pt* player-multiplier offset)) original-offset*))

   ; Find the first target
   (define first-target
     (for/first ([i (in-naturals)]
                 [offset (in-list offset*)]
                 #:when (board-ref b (pt+ origin offset)))
       (list i (board-ref b (pt+ origin offset)))))

   ; If the first target belongs to the owner, remove it (no self captures)
   ; TODO: Add an option for self-captures
   (define self-capture
     (and first-target
          (eq? (first (second first-target)) player)))
   ...</code></pre>
<p>Another amusing option that I'm sure there are fairy chess pieces that use: self-captures.</p>
<p>Next, we want to unfold those lists based on how we found the <code>first-target</code>:</p>
<pre class="scheme"><code>...
             (map (Î» (offset) (pt+ origin offset))
                  (cond
                    ; Bail out if we're initial only but not on the initial move
                    [(and (set-member? tags 'initial-only) (not initial))
                     (list)]
                    ; If we're capturing only, can only move if we have a target
                    ; and to that square
                    [(set-member? tags 'capture-only)
                     (if (and first-target (not self-capture))
                         (list (list-ref offset* (first first-target)))
                         (list))]
                    ; If we're not capturing, get everything up until the target
                    ; (or everything if no target)
                    [(set-member? tags 'non-capture)
                     (if (and first-target (&gt; (first first-target) 0))
                         (take offset* (- (first first-target) 1))
                         offset*)]
                    ; If we're a locust, we have to check the space after the self
                    ; target is empty
                    [(set-member? tags 'as-locust)
                     (cond
                       [(and first-target
                             (not self-capture)
                             (&gt; (length offset*) (+ (first first-target) 1)))
                        (define next-target
                          (board-ref b (list-ref offset* (+ (first first-target) 1))))
                        (if (not next-target)
                            (list (list-ref offset* (+ 1 (first first-target))))
                            (list))]
                       [else
                        (list)])]
                    ; If the target is an enemy, capture it and stop
                    ; Otherwise, if the target is a piece but we own, don't land there
                    [first-target
                     (if self-capture
                         (if (&gt; (first first-target) 0)
                             (take offset* (first first-target))
                             (list))
                         (take offset* (+ (first first-target) 1)))]
                    ; Otherwise, include the entire range
                    [else
                     offset*]))))

          ...</code></pre>
<p>Oof. That's a lot of code. But luckily, each case is fairly straight forward. We remove non-initial moves (like for pawns), set the capturing / non-capturing conditions, or move like a locust (that have to jump to capture). And then finally, if the first thing is our own, just cut that off (this is where a self-capture tag would come in).</p>
<p>And then to finish it off:</p>
<pre class="scheme"><code>      ...
      ; Stick all the lists together since we no longer care how they got there
      ; And remove all moves that jump off of the board somehow
      (filter (Î» (p) (on-board? b p)) (apply append move-sublists)))]
[else
 '()]))</code></pre>
<p>Bam. We have moves. Let's try it out:</p>
<pre class="scheme"><code>; Black pawn
&gt; (moves-from (make-standard-board) (pt 3 1) #:initial #t)
(list (pt 3 3) (pt 3 2))

; White knight
&gt; (moves-from (make-standard-board) (pt 6 7))
(list (pt 7 5) (pt 5 5))</code></pre>
<p>And using our highlighting code:</p>
<pre class="scheme"><code>&gt; (let* ([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt 3 1) #:initial #t)])
                        (values pt "green"))])
    (render/pict board #:highlights highlight))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-pawn.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-pawn.png" /></a></p>
<pre class="scheme"><code>&gt; (let* ([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt 6 7))])
                        (values pt "green"))])
    (render/pict board #:highlights highlight))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-knight.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/moves-knight.png" /></a></p>
<p>Shiny!</p>
<p>Looks like it's working great. Let's generate images for all of the pieces:</p>
<pre class="scheme"><code>&gt; (for/list ([piece (in-list '(Pawn Rook Knight Bishop Queen King))])
    (define test-board
      (board (hash 'Rook   Rook
                   'Knight Knight
                   'Bishop Bishop
                   'Queen  Queen
                   'King   King
                   'Pawn   Pawn)
             `#(#(#f #f #f #f #f #f #f #f)
                #(#f #f #f #f #f #f (White Pawn) #f)
                #(#f #f #f #f (White Pawn) #f #f #f)
                #(#f #f #f (White Pawn) #f (Black Pawn) #f #f)
                #(#f #f #f #f (White ,piece) #f #f (Black Pawn))
                #(#f #f #f #f (Black Pawn) #f #f #f)
                #(#f #f #f #f #f #f (Black Pawn) #f)
                #(#f #f #f #f #f #f #f #f))))

    (define highlights
      (for/hash ([pt (in-list (moves-from test-board (pt 4 4)))])
        (values pt "green")))

    (render/pict test-board #:highlights highlights))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-pawn.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-pawn.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-rook.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-rook.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-knight.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-knight.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-bishop.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-bishop.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-queen.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-queen.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-king.png"><img src="http://blog.jverkamp.com/2014/08/28/chess-puzzles-2-board/demo-king.png" /></a></p>
<p>That is cool. I love it when something works like that!</p>
<p>(Note: Yes, the king can currently move into check. That's on the list of things to fix yet, along with castling and en passant.)</p>
<p>Here's actually a lesson too, until I generated those images for this post, I actually had a bug where I wasn't stopping after hitting an enemy piece. Good thing I checked otherwise who knows what would have happened?</p>
<p>And that's about it for today. We now have move lists, a board, and some rendering. Should be enough so that next time we can <em>actually</em> write up a chess puzzle. Third time's a charm, eh?</p>
<p>If you'd like to see the entire code, it's on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles">jpverkamp/chess-puzzles</a></p>]]></content></entry><entry><title>Sandbox Battle!</title><link href="http://blog.jverkamp.com/2014/08/24/sandbox-battle" /><id>urn:uuid:645b48c8-e1d6-e804-d919-58df438ef692</id><updated>2014-08-24T18:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png"><img src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/title.png" /></a></p>
<!--more-->
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/sandbox-battle/sandbox-battle.embed.htm"></iframe></p>
<h2>Created for <a href="http://www.ludumdare.com/compo/ludum-dare-30/">Ludum Dare 30</a></h2>
<h3><a href="http://www.ludumdare.com/compo/ludum-dare-30/?action=preview&uid=19702">Entry</a></h3>
<h3><a href="https://github.com/jpverkamp/sandbox-battle">Source code</a></h3>
<h4>Note: Runs best in <a href="https://www.google.com/chrome/browser/">Chrome</a>.</h4>
<h3>Instructions</h3>
<ul>
  <li>You have 60 seconds to collect as much sand as you can</li>
  <li>Each player's sand falls to the bottom of their tile</li>
  <li>Colliding with other players will steal their sand</li>
  <li>Choose options for keyboard controls and to enable multiplayer</li>
</ul>
<h3>Comments</h3>
<ul>
  <li>Libraries used: <a href="https://jquery.com/">jQuery</a>, <a href="http://getbootstrap.com/">Boostrap</a></li>
  <li>Graphics generated in Photoshop CS6</li>
</li>]]></content></entry><entry><title>Ludum Dare 30: Demo mode</title><link href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode" /><id>urn:uuid:eaf9e838-2040-375f-db84-612ac3daf122</id><updated>2014-08-24T12:00:00Z</updated><summary type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
]]></summary><content type="html"><![CDATA[<p>Quick update this morning: I managed to get a 'demo mode' working. Now when you first start the game, the boxes will be whizzing around in the background giving you an idea of what you're about to get yourself into!</p>
<!--more-->
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/screenshot.png" /></a></p>
<p>As soon as you start, you'll go right back to the normal mode. Between rounds, there's no demo, since it's still showing the last round's game.</p>
<p>Unfortunately, it doesn't stop, so if you just let it sit for a while, strange things may happen:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/oops.png" /></a></p>
<p>Also, instructions (technically, these were in last night, but I don't think I mentioned them):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png"><img src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/instructions.png" /></a></p>
<p>Up to date code (as always): <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/24/ludum-dare-30-demo-mode/demo.embed.htm"></iframe></p>]]></content></entry><entry><title>Ludum Dare 30: Programmer art and simple AI</title><link href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai" /><id>urn:uuid:f2360aa3-c003-b836-c4a8-ea379a7ef8de</id><updated>2014-08-23T23:00:00Z</updated><summary type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
]]></summary><content type="html"><![CDATA[<p>A few hours later and we've already finished (or at least made good progress on) two of the goals that I was hoping for:</p>
<ul>
  <li>AI players; at the very least one that moves randomly, but optimally several different kinds</li>
  <li>Pending the previous, a selector on the options screen that can turn each player either off, on, or to any of the current AIs</li>
  <li>Stylings around the page; probably some sort of thick border that bleeds a little in and out, looking different per player</li>
</ul>
<!--more-->
<p>More specifically, here's how you can change the AIs:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png"><img src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/choose-ai.png" /></a></p>
<p>Those are the three AIs currently implemented. I've tied them into the same framework as the player movement. It's a bit hacky and could be in its own file, but for a 48 hour game, it works well enough.</p>
<p>The first, the <code>Wiggle</code>, is straight forward:</p>
<pre class="javascript"><code>// Randomly wiggle about, changing directions no slower than every second
case 'wiggle':
  ai['nextWiggle'] = ai['nextWiggle'] || new Date().getTime() + 1000 * Math.random();
  ai['xAccel'] = ai['xAccel'] || 0;
  ai['yAccel'] = ai['yAccel'] || 0;

  if (new Date().getTime() &gt; ai['nextWiggle']) {
    ai['xAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;
    ai['yAccel'] = (Math.floor(Math.random() * 3) - 1) * PER_TICK_ACCELERATION;

    ai['nextWiggle'] = new Date().getTime() + 1000 * Math.random();
  }

  vel[player][0] += ai['xAccel'];
  vel[player][1] += ai['yAccel'];

  break;</code></pre>
<p>The other two (<code>Chicken</code> and <code>Shark</code>) are actually really similar. Enough so that they share almost all of their code. The only difference is that the former runs from the closest neighbor while the latter chases it. It's a bit of math, but it runs great:</p>
<pre class="javascript"><code>case 'chicken': // Run away from the nearest other tile
case 'shark':   // Run towards the nearest other tile
  $me = $('#tiles *[data-player="' + player + '"]');
  var myCenterX = $me.offset().left + $me.width() / 2;
  var myCenterY = $me.offset().top + $me.height() / 2;

  // Find the closest target
  var otherCenterX, otherCenterY, distance;
  var minimumDistance = +Infinity, $target;
  $('#tiles *[data-player]').each(function(otherPlayer, other) {
    $other = $(other);

    var otherCenterX = $other.offset().left + $other.width() / 2;
    var otherCenterY = $other.offset().top + $other.height() / 2;

    distance = (
      (myCenterX - otherCenterX) * (myCenterX - otherCenterX) +
      (myCenterY - otherCenterY) * (myCenterY - otherCenterY)
    );

    if (distance &gt; 0 && distance &lt; minimumDistance) {
      minimumDistance = distance;
      $target = $other;
    }
  });

  // Calculate the direction to that target
  var targetCenterX = $target.offset().left + $target.width() / 2;
  var targetCenterY = $target.offset().top + $target.height() / 2;

  // Get the length and normalized direciton
  var length = Math.sqrt(
    (targetCenterX - myCenterX) * (targetCenterX - myCenterX) +
    (targetCenterY - myCenterY) * (targetCenterY - myCenterY)
  );

  var directionX = (targetCenterX - myCenterX) / length;
  var directionY = (targetCenterY - myCenterY) / length;

  // If we're the chicken, invert that and run away rather than towards
  // Sharks also move away, once they've come in for the kill
  if (ai['type'] == 'chicken' || distance &lt; 25) {
    directionX *= -1;
    directionY *= -1;
  }

  // Apply a force in that direction
  // Sharks and chickens accelerate more slowly or they'll stay right on the player
  vel[player][0] += directionX * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);
  vel[player][1] += directionY * PER_TICK_ACCELERATION * (Math.random() / 2 + 0.5);

  break;</code></pre>
<p>Shiny.</p>
<p>Up to date code: <a href="https://github.com/jpverkamp/sandbox-battle">jpverkamp/sandbox-battle</a></p>
<p>Current demo:</p>
<p><iframe width="660" height="440" frameBorder="0" scrolling="no" style="overflow: hidden" src="http://blog.jverkamp.com/2014/08/23/ludum-dare-30-programmer-art-and-simple-ai/demo.embed.htm"></iframe></p>]]></content></entry></feed>