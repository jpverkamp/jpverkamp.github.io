<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-08-13T17:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>Minimal palindromic base</title><link href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base" /><id>urn:uuid:dccae1c2-8231-ed96-21a1-54145cd10b47</id><updated>2014-08-13T17:00:00Z</updated><summary type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>What's this? Two posts in one day? Well, <a href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards">writing a static blog generator</a> can do that. :)</p>
<p>Another easily phrased challenge:</p>
<blockquote>
    <p>We have a simple little problem today: Given an integer n > 2, find the minimum b > 1 for which n base b is a palindrome.</p>
    <p>-- <a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base</a> via Programming Praxis</p>
</blockquote>
<!--more-->
<p>More specifically, consider the number 15:</p>
<div>$$15_{10} = 1111_2 = 120_3 = 33_4 = 30_5 = 23_6 = 21_7 = 17_8 = 16_9$$</div>
<div>$$15_{10} = 14_{11} = 13_{12} = 12_{13} = 11_{14} = 10_{15}$$</div>
<p>In this case, <code>2</code> is our golden number, since <code>1111</code> is a palindrome. But if it wasn't, 14 is the next case, with <code>11</code>.</p>
<p>So, what do we need? Well, first we want a generic way to convert bases. We could use different characters up to base 64, but we'll eventually get beyond that. So instead, we'll use lists of digits, each of which can be any integer:</p>
<pre class="scheme"><code>; Convert a decimal number n to base b
(define (rebase n b)
  (let loop ([n n] [ls '()])
     (if (= n 0)
        ls
        (loop (quotient n b)
              (cons (remainder n b) ls)))))</code></pre>
<pre class="scheme"><code>&gt; (rebase 15 2)
'(1 1 1 1)

&gt; (rebase 15 5)
'(3 0)

&gt; (rebase 15 10)
'(1 5)

&gt; (rebase 15 14)
'(1 1)</code></pre>
<p>Looks good. Next, we'll use a macro we've often used before: <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>. It's perfect for our uses, since it will return the first value that is non-<code>#f</code>. In this case, our base:</p>
<pre class="scheme"><code>; Find the minimal base b such that n in base b is a palindrome
(define (minimal-palindromic-base n)
  (for/first ([b (in-naturals 2)]
              #:when (let ([nb (rebase n b)])
                       (equal? nb (reverse nb))))
    b))</code></pre>
<p>Bam. Let's try a few:</p>
<pre class="scheme"><code>&gt; (minimal-palindromic-base 15)
2

&gt; (minimal-palindromic-base 1234)
22

&gt; (rebase 1234 22)
'(2 12 2)

&gt; (minimal-palindromic-base 8675309)
8675308</code></pre>
<p>Huh. I think <a href="https://en.wikipedia.org/wiki/867-5309/Jenny">Jenny</a> has a secret. :)</p>
<p>That's pretty much it for the puzzle as stated, but there are still a few things that we can do. For example, we've only seen small examples. What if we want to find the number with the largest minimal palindromic base:</p>
<pre class="scheme"><code>; Find the number n which has the largest palindromic base
(define (maximal-minimal-palindromic-base n-min n-max)
  (for/fold ([b -1] [n #f]) ([i (in-range n-min (+ n-max 1))])
    (define mpb (minimal-palindromic-base i))
    (if (&gt; i b)
        (values mpb i)
        (values b   n))))</code></pre>
<p>I may or may not have just wanted an excuse to use a crazy long function name. :)</p>
<p>Give it a try:</p>
<pre class="scheme"><code>&gt; (maximal-minimal-palindromic-base 100 200)
7
200

&gt; (rebase 200 7)
'(4 0 4)</code></pre>
<p>Error, <code>maximal-minimal-palindromic-base</code> not found!</p>
<p>Okay, more seriously, what does that even look like? Let's <code><a href="http://docs.racket-lang.org/search/index.html?q=plot">plot</a></code>!</p>
<pre class="scheme"><code>(require plot)

; Plot a whole range of minimal palindromic bases
(define (plot-minimal-palindromic-bases n-min n-max)
  (plot (lines (for/list ([i (in-range n-min (+ n-max 1))])
                 (vector i (minimal-palindromic-base i)))
               #:color 6
               #:label "minimal palindromic base")))</code></pre>
<p>Basically, we're going to draw a chart relating each number to it's minimal palindromic base.</p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 100)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-100.png" /></a></p>
<pre class="scheme"><code>(plot-minimal-palindromic-bases 1 1000)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png"><img src="http://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/plot-minimal-palindromic-bases-1000.png" /></a></p>
<p>Looks like like there's basically two behaviors. A background noise of really low bases (binary or trinary is often palindromic just because there aren't many digits) and a few spikes growing ever larger. Neat.</p>
<p>And that's it. Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/minimal-palindromic-base.rkt">minimal-palindromic-base.rkt</a></p>]]></content></entry><entry><title>Number words</title><link href="http://blog.jverkamp.com/2014/08/13/number-words" /><id>urn:uuid:67236730-531b-effa-30b3-b69308ea8187</id><updated>2014-08-13T14:00:00Z</updated><summary type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Today's five minute post brought to you via <a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis</a> / <a href="http://www.careercup.com/question?id=5120347909128192">Career Cup</a>:</p>
<blockquote>
Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -> A, 2 -> B, …, 26 -> Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.
</blockquote>
<!--more-->
<p>That may look fairly straight forward. Basically, it's a <a href="https://en.wikipedia.org/wiki/parsing">parsing</a>/<a href="https://en.wikipedia.org/wiki/lexing">lexing</a> problem. You take a string as input and break it into a series of tokens (in this case, numbers 1-26); then each token is converted into a letter.</p>
<p>Unfortunately, it's a bit more complicated than that, since the grammar is ambiguous. Taking the example <code>1234</code> from above, should you parse that as <code>1 2 3 4 = ABCD</code>? Or what about <code>1 23 4 = AWD</code>? Or even <code>12 3 4 = LCD</code>? In a nutshell, we have to do all of them. So we want some sort of branching lexer that will try all possible routes.</p>
<p>So let's start with a function that meta-function that can make such a parser:</p>
<pre class="scheme"><code>; Make an optional parser
; If the regex matches, add it to each possible next parse
; If it does not, return an empty list (to be appendable)
(define (make-parser re)
  (λ (str)
    (match str
      [(regexp re (list _ n rest))
       (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
      [any
       '()])))</code></pre>
<p>Looks a bit funny, (especially since we haven't defined <code>number-&gt;words</code> yet), but basically we try to match the regular expression. If that works, make the recursive call (to <code>number-&gt;words</code>) and then append that string (as a character via <code>n->char</code>) to each recursive result. If there are no recursive results, this <code>map</code> will return an empty list. Likewise, if the regular expression doesn't match.</p>
<p>Next step, write the two parsers. We want to parse either a single digit number or a two digit number:</p>
<pre class="scheme"><code>; Create parsers for valid 1 digit and 2 digit letter numbers
(define parse-1 (make-parser #px"([1-9])(.*)"))
(define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))</code></pre>
<p>That's what makes the ambiguity the most interesting. If only <code>0</code> were a valid digit... As it is, there are four possible cases (and these two functions handle them all!):</p>
<ul>
    <li><code>str</code> starts with 1 and a digit 0-9, parse both</li>
    <li><code>str</code> starts with 2 and a digit 0-6, parse both</li>
    <li><code>str</code> starts with 2 and a digit 7-9, parse 2 digits only</li>
    <li><code>str</code> starts with 3-9, parse 1 digit only</li>
</ul>
<p>And finally, try both:</p>
<pre class="scheme"><code>; Base case, so we can stop eventually
(if (equal? str "")
    '("")
    (append (parse-1 str) (parse-2 str)))</code></pre>
<p>The base case looks a bit funny, since you might assume that if neither case matches we'll get there. That's the difference between the empty list <code>'()</code> and the list containing just an empty string <code>'("")</code>. In the latter, there's nothing to map against, ergo necessary.</p>
<p>And then all we need is the <code>n->char</code> function:</p>
<pre class="scheme"><code>; Convert a number 1-26 to a letter A-Z
(define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))</code></pre>
<p>And that's it. Put it all together:</p>
<pre class="scheme"><code>; Given 1-26 mapping to A-Z, determine all possible words represented by a number
; Correctly resolve ambiguities where 1234 -&gt; 1 2 3 4 = ABCD / 1 23 4 -&gt; AWD / 12 3 4 -&gt; LCD
(define (number-&gt;words str)
  ; Convert a number 1-26 to a letter A-Z
  (define (n-&gt;char n) (integer-&gt;char (+ 64 (string-&gt;number n))))

  ; Make an optional parser
  ; If the regex matches, add it to each possible next parse
  ; If it does not, return an empty list (to be appendable)
  (define (make-parser re)
    (λ (str)
      (match str
        [(regexp re (list _ n rest))
         (map (curry ~a (n-&gt;char n)) (number-&gt;words rest))]
        [any
         '()])))

  ; Create parsers for valid 1 digit and 2 digit letter numbers
  (define parse-1 (make-parser #px"([1-9])(.*)"))
  (define parse-2 (make-parser #px"(1[0-9]|2[0-6])(.*)"))

  ; Base case, so we can stop eventually
  (if (equal? str "")
      '("")
      (append (parse-1 str) (parse-2 str))))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (number-&gt;words "1234")
'("ABCD" "AWD" "LCD")

&gt; (number-&gt;words "8675309")
'("HFGECI")

&gt; (length (number-&gt;words "85121215231518124"))

1181

&gt; (number-&gt;words "85121215231518124")
'(... "HELLOWORLD" ...)</code></pre>
<p>I could claim that I just happen to know the number code for <code>HELLOWORLD</code>, but really I wrote a quick inverse function:</p>
<pre class="scheme"><code>; Convert words back to numbers
(define (words-&gt;number str)
  (define (char-&gt;n c) (number-&gt;string (- (char-&gt;integer c) 64)))
  (apply ~a (for/list ([c (in-string str)]) (char-&gt;n c))))</code></pre>
<p>Shiny!</p>
<p>Code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/number-words.rkt">number-words.rkt</a></p>]]></content></entry><entry><title>Onwards and upwards</title><link href="http://blog.jverkamp.com/2014/08/08/onwards-and-upwards" /><id>urn:uuid:3d69145f-292b-c8aa-9e92-1151fa3a6bf2</id><updated>2014-08-08T00:05:00Z</updated><summary type="html"><![CDATA[<p>Huh. Things suddenly look a bit different around here, don't they?</p>
<p>Long story short, I finally finished a project that I've been working on off and on for the better part of two years: converting my blog to a static website.</p>
]]></summary><content type="html"><![CDATA[<p>Huh. Things suddenly look a bit different around here, don't they?</p>
<p>Long story short, I finally finished a project that I've been working on off and on for the better part of two years: converting my blog to a static website.</p>
<!--more-->
<p>For years, I've been running this blog on a custom <a href="http://wordpress.org/">Wordpress</a> installation, first on <a href="https://www.ipower.com/">ipower</a> and then on <a href="http://www.dreamhost.com/">dreamhost</a>. That works well enough (and is certainly easier to get started), but eventually (especially as you add plugins) it just starts getting slower and slower.</p>
<p>And that makes you think... Why? It's not like my blog content is actually dynamic<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. So why do I constantly re-render the content? There are caching plugins galore for Wordpress, but even those can only do so much. Why not go old-school<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>? Purely a collection of static content.</p>
<p>Once I decided to do that, the next step was to find a static blog generator. Luckily, this isn't exactly a new idea. There are a whole pile of options out there. Here are a few that I spent at least a good amount of time looking into:</p>
<ul>
    <li><a href="http://jekyllrb.com/">Jekyll</a> - Ruby + Liquid, MIT licensed</li>
    <li><a href="http://octopress.org/">Octopress</a> - Ruby + Liquid, MIT licensed, runs Jekyll under the hood</li>
    <li><a href="http://blog.getpelican.com/">Pelican</a> - Python + Jinja2, GPL</li>
    <li><a href="http://hyde.github.io/">hyde</a> - Python + Jinj2, conceptually based on Jekyll</li>
    <li><a href="https://github.com/greghendershott/frog">frog</a> - Racket + Markdown, MIT licensed</li>
</ul>
<p>The Ruby ones are a little less good for me personally, since when I first was learning a language of that ilk, the choice was basically Python or Ruby. I choose Python. I've been meaning to learn Roby, but don't have nearly enough experience to tune a blog generator nearly as much as I want.</p>
<p>The next problem was that none of them worked. Seriously, I tried installing each, writing a number of conversion scripts (starting with the excellent <a href="https://github.com/thomasf/exitwp">exitwp</a>) to push my posts into shape, but nothing worked. Either I couldn't get the page to build at all or I couldn't get anywhere near what I thought would be a good starting point.</p>
<p>So I did what any other sane<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span> person would do. I built my own!</p>
<p>As you may have noticed, I write a lot of Racket code. I've drunk the functional language Kool-aid, but I like having 'batteries included', so Racket just works. As mentioned, there's at least one static blog generator written in Racket already: <a href="https://github.com/greghendershott/frog">frog</a>. It's a great project (and it could actually build my blog from the ground up), but it doesn't quite have any of the more powerful functionality I was looking for. Most specifically, plugins. Even static, I want my site to be as powerful/dynamic as it can be... but without rewriting html over and over again. So I took the general idea and off I went....</p>
<p>... two years later ...</p>
<p>It's finally done. What you're reading now is built by my own <a href="https://github.com/jpverkamp/blog-generator">blog-generator</a><span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>. It takes in a pile of more or less Markdown + <code><a href="http://docs.racket-lang.org/search/index.html?q=at expressions">at expressions</a></code>, runs them through a bunch of plugins, and spits out a giant pile of static html content.</p>
<p>That being said, I'm sure I missed something. If you notice anything, I'd love to hear about / fix it. Let me know below / email me at <a href="mailto:me@jverkamp.com">me@jverkamp.com</a>.</p>
<p>Eventually, I'll probably write up a few posts about how exactly the blog generator works (and some of the problems I ran into writing it), but for now, I just want to get it up.</p>
<p>Keep an eye out for any changes:</p>
<ul>
    <li><a href="https://twitter.com/@jpverkamp">@jpverkamp</a></li>
    <li><a href="/feed/">RSS</a></li>
</ul>]]></content></entry><entry><title>Langton's ant</title><link href="http://blog.jverkamp.com/2014/08/07/langtons-ant" /><id>urn:uuid:e9c60746-187f-a46d-0c07-bb5bd223be2d</id><updated>2014-08-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Here's another post from /r/DailyProgrammer: <a href="http://www.reddit.com/r/dailyprogrammer/comments/2c4ka3/7302014_challenge_173_intermediate_advanced/">Advanced Langton's Ant</a>. I'm a bit behind the times (see tomorrow's post), but it's still an interesting enough exercise, so let's go for it!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<!--more-->
<p>First, let's define the problem. From Wikipedia: <a href="https://en.wikipedia.org/wiki/Langton's_ant">Langton's ant</a></p>
<blockquote>
    <p>Squares on a plane are colored variously either black or white. We arbitrarily identify one square as the "ant". The ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:</p>

    <ul>
        <li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
        <li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
    </ul>
</blockquote>
<p>That's actually pretty simple sounding, so let's just go ahead and jump into generalizing. Instead of only two states (<code>white</code> and <code>black</code>), let's generalize to an arbitrary number of states. Instead of flipping when the ant visits the state, instead advance to the next. That way, we can define ants quite simply:</p>
<ul>
    <li><code>LR</code> - an ant that turns left on state 1 to 2 and right on state 2 to 1 (the simple ant described above)</li>
    <li><code>LL</code> - an ant that always turns left; this one is boring, it just runs in circles</li>
    <li><code>LRRL</code> - a more complicated ant that turns left on either 1 to 2 or 4 to 1, but turns right on 2 to 3 or 3 to 4<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
</ul>
<p>Okay, fair enough. We also want to decide right now that we're going to support arbitrarily large grids. It would be a lot easier to define a certain region, since then we can use something like a 2-dimensional array to store the current states, but it's not actually any harder to support an unlimited grid. What we need is a way of associating a location with a state. Sounds like a job for a hash!</p>
<p>Except we need two points for a location. So we can either have nested hashes, or we can use a trick that I've used a time or two before: representings points as complex numbers. In this way, the point <code>(0, 0)</code> is the number <code>0+0i</code>; <code>(3, -7)</code> is <code>3-7i</code>. So long as we keep the numbers <code><a href="http://docs.racket-lang.org/search/index.html?q=exact">exact</a></code>, we should be able to use it as a hash key without issue.</p>
<p>Okay, so what do we need to represent the current state of a Langton's Ant simulation? We need the grid, that's true. But we also need the ant. More specifically, we need a location and current facing (since we need a direction to turn left/right from). Also, we'll need to store the current rule. We could keep this out of the structure, but since it's essentially the core of what we need to do, we'll put it in the <code><a href="http://docs.racket-lang.org/search/index.html?q=struct">struct</a></code>.</p>
<p>Something like this:</p>
<pre class="scheme"><code>(struct ant (rule location direction grid) #:transparent)
(define (make-ant rule) (ant rule 0 0+i (hash)))</code></pre>
<p>Okay, the rule is straight forward enough. Just a string of <code>L</code> or <code>R</code> characters. Location is a little stranger, but just remember that it's an exact complex number. So <code>0</code> is <code>0+0i</code> is <code>(0, 0)</code>. Direction takes some doing. Luckily though, it's going to make our math amazingly easy. Essentially, we're going to use complex multiplication. Taking from the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Rotation_(mathematics)">rotation</a>:</p>
<blockquote>
  <p>Points on the <span>\(R^2\)</span> plane can be also presented as complex numbers: the point <code>(x, y)</code> in the plane is represented by the complex number</p>

  <div>$$z = x + iy$$</div>

  <p>This can be rotated trhough an angle <span>\(\theta\)</span> by multiplying it by <span>\(e^{i\theta}\)</span>, then expanding the product using <a href="https://en.wikipedia.org/wiki/Euler's_formula">Euler's formula</a> as follows:</p>

  <p>...</p>
</blockquote>
<p>The important part is that Racket can do the complex multiplication for us. Even better, we only have to deal with two cases: left or right rotation by 90° / <span>\(\pi/2\)</span>. Expanding <span>\(e^{i\theta}\)</span>:</p>
<div>$$e^{i\pi/2} = i$$</div>
<div>$$e^{-i\pi/2} = -i$$</div>
<p>What's that? Left rotation is just multiplying by <span>\(i\)</span> and right rotation, multiplication by <span>\(-i\)</span>. Dang. That's easy. Take that, a rule to increment each state by one (modulus the number of states), and a rule to add the direction to the location (for the new location) and we have an update function.</p>
<pre class="scheme"><code>; Update an ant
(define (tick a)
  ; Unpack the previous ant, get the current cell
  (match-define (ant rule location direction grid) a)
  (define cell (hash-ref grid location 0))

  ; Rotate, multiply by e^iθ, which for 90° left or right is ±i
  (define new-direction (* direction (if (eq? #\L (string-ref rule cell)) 0+i 0-i)))

  ; Create and return the new ant
  ; Update the position via direction and move to the next state (wrapping)
  (ant rule
       (+ location new-direction)
       new-direction
       (hash-set grid location (remainder (+ cell 1) (string-length rule)))))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=match-define">match-define</a></code> is a great way to unpack the structure. <code>cell</code> holds the current state (since we need that both for the new facing and the new state). The direction is the multiplication as explained above and the new location just adds the old location and direction.</p>
<p>Nice and clean. I love it. Even better, it's completely functional. We're not actually mutating anything, even the call to <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-set">hash-set</a></code> creates a new hash rather than modifying the current one.</p>
<p>If we want to see the first few ticks of the <code>LR</code> ant:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (tick a)
(ant "LR" -1 -1 '#hash((0 . 1)))
&gt; (tick (tick a))
(ant "LR" -1-1i 0-1i '#hash((0 . 1) (-1 . 1)))
&gt; (tick (tick (tick a)))
(ant "LR" 0-1i 1 '#hash((0 . 1) (-1-1i . 1) (-1 . 1)))</code></pre>
<p>Take it from me, that's exactly what we're looking for. But it would be nice if we had a way to visualize it. Eventually, we'll want to generate actual images, but before we do that, let's do some ASCII art.</p>
<p>First, since the grid is allowed to grow unbounded, we first need to figure out how large of a grid we need to draw. Something like this:</p>
<pre class="scheme"><code>; Return the current bounds for an ant
(define (bounds a)
  (for/fold ([min-x +inf.0] [max-x -inf.0] [min-y +inf.0] [max-y -inf.0])
            ([(index cell) (in-hash (ant-grid a))])
    (values (min min-x (real-part index))
            (max max-x (real-part index))
            (min min-y (imag-part index))
            (max max-y (imag-part index)))))</code></pre>
<p>I like how <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> can be used to generate multiple values all at once, in this case both the min and max for both x and y.</p>
<p>Okay, with that, we render ASCII:</p>
<pre class="scheme"><code>; Render an ant into ASCII characters
(define (render/ascii a [charset " .:-=+*#%@"])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check the given charset
  (when (&gt; (string-length rule) (string-length charset))
    (error 'render-ascii "Charset is not longer enough, need ~a, given ~a" (string-length rule) (string-length charset)))

  ; Render an ASCII grid to current-output-port
  ; inexact-&gt;exact is necessary to avoid floating point hash errors
  (for ([y (in-range min-y (+ max-y 1))])
    (for ([x (in-range min-x (+ max-x 1))])
      (define p (inexact-&gt;exact (make-rectangular x y)))
      (display (string-ref charset (hash-ref grid p 0))))
    (newline)))</code></pre>
<p>We have a bit of error handling, which also unfortunately means that we can't deal with more than 10 characters. But it looks pretty good:</p>
<pre class="scheme"><code>&gt; (define a (make-ant "LR"))
&gt; (render/ascii (tick a))
.
&gt; (render/ascii (tick (tick a)))
..
&gt; (render/ascii (tick (tick (tick a))))
.
..</code></pre>
<p>Hmm. Not very impressive. Let's write a function to do a bunch of ticks in a row.</p>
<pre class="scheme"><code>; Run multiple ticks sequentially
(define (fast-tick a n)
  (for/fold ([a a]) ([i (in-range n)])
    (tick a)))

&gt; (render/ascii (fast-tick a 10))
..
..
 ..

&gt; (render/ascii (fast-tick a 1000))
       ..    ..
      .  .    ..
     ...     .. .
  .. . ....     .
 .  ...     ..
.      ......  .
.   . ...  ..  .
.  ...   ..  . .
.   .      ......
.    .. ...   ....
.  .. ..  ...
 .   ....   ...... .
 ...  ...    .   ...
 . .. ....  .  .  .
      ..  .  .  ..
           ..</code></pre>
<p>Now, we're getting somewhere. Remember how we already built in some support for more than two character rules? Let's try a few more:</p>
<pre class="scheme"><code>&gt; (render/ascii (fast-tick (make-ant "LRL") 100))
   ..
  .  .
 .   :
.   .:
.   . .
 .    .
  .::.

&gt; (render/ascii (fast-tick (make-ant "LRRL") 100))
......
.----.
.::.
:---.
:... .
.::...</code></pre>
<p>Okay. A picture may be worth a thousand words, but these need a little work. Better yet would be an animation. To make that easier (using <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> as I often do), let's use <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code> to make some pretty pictures:</p>
<pre class="scheme"><code>; Render using htdp
(define (render/htdp a [colors '#("white" "black" "red" "blue" "green" "yellow" "magenta" "cyan" "gray" "pink")])
  ; Unpack the ant and determine how large of a grid we need
  (match-define (ant rule location direction grid) a)
  (define-values (min-x max-x min-y max-y) (bounds a))

  ; Sanity check that we have enough colors, then generate some
  (when (&gt; (string-length rule) (vector-length colors))
    (error 'render-ascii "Not enough colors, need ~a, given ~a" (string-length rule) (vector-length colors)))

  ; Generate the raw images
  (define images
    (for/list ([y (in-range   (- min-y 1) (+ max-y 2))])
      (for/list ([x (in-range (- min-x 1) (+ max-x 2))])
        (define p (inexact-&gt;exact (make-rectangular x y)))
        (define c (vector-ref colors (hash-ref grid p 0)))
        (define block (rectangle 10 10 "solid" c))
        (if (= p location)
            (rotate (case direction [(0+i) 0] [(1) 90] [(0-i) 180] [(-1) 270])
                    (overlay (isosceles-triangle 5 45 'outline "red")
                             (isosceles-triangle 5 45 'solid "black")
                             block))
            block))))

  ; Combine them
  (define null (empty-scene 0 0))
  (foldl above null (map (λ (row) (foldl beside null row)) images)))</code></pre>
<p>Even better, this time we have the actual ant represented as a red outlined triangle (to show facing). Let's render a few of those previous images:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 10))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-10.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRL-100.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRRL") 100))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL-100.png" /></a></p>
<p>Beautiful. Let's animate it:</p>
<pre class="scheme"><code>; Simulate a rule using big bang
(define (simulate rule [width 800] [height 600])
  (define background (empty-scene width height))
  (big-bang (make-ant rule)
    [on-tick tick]
    [to-draw (λ (ant) (overlay (render/2htdp ant) background))]
    [record? #t]))</code></pre>
<p>I love how what should theoretically be the most complicated part is actually so simple. Both the basic simulation itself (8 lines without comments) and the simulation loop (6 lines) are tiny. The rendering is a bit worse, but still not that bad. And you can get some <em>crazy</em> behavior with these things...</p>
<pre class="scheme"><code>&gt; (simulate "LR")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR.gif" /></a></p>
<pre class="scheme"><code>&gt; (simulate "LRRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRL.gif" /></a></p>
<p>It's interesting how this one makes such a regular grid.</p>
<pre class="scheme"><code>&gt; (simulate "LRRRLRLRL")</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRRRLRLRL.gif" /></a></p>
<p>And this one is forming a nice black (state 1) border which keeps getting pushed out further and further.</p>
<p>The basic Langton's Ant (<code>LR</code>) is actually fairly famous for it's behavior:</p>
<ul>
  <li><em>simplicity</em> - &lt; ~300 steps, simple, symmetric patterns</li>
  <li><em>chaos</em> - &lt; ~10,000 steps, large irregular blocks</li>
  <li><em>order</em> - &gt; ~10,000 steps, a recurrent "highway" cycle, 104 blocks in length</li>
</ul>
<p>Examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 300))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-300.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 9000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-9000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 11000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-11000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 15000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-15000-half.png" /></a></p>
<p>Let it run forever, it just runs off in that one direction. It's actually really interesting:</p>
<blockquote>
  <p>Finally the ant starts building a recurrent "highway" pattern of 104 steps that repeat indefinitely. All finite initial configurations tested eventually converge to the same repetitive pattern, suggesting that the "highway" is an attractor of Langton's ant, but no one has been able to prove that this is true for all such initial configurations. It is only known that the ant's trajectory is always unbounded regardless of the initial configuration[4] – this is known as the Cohen-Kung theorem.</p>
  <p>-- <a href="https://en.wikipedia.org/wiki/Langton's_Ant">Langton's Ant</a></p>
</blockquote>
<p>And that's about it. Surprisingly simple, yet awesome emergent behavior.</p>
<p>Here are a few more fun examples:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "RLLRR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/RLLRR-1000-cyclops.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>That's actually an interesting aspect: repeated rules form the same patterns, just with different colors. This makes sense if you think about it, since you're getting the same pattern of <code>L</code> and <code>R</code>, just on a larger space. So:</p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLR-1000.png" /></a></p>
<pre class="scheme"><code>&gt; (render/2htdp (fast-tick (make-ant "LRLRLR") 1000))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png"><img src="http://blog.jverkamp.com/2014/08/07/langtons-ant/LRLRLR-1000-link.png" /></a></p>
<p>And that's it for today. Take a look; if you find any other awesome patterns, leave a comment! If you want to see the entire source, you can do so (as always) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/langtons-ant.rkt">langtons-ant.rkt</a></p>]]></content></entry><entry><title>Guardians of the Galaxy</title><link href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy" /><id>urn:uuid:d62a5efa-1226-9ae7-844c-13b8355842bc</id><updated>2014-08-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy/guardians-of-the-galaxy.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy/guardians-of-the-galaxy.jpg" /></a></p>
<p>Can Marvel do no wrong?</p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy/guardians-of-the-galaxy.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy/guardians-of-the-galaxy.jpg" /></a></p>
<p>Can Marvel do no wrong?</p>
<!--more-->
<p>More than anything, Guardians of the Galaxy was the film that people were expecting to flop. An unknown--and quite frankly weird--ensemble cast of characters combined with the first solid taste of the cosmic end of Marvel's universe and its amazing that they pulled it off at all. Still, Marvel has made a name for itself. That name filled the theaters... and Guardians of the Galaxy lived up to the hype.</p>
<p>Like many of the other Marvel movies, Guardians of the Galaxy thrived on its humor. With both Rocket and Quill wisecracking, Drax's overly literal nature, and <a href="https://en.wikipedia.org/wiki/Vin_Diesel">Vin Diesel's</a> command of Groot's native tongue, they had me laughing again and again. Contrasted with a whole pile of more dramatic moments (WE are Groot!) and you have one heck of a solid film.</p>
<p>One thing that I thought they overdid--just a little--was just how much of the universe they threw at viewers. In the rest of the Marvel movies, they've done a relatively good job at introducing things slowly. Here, we went from 0 to 60 in minutes flat, with aliens left and right (finally, a movie where humans really are the minority though), a big bad/bigger bad/biggest bad that we're supposed to somehow care about, and more references and shout outs than you can shake a stick at. That's one thing The Avengers had going for it--they had a whole slew of prequels to iron out the details. In Guardians of the Galaxy they had to hit the ground running.</p>
<p>Overall, if I had to rank Guardians of the Galaxy against the rest of the Marvel Cinematic Universe, I would put it below Captain America (both), Iron Man (the first), and the Avengers. Not too bad otherwise though. This year though, that puts it number 3 of 8. Again and again, this has been an excellent year for movies.</p>
<div><h3 class="ranking-title">2014 Movie Rankings</h3><ol><li><a href="http://blog.jverkamp.com/2014/02/15/the-lego-movie">The Lego Movie</a></li><li><a href="http://blog.jverkamp.com/2014/04/05/captain-america-the-winter-soldier">Captain America: The Winter Soldier</a></li><li><a href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy">Guardians of the Galaxy</a></li><li><a href="http://blog.jverkamp.com/2014/06/08/x-men-days-of-future-past">X-Men: Days of Future Past</a></li><li><a href="http://blog.jverkamp.com/2014/06/14/maleficent">Maleficent</a></li><li><a href="http://blog.jverkamp.com/2014/07/26/lucy">Lucy</a></li><li><a href="http://blog.jverkamp.com/2014/05/10/the-amazing-spider-man-2">The Amazing Spider-Man 2</a></li><li><a href="http://blog.jverkamp.com/2014/03/29/divergent">Divergent</a></li></ol></div>]]></content></entry><entry><title>Lucy</title><link href="http://blog.jverkamp.com/2014/07/26/lucy" /><id>urn:uuid:4a767f37-0649-33d0-1607-e5a374258448</id><updated>2014-07-26T00:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/26/lucy/lucy.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/07/26/lucy/lucy.jpg" /></a></p>
<p>If only the writers had used more than 10% of their brains to come up with a better basis for their film...</p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/26/lucy/lucy.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/07/26/lucy/lucy.jpg" /></a></p>
<p>If only the writers had used more than 10% of their brains to come up with a better basis for their film...</p>
<!--more-->
<p>Generally, when I'm watching a movie or reading a book, I allow it one freebie, one thing which I will just accept and that they don't have to justify. Anything built on that, so long as it's reasonably internally consistent is fine. In Lucy, that would have been the 10% malarkey. It's absolute crap. And I would have been fine with it, if it didn't underpin *<em>the entire film</em>*. Plus, it would have been so easy to avoid. Just say the drugs boost the rate of electrical / chemical reactions or something like that. Or that it added more neurons, growing more brain matter. Heck, it even would have fit better with the growth hormone idea.</p>
<p>It's doubly unfortunate, since other than that it was a pretty good movie. <a href="https://en.wikipedia.org/wiki/Scarlett_Johansson">Scarlett Johansson</a> was amazing. She had just the right blend of vulnerable and kick ass to really sell what was happening. The progression of powers was odd, but just seeing the expression on her face--that slight tilt of her head--when she knocked out a whole hallway full of men was well worth it. Likewise, <a href="https://en.wikipedia.org/wiki/Morgan_Freeman">Morgan Freeman</a> was a solid choice. The disbelief when Lucy first calls him? Priceless.</p>
<p>On the flip side, I did find it a little problematic that every single one of the villains in the film was Chinese--and basically none of the 'good guys' (for what they were). I'm all for diversity in film making... but it would be nice in general to have a better mix throughout the film industry.</p>
<p>One thing that seemed really strange at first but sort of grew on me was the quick cuts spaced throughout the film. When you have Lucy cornered by thugs, cut to a scene of a cheetah cornering an antelope. When Lucy's powers are ever increasing, cut to a full screen black and white percentage of her progress. At first, it felt rather 'film-schooly', but it grew on me.</p>
<p>Overall, I just can't let go of the 10% thing. Johansson brings it up a touch--and it works well enough as a mindless action flick. Let's say... #5. Just below Maleficent. Perhaps we need a film with Angelina Jolie opposing Scarlett Johansson. Now that would be something to see.</p>
<div><h3 class="ranking-title">2014 Movie Rankings</h3><ol><li><a href="http://blog.jverkamp.com/2014/02/15/the-lego-movie">The Lego Movie</a></li><li><a href="http://blog.jverkamp.com/2014/04/05/captain-america-the-winter-soldier">Captain America: The Winter Soldier</a></li><li><a href="http://blog.jverkamp.com/2014/06/08/x-men-days-of-future-past">X-Men: Days of Future Past</a></li><li><a href="http://blog.jverkamp.com/2014/06/14/maleficent">Maleficent</a></li><li><a href="http://blog.jverkamp.com/2014/07/26/lucy">Lucy</a></li><li><a href="http://blog.jverkamp.com/2014/05/10/the-amazing-spider-man-2">The Amazing Spider-Man 2</a></li><li><a href="http://blog.jverkamp.com/2014/03/29/divergent">Divergent</a></li></ol></div>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 3</title><link href="http://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3" /><id>urn:uuid:9bd5dcc8-74cb-9d93-1a71-996438d2daa2</id><updated>2014-07-10T09:00:00Z</updated><summary type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
]]></summary><content type="html"><![CDATA[<p>If you were paying attention when I posted part 2 to GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a>), you might have noticed a function I hadn't talked about: <code>play</code></p>
<!--more-->
<p>With everything we've done over the past two posts, we have everything we need to actually play the peg game:</p>
<pre class="scheme"><code>(define (play p)
  (cond
    [(= 1 (count p))         (displayln "YOU WIN!")]
    [(= 0 (length (next p))) (display "You lose. :(")]
    [else
     (render-text p)
     (displayln "Enter the peg to use and the peg to jump")
     (define from (read))
     (define over (read))
     (cond
       [(jump p from over) =&gt; play]
       [else
        (displayln "Invalid move.")
        (play p)])]))</code></pre>
<p>Let's play!</p>
<pre class="racket"><code>&gt; (play (invert (make-puzzle 1)))

        2   3
      4   5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
4 2
          1
            3
          5   6
    7   8   9   10
  11  12  13  14  15

Enter the peg to use and the peg to jump
9 5
          1
        2   3
              6
    7   8       10
  11  12  13  14  15

Enter the peg to use and the peg to jump
12 8
          1
        2   3
          5   6
    7           10
  11      13  14  15

Enter the peg to use and the peg to jump
11 7
          1
        2   3
      4   5   6
                10
          13  14  15

Enter the peg to use and the peg to jump
14 13
          1
        2   3
      4   5   6
                10
      12          15

Enter the peg to use and the peg to jump
3 5
          1
        2
      4       6
        8       10
      12          15

Enter the peg to use and the peg to jump
12 8
          1
        2
      4   5   6
                10
                  15

Enter the peg to use and the peg to jump
2 4
          1

          5   6
    7           10
                  15

Enter the peg to use and the peg to jump
6 5
          1

      4
    7           10
                  15

Enter the peg to use and the peg to jump
7 4
          1
        2

                10
                  15

Enter the peg to use and the peg to jump
1 2

      4
                10
                  15

Enter the peg to use and the peg to jump
15 10
You lose. :(</code></pre>
<p>Oops.</p>
<p>Can you do any better? (Without using <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">part 1</a>?)</p>]]></content></entry><entry><title>Cracker Barrel Peg Game, Part 2</title><link href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2" /><id>urn:uuid:35e19305-69d3-fb61-a39e-a5cb4a314d43</id><updated>2014-07-09T09:00:00Z</updated><summary type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Hey, remember that post a few days ago about the <a href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game">Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we're going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let's do it!</p>
<!--more-->
<p>Okay, first things first. Remember how we represented the puzzles as either a 15 element vector or 15 bit integer? Well that gives us a pretty solid upper bound on how many possible ways that the puzzle can end up being arrange. Specifically, <span>\(2^{15} = 32768\)</span> total states. For a computer... that's actually not that big of a number. First, let's see how many of those we can actually reach.</p>
<pre class="scheme"><code>; Count how many total states are reachable from any initial state
; By default, start with one copy of each peg missing
(define (reachable [queue (for/list ([i (in-range 15)])
                            (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [(hash-ref reached (index (first queue)) #f)
       (loop reached (rest queue))]
      ; New state, add it to the hash and all next states to the queue
      [else
       (loop (hash-set reached (index (first queue)) #t)
             (append (rest queue) (next (first queue))))])))</code></pre>
<p>Hopefully straight forward algorithm, basically we start with an (empty) index of which nodes we've visited--a hash in our case. Start with each of the fifteen opening moves in a queue. Then, keep taking one nodes off the queue. For new nodes, add that to the list of visited nodes and all its neighbors to the queue. A <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>. Give it a run:</p>
<pre class="scheme"><code>&gt; (hash-count (reachable))
13935</code></pre>
<p>So only 42.5%. Huh. A few examples of states that can't be reached:</p>
<pre class="scheme"><code>&gt; (define r (reachable))
&gt; (for/list ([i (in-range 5)])
    (let loop ()
      (define p (make-puzzle (random (expt 2 15))))
      (if (hash-ref r (index p) #f)
          (render p)
          (loop))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-4.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/unreachable-5.png" /></a></p>
<p>But that doesn't necessary tell us which starting positions are easier. For that, we need something more like this:</p>
<pre class="scheme"><code>&gt; (require plot)
&gt; (plot (discrete-histogram
         (for/list ([i (in-range 15)])
           (vector (+ i 1)
                   (hash-count (reachable (list (invert (make-puzzle (expt 2 i))))))))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reachable-by-initial.png" /></a></p>
<p>Interesting. So there are three states that reach the most (4, 6, and 13), three on the next tier (1, 11, and 15), 6 on the next, and 3 that reach the least (5, 8, and 9). If you think about it, that makes a lot of sense. For each position, there are two other identical positions--rotations:</p>
<pre class="scheme"><code>; Rotate a puzzle clockwise
(define (rotate p)
  (puzzle (for/vector ([i (in-list '(11 12 7 13 8 4 14 9 5 2 15 10 6 3 1))])
            (vector-ref (puzzle-data p) (- i 1)))))

&gt; (define random-puzzle (make-puzzle (random (expt 2 15))))
&gt; (map render (list random-puzzle
                    (rotate random-puzzle)
                    (rotate (rotate random-puzzle))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/rotation-example-3.png" /></a></p>
<p>Further than that, there are also reflections:</p>
<pre class="scheme"><code>; Reflect a puzzle left to right
(define (reflect p)
  (puzzle (for/vector ([i (in-list '(1 3 2 6 5 4 10 9 8 7 15 14 13 12 11))])
            (vector-ref (puzzle-data p) (- i 1)))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/reflection-example-1.png" /></a></p>
<p>This is what I meant last time, when I said that there were only four initial states (1, 2, 4, and 5). All of the rest are reflections and/or rotations of one of those 4.</p>
<p>Finally, if you combine these two functions, it should be possible to get a real idea of how many truly unique states there are. Since each puzzle has a numeric form and each puzzle has up to six unique states (three rotations, each with two reflections), we can consistently find the one of those six with the lowest value. Something like this:</p>
<pre class="scheme"><code>; Minimize a puzzle by finding the reflection/rotation with the minimal vector
(define (minify p)
  (define r1 (rotate p))
  (define r2 (rotate r1))
  (first (sort (list p r1 r2 (reflect p) (reflect r1) (reflect r2))
               (λ (p1 p2)
                 (&lt; (index p1) (index p2))))))

&gt; (map index (list random-puzzle
                   (reflect random-puzzle)
                   (rotate random-puzzle)
                   (reflect (rotate random-puzzle))
                   (rotate (rotate random-puzzle))
                   (reflect (rotate (rotate random-puzzle)))))
'(26794 21322 10025 7474 12412 12679)
&gt; (index (minify random-puzzle))
7474
&gt; (render (minify random-puzzle))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png"><img src="http://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/minimum-random-puzzle.png" /></a></p>
<p>So how many states do we get if we take only the minimum form? Both overall and reachable?</p>
<pre class="scheme"><code>&gt; (set-count
   (for/set ([i (in-range (expt 2 15))])
     (index (minify (make-puzzle i)))))
5728

; Modification of reachable states, only minified
; By default, start with one copy of each peg missing
(define (reachable-min [queue (for/list ([i (in-range 15)])
                                (invert (make-puzzle (expt 2 i))))])
  (let loop ([reached (hash)] [queue queue])
    (cond
      ; Queue is empty, done
      [(null? queue)
       reached]
      ; Already checked this state, check the rest
      [else
       (define p (minify (first queue)))
       (define i (index p))
       (cond
         [(hash-ref reached i #f)
          (loop reached (rest queue))]
         [else
          (loop (hash-set reached i #t)
                (append (rest queue) (next p)))])])))

&gt; (hash-count (reachable-min))
2383</code></pre>
<p>Still about the same (technically slightly lower, it's only 41.6%). That's a good sign. We're all of the way down to 2,383 states from the original potential 32,768. A lot more manageable.</p>
<p>Next, let's shift to moves rather than states. Given two states, they are connected with a move if you could make a single jump to get from one to the other. So now rather than a set, we have a graph. Something like this:</p>
<pre class="scheme"><code>; Find a map of all possible moves from a given puzzle
(define (all-moves p)
  (define moves (make-hash))
  (let loop ([p p])
    (let ([p (minify p)])
      (define i (index (minify p)))
      (when (not (hash-has-key? moves i))
        (define next-ps (next p))
        (hash-set! moves i (list-&gt;set (map index (map minify next-ps))))
        (map loop next-ps))))
  moves)</code></pre>
<p>From there, we can recursively build up a count for each state how many times we win (end up with only a single peg) and how many times we lose.</p>
<pre class="scheme"><code>; Count the number of winning and losing states from a given puzzle
(define (score p)
  (define moves (all-moves p))
  (define-values (wins losses)
    (let loop ([i (index (minify p))])
      (define nxt (hash-ref moves i (set)))
      (cond
        [(set-empty? nxt)
         (if (= 1 (count (make-puzzle i)))
             (values 1 0)
             (values 0 1))]
        [else
         (for/fold ([wins 0] [losses 0]) ([n (in-set nxt)])
           (define-values (r-wins r-losses) (loop n))
           (values (+ wins   r-wins)
                   (+ losses r-losses)))])))
  (* 1.0 (/ wins (+ wins losses))))</code></pre>
<p>That way we can tell how 'hard' each puzzle is, assuming that you always rotate/reflect to avoid potential duplicate state:</p>
<pre class="scheme"><code>&gt; (for/list ([i (in-list '(1 2 3 5))])
    (list i (score (invert (make-puzzle i)))))

'((1 0.05239514926876435)
  (2 0.05138285262741999)
  (3 0.08392304995059131)
  (5 0.08392304995059131))</code></pre>
<p>So there you have it. If you're playing optimally, it's slightly easier to do so starting with a corner or the second. The center or center of each edge are slightly harder.</p>
<p>And that's all we have for today. Originally, I meant to use the graph library I've used a number of times before to visualize the solution space (there's a function that will do that on GitHub), but the graphs honestly aren't that helpful. There nodes are too nested and there are just too many to helpfully visualize. So it goes. Still, I think we found a few interesting things.</p>
<p>As always, the code is available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Cracker Barrel Peg Game</title><link href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game" /><id>urn:uuid:d9fc95b6-10c0-7679-ae85-b61ec0a2f271</id><updated>2014-07-05T09:00:00Z</updated><summary type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
]]></summary><content type="html"><![CDATA[<p>Ever been to <a href="http://www.crackerbarrel.com/">Cracker Barrel</a>? Remember that <a href="http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA">peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let's do that.</p>
<!--more-->
<p>Let's start with a bit of ground work:</p>
<pre class="scheme"><code>; Puzzles are represented as a 15 element vector (#t for pegs)
; but can be entered as a 15 bit integer (1 for pegs)
(struct puzzle (data) #:transparent)
(define (make-puzzle v)
  (cond
    [(and (integer? v) (&lt;= 0 v 32767))
     (puzzle (list-&gt;vector
              (map (curry eq? #\1)
                   (reverse (string-&gt;list (~a (number-&gt;string v 2)
                                              #:width 15
                                              #:align 'right
                                              #:pad-string "0"))))))]
    [(and (vector? v) (= 15 (vector-length v)))
     (puzzle v)]
    [(and (list? v) (length v 15))
     (puzzle (list-&gt;vector v))]))</code></pre>
<p>It's a bit heavier than it needs to be (in order to support multiple datatypes), but that saved me all sorts of time in testing. It's a lot easier to enter a puzzle like this:</p>
<pre class="scheme"><code>(make-puzzle #b111110010000000)</code></pre>
<p>Rather than:</p>
<pre class="scheme"><code>(make-puzzle '#(#f #f #f #f #f #f #f #t #f #f #t #t #t #t #t))</code></pre>
<p>(Note that the ordering is opposite. The highest bit is the last peg, while the first vector is the first peg. This is so that puzzle 1 is peg 1 and so on.)</p>
<p>Anyways.</p>
<p>Next, we need to be able to visualize what we're working with. You can always see the sequence of pegs, but without putting them in their proper triangular shape, it's a bit hard to tell what exactly is going on. So first, let's render a puzzle as text:</p>
<pre class="scheme"><code>; Render a puzzle to text
(define (render-text puzzle)
  (for ([row (in-range 1 6)])
    (display (~a "" #:width (* 2 (- 6 row))))
    (for ([col (in-range 1 (+ 1 row))])
      (define i (+ (* 1/2 row (- row 1)) col))
      (display (~a (if (vector-ref (puzzle-data puzzle) (- i 1)) i "") #:width 4)))
    (newline)))</code></pre>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code> is rather handy for formatting like this, making sure that each peg (at least the ones still visible) is exactly four characters wide. The formula in the line defining <code>i</code> should look familiar: it's the sum of the first i integers. Neat.</p>
<pre class="scheme"><code>&gt; (render-text (make-puzzle (random (expt 2 15))))

        2
          5   6
    7   8   9   10
      12  13      15</code></pre>
<p>That's all well and good, but it's the 21st century. We should be able to make pretty pictures as well:</p>
<pre class="scheme"><code>; Render a puzzle to a bitmap
(define (render puzzle)
  (define (bit-set? i) (vector-ref (puzzle-data puzzle) (- i 1)))

  (define imgs
    (for/list ([row (in-range 1 6)])
      (for/list ([col (in-range 1 (+ 1 row))])
        (define i (+ (* 1/2 row (- row 1)) col))
        (define color (if (bit-set? i) "black" "gray"))
        (htdp:overlay (htdp:text (~a i) 12 color)
                      (htdp:circle 10 "outline" color)
                      (htdp:circle 12 "solid" "white")))))

  (define rows (map (λ (row) (if (= 1 (length row))
                                 (first row)
                                 (apply htdp:beside row)))
                    imgs))

  (apply htdp:above rows))</code></pre>
<p>That's a bit more complicated. The basic idea is straight forward enough. First, for each peg we're going to overlay the number as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code> on an outlined <code><a href="http://docs.racket-lang.org/search/index.html?q=circle">circle</a></code>. The second, white circle is in order to get a bit of spacing. We'll render each of these into nested lists, each of increasing length. Then we shove each row together with <code><a href="http://docs.racket-lang.org/search/index.html?q=beside">beside</a></code>, then the rows together with <code><a href="http://docs.racket-lang.org/search/index.html?q=above">above</a></code>. All that to make a picture something like this:</p>
<pre class="scheme"><code>&gt; (render (make-puzzle (random (expt 2 15))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/sample-render.png" /></a></p>
<p>Looks good! (And it's nice being able to see the locations where there currently isn't a peg as well).</p>
<p>Okay, so now that we have some framework set up, how are we going to attack this problem?</p>
<p>Well, the first thing we need is the ability to make a move. In this case, given two neighboring pegs, jump one over the other:</p>
<pre class="scheme"><code>; Given a peg to move from and the peg to move over, return the new puzzle state
(define (jump p ifrom iover)
  (define from-list '(1  1  2  2  3  3  4  4  4  5  5  6  6  7  8  11 12 13))
  (define over-list '(2  3  4  5  5  6  5  7  8  8  9  9  10 8  9  12 13 14))
  (define to-list   '(4  6  7  9  8  10 6  11 13 12 14 13 15 9  10 13 14 15))

  (for/first ([from (in-list (append from-list to-list))]
              [over (in-list (append over-list over-list))]
              [to   (in-list (append to-list from-list))]
              #:when (and (= from ifrom)
                          (= over iover)
                          (vector-ref (puzzle-data p) (- from 1))
                          (vector-ref (puzzle-data p) (- over 1))
                          (not (vector-ref (puzzle-data p) (- to 1)))))
    (let ([new-data (vector-copy (puzzle-data p))])
      (vector-set! new-data (- from 1) #f)
      (vector-set! new-data (- over 1) #f)
      (vector-set! new-data (- to   1) #t)
      (puzzle new-data))))</code></pre>
<p>That's a bit of an ugly function. Unfortunately, I'm not entirely sure how it could be made better. Still, it works. By virtue of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>, we'll either get the new puzzle or <code>#f</code> if it's not a valid move.</p>
<p>Next, we take this function and map it over a puzzle in order to generate all possible next states. Something like this:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      [over (in-range 1 16)])
            (jump p from over))))</code></pre>
<p>This one though, you should see a fairly easy way to optimize. Right now, no matter how many pegs there are in a puzzle, we're going to try every neighboring pair. <code>jump</code> can deal with the weird cases, but we shouldn't have to:</p>
<pre class="scheme"><code>; Get a list of all next states from a given puzzles
(define (next p)
  (filter identity
          (for*/list ([from (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- from 1))
                      [over (in-range 1 16)]
                      #:when (vector-ref (puzzle-data p) (- over 1)))
            (jump p from over))))</code></pre>
<p>That way, the further we get down the puzzle, the fewer cases we will check while still not duplicating <em>too</em> much of the code between the two.</p>
<p>Believe it or not... That's it. That's all we need:</p>
<pre class="scheme"><code>; Solve a puzzle using backtracking
(define (solve p)
  (cond
    [(= 1 (count p))
     (list p)]
    [else
     (let ([n (ormap solve (next p))])
       (and n (cons p n)))]))</code></pre>
<p><code>count</code> returns the number of pegs left on the current board:</p>
<pre class="scheme"><code>; Count how many pegs are left in a puzzle
(define (count p)
  (vector-length (vector-filter identity (puzzle-data p))))</code></pre>
<p>That's it. Give it any peg puzzle and it will solve it. Quickly too. On my machine, it might as well be instantaneous. So how does it work?</p>
<p>Two cases: Either we're done or we're not. If we're done, return the end state. Otherwise, we need to find a state we can move forward from. With <code>ormap</code>, we're going to try each in turn, returning the first thing that isn't <code>#f</code>. Since we're mapping <code>solve</code> (recurring) and almost making progress (<code>next</code> always has at least one less peg), we can rely on the recursion to do it's job. In this case, we'll either find a solution one step down (return that one) or not (check the next one).</p>
<p>Don't believe me? Let's check it out:</p>
<pre class="scheme"><code>&gt; (map render (solve (make-puzzle #b111111111111110)))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-01.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-02.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-03.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-04.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-05.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-06.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-07.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-08.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-09.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-10.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-11.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-12.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-13.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png"><img src="http://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/solve-14.png" /></a></p>
<p>Flip the board over and it looks like we're genius. :) Sweet.</p>
<p>That's all for today. I am working on a part two though. As a preview: If you take rotations and reflections into account, there are only four possible starting pegs (1, 2, 4, and 5). But it turns out that not all four are created equal--some are (relatively) easy to solve. Some are not.</p>
<p>If you'd like to check out the full source code (and possibly a preview for next time), you can do so on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt">pegs.rkt</a></p>]]></content></entry><entry><title>Factor trees</title><link href="http://blog.jverkamp.com/2014/06/17/factor-trees" /><id>urn:uuid:1797c7a3-6e74-dfbc-5e52-3c2d7b9eaa14</id><updated>2014-06-17T14:00:00Z</updated><summary type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
]]></summary><content type="html"><![CDATA[<p>Another five minute challenge<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, this time from <a href="http://www.reddit.com/r/dailyprogrammer/comments/284uhh/6142014_challenge_166b_intermediate_prime_factor/">/r/dailyprogrammer</a>: given any positive integer, create and render a factor tree.</p>
<!--more-->
<p>The basic idea is straight forward enough. Each positive integer of note<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> is in one of two classes: either it is <a href="https://en.wikipedia.org/wiki/prime">Prime number</a> or a <a href="https://en.wikipedia.org/wiki/composite">Composite number</a>. For the composite numbers, there are at least two numbers <em>m</em> and <em>n</em> such that neither <em>m</em> nor <em>n</em> is 1 and <em>mn</em> equals that number. For example, 6 is composite because <em>2 * 3 = 6</em>, yet 5 is not, since the only numbers that divide it are 1 and itself. Since 5 is not composite, it only makes sense that it is prime.</p>
<p>But then, what if you have a bigger number, such as 24. You can break that into <em>4 * 6</em>. But neither of those is prime, so you can further break it into <em>(2 * 2) * (2 * 3)</em>. Finally, each of those is prime. All together, that makes up what is called a <a href="https://en.wikipedia.org/wiki/factor_tree">factor tree</a>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24.png" /></a></p>
<p>That's the challenge this week. Generate that tree.</p>
<p>Well, that's more than enough description. Let's get to it.</p>
<p>Basically, there's a quick (albeit not perfectly efficient) way to find factors: <a href="https://en.wikipedia.org/wiki/trial_division">trial division</a>. Basically, you loop through all of the numbers from 2 to the square root of the number (any larger and you'll find factors you've already found), trying to divide by each in turn. That though, generates this image rather than the previous:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-24-small.png" /></a></p>
<p>Not quite as nice and balanced. Easily fixed though. Rather than looping from 2 up, loop from the square root down. You'll find the same factors, but you'll find the largest (and thus the most likely split) first.</p>
<p>Code:</p>
<pre class="scheme"><code>; Return a tree of the factors of n
(define (factor-tree n)
  (or
   ; Try to find the first pair of factors
   ; Start from sqrt(n) and work down to get the largest factors first
   (for/first ([i (in-range (integer-sqrt n) 1 -1)]
               #:when (zero? (remainder n i)))
     ; Factor, create a tree with that node and it's further factors
     (list n
           (factor-tree i)
           (factor-tree (quotient n i))))
   ; If for/first returns #f there are no other factors, n is prime
   n))</code></pre>
<p>The comments should be straight forward enough to explain the rest of the structure. <code>for/first</code> will return the first factor that we've found (if any) or <code>#f</code> if not (which then falls through to the next case).</p>
<p>That gives us this structure:</p>
<pre class="scheme"><code>&gt; (factor-tree 24)
'(24 (4 2 2) (6 2 3))</code></pre>
<p>It's perhaps a bit odd to read, but look at the first of each triple. 24 has factors 4 and 6. 4 has factors 2 and 2, 6 has 2 and 3. A bit larger example (formatted to make it a bit easier to read):</p>
<pre class="scheme"><code>&gt; (factor-tree 1767150)
'(1767150 (1309 17
                (77 7 11))
          (1350 (30 5 (6 2 3))
                (45 5 (9 3 3))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1767150.png" /></a></p>
<p>Speaking of which, how am I getting those nice images?</p>
<p>Well, to some extent, I'm cheating. I took the code that I'd written a while ago for the <a href="https://github.com/iu-c211/c211-libs/blob/master/c211-libs/tree.rkt">c211-lib/tree</a> library, designed to render trees. All I needed to do was rewrite the <code>match</code> to match against <code>list</code> instead of <code>tree</code>:</p>
<pre class="scheme"><code>; Render a tree structure
; Tree : (U (List Integer Tree Tree) Integer)
(define (render-factor-tree tr)
  (match tr
    ; Recursive tree, unpack the value and render subtrees
    [(list factor left right)
     (define v (text (~a factor)))
     (define l (render-factor-tree left))
     (define r (render-factor-tree right))
     ; Pin-line connects the nodes, append sets the trees side by side
     ; cb/ct-find tells the pins how to connect to the nodes (center bottom/top)
     (pin-line (pin-line (vc-append 10 v (ht-append 10 l r))
                         v cb-find
                         l ct-find)
               v cb-find
               r ct-find)]
    ; Values are directly rendered
    [prime
     (text (~a prime))]))</code></pre>
<p>The interesting parts are the functions <code>text</code> which turns text into an image, <code>pin-line</code> which draws lines between two images, and <code>vc-append</code> / <code>ht-append</code> to combine them vertically centered or horizontal aligned to the top. All together, it lets us render all sorts of nice trees:</p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 828441))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-828441.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 863029))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-863029.png" /></a></p>
<pre class="scheme"><code>&gt; (render-factor-tree (factor-tree 1048576))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png"><img src="http://blog.jverkamp.com/2014/06/17/factor-trees/tree-1048576.png" /></a></p>
<p>And that's about it. Quick enough (even if the rendering probably took a bit more than five minutes when I first wrote it). As always, you can see the entire code for this (and most of my other small projects) on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/factor-tree.rkt">factor-tree.rkt</a></p>]]></content></entry></feed>