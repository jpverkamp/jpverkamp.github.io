<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2015-12-09T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:b26bbc31-d1d1-3557-055d-3c47073ed3bd</id><entry><title>Advent of Code: Day 9</title><link href="//blog.jverkamp.com/2015/12/09/advent-of-code-day-9" /><id>urn:uuid:3e5f9ba8-905e-0cbb-f48a-bb215e562fe1</id><updated>2015-12-09T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/9">Source</a></p>
<p><strong>Part 1:</strong> Given a list of distances between cities of the form <code>London to Dublin = 464</code>, calculate the shortest route that visits each city exactly once.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/9">Source</a></p>
<p><strong>Part 1:</strong> Given a list of distances between cities of the form <code>London to Dublin = 464</code>, calculate the shortest route that visits each city exactly once.</p>
<!--more-->
<pre class="python"><code>routes = collections.defaultdict(
  lambda : collections.defaultdict(
    lambda : float("inf")
  )
)

for line in sys.stdin:
    src, dst, dist = re.match(r'(\w+) to (\w+) = (\d+)', line).groups()
    dist = int(dist)

    routes[src][dst] = dist
    routes[dst][src] = dist

best_length, best_ordering = min(
    (sum(
      routes[src][dst]
      for src, dst in zip(ordering, ordering[1:])
    ), ordering)
    for ordering in itertools.permutations(routes.keys())
)

print(best_length)</code></pre>
<p>There are a few neat tricks here that I've used. First <code>routes</code> is defined as nested <code>defaultdict</code>, with an eventual default value of <code>float("inf")</code>. This solves two problems:</p>
<ol>
  <li>We don't have to explicitly check if a station exists before adding a route to it:

  <pre class="python"><code>routes[src][dst] = dist</code></pre>

  rather than

  <pre class="python"><code>if src in routes:
  routes[src][dst] = dist
else:
  routes[src] = {dst: dist}</code></pre>
  </li>
  <li>Any missing routes will have an infinite distance, which will work correctly with <code>+</code> and <code>min</code>.</li>
</ol>
<p>We add each distance to both <code>routes[src][dst]</code> and <code>routes[dst][src]</code> so that we don't have to worry about ordering when we calculate full routes. The other way to do this would be to sort <code>src</code> and <code>dst</code> so that <code>src < dst</code> is always true. I think this way is a little cleaner.</p>
<p>Next, we use a bunch of tools to calculate the shortest route.</p>
<p>First, <code>itertools.permutations</code> will give us every possible ordering:</p>
<pre class="python"><code>&gt;&gt;&gt; pprint.pprint(list(itertools.permutations(routes.keys())))
[('London', 'Belfast', 'Dublin'),
 ('London', 'Dublin', 'Belfast'),
 ('Belfast', 'London', 'Dublin'),
 ('Belfast', 'Dublin', 'London'),
 ('Dublin', 'London', 'Belfast'),
 ('Dublin', 'Belfast', 'London')]</code></pre>
<p>Next, <code>zip</code> over <code>ordering</code> and <code>ordering[1:]</code> will give us the pairs of stations (since <code>zip</code> after exhausting its shortest argument):</p>
<pre class="python"><code>&gt;&gt;&gt; ordering = ('Dublin', 'Belfast', 'London')
&gt;&gt;&gt; pprint.pprint(list(zip(ordering, ordering[1:])))
[('Dublin', 'Belfast'), ('Belfast', 'London')]</code></pre>
<p>Next, we can get the distance for each pairing and <code>sum</code> them all up. This is where <code>float("inf")</code> really comes in handy (although in this smaller example, we don't need it):</p>
<pre class="python"><code>&gt;&gt;&gt; orderings = (routes[src][dst] for src, dst in zip(ordering, ordering[1:]))
&gt;&gt;&gt; pprint.pprint(list(orderings))
[141, 518]
&gt;&gt;&gt; pprint.pprint(sum(orderings))
659</code></pre>
<p>That, we wrap up in a tuple of <code>(distance, ordering)</code> so that they are sortable. Then, apply <code>min</code> to that to find the route with the minimum distance and unpack the tuple again.</p>
<p>And that's it. Minimum distance.</p>
<p>It's certainly a brute force solution in that it will try every possible route to find the shortest one. There are probably a few dynamic programming tricks that could cut that down a bit. On the other hand, the input is relatively short (28 connections between 8 stations for a total of 40320 orderings), so just do them all.</p>
<p><strong>Part 2:</strong> Find the longest route.</p>
<p>Just change <code>min</code> to <code>max</code>.</p>
<p>This wouldn't work if there wasn't a connection listed between every possible station (there is in my given input, since 8 stations will have <code>8*7/2 = 28</code> connections). That's solveable though. Just use <code>float("-inf")</code> for the default distance, so that any routes with invalid stations will have an infinitely small distance.</p>
<p>This was a pretty cool problem again!</p>]]></content></entry><entry><title>Advent of Code: Day 8</title><link href="//blog.jverkamp.com/2015/12/08/advent-of-code-day-8" /><id>urn:uuid:843d447d-6189-6d67-4c59-7ce85e2a5d3c</id><updated>2015-12-08T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/8">Source</a></p>
<p><strong>Part 1:</strong> Given an escaped string of the form <code>"\xa8br\x8bjr\""</code>, convert it to the escaped form: <code>br js</code>. Calculate the total difference of lengths between the former (<code>16</code>) and the latter (<code>5</code>).</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/8">Source</a></p>
<p><strong>Part 1:</strong> Given an escaped string of the form <code>"\xa8br\x8bjr\""</code>, convert it to the escaped form: <code>br js</code>. Calculate the total difference of lengths between the former (<code>16</code>) and the latter (<code>5</code>).</p>
<!--more-->
<pre class="python"><code>memory_count = 0
raw_count = 0

for line in sys.stdin:
    raw = line.strip()
    parsed = ast.literal_eval(raw) # This is probably cheating

    raw_count += len(raw)
    memory_count += len(parsed)

print(raw_count - memory_count)</code></pre>
<p>For a basic solution, we can cheat and use the <code>ast</code> module. It can interpret any Python literal, which includes escaped strings. Free!</p>
<p>If we actually want to do it ourselves, it's straight forward enough to use regular expressions instead:</p>
<pre class="python"><code>memory_count = 0
raw_count = 0

patterns = [
    (r'\\"', '"'),
    (r'\\\\', r'\\'),
    (r'\\x(\d\d)', chr),
    (r'^"(.*)"$', r'\1'),
]

for line in sys.stdin:
    parsed = raw = line.strip()
    for src, dst in patterns:
        parsed = re.sub(src, dst, parsed)

    print(raw, parsed)

    raw_count += len(raw)
    memory_count += len(parsed)

print(raw_count - memory_count)</code></pre>
<p>One interesting aspect is <code>chr</code>. That will convert a number such as <code>\x65</code> into the corresponding character <code>A</code>. It doesn't really matter since we just want the count, but it's kind of elegant.</p>
<p>There is a subtle bug in this, bonus points to anyone that can figure it out. But for the moment, it works great on the given test cases.</p>
<p><strong>Part 2:</strong> Do the opposite. Add another level of encoding such that <code>"\xa8br\x8bjr\""</code> would become <code>\"\\xa8br\\x8bjr\\\"\"</code>.</p>
<pre class="python"><code>raw_count = 0
encoded_count = 0

for line in sys.stdin:
    raw = line.strip()
    encoded = re.sub(r'(["\\])', r'\\\1', raw)

    raw_count += len(raw)
    encoded_count += len(encoded) + 2 # Quotes are not included

print(encoded_count - raw_count)</code></pre>
<p>This time since we don't have different behavior for the different escaped characters, we can use a single regular expression.</p>
<p>Not quite as interesting as <a href="//blog.jverkamp.com/2015/12/07/advent-of-code-day-7">Day 7</a>, but still neat.</p>]]></content></entry><entry><title>FreeÂ² HTTPS blog hosting via GitHub and CloudFlare</title><link href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare" /><id>urn:uuid:e034b0e0-08d4-330c-6f0a-b7af6af134cd</id><updated>2015-12-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>The eagle-eyed among you<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> may have noticed something a bit different since last night:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" /></a></p>
<p>That's right, I'm finally using HTTPS!</p>
]]></summary><content type="html"><![CDATA[<p>The eagle-eyed among you<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> may have noticed something a bit different since last night:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" /></a></p>
<p>That's right, I'm finally using HTTPS!</p>
<!--more-->
<p>Coming on the heels of the <a href="https://letsencrypt.org/">Let's Encrypt</a> public beta, you might think I'm using that. If I were running this blog on my own servers, I probably would be. But since I'm actually (for the moment) using <a href="https://pages.github.com/">GitHub pages</a>, that's not actually the case. I'm actually using <a href="https://www.cloudflare.com/">CloudFlare's</a> free<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> tier.</p>
<p>Basically, here is my tech stack:</p>
<p>Source files are written in Markdown(ish) stored in a GitHub git repo: <a href="https://github.com/jpverkamp/blog">github:jpverkamp/blog</a></p>
<p>Source files are translated into static HTML via my custom blog generator: <a href="https://github.com/jpverkamp/blog-generator">github:jpverkamp/blog-generator</a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></li></p>
<p>Files are deployed to a GitHub pages repo: <a href="https://github.com/jpverkamp/jpverkamp.github.io">github:jpverkamp/jpverkamp.github.io</a>, which you used to be able to directly access in the browser at <a href="http://jpverkamp.github.io">jpverkamp.github.io</a><span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span></p>
<p>CloudFlare handles my DNS, with a <a href="https://en.wikipedia.org/wiki/CNAME">CNAME</a> directing <code>blog.jverkamp.com</code> to <code>jpverkamp.github.io</code>:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-options.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-options.png" /></a></p>
<p>A custom Page Rule tells CloudFlare to automatically redirect incoming HTTP traffic to HTTPS:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-page-rule.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-page-rule.png" /></a></p>
<p>In order to ease this transaction, I changed my config file so that all internal links to my own blog now use a relative protocol: <code>//blog.jverkamp.com</code></p>
<p>And... that's it.</p>
<p>I only had one hiccup transferring my DNS entries to CloudFlare (it missed email records on a subdomain), but other than that it was rather easy to set up.</p>
<p>If you haven't given it a try, check it out! Between CloudFlare and now Let's Encrypt, there's really no good reason you shouldn't be encrypting just about everything.</p>]]></content></entry><entry><title>Advent of Code: Day 7</title><link href="//blog.jverkamp.com/2015/12/07/advent-of-code-day-7" /><id>urn:uuid:43df33f1-13b4-5b4b-cbce-a7118aadaadd</id><updated>2015-12-07T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
<!--more-->
<p>This one is actually really cool. It's basically a full <a href="https://en.wikipedia.org/wiki/declarative_programming language">declarative programming language</a>.</p>
<pre class="python"><code>monops = {
    'NOT': lambda x : ~x & 0xFFFF,
}

binops = {
    'AND': operator.and_,
    'OR': operator.or_,
    'LSHIFT': operator.lshift,
    'RSHIFT': operator.rshift,
}

machine = {}

for line in sys.stdin:
    line = line.strip()

    m = (
        re.match(r'(\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) (\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) -&gt; (\w+)', line)
    ).groups()

    machine[m[-1]] = m[:-1]

def evaluate(register_or_value):
    try:
        return int(register_or_value)
    except:
        return run(register_or_value)

def run(register, state = {}):
    if not register in state:
        command = machine[register]

        if len(command) == 1:
            value, = command
            state[register] = evaluate(value)

        elif len(command) == 2:
            monop, input = command
            state[register] = monops[monop](evaluate(input))

        elif len(command) == 3:
            input_1, binop, input_2 = command
            state[register] = binops[binop](evaluate(input_1), evaluate(input_2))

    return state[register]

print(run('a'))</code></pre>
<p>Basically, we have two interesting functions: <code>evaluate</code> and <code>run</code>. Each of those will be applied to any parameters. <code>evaulate</code> will check first if the parameter is an integer, if so return it directly. If not, fall back to <code>run</code>, which is a <a href="https://en.wikipedia.org/wiki/memoized">memoized</a> virtual machine.</p>
<p>If we have the values of any inputs (either because they are numeric or because we've already calculated them), it will directly calculate the value for that gate and cache it. If not, it will calculate any recursive outputs it needs (caching them as well), and then calculate it's own. Through the power of <a href="https://en.wikipedia.org/wiki/dynamic_programming">dynamic programming</a>, this will naturally resolve the order the gates need to be run in while still running in <code>O(n)</code> time to the number of gates. Very cool, in my opinion<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p>The only other oddity is the definition of <code>NOT</code>. Since Python integers are not 16-bits, doing a bitwise and with <code>0xFFFF</code> (the maximum 16-bit value) will lock the result into that range.</p>
<p><strong>Part 2:</strong> Take the value of <code>a</code> after running part 1 and assign it to <code>b</code>. Run the simulation again.</p>
<p>Due to how I load in the instructions, this is as easy as adding a line of the form <code>14710 -> b</code> to the end of my input before running it. That will replace the previous command for <code>b</code>. You can do it in a <a href="http://www.zsh.org/"><code>zsh</code></a> one liner<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span> shells would work just as well}:</p>
<pre class="zsh"><code>{cat input.txt; (echo "\n" &#96;cat input.txt | python part-1.py&#96; "-&gt; b")} | python3 part-1.py</code></pre>]]></content></entry><entry><title>Advent of Code: Day 6</title><link href="//blog.jverkamp.com/2015/12/06/advent-of-code-day-6" /><id>urn:uuid:4b503edf-8fe1-cc51-66e7-ad352be59fb5</id><updated>2015-12-06T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/6">Source</a></p>
<p><strong>Part 1:</strong> Given a 1000 by 1000 grid of lights and a list of instructions of the form <code>(turn on|turn off|toggle) 5,10 through 15,20</code>, determine how many lights are on.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/6">Source</a></p>
<p><strong>Part 1:</strong> Given a 1000 by 1000 grid of lights and a list of instructions of the form <code>(turn on|turn off|toggle) 5,10 through 15,20</code>, determine how many lights are on.</p>
<!--more-->
<pre class="python"><code>lights = [
    [False for y in range(1000)]
    for x in range(1000)
]

for line in sys.stdin:
    mode, x1, y1, x2, y2 = re.match('(.*) (\d+),(\d+) through (\d+),(\d+)', line.strip()).groups()
    x1, y1, x2, y2 = map(int, (x1, y1, x2, y2))

    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            if mode == 'turn on':
                lights[x][y] = True
            elif mode == 'turn off':
                lights[x][y] = False
            else:
                lights[x][y] = not lights[x][y]

print(sum(
    1 if lights[x][y] else 0
    for x in range(1000)
    for y in range(1000)
))</code></pre>
<p>At first, I was going to use <a href="http://pyparsing.wikispaces.com/">pyparsing</a> to parse the input, but then I decided that it was far too heavy weight for what I was doing. All I needed was regular expressions. After that, it's just a matter of creating a relatively large two dimensional array and running each instruction.</p>
<p>This one I actually did twice. I was curious if CPU would be significantly faster than memory (it is) to the extent that it would be faster to just calculate each light as we went:</p>
<pre class="python"><code>filters = []
for line in sys.stdin:
    m = re.match('(.*) (\d+),(\d+) through (\d+),(\d+)', line.strip())
    filters.append([m.group(1)] + list(map(int, m.groups()[1:])))

def is_on(x, y):
    on = False
    for mode, x1, y1, x2, y2 in filters:
        if x1 &lt;= x &lt;= x2 and y1 &lt;= y &lt;= y2:
            if mode == 'turn on':
                on = True
            elif mode == 'turn off':
                on = False
            else:
                on = not on
    return on

print(sum(
    1 if is_on(x, y) else 0
    for x in range(1000)
    for y in range(1000)
))</code></pre>
<p>I works at least, giving the same answer, but it's roughly an order of magnitude slower. So it goes.</p>
<p><strong>Part 2:</strong> This time <code>turn on</code> is <code>+1</code>, <code>turn off</code> is <code>-1</code>, <code>toggle</code> is <code>+2</code> and you cannot go below zero for any single cell.</p>
<p>The code doesn't actually change much from the first solution to the first part, we just initialize to <code>0</code> instead of <code>False</code> and tweak the updates. The only interesting one is the <code>turn off</code> case:</p>
<pre class="python"><code>elif mode == 'turn off':
    if lights[x][y] &gt; 0:
        lights[x][y] -= 1</code></pre>
<p>Since this is the only case that can be negative, it's the only one we have to special case.</p>]]></content></entry><entry><title>Powder Mage Trilogy</title><link href="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy" /><id>urn:uuid:1e22dce1-ebc3-45ce-27fe-5c3ad545ecb7</id><updated>2015-12-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/15790883-promise-of-blood"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/1-promise-of-blood.jpg" /></a> <a href="https://www.goodreads.com/book/show/17608111-the-crimson-campaign"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/2-crimson-campaign.jpg" /></a> <a href="https://www.goodreads.com/book/show/20883847-the-autumn-republic"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/3-autumn-republic.jpg" /></a></p>
<p>The <a href="https://www.goodreads.com/series/99602-powder-mage">Powder Mage trilogy</a> by <a href="https://www.goodreads.com/author/show/6524620.Brian_McClellan">Brian McClellan</a> best fits in with the relatively uncommon (at least so far as I've seen) genre of flintlock fantasy. Basically, Revolutionary Era technology mixed with magic. It's actually pretty cool, especially when one of the major magic systems in the book revolves around the so called Powder Mages, who magically manipulate gunpowder. Honestly, I wish that was the only magic system in the world--I'd like to see that world.</p>
<p>On the negative end, there are a lot of characters to keep track of and some of the names are similar enough that it took entirely too long to remember who was who (Tamas and Taniel for one example). Eventually, I grew to the point where I couldn't actually pick which viewpoint I would have gotten rid of had it been a choice, but it made starting out rough.</p>
<p>On the positive end, the world feels fairly realistic and the action scenes are are pretty awesome (and there are a lot of them). Some of the descriptions get rather gruesome, but I think that serves to underscore just how dangerous the world is--and the magic systems in particular.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/15790883-promise-of-blood"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/1-promise-of-blood.jpg" /></a> <a href="https://www.goodreads.com/book/show/17608111-the-crimson-campaign"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/2-crimson-campaign.jpg" /></a> <a href="https://www.goodreads.com/book/show/20883847-the-autumn-republic"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/3-autumn-republic.jpg" /></a></p>
<p>The <a href="https://www.goodreads.com/series/99602-powder-mage">Powder Mage trilogy</a> by <a href="https://www.goodreads.com/author/show/6524620.Brian_McClellan">Brian McClellan</a> best fits in with the relatively uncommon (at least so far as I've seen) genre of flintlock fantasy. Basically, Revolutionary Era technology mixed with magic. It's actually pretty cool, especially when one of the major magic systems in the book revolves around the so called Powder Mages, who magically manipulate gunpowder. Honestly, I wish that was the only magic system in the world--I'd like to see that world.</p>
<p>On the negative end, there are a lot of characters to keep track of and some of the names are similar enough that it took entirely too long to remember who was who (Tamas and Taniel for one example). Eventually, I grew to the point where I couldn't actually pick which viewpoint I would have gotten rid of had it been a choice, but it made starting out rough.</p>
<p>On the positive end, the world feels fairly realistic and the action scenes are are pretty awesome (and there are a lot of them). Some of the descriptions get rather gruesome, but I think that serves to underscore just how dangerous the world is--and the magic systems in particular.</p>
<!--more-->
<p>Disclaimer: When I first read Promise of Blood, I was reading it one chapter per day (discussing each over email as we went). Given the number of characters and initially disparate plot lines, this was probably not the best way to read this series. After reading the second two straight through in a single sitting or four, I actually went back and upped my rating for the first book. I almost want to go back and re-read it properly, but I doubt I'll do so.</p>
<p>Individual reviews (minor spoilers):</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/15790883-promise-of-blood"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/1-promise-of-blood.jpg" /></a></p>
<p>I'm not entirely sure what to think about this book.</p>
<p>On one hand, there are several varied magic systems in this book. You have the Privileged, the Marked, and the Knacked.</p>
<p>The Marked, also known as Powder Mages, are what I would have thought of as the core of the book, with the ability to basically control gun powder in various ways and to snort it as a drug, increasing their physical abilities. Side note though: It's weird that they're interchangeably called Marked and Powder Mages throughout the book. It took me more than a while to realize those two were the same thing.</p>
<p>The Privileged are more traditional fireball, lightning bolt sort of mages and, honestly, are more interesting. Which, for a series named after the Powder Mages, is a bit weird.</p>
<p>The Knacked are a fairly unique idea in that their magic is basically limited use super powers--the ability to go without sleep, for example, or a perfect memory. It's a neat idea, but I think it would be even better if it were the only magic system in the world. On top of the other two, it just seems ... busy.</p>
<p>So far as the actual story goes, you kick off the book with a bloody revolution: overthrowing and killing the king, along with much of the court, and all of the Privileged in the city. That's certainly a powerful start, and the rest of the book deals with the aftermath of such an event. I wish it had been a bit more focused though. The book jumps from scene to scene and viewpoint to viewpoint, sometimes skipping days or more in between. It's jarring and sometimes hard to follow.</p>
<p>Mostly related, I wish that there was a little more depth to the characters. You basically had Tamas the Angry, Taniel the Druggie, Adamat the Investigator, and Ka-poel the Voodoo Sidekick. I do like Adamat at least. Maybe the entire book should have been from his point of view? (Side note: Having Tamas and Taniel, both Powder Mages, be father and son was confusing. Their names are too similar. I kept getting them confused.)</p>
<p>And then the ending. So many things all come to a head all at once... and then it's over. A single shot and then we're in the Epilogue. It was surprising to say the least. I guess the sequels will deal with the fallout of those last few chapters, but honestly I'm not sure if this book caught me enough to convince me to read the sequels.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/17608111-the-crimson-campaign"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/2-crimson-campaign.jpg" /></a></p>
<p>I think the main reason that I had some problems following all of the different storylines in the first Powder Mage book was that I was reading one chapter per day and discussion as I went. Reading straight through the second book helped keep everything together. It also helps that there are few to no new major characters.</p>
<p>Overall, this was very much the second book in a trilogy. It picks up where the first left off and sets up the third. It probably wouldn't stand particularly well alone, but then again it doesn't have to. It's pretty much action all of the way through, tying up various plot lines just to ramp things up even more.</p>
<p>The general world building continues to feel something like a kitchen sink, with at least four different fairly vague magic systems all interacting in odd ways. Ka-poel is even more a singleton that everyone (even the 'gods') underestimates. I'm still not sure exactly what she did to Taniel (if it was in fact her), but I am curious how that particularly bit will end.</p>
<p>I think Taniel had the strongest story of the book, growing and changing the most of any of the characters. He's still insufferable at times, but he's also interesting. Adamat got pushed to the edge and breaks things (and people) to get his family back. It's obvious, but it's still a solid storyline (and I'm glad it ended up as relatively well as it has for him).  Tamas' storyline behind enemy lines was interesting enough, but I want to see him back with the others again.</p>
<p>And ... cliffhangers. I cannot stop now, which is of course the point. But now I'm actually looking forward to what's next.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/20883847-the-autumn-republic"><img src="//blog.jverkamp.com/2015/12/05/powder-mage-trilogy/3-autumn-republic.jpg" /></a></p>
<p>A solid conclusion. Basically, The Autumn Republic builds on the world of the first two books, without really needing to introduce much in the way of new characters (with a few relatively minor exceptions) or new world building, instead taking everything to a final conclusion.</p>
<p>So far as the characters go, I really found myself rooting for the good guys and hoping they would save the day, even when they did some not entirely unobjectionable things. In particular, I'm glad that Adamat's story at least didn't get any worse and that he managed to survive (spoilers) all the crap that the Marked and Privileged put him through.</p>
<p>So far as the world building goes, I still think that there were too many different magic systems floating around (especially when you take into account various power levels), but I think we finally got a bit more insight into some of the inner workings at least of the powder mages and Privileged which was nice. I'm vaguely annoyed that we didn't get any more about Ka-Poel or Nila, given that this is the last in the series. So it goes.</p>
<hr />
<p>Overall, worth the read. McClellan goes on my list of authors to watch.</p>
<p>Next up, I'm going to step away from my <a href="//blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a> for a moment, since I have a book club meeting coming up and instead read <a href="https://www.goodreads.com/book/show/15819028-the-golem-and-the-jinni">The Golem and the Jinni</a> by <a href="https://www.goodreads.com/author/show/6466778.Helene_Wecker">Helene Wecker</a> and <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> by <a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>.</p>
<p>After that, I should be back on track for my final (planned) series of the year: <a href="https://www.goodreads.com/series/40853-necroscope">Necroscope</a> (15 books!).</p>
<p>Onwards!</p>]]></content></entry><entry><title>Advent of Code: Day 5</title><link href="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5" /><id>urn:uuid:1d7592cf-1697-7d8b-e618-55152e623f25</id><updated>2015-12-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/5">Source</a></p>
<p><strong>Part 1:</strong> A 'nice' string contains at least three vowels, one double letter (such as <code>xx</code>), and none of the strings <code>ab</code>, <code>cd</code>, <code>pq</code>, or <code>xy</code>. Count nice strings.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/5">Source</a></p>
<p><strong>Part 1:</strong> A 'nice' string contains at least three vowels, one double letter (such as <code>xx</code>), and none of the strings <code>ab</code>, <code>cd</code>, <code>pq</code>, or <code>xy</code>. Count nice strings.</p>
<!--more-->
<pre class="python"><code>def is_nice(word):
    return (
        re.search(r'.*([aeiou].*){3}', word)
        and re.search(r'(.)\1', word)
        and not re.search(r'(ab|cd|pq|xy)', word)
    )

nice_count = 0
for line in sys.stdin:
    if is_nice(line.strip()):
        nice_count += 1

print(nice_count)</code></pre>
<p>This is a perfect application for regular expressions. In this case, <code>.*([aeiou].*){3}</code> says to match a vowel <code>[aeiou]</code> followed by any number (including zero) three times. <code>(.)\1</code> says to match any one character, then match that same character again (<code>\1</code> refers to the first matched group in parenthesis). <code>(ab|cd|pq|xy)</code> matches any one of the verboten sequences and then we negate it with <code>not</code>.</p>
<p><strong>Part 2:</strong> A 'nice' string now contains a pair of letters appearing twice in a string (such as <code>xy</code> in <code>axybcxydef</code>) and one pattern of the form <code>xyx</code> (with the first and third letters the same).</p>
<p>The code is the same, just change the regular expressions to two new patterns, each with a back reference:</p>
<pre class="python"><code>re.search(r'(..).*\1', word)
and re.search(r'(.).\1', word)</code></pre>
<p>The first matches any two characters followed by any number (including zero) uninteresting characters, followed by that same first two characters. The second does the same, only with a single character repeated group and exactly one random character in between.</p>
<p><a href="http://xkcd.com/208/"><img src="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5/xkcd-208.png" /></a></p>]]></content></entry><entry><title>Advent of Code: Day 4</title><link href="//blog.jverkamp.com/2015/12/04/advent-of-code-day-4" /><id>urn:uuid:216f239d-ca7c-12de-7b86-7275e8f4baab</id><updated>2015-12-04T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/4">Source</a></p>
<p><strong>Part 1:</strong> Mine Adventcoins. Basically, find the lowest integer such that the string <code>{prefix}{integer}</code> has an <a href="https://en.wikipedia.org/wiki/md5">md5</a> hash with at least 5 leading zeros. <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/4">Source</a></p>
<p><strong>Part 1:</strong> Mine Adventcoins. Basically, find the lowest integer such that the string <code>{prefix}{integer}</code> has an <a href="https://en.wikipedia.org/wiki/md5">md5</a> hash with at least 5 leading zeros. <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></p>
<!--more-->
<pre class="python"><code>def naturals(i = 0):
    while True:
        yield i
        i += 1

def mine(prefix, length):
    for i in naturals(1):
        coin = '{prefix}{suffix}'.format(prefix = prefix, suffix = i).encode('utf-8')
        hash = hashlib.md5(coin).hexdigest()
        if all(c == '0' for c in hash[0:length]):
            return (i, hash)

print(mine(sys.argv[1], 5))</code></pre>
<p><code>naturals</code> is code that I've used on a number of previous occasions and basically <del>stole</del> borrowed from Racket's <code><a href="http://docs.racket-lang.org/search/index.html?q=n-naturals">n-naturals</a></code>. It allows you to iterate indefinitely over the <a href="https://en.wikipedia.org/wiki/natural_numbers">natural numbers</a>. Then, just hash and look for enough leading zeros.</p>
<p><strong>Part 2:</strong> Do the same thing, only with six leading zeros.</p>
<p>Nothing changes; just change the <code>length</code> parameter and wait a bit longer. Moderns computers can still crunch through a whole heck of a lot of hashes (9958218 for my particular input) in next to no time at all.</p>]]></content></entry><entry><title>Advent of Code: Day 3</title><link href="//blog.jverkamp.com/2015/12/03/advent-of-code-day-3" /><id>urn:uuid:68885146-6356-7c02-ec5c-5f0fbb4bf956</id><updated>2015-12-03T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/3">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code><>^v</code> characters which mean move west, east, north, or south respectively and starting at the origin, how many unique positions do you pass through?</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/3">Source</a></p>
<p><strong>Part 1:</strong> Given a string of <code><>^v</code> characters which mean move west, east, north, or south respectively and starting at the origin, how many unique positions do you pass through?</p>
<!--more-->
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
location = 0+0j

directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for c in sys.stdin.read():
    location += directions.get(c, 0+0j)
    presents[location] += 1

print(len(presents))</code></pre>
<p>There are two tricks here, both of which I've used before. First, we have use <code>collections.defaultdict</code> to implement a basic counter. That way, we can safely do <code>+= 1</code> to any element without worrying if it exists first and without initializing the (potentially infinite) grid.</p>
<p>Second, we represent points using <a href="https://en.wikipedia.org/wiki/complex_numbers">complex numbers</a>. That has the advantage of meaning that movement is just adding two (complex) numbers together and we can directly index the <code>presents</code> dictionary with the locations.</p>
<p>At the end, the <code>len</code> of a dictionary is the number of keys, thus exactly equal to the number of locations visited (which thankfully works correctly even with a <code>defaultdict</code>). Neat.</p>
<p><strong>Part 2:</strong> Start with two actors, each at the origin. Apply alternating characters to first one then the other, such that <code>^v^v</code> would result in one moving north twice, the other two south.</p>
<pre class="python"><code>presents = collections.defaultdict(lambda : 0)
presents[0+0j] = 2

locations = [0+0j, 0+0j]
directions = {'&lt;': -1+0j, '&gt;':  1+0j, '^':  0+1j, 'v':  0-1j}

for i, c in enumerate(sys.stdin.read()):
    which = i % len(location)
    locations[which] += directions.get(c, 0+0j)
    presents[locations[which]] += 1

print(len(presents))</code></pre>
<p>The basic code is the same here, the only difference is that we determine <code>which</code> actor is moving using <a href="https://en.wikipedia.org/wiki/modular_arithmatic">modular arithmatic</a> (<code>%</code>). One neat thing about this is that it scales without any other changes to any number of actors merely by putting more elements in the initial <code>locations</code> array.</p>]]></content></entry><entry><title>Advent of Code: Day 2</title><link href="//blog.jverkamp.com/2015/12/02/advent-of-code-day-2" /><id>urn:uuid:7acbe2e4-c172-21ea-ec12-8be3477262de</id><updated>2015-12-02T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/2">Source</a></p>
<p><strong>Part 1:</strong> A gift requires enough wrapping paper to cover the surface plus an additional amount equal to the area smallest side. Calculate the total wrapping paper needed for a list of dimensions of the form <code>2x3x4</code>.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/2">Source</a></p>
<p><strong>Part 1:</strong> A gift requires enough wrapping paper to cover the surface plus an additional amount equal to the area smallest side. Calculate the total wrapping paper needed for a list of dimensions of the form <code>2x3x4</code>.</p>
<!--more-->
<pre class="python"><code>total_area = 0

for line in sys.stdin:
    l, w, h = list(sorted(map(int, line.strip().split('x'))))
    area = 3 * l * w + 2 * w * h + 2 * h * l
    total_area += area

print(total_area)</code></pre>
<p>The only real trick here is the use of <code>list(sorted(...))</code>. This will guarantee that <code>l</code> and <code>w</code> are the smallest dimensions and thus represent the extra area to add.</p>
<p><strong>Part 2:</strong> Given the same input, calculate the amount of ribbon needed. You need the larger of either the shortest distance around the outside or the smallest perimeter of any one face. In addition, you need an additional amount equal to the volume in cubic feet.</p>
<pre class="python"><code>total_ribbon = 0

for line in sys.stdin:
    l, w, h = list(sorted(map(int, line.strip().split('x'))))

    total_ribbon += max(
        2 * (l + w), # smallest distance around sides
        4 * l,       # smallest perimeter
    )

    total_ribbon += l * w * h

print(total_ribbon)</code></pre>
<p>This one was a little stranger since the original description was unclear if you needed the larger or smaller of the first two measurements, but it was easy enough to calculate both. Turns out, they meant the larger of those two.</p>]]></content></entry></feed>