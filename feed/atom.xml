<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-11-05T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>NaNoWriMo 2015</title><link href="http://blog.jverkamp.com/2015/11/05/nanowrimo-2015" /><id>urn:uuid:1cebb79e-a448-08da-2796-1af10dc2c2cf</id><updated>2015-11-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2014/11/04/nanowrimo-2014">Last year</a> I had a two week old; this year, I have a one year old. I'm honestly not sure yet which is more distracting!</p>
<p><a href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" data-toggle="lightbox"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>This year, I've been going for 2500 words per day (I know). It's an intense pace, but I've done it so far. And, if all goes well, I'll be done before Thanksgiving. Of course, I won't actually stop then...</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2014/11/04/nanowrimo-2014">Last year</a> I had a two week old; this year, I have a one year old. I'm honestly not sure yet which is more distracting!</p>
<p><a href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" data-toggle="lightbox"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>This year, I've been going for 2500 words per day (I know). It's an intense pace, but I've done it so far. And, if all goes well, I'll be done before Thanksgiving. Of course, I won't actually stop then...</p>
<!--more-->
<blockquote>
    <p>Title: <strong>The Last John Smith</strong></p>

    <p>Premise: <em>Among a thousand parallel realities, everyone has a thousand twins. Except for John Smith. Someone has been systematically killing all of the alternate John Smiths on all of the worlds.</em><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
</blockquote>
<p>Eventually, I'll probably publish the first chapter online. If anyone wants to read the story as I go or after I'm done though, just <a href="mailto:me@jverkamp.com">email me</a>. I'd be happy to have more beta readers.</p>]]></content></entry><entry><title>Mostly homemade pumpkin pie</title><link href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie" /><id>urn:uuid:a8effba5-c1cc-f361-f262-5673a40cf49c</id><updated>2015-11-02T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>
<p>Pumpkin pie, truly the reason for the season.</p>
<p>Other than the crust, everything is made from scratch! Including the whipped cream.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>
<p>Pumpkin pie, truly the reason for the season.</p>
<p>Other than the crust, everything is made from scratch! Including the whipped cream.</p>
<!--more-->
<h3>Pumpkin pie</h3>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Pumpkins</li>
    <li>1 pie crust</li>
    <li>2 large eggs</li>
    <li>1 cup heavy cream</li>
    <li>1 teaspoon ground cinnamon</li>
    <li>1/4 teaspoon ground cardamom</li>
    <li>1/4 teaspoon ground nutmeg</li>
    <li>1/4 teaspoon ground cloves</li>
    <li>1/2 cup sugar</li>
    <li>1/2 cup maple extract</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
        <li>Cut pumpkin in half; remove seeds</li>
    <li>Bake at 425℉ for 40-50 minutes</li>
    <li>Remove from oven and allow to cool</li>
    <li>Scoop out flesh and puree</li>
    <li>Mix puree, maple syrup, and vanilla</li>
    <li>Add eggs, spices and sugar, and cream</li>
    <li>Bake for 15 minutes at 425℉</li>
    <li>Turn oven down to 90 minutes, bake for 90 more minutes</li>
    <li>Cool and serve</li>
</ol>
<h3>Whipped cream</h3>
<p><strong>Ingredients</strong></p>
<ul>
        <li>1 cup heavy whipping cream<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>2 tablespoons sugar</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
        <li>Whisk for 10-15 minutes</li>
</ol>
<p>And now pictures, because pictures are awesome!</p>
<p>First, you cut up the pumpkins and scoop out the guts:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/1-cut-up-and-scoop.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/1-cut-up-and-scoop.jpg" /></a></p>
<p>My daughter is helping. She decorated hers:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/2-daughter-is-helping.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/2-daughter-is-helping.jpg" /></a></p>
<p>Next, you cook them for a while (see above). The nice bit is that once you've cooked them, the skin comes right off. That is glorious, since it's so much easier to peel than with a knife.</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/3-peel.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/3-peel.jpg" /></a></p>
<p>See, the skin just comes right off:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/4-peel-easy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/4-peel-easy.jpg" /></a></p>
<p>Next, mix everything except the spices into the pumpkin puree:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/5-mix.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/5-mix.jpg" /></a></p>
<p>And now mix in the spices. The spices really make the pie:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/6-add-spices.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/6-add-spices.jpg" /></a></p>
<p>Then... bake! It's odd that it's at two different temperatures, but so it goes:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/7-bake.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/7-bake.jpg" /></a></p>
<p>And, we're done!</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/8-all-done.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/8-all-done.jpg" /></a></p>
<p>Mmm, top with homemade whipped cream and nom away.</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>]]></content></entry><entry><title>Finding EC2 instances by tag</title><link href="http://blog.jverkamp.com/2015/10/30/finding-ec2-instances-by-tag" /><id>urn:uuid:dcd71490-1abf-0503-d116-70fb4eeb29cd</id><updated>2015-10-30T00:00:00Z</updated><summary type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
]]></summary><content type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
<!--more-->
<pre class="python"><code>#!/usr/bin/env python3

import argparse
import boto.ec2
import json
import re
import sys

parser = argparse.ArgumentParser(description = 'Find out information about EC2 instances')
parser.add_argument('--region', default = 'us-west-2', help = 'The AWS region to search')
parser.add_argument('--limit', type = int, default = 1, help = 'How many results to report, 0 will return all')
parser.add_argument('--output', default = 'private_ip_address', help = 'The output to fetch for each instance; json will output a json object will all of the outputs')
parser.add_argument('filters', nargs = argparse.REMAINDER, help = 'Regular expressions to apply to each tag')
args = parser.parse_args()

ec2 = boto.ec2.connect_to_region('us-west-2')

if not args.filters:
    raise Exception('You must specify at least one instance')

def include_instance(instance):
    if instance.state != 'running':
        return

    if not args.filters:
        return instance

    for filter in args.filters:
        for tag_key in instance.tags:
            tag_value = instance.tags[tag_key]
            tag = '{}={}'.format(tag_key, tag_value).lower()

            if re.search(filter, tag_value):
                return instance

def filter():
    for reservation in ec2.get_all_instances():
        for instance in reservation.instances:
            if include_instance(instance):
                yield instance

for i, instance in enumerate(filter(), 1):
    if args.output == 'json':
        print(json.dumps(instance.__dict__, default = str))
    else:
        print(getattr(instance, args.output))

    if args.limit and i &gt;= args.limit:
        break</code></pre>
<p>It's original goal was to get a single IP from a group of servers with a specific tag so that I could log in and poke around:</p>
<pre class="bash"><code>$ ssh &grave;ec2 prod-server&grave;</code></pre>
<p>There are a few other uses though, especially when combined with other tools such as <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.</p>
<pre class="bash"><code>ec2 --limit 0 --output json | jq '.instance_type' | sort | uniq -c | sort -nr

  27 "t2.micro"
   5 "m3.medium"
   1 "c4.xlarge"</code></pre>
<p>That's neat.</p>
<p>Much as <code>who-iam</code> it's a bit slow, but it still works great.</p>
<p>If you'd like to download the script, it's available in my <a href="https://github.com/jpverkamp/dotfiles">dotfiles</a>: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/ec2">ec2</a></p>]]></content></entry><entry><title>Takuzu solver</title><link href="http://blog.jverkamp.com/2015/10/29/takuzu-solver" /><id>urn:uuid:db1688ed-6c5a-fd87-ce8b-71c39075285b</id><updated>2015-10-29T00:00:00Z</updated><summary type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
<!--more-->
<p>First, we need some sort of structure to represent and read in a Takuzu board. I think I'm going to over-engineer a little bit here, since I think it will be helpful in the long run.</p>
<p>My basic idea is to represent it in a way without mutation, that is to say once I've created a board, that board will never change. That will make it easier to write a backtracking solution, since when we need to back up to a previous state, we just throw away any of the derivative boards.</p>
<p>Taking that a level further, let's represent the Takuzu board as a base board with an essentially a 'changelog' on top of it, storing any differences from the boards 'under' it. Something like this:</p>
<pre class="text"><code>....    ..1.    ....    ..1.
0.0. {- .... {- .... == 0.0.
..0.    ....    ....    ..0.
...1    ..1.    .0..    .011</code></pre>
<p>In that diagram, the board on the far left is the first layer, then the second is the next layer up, and the third is the final layer. The fourth image is the virtual board that any user of the program would actually see.</p>
<p>So how do we turn that into code?</p>
<pre class="python"><code>class Takuzu(object):

    def __init__(self, filename = None, parent = None):
        '''
        Represent a Takuzu puzzle (a grid of 0, 1, and .)

        If filename is set, load from file.
        If parent is set, extend that Takuzu puzzle.

        If neither or both is set, that is an error.
        '''

        if not (filename or parent) or (filename and parent):
            raise Exception('Set exactly one of filename and parent')

        self.size = 0
        self.tiles = collections.defaultdict(lambda : False)
        self.parent = False

        if parent:
            self.size = parent.size
            self.parent = parent

        elif filename:
            with open(filename, 'r') as fin:
                for row, line in enumerate(fin):
                    for col, char in enumerate(line.strip()):
                        if char in '01':
                            self.tiles[row, col] = char

                        self.size = col + 1

    def get(self, row = None, col = None):
        '''
        Access a tile in the current puzzle, return False for unset values

        If the current puzzle doesn't have a value set, recur to parents.
        If either row or col is set to None, return that entire row or column.
        If neither is set, return nested lists containing all current values.
        '''

        # Note: We need the ugly != None to correctly deal with row or col = 0.
        # Sometimes truthiness is annoying.

        if row != None and col != None:
            return self.tiles[row, col] or (self.parent and self.parent.get(row, col))
        elif row != None:
            return [self.get(row, col) for col in range(self.size)]
        elif col != None:
            return [self.get(row, col) for row in range(self.size)]
        else:
            return [
                [self.get(row, col) for col in range(self.size)]
                for row in range(self.size)
            ]

    def set(self, row, col, val):
        '''
        Create a child Takuzu object with the specific value set.

        If either row or column is set to None, fill any empty elements in that entire row
        with the given value.
        '''

        child = Takuzu(parent = self)

        if row != None and col != None:
            child.tiles[row, col] = val
        elif row != None:
            for col in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        elif col != None:
            for row in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        else:
            raise Exception('Must set at least one of row and column')

        return child</code></pre>
<p>The interesting bits here are the <code>get</code> and <code>set</code> methods. <code>get</code>, as mentioned, assumes the layered structure above. It will start on the topmost layer (the actual object the program has a reference to) and try to look up the given point. If that fails (we're using a <code>collections.defaultdict</code>, so every reference will either by <code>'0'</code>, <code>'1'</code>, or <code>False</code>), fall back to the next layer up (the <code>parent</code>) until we either find one or run out of <code>parent</code> nodes.</p>
<p>Similarly, <code>set</code> doesn't actually change the current Takuzu object. Instead, it creates a new object with the current one as its parent, setting the new value in the child. This means that any values that were previously set are transparently available in the child, but we can at any point backtrack so long as we keep a reference to the now parent object around.</p>
<p>In addition, I've gone ahead and built in a bit of functionality that I know we're going to need into <code>get</code> and <code>set</code>. In either case, if you only specify either the <code>row</code> or <code>col</code> and leave the other empty (<code>None</code>), then we will return that entire row or column (or <code>set</code> any empty values). That's easy enough to code and it has the advantage of making it easy to compare rows to one another (for the third requirement above).</p>
<p>Okay, up next, we'll probably want a few more helper functions in this class in order to actually tell when we've solved one of these puzzles so the algorithms we eventually write can actually terminate:</p>
<pre class="python"><code>class Takuzu(object):
    ...

    def __eq__(self, other):
        '''Check if two Takuzu puzzles are equal.'''

        for row in range(self.size):
            for col in range(self.size):
                if self.get(row, col) != other.get(row, col):
                    return False

        return True

    def __str__(self):
        '''Return a string representation the same as can be read from a file.'''

        out = ''

        for row in range(self.size):
            for col in range(self.size):
                out += str(self.get(row, col) or '.')
            out += '\n'

        return out

    def is_full(self):
        '''If all values have been filled in.'''

        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    return False

        return True

    def is_valid(self):
        '''Test if the current is still possibly a valid solution. If it also is_full,
        the board is solved.'''

        # Cannot have three identical numbers in a line
        # Ignore unset pieces
        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    continue

                if self.get(row - 1, col) == self.get(row, col) == self.get(row + 1, col):
                    return False

                if self.get(row, col - 1) == self.get(row, col) == self.get(row, col + 1):
                    return False

        # All rows and columns must have no more than the maximum (size/2) number of 0s or 1s
        for index in range(self.size):
            if (
                self.get(index, None).count('0') &gt; self.size / 2
                or self.get(index, None).count('1') &gt; self.size / 2
                or self.get(None, index).count('0') &gt; self.size / 2
                or self.get(None, index).count('1') &gt; self.size / 2
            ):
                return False

        # No two rows or columns can be equal (ignore rows/columns that contain unset values)
        # all(...) on a row or column will be true iff all values are set
        for first_index in range(self.size):
            for second_index in range(first_index):
                if (
                    all(self.get(first_index, None))
                    and all(self.get(None, first_index))
                    and (
                        self.get(first_index, None) == self.get(second_index, None)
                        or self.get(None, first_index) == self.get(None, second_index)
                    )
                ):
                    return False

        # Whee passed all three conditions!
        return True

    def is_solved(self):
        '''Return True iff this puzzle is solved.'''

        return self.is_full() and self.is_valid()</code></pre>
<p><code>__eq__</code> and <code>__str__</code> are 'magic' methods in Python that will define equality and converting this object to a string respectively. This will be nice to make sure we don't investigate the same board more than once later.</p>
<p>After that, we have <code>is_full</code>, <code>is_valid</code>, and <code>is_solved</code><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>. In the first case, we're checking if a puzzle has everything filled in. That way we know if we can stop recurring one way or the other.</p>
<p><code>is_valid</code> is actually a relatively new method. Before that, I could only check if a puzzle <code>is_solved</code>, but this way we can eliminate entire branches of the search space much earlier. For example, as soon as a backtracking solution places the third <code>0</code> in a row, it can stop looking down that path since <code>is_valid</code> will return <code>False</code>. Finally, <code>is_solved</code>. It used to have most of the <code>is_valid</code> code, but once that method existed, a puzzle <code>is_solved</code> simply if both it <code>is_full</code> and it <code>is_valid</code>. Easy enough.</p>
<p>So how do we actually solve a puzzle with this?</p>
<p>Let's start with the simple (relatively speaking, since we've done it before) backtracking solution. Given everything that we have in the Takuzu class, the actual solver is actually really simple:</p>
<pre class="python"><code>def solve(takuzu):
    '''Solve a puzzle using backtracking (also a fall back for the human solver).'''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Otherwise, find one empty spot and try both possiblities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.insert(takuzu.set(row, col, value), 0)
                        return
        enqueue()

    return False</code></pre>
<p>Basically, we keep a stack of solutions, which will allow us to perform a <a href="https://en.wikipedia.org/wiki/depth-first_search">depth-first search</a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>.</p>
<p>Basically, create a branch, trying first a <code>0</code> in the first empty spot. Looking down that path, if we find a solution, we're done. If we don't try a <code>1</code> instead. That's really it. And it's actually relatively fast.</p>
<p>Given the input:</p>
<pre class="test"><code>0..1.0
0.11..
......
......
1..1..
.....0</code></pre>
<p>We can solve it easily enough:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.15 seconds</code></pre>
<p>Nice. (You can check out the <a href="https://github.com/jpverkamp/takuzu">full source</a> if you'd like to see how I'm handling the command line parameters along with a few other goodies.<span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>)</p>
<p>Unfortunately, as puzzles get a bit larger, that runtime isn't so great:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 47.03 seconds</code></pre>
<p>Yeah...</p>
<p>We can do better.</p>
<p>How about instead of trying to solve the puzzle like a computer (brute forcing it), let's apply some heuristics more like a human would solve the puzzle. For example, if we see a pair of 0s next to each other, we know the tile on either side of it is a 1 (likewise for a pair of 0s separated by a single space and said space):</p>
<pre class="python"><code>def __third_of_a_kind__(takuzu):
    '''If adding a value would make three in a row, add the other.'''

    for row in range(takuzu.size):
        for col in range(takuzu.size):
            if takuzu.get(row, col):
                continue

            for ((offset1_row, offset1_col), (offset2_row, offset2_col)) in [
                # Two already in a line
                (( 0,  1), ( 0,  2)),
                (( 0, -1), ( 0, -2)),
                (( 1,  0), ( 2,  0)),
                ((-1,  0), (-2,  0)),
                # Two with a hole in between
                (( 0,  1), ( 0, -1)),
                (( 1,  0), (-1,  0)),
            ]:

                val1 = takuzu.get(row + offset1_row, col + offset1_col)
                val2 = takuzu.get(row + offset2_row, col + offset2_col)

                if val1 and val2 and val1 == val2:
                    return takuzu.set(row, col, invert(val1))

    return False</code></pre>
<p>Basically, for each empty tile in the current puzzle, compare each of six pairs. Either those in the four cardinal directions or the pair on either side horizontally or vertically.</p>
<p>Next rule, let's look for rows where we already have the necessary number of 0s and only need 1s. We can just fill those out:</p>
<pre class="python"><code>def __fill_rows__(takuzu):
    '''If we can figure out how many 0s and 1s we need for each and any row/col needs
    only 0s or 1s, add them'''

    # Try to fill any rows that have all of the needed 0s/1s but not the other
    for index in range(takuzu.size):
        for row, col in [(index, None), (None, index)]:
            for value in '01':
                # Have enough of 'value'
                if takuzu.get(row, col).count(value) == takuzu.size / 2:
                    # Not enough of the other one
                    if takuzu.get(row, col).count(invert(value)) &lt; takuzu.size / 2:
                        return takuzu.set(row, col, invert(value))

    return False</code></pre>
<p>It's neat how short that code is.</p>
<p>Finally (for the moment at least), let's write a slightly more complicated method. This time, let's take a single row or column and generate all the possible ways we can fill it out. Then remove those that would either lead to a duplicate or three in a row. If we have only exactly one row left, then we're golden. That's our row:</p>
<pre class="python"><code>def __fill_by_duplicates__(takuzu):
    '''Fill a puzzle by checking if any rows/cols are near enough to done that only one
    possibility is left.'''

    def row_or_col(which, index):
        if which == 'row':
            return takuzu.get(index, None)
        else:
            return takuzu.get(None, index)

    for major in ('row', 'col'):
        # Completed rows/cols have no Nones (so are 'all')
        completed = filter(all, [
            row_or_col(major, index)
            for index in range(takuzu.size)
        ])

        for index in range(takuzu.size):
            current = row_or_col(major, index)

            # Already a complete row/col, skip it
            if all(current):
                continue

            # Generate all posibilities, removing any that we already see
            possibilities = [
                option
                for option in permute_nones(current)
                if (
                    option not in completed
                    and option.count('0') == takuzu.size / 2
                    and option.count('1') == takuzu.size / 2
                    and '000' not in ''.join(option)
                    and '111' not in ''.join(option)
                )
            ]

            # If we have exactly one, set that one
            if len(possibilities) == 1:
                for other_index, value in enumerate(possibilities[0]):
                    if major == 'row':
                        takuzu = takuzu.set(index, other_index, value)
                    else:
                        takuzu = takuzu.set(other_index, index, value)

                return takuzu

    # Never found one
    return False</code></pre>
<p>I'm not nearly as happy with this rule as I am with the other two. Mostly because of the difference between rows and columns, the code is a little strange. The core of it is the <code>permute_nones</code> helper, which will take a list containing some number of <code>None</code> entries and fill them each with either a <code>0</code> or <code>1</code>, generating all possibilities:</p>
<pre class="python"><code>def permute_nones(ls):
    '''Helper function to generate all permutations from filling in 0s and 1s into a list'''

    if ls == []:
        yield []
    elif ls[0]:
        for recur in permute_nones(ls[1:]):
            yield [ls[0]] + recur
    else:
        for value in '01':
            for recur in permute_nones(ls[1:]):
                yield [value] + recur</code></pre>
<p>And that's all of my rules from now. The basic algorithm will be to apply each of those three rules in turn (since even after one has stopped working, another may 'unblock it'). If we get to the point where none of those three rules work, fall back to the backtracker we discussed above:</p>
<pre class="python"><code>RULES = [
    __third_of_a_kind__,
    __fill_rows__,
    __fill_by_duplicates__,
    solvers.backtracker.solve,
]

def solve(takuzu):
    '''Solve a Takuzu puzzle much as a human would: by applying a series of logical rules.'''

    while True:
        updated = False

        # If we've already solved it, return
        if takuzu.is_solved():
            return takuzu

        # Try to apply each rule in turn; if any rule works start over
        for rule in RULES:
            next_takuzu = rule(takuzu)

            if next_takuzu:
                takuzu = next_takuzu
                updated = True
                break

        # If we didn't apply any rule this iteration, done trying
        if not updated:
            break

    return takuzu</code></pre>
<p>Since we don't have to use the much slower (runtime <span>\(O(2^n)\)</span>) backtracking solution for the entire puzzle, this should run significantly faster:</p>
<pre class="python"><code>$ python3 takuzu.py --method human sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.13 seconds

$ python3 takuzu.py --method human sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 37.23 seconds</code></pre>
<p>Okay. So 0.13 seconds isn't <em>that</em> much faster than 0.15 seconds, and 37.23 seconds is only a bit faster than 47.03 seconds. For easier puzzles (those where a human wouldn't have to guess), you'll get a better improvement. These were considered 'hard'.</p>
<p>We can do better though.</p>
<p>Right now, we fall back to a pure backtracking solution rather than the faster human rules if we ever fail to advance. What if we combined the two models? Use the human solution until you get stuck; then advance exactly one step with the backtracking model; then switch back to the human model. If that branch fails, you reset back to the backtracking step, the human steps can be skipped for this.</p>
<p>Let's try it:</p>
<pre class="python"><code>RULES = copy.copy(solvers.human.RULES)
RULES.remove(solvers.backtracker.solve)

def solve(takuzu):
    '''
    Solve a puzzle using a hybrid model.

    Start with the human solver.
    Every time you get stuck, guess at a spot.
    Switch back to the human solver (backtracking to step 2 on failures).
    '''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Try to advance using the human rules until they all fail
        while True:
            updated = False
            for rule in RULES:
                next_takuzu = rule(takuzu)

                if next_takuzu:
                    takuzu = next_takuzu
                    updated = True
                    break

            if not updated:
                break

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # Once they've failed, find one empty spot and try both possibilities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.append(takuzu.set(row, col, value))
                        return
        enqueue()

    return False</code></pre>
<p>So how much does that buy us?</p>
<pre class="python"><code>$ python3 takuzu.py --method hybrid sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.05 seconds

$ python3 takuzu.py --method hybrid sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 0.67 seconds</code></pre>
<p>Hah! That's more like it!</p>
<p>For now, that's it<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span>. If you'd like to see how I structured the code (it's big enough to spread into multiple files), how I parsed command line parameters, or how I dynamically load the various solvers, you can see the entire code on GitHub: <a href="https://github.com/jpverkamp/takuzu">jpverkamp/takuzu</a>.</p>
<p>I like puzzles. Perhaps I'll try <a href="https://en.wikipedia.org/wiki/Suduko">Suduko</a> next. Or maybe <a href="https://en.wikipedia.org/wiki/Hashiwokakero">Hashi puzzles</a><span class="footnote"><sup><a href="#footnote-6">[6]</a></sup></span>. Onwards!<span class="footnote"><sup><a href="#footnote-7">[7]</a></sup></span></p>]]></content></entry><entry><title>Oven sheet omelette</title><link href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette" /><id>urn:uuid:36c66318-9491-65aa-3cab-e1762b4bcf49</id><updated>2015-10-27T00:00:00Z</updated><summary type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
<!--more-->
<p>(Keen-eyed observers will note I may have forgotten the onions...)</p>
<p>And done / partially eaten:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" /></a></p>
<p>It's really easy with only a couple minutes of prep and 15 minutes of waiting time. Nice for when you have only limited supplies and want a breakfasty dish.</p>]]></content></entry><entry><title>The Kane Chronicles</title><link href="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles" /><id>urn:uuid:5fcdb108-3d88-2e8f-19e3-9454cdebeb7a</id><updated>2015-10-23T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a> <a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>Three more down on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. This is the same author (and based on a few hints, the same universe) as <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and before that the Percy Jackson series. Basically, it's the same rough idea, except instead of Greek/Roman mythology, we have Egyptian.</p>
<p>On one hand: Egyptian myths are awesome (and weird). There is a lot to mine from that. On the other: Riordan has told essentially the same core story a dozen times now. It's starting to show.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a> <a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>Three more down on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. This is the same author (and based on a few hints, the same universe) as <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and before that the Percy Jackson series. Basically, it's the same rough idea, except instead of Greek/Roman mythology, we have Egyptian.</p>
<p>On one hand: Egyptian myths are awesome (and weird). There is a lot to mine from that. On the other: Riordan has told essentially the same core story a dozen times now. It's starting to show.</p>
<!--more-->
<p>Overall, I liked them. I thought they were weaker than either Percy Jackson or <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> but still strong enough on their own merits.</p>
<p>Individual reviews:</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a></p>
<p>Red Pyramid would be a lot strong if I hadn't read Percy Jackson.</p>
<p>Don't get me wrong. Red Pyramid is still a fine book, although it feels like it's written for an even younger audience than Percy Jackson.</p>
<p>A few of the downsides:</p>
<ul>
        <li>Red Pyramid is told 'interview style', as if it were a transcribed copy of an audio recording. It would be fine as a framing device, except there are random interjections between the two narrators that each time pulled me out of the story. They're supposed to be 'witty', but I could have done without them.</li>

        <li>The humor feels younger than Percy Jackson. The five elements: Earth, Air, Fire, Water, and ... Cheese. I guess I'm getting old.</li>

        <li>Despite having two narrators, it was hard to tell who's chapter I was reading at times. Riordan did this much better in the Heroes of Olympus.</li>

        <li>The BAD GUYS were BAD just for the sake of BEING BAD. Even from a kid's book, I would like a little more depth. Although I guess there's something to be said for gods playing a role.</li>
</ul>
<p>On a more positive note:</p>
<ul>
        <li>Egyptian mythology is weird! The flavor does play through several points of the story. Where the Greek and Roman gods felt 'human', the Egyptian gods feel weird. That's a good thing. The hieroglyphics in particular were a neat touch.</li>

        <li>There are hints at a shared universe (the western bank belongs to ... others) without it being overbearing. I don't think I would ever like to see a crossover with the Greek/Roman books, but the possibility is neat in and of itself.</li>

        <li>SUMMON BIGGER BAD. The ending was fairly obvious from early on (and once again strongly echoes Percy Jackson), but it did leave me wanting more.</li>
</ul>
<p>Still. A fun read. Relatively quick. I'll finish the series.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a></p>
<p>I don't really have particularly much to add for Throne of Fire that I didn't already say for The Red Pyramid.</p>
<p>Basically, more of the same. The Kanes have five days to save the world (it's impressive how even something like that can start to get old after a dozen novels...). They proceed to do so.</p>
<p>One particularly weird part this time: Sadie takes the time in the second day of the novel to go to Londor for her birthday. The fate of the world hangs in the balance... And you can teleport around the world. You can go to London later.</p>
<p>Another slight downside is that this very much feels like the middle book of a trilogy (which of course it is). It works more to set up the third and final book rather than being able to stand by itself. That doesn't necessarily make it bad, but it's not great when it's that obvious.</p>
<p>On the up side, the cast of characters has expanded a bit with a few new trainee godlings brought into the fold, apparently from that audio recording from the first novel.</p>
<p>Still, it was an entertaining enough read and kept me going enough that I still want to finish the trilogy.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>A solid ending to the series. Once again the world will end in <i>n</i> days and it's up to Sadie and Carter to save that day.</p>
<p>Really, it feels like the second half of The Throne of Fire. We have the same support characters, the same big bad, the same magic, and it doesn't feel like that terribly much time has passed. Honestly, it's not a bad thing; it's just a little bit weird.</p>
<p>One thing I did like is that the climactic battle did actually feel big. It was a bit rushed, but it was nice to see everything coming together in a bunch of ways. The afterwards with the gods withdrawing was odd, but made sense. There there was a paragraph or two dedicated to setting the stage for a potential Percy Jackson crossover. I mentioned in a previous review: it's neat to think about, but I'm not sure how well it could be done.</p>
<p>So far as downsides, really the same as the previous two books. The meta story of being a transcription of an audio recording is weird. I sometimes couldn't tell which sibling I was reading. But it felt a little less bad this time around. Perhaps I just got used to it?</p>
<p>As I've said before: the series isn't quite as good as either the Greek or Roman series, but stand alone it's still certainly enjoyable. I'm glad I read them.</p>
<hr />
<p>Next up, <a href="https://www.goodreads.com/book/show/2429135.The_Girl_with_the_Dragon_Tattoo">The Girl with the Dragon Tattoo</a> by <a href="https://www.goodreads.com/author/show/706255.Stieg_Larsson">Stieg Larsson</a>. Based on the reviews--everyone seems to either love it or hate it--and the genre--I tend not to like stories set in (or that could be set in) the modern real world... I have no idea if I'm going to like it.</p>
<p>We'll find out!</p>]]></content></entry><entry><title>First Birthday Weekend</title><link href="http://blog.jverkamp.com/2015/10/18/first-birthday-weekend" /><id>urn:uuid:ccff63ed-829e-870a-205d-a65987dd55a8</id><updated>2015-10-18T00:00:00Z</updated><summary type="html"><![CDATA[<p>My daughter's first birthday was this weekend. We spent Saturday at Pomponio State Beach and went to a pumpkin seller on Sunday. Lovely fun.</p>
<div><div class="flickr-gallery" data-set-id="72157657717114853" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157657717114853">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>My daughter's first birthday was this weekend. We spent Saturday at Pomponio State Beach and went to a pumpkin seller on Sunday. Lovely fun.</p>
<div><div class="flickr-gallery" data-set-id="72157657717114853" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157657717114853">View on Flickr</a></p></div>]]></content></entry><entry><title>Yosemite</title><link href="http://blog.jverkamp.com/2015/10/09/yosemite" /><id>urn:uuid:01817433-b4d9-cac5-d648-695922174b8b</id><updated>2015-10-09T00:00:00Z</updated><summary type="html"><![CDATA[<p>Back to Yosemite, this time in the fall. A bit drier, but still beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157659203053618" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659203053618">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Back to Yosemite, this time in the fall. A bit drier, but still beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157659203053618" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659203053618">View on Flickr</a></p></div>]]></content></entry><entry><title>Throne of the Crescent Moon</title><link href="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon" /><id>urn:uuid:e6d8363e-1056-6e43-dd61-f350164b74f0</id><updated>2015-10-04T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon"><img src="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon/throne-of-the-crescent-moon.jpg" /></a></p>
<p>I really liked this book.</p>
<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon">Throne of the Crescent Moon</a> (by <a href="https://www.goodreads.com/author/show/4025591.Saladin_Ahmed">Saladin Ahmed</a>) follows a band of somewhat unlikely heroes as they're off to save the day. You have an old ghul hunter (one of the last of his kind), a whirling dervish (I'd never before looked up what that actually meant), an alchemist and her mage of a husband, and a shape shifter who can take the form of a golden lion.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon"><img src="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon/throne-of-the-crescent-moon.jpg" /></a></p>
<p>I really liked this book.</p>
<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon">Throne of the Crescent Moon</a> (by <a href="https://www.goodreads.com/author/show/4025591.Saladin_Ahmed">Saladin Ahmed</a>) follows a band of somewhat unlikely heroes as they're off to save the day. You have an old ghul hunter (one of the last of his kind), a whirling dervish (I'd never before looked up what that actually meant), an alchemist and her mage of a husband, and a shape shifter who can take the form of a golden lion.</p>
<!--more-->
<p>Arrayed against them; a beastie from the time of the dead gods raising a whole bunch of ghuls. Also a corrupt all powerful ruler and the Robin Hood esqe figure who may or may not be any better in the end.</p>
<p>One thing that I really loved about this book: the world. It's based on Arabic influences rather than the pseudo-European that I've seen in most of the fantasy I've read. Better yet, the Arabic influence is woven throughout the story in a way that just makes it come alive. You have sights and sounds and history and magic, all with (to me) a very new feel to it. If you've read a similar selection to me, this is worth reading just for that.</p>
<p>On top of that, I liked the relatively large ensemble cast. Even though we had five main characters and a whole pile of supporting cast (see above), I really thought that each had their own voice and I was greatly amused and intrigued with how each of them interacted with one another.</p>
<p>All together, it's a neat book. Especially after everything shakes out in the end, I wish the sequel were out already (planned release in 2016). What I think I really need is to do is to go find other fantasy novels from non-European authors...</p>
<p>Excellent.</p>
<p>Next up on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>, I'm going to re-read / finish the <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. A combination of Percy Jackson / <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and Egyptian mythology? Count me in!</p>]]></content></entry><entry><title>Burlingame Gardens</title><link href="http://blog.jverkamp.com/2015/10/02/burlingame-gardens" /><id>urn:uuid:c851c1a3-24ea-4554-f678-4a163d4b6fed</id><updated>2015-10-02T00:00:00Z</updated><summary type="html"><![CDATA[<p>Took a walk with a around Burlingame Gardens. All sorts of neat moments.</p>
<div><div class="flickr-gallery" data-set-id="72157659331994936" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659331994936">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Took a walk with a around Burlingame Gardens. All sorts of neat moments.</p>
<div><div class="flickr-gallery" data-set-id="72157659331994936" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659331994936">View on Flickr</a></p></div>]]></content></entry></feed>