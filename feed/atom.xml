<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-10-30T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>Finding EC2 instances by tag</title><link href="http://blog.jverkamp.com/2015/10/30/finding-ec2-instances-by-tag" /><id>urn:uuid:dcd71490-1abf-0503-d116-70fb4eeb29cd</id><updated>2015-10-30T00:00:00Z</updated><summary type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
]]></summary><content type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
<!--more-->
<pre class="python"><code>#!/usr/bin/env python3

import argparse
import boto.ec2
import json
import re
import sys

parser = argparse.ArgumentParser(description = 'Find out information about EC2 instances')
parser.add_argument('--region', default = 'us-west-2', help = 'The AWS region to search')
parser.add_argument('--limit', type = int, default = 1, help = 'How many results to report, 0 will return all')
parser.add_argument('--output', default = 'private_ip_address', help = 'The output to fetch for each instance; json will output a json object will all of the outputs')
parser.add_argument('filters', nargs = argparse.REMAINDER, help = 'Regular expressions to apply to each tag')
args = parser.parse_args()

ec2 = boto.ec2.connect_to_region('us-west-2')

if not args.filters:
    raise Exception('You must specify at least one instance')

def include_instance(instance):
    if instance.state != 'running':
        return

    if not args.filters:
        return instance

    for filter in args.filters:
        for tag_key in instance.tags:
            tag_value = instance.tags[tag_key]
            tag = '{}={}'.format(tag_key, tag_value).lower()

            if re.search(filter, tag_value):
                return instance

def filter():
    for reservation in ec2.get_all_instances():
        for instance in reservation.instances:
            if include_instance(instance):
                yield instance

for i, instance in enumerate(filter(), 1):
    if args.output == 'json':
        print(json.dumps(instance.__dict__, default = str))
    else:
        print(getattr(instance, args.output))

    if args.limit and i &gt;= args.limit:
        break</code></pre>
<p>It's original goal was to get a single IP from a group of servers with a specific tag so that I could log in and poke around:</p>
<pre class="bash"><code>$ ssh &grave;ec2 prod-server&grave;</code></pre>
<p>There are a few other uses though, especially when combined with other tools such as <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.</p>
<pre class="bash"><code>ec2 --limit 0 --output json | jq '.instance_type' | sort | uniq -c | sort -nr

  27 "t2.micro"
   5 "m3.medium"
   1 "c4.xlarge"</code></pre>
<p>That's neat.</p>
<p>Much as <code>who-iam</code> it's a bit slow, but it still works great.</p>
<p>If you'd like to download the script, it's available in my <a href="https://github.com/jpverkamp/dotfiles">dotfiles</a>: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/ec2">ec2</a></p>]]></content></entry><entry><title>Takuzu solver</title><link href="http://blog.jverkamp.com/2015/10/29/takuzu-solver" /><id>urn:uuid:db1688ed-6c5a-fd87-ce8b-71c39075285b</id><updated>2015-10-29T00:00:00Z</updated><summary type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
<!--more-->
<p>First, we need some sort of structure to represent and read in a Takuzu board. I think I'm going to over-engineer a little bit here, since I think it will be helpful in the long run.</p>
<p>My basic idea is to represent it in a way without mutation, that is to say once I've created a board, that board will never change. That will make it easier to write a backtracking solution, since when we need to back up to a previous state, we just throw away any of the derivative boards.</p>
<p>Taking that a level further, let's represent the Takuzu board as a base board with an essentially a 'changelog' on top of it, storing any differences from the boards 'under' it. Something like this:</p>
<pre class="text"><code>....    ..1.    ....    ..1.
0.0. {- .... {- .... == 0.0.
..0.    ....    ....    ..0.
...1    ..1.    .0..    .011</code></pre>
<p>In that diagram, the board on the far left is the first layer, then the second is the next layer up, and the third is the final layer. The fourth image is the virtual board that any user of the program would actually see.</p>
<p>So how do we turn that into code?</p>
<pre class="python"><code>class Takuzu(object):

    def __init__(self, filename = None, parent = None):
        '''
        Represent a Takuzu puzzle (a grid of 0, 1, and .)

        If filename is set, load from file.
        If parent is set, extend that Takuzu puzzle.

        If neither or both is set, that is an error.
        '''

        if not (filename or parent) or (filename and parent):
            raise Exception('Set exactly one of filename and parent')

        self.size = 0
        self.tiles = collections.defaultdict(lambda : False)
        self.parent = False

        if parent:
            self.size = parent.size
            self.parent = parent

        elif filename:
            with open(filename, 'r') as fin:
                for row, line in enumerate(fin):
                    for col, char in enumerate(line.strip()):
                        if char in '01':
                            self.tiles[row, col] = char

                        self.size = col + 1

    def get(self, row = None, col = None):
        '''
        Access a tile in the current puzzle, return False for unset values

        If the current puzzle doesn't have a value set, recur to parents.
        If either row or col is set to None, return that entire row or column.
        If neither is set, return nested lists containing all current values.
        '''

        # Note: We need the ugly != None to correctly deal with row or col = 0.
        # Sometimes truthiness is annoying.

        if row != None and col != None:
            return self.tiles[row, col] or (self.parent and self.parent.get(row, col))
        elif row != None:
            return [self.get(row, col) for col in range(self.size)]
        elif col != None:
            return [self.get(row, col) for row in range(self.size)]
        else:
            return [
                [self.get(row, col) for col in range(self.size)]
                for row in range(self.size)
            ]

    def set(self, row, col, val):
        '''
        Create a child Takuzu object with the specific value set.

        If either row or column is set to None, fill any empty elements in that entire row
        with the given value.
        '''

        child = Takuzu(parent = self)

        if row != None and col != None:
            child.tiles[row, col] = val
        elif row != None:
            for col in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        elif col != None:
            for row in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        else:
            raise Exception('Must set at least one of row and column')

        return child</code></pre>
<p>The interesting bits here are the <code>get</code> and <code>set</code> methods. <code>get</code>, as mentioned, assumes the layered structure above. It will start on the topmost layer (the actual object the program has a reference to) and try to look up the given point. If that fails (we're using a <code>collections.defaultdict</code>, so every reference will either by <code>'0'</code>, <code>'1'</code>, or <code>False</code>), fall back to the next layer up (the <code>parent</code>) until we either find one or run out of <code>parent</code> nodes.</p>
<p>Similarly, <code>set</code> doesn't actually change the current Takuzu object. Instead, it creates a new object with the current one as its parent, setting the new value in the child. This means that any values that were previously set are transparently available in the child, but we can at any point backtrack so long as we keep a reference to the now parent object around.</p>
<p>In addition, I've gone ahead and built in a bit of functionality that I know we're going to need into <code>get</code> and <code>set</code>. In either case, if you only specify either the <code>row</code> or <code>col</code> and leave the other empty (<code>None</code>), then we will return that entire row or column (or <code>set</code> any empty values). That's easy enough to code and it has the advantage of making it easy to compare rows to one another (for the third requirement above).</p>
<p>Okay, up next, we'll probably want a few more helper functions in this class in order to actually tell when we've solved one of these puzzles so the algorithms we eventually write can actually terminate:</p>
<pre class="python"><code>class Takuzu(object):
    ...

    def __eq__(self, other):
        '''Check if two Takuzu puzzles are equal.'''

        for row in range(self.size):
            for col in range(self.size):
                if self.get(row, col) != other.get(row, col):
                    return False

        return True

    def __str__(self):
        '''Return a string representation the same as can be read from a file.'''

        out = ''

        for row in range(self.size):
            for col in range(self.size):
                out += str(self.get(row, col) or '.')
            out += '\n'

        return out

    def is_full(self):
        '''If all values have been filled in.'''

        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    return False

        return True

    def is_valid(self):
        '''Test if the current is still possibly a valid solution. If it also is_full,
        the board is solved.'''

        # Cannot have three identical numbers in a line
        # Ignore unset pieces
        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    continue

                if self.get(row - 1, col) == self.get(row, col) == self.get(row + 1, col):
                    return False

                if self.get(row, col - 1) == self.get(row, col) == self.get(row, col + 1):
                    return False

        # All rows and columns must have no more than the maximum (size/2) number of 0s or 1s
        for index in range(self.size):
            if (
                self.get(index, None).count('0') &gt; self.size / 2
                or self.get(index, None).count('1') &gt; self.size / 2
                or self.get(None, index).count('0') &gt; self.size / 2
                or self.get(None, index).count('1') &gt; self.size / 2
            ):
                return False

        # No two rows or columns can be equal (ignore rows/columns that contain unset values)
        # all(...) on a row or column will be true iff all values are set
        for first_index in range(self.size):
            for second_index in range(first_index):
                if (
                    all(self.get(first_index, None))
                    and all(self.get(None, first_index))
                    and (
                        self.get(first_index, None) == self.get(second_index, None)
                        or self.get(None, first_index) == self.get(None, second_index)
                    )
                ):
                    return False

        # Whee passed all three conditions!
        return True

    def is_solved(self):
        '''Return True iff this puzzle is solved.'''

        return self.is_full() and self.is_valid()</code></pre>
<p><code>__eq__</code> and <code>__str__</code> are 'magic' methods in Python that will define equality and converting this object to a string respectively. This will be nice to make sure we don't investigate the same board more than once later.</p>
<p>After that, we have <code>is_full</code>, <code>is_valid</code>, and <code>is_solved</code><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>. In the first case, we're checking if a puzzle has everything filled in. That way we know if we can stop recurring one way or the other.</p>
<p><code>is_valid</code> is actually a relatively new method. Before that, I could only check if a puzzle <code>is_solved</code>, but this way we can eliminate entire branches of the search space much earlier. For example, as soon as a backtracking solution places the third <code>0</code> in a row, it can stop looking down that path since <code>is_valid</code> will return <code>False</code>. Finally, <code>is_solved</code>. It used to have most of the <code>is_valid</code> code, but once that method existed, a puzzle <code>is_solved</code> simply if both it <code>is_full</code> and it <code>is_valid</code>. Easy enough.</p>
<p>So how do we actually solve a puzzle with this?</p>
<p>Let's start with the simple (relatively speaking, since we've done it before) backtracking solution. Given everything that we have in the Takuzu class, the actual solver is actually really simple:</p>
<pre class="python"><code>def solve(takuzu):
    '''Solve a puzzle using backtracking (also a fall back for the human solver).'''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Otherwise, find one empty spot and try both possiblities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.insert(takuzu.set(row, col, value), 0)
                        return
        enqueue()

    return False</code></pre>
<p>Basically, we keep a stack of solutions, which will allow us to perform a <a href="https://en.wikipedia.org/wiki/depth-first_search">depth-first search</a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>.</p>
<p>Basically, create a branch, trying first a <code>0</code> in the first empty spot. Looking down that path, if we find a solution, we're done. If we don't try a <code>1</code> instead. That's really it. And it's actually relatively fast.</p>
<p>Given the input:</p>
<pre class="test"><code>0..1.0
0.11..
......
......
1..1..
.....0</code></pre>
<p>We can solve it easily enough:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.15 seconds</code></pre>
<p>Nice. (You can check out the <a href="https://github.com/jpverkamp/takuzu">full source</a> if you'd like to see how I'm handling the command line parameters along with a few other goodies.<span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>)</p>
<p>Unfortunately, as puzzles get a bit larger, that runtime isn't so great:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 47.03 seconds</code></pre>
<p>Yeah...</p>
<p>We can do better.</p>
<p>How about instead of trying to solve the puzzle like a computer (brute forcing it), let's apply some heuristics more like a human would solve the puzzle. For example, if we see a pair of 0s next to each other, we know the tile on either side of it is a 1 (likewise for a pair of 0s separated by a single space and said space):</p>
<pre class="python"><code>def __third_of_a_kind__(takuzu):
    '''If adding a value would make three in a row, add the other.'''

    for row in range(takuzu.size):
        for col in range(takuzu.size):
            if takuzu.get(row, col):
                continue

            for ((offset1_row, offset1_col), (offset2_row, offset2_col)) in [
                # Two already in a line
                (( 0,  1), ( 0,  2)),
                (( 0, -1), ( 0, -2)),
                (( 1,  0), ( 2,  0)),
                ((-1,  0), (-2,  0)),
                # Two with a hole in between
                (( 0,  1), ( 0, -1)),
                (( 1,  0), (-1,  0)),
            ]:

                val1 = takuzu.get(row + offset1_row, col + offset1_col)
                val2 = takuzu.get(row + offset2_row, col + offset2_col)

                if val1 and val2 and val1 == val2:
                    return takuzu.set(row, col, invert(val1))

    return False</code></pre>
<p>Basically, for each empty tile in the current puzzle, compare each of six pairs. Either those in the four cardinal directions or the pair on either side horizontally or vertically.</p>
<p>Next rule, let's look for rows where we already have the necessary number of 0s and only need 1s. We can just fill those out:</p>
<pre class="python"><code>def __fill_rows__(takuzu):
    '''If we can figure out how many 0s and 1s we need for each and any row/col needs
    only 0s or 1s, add them'''

    # Try to fill any rows that have all of the needed 0s/1s but not the other
    for index in range(takuzu.size):
        for row, col in [(index, None), (None, index)]:
            for value in '01':
                # Have enough of 'value'
                if takuzu.get(row, col).count(value) == takuzu.size / 2:
                    # Not enough of the other one
                    if takuzu.get(row, col).count(invert(value)) &lt; takuzu.size / 2:
                        return takuzu.set(row, col, invert(value))

    return False</code></pre>
<p>It's neat how short that code is.</p>
<p>Finally (for the moment at least), let's write a slightly more complicated method. This time, let's take a single row or column and generate all the possible ways we can fill it out. Then remove those that would either lead to a duplicate or three in a row. If we have only exactly one row left, then we're golden. That's our row:</p>
<pre class="python"><code>def __fill_by_duplicates__(takuzu):
    '''Fill a puzzle by checking if any rows/cols are near enough to done that only one
    possibility is left.'''

    def row_or_col(which, index):
        if which == 'row':
            return takuzu.get(index, None)
        else:
            return takuzu.get(None, index)

    for major in ('row', 'col'):
        # Completed rows/cols have no Nones (so are 'all')
        completed = filter(all, [
            row_or_col(major, index)
            for index in range(takuzu.size)
        ])

        for index in range(takuzu.size):
            current = row_or_col(major, index)

            # Already a complete row/col, skip it
            if all(current):
                continue

            # Generate all posibilities, removing any that we already see
            possibilities = [
                option
                for option in permute_nones(current)
                if (
                    option not in completed
                    and option.count('0') == takuzu.size / 2
                    and option.count('1') == takuzu.size / 2
                    and '000' not in ''.join(option)
                    and '111' not in ''.join(option)
                )
            ]

            # If we have exactly one, set that one
            if len(possibilities) == 1:
                for other_index, value in enumerate(possibilities[0]):
                    if major == 'row':
                        takuzu = takuzu.set(index, other_index, value)
                    else:
                        takuzu = takuzu.set(other_index, index, value)

                return takuzu

    # Never found one
    return False</code></pre>
<p>I'm not nearly as happy with this rule as I am with the other two. Mostly because of the difference between rows and columns, the code is a little strange. The core of it is the <code>permute_nones</code> helper, which will take a list containing some number of <code>None</code> entries and fill them each with either a <code>0</code> or <code>1</code>, generating all possibilities:</p>
<pre class="python"><code>def permute_nones(ls):
    '''Helper function to generate all permutations from filling in 0s and 1s into a list'''

    if ls == []:
        yield []
    elif ls[0]:
        for recur in permute_nones(ls[1:]):
            yield [ls[0]] + recur
    else:
        for value in '01':
            for recur in permute_nones(ls[1:]):
                yield [value] + recur</code></pre>
<p>And that's all of my rules from now. The basic algorithm will be to apply each of those three rules in turn (since even after one has stopped working, another may 'unblock it'). If we get to the point where none of those three rules work, fall back to the backtracker we discussed above:</p>
<pre class="python"><code>RULES = [
    __third_of_a_kind__,
    __fill_rows__,
    __fill_by_duplicates__,
    solvers.backtracker.solve,
]

def solve(takuzu):
    '''Solve a Takuzu puzzle much as a human would: by applying a series of logical rules.'''

    while True:
        updated = False

        # If we've already solved it, return
        if takuzu.is_solved():
            return takuzu

        # Try to apply each rule in turn; if any rule works start over
        for rule in RULES:
            next_takuzu = rule(takuzu)

            if next_takuzu:
                takuzu = next_takuzu
                updated = True
                break

        # If we didn't apply any rule this iteration, done trying
        if not updated:
            break

    return takuzu</code></pre>
<p>Since we don't have to use the much slower (runtime <span>\(O(2^n)\)</span>) backtracking solution for the entire puzzle, this should run significantly faster:</p>
<pre class="python"><code>$ python3 takuzu.py --method human sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.13 seconds

$ python3 takuzu.py --method human sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 37.23 seconds</code></pre>
<p>Okay. So 0.13 seconds isn't <em>that</em> much faster than 0.15 seconds, and 37.23 seconds is only a bit faster than 47.03 seconds. For easier puzzles (those where a human wouldn't have to guess), you'll get a better improvement. These were considered 'hard'.</p>
<p>We can do better though.</p>
<p>Right now, we fall back to a pure backtracking solution rather than the faster human rules if we ever fail to advance. What if we combined the two models? Use the human solution until you get stuck; then advance exactly one step with the backtracking model; then switch back to the human model. If that branch fails, you reset back to the backtracking step, the human steps can be skipped for this.</p>
<p>Let's try it:</p>
<pre class="python"><code>RULES = copy.copy(solvers.human.RULES)
RULES.remove(solvers.backtracker.solve)

def solve(takuzu):
    '''
    Solve a puzzle using a hybrid model.

    Start with the human solver.
    Every time you get stuck, guess at a spot.
    Switch back to the human solver (backtracking to step 2 on failures).
    '''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Try to advance using the human rules until they all fail
        while True:
            updated = False
            for rule in RULES:
                next_takuzu = rule(takuzu)

                if next_takuzu:
                    takuzu = next_takuzu
                    updated = True
                    break

            if not updated:
                break

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # Once they've failed, find one empty spot and try both possibilities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.append(takuzu.set(row, col, value))
                        return
        enqueue()

    return False</code></pre>
<p>So how much does that buy us?</p>
<pre class="python"><code>$ python3 takuzu.py --method hybrid sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.05 seconds

$ python3 takuzu.py --method hybrid sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 0.67 seconds</code></pre>
<p>Hah! That's more like it!</p>
<p>For now, that's it<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span>. If you'd like to see how I structured the code (it's big enough to spread into multiple files), how I parsed command line parameters, or how I dynamically load the various solvers, you can see the entire code on GitHub: <a href="https://github.com/jpverkamp/takuzu">jpverkamp/takuzu</a>.</p>
<p>I like puzzles. Perhaps I'll try <a href="https://en.wikipedia.org/wiki/Suduko">Suduko</a> next. Or maybe <a href="https://en.wikipedia.org/wiki/Hashiwokakero">Hashi puzzles</a><span class="footnote"><sup><a href="#footnote-6">[6]</a></sup></span>. Onwards!<span class="footnote"><sup><a href="#footnote-7">[7]</a></sup></span></p>]]></content></entry><entry><title>Oven sheet omelette</title><link href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette" /><id>urn:uuid:36c66318-9491-65aa-3cab-e1762b4bcf49</id><updated>2015-10-27T00:00:00Z</updated><summary type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
<!--more-->
<p>(Keen-eyed observers will note I may have forgotten the onions...)</p>
<p>And done / partially eaten:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" /></a></p>
<p>It's really easy with only a couple minutes of prep and 15 minutes of waiting time. Nice for when you have only limited supplies and want a breakfasty dish.</p>]]></content></entry><entry><title>The Kane Chronicles</title><link href="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles" /><id>urn:uuid:5fcdb108-3d88-2e8f-19e3-9454cdebeb7a</id><updated>2015-10-23T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a> <a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>Three more down on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. This is the same author (and based on a few hints, the same universe) as <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and before that the Percy Jackson series. Basically, it's the same rough idea, except instead of Greek/Roman mythology, we have Egyptian.</p>
<p>On one hand: Egyptian myths are awesome (and weird). There is a lot to mine from that. On the other: Riordan has told essentially the same core story a dozen times now. It's starting to show.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a> <a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>Three more down on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. This is the same author (and based on a few hints, the same universe) as <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and before that the Percy Jackson series. Basically, it's the same rough idea, except instead of Greek/Roman mythology, we have Egyptian.</p>
<p>On one hand: Egyptian myths are awesome (and weird). There is a lot to mine from that. On the other: Riordan has told essentially the same core story a dozen times now. It's starting to show.</p>
<!--more-->
<p>Overall, I liked them. I thought they were weaker than either Percy Jackson or <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> but still strong enough on their own merits.</p>
<p>Individual reviews:</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/7090447-the-red-pyramid"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/1-the-red-pyramid.jpg" /></a></p>
<p>Red Pyramid would be a lot strong if I hadn't read Percy Jackson.</p>
<p>Don't get me wrong. Red Pyramid is still a fine book, although it feels like it's written for an even younger audience than Percy Jackson.</p>
<p>A few of the downsides:</p>
<ul>
        <li>Red Pyramid is told 'interview style', as if it were a transcribed copy of an audio recording. It would be fine as a framing device, except there are random interjections between the two narrators that each time pulled me out of the story. They're supposed to be 'witty', but I could have done without them.</li>

        <li>The humor feels younger than Percy Jackson. The five elements: Earth, Air, Fire, Water, and ... Cheese. I guess I'm getting old.</li>

        <li>Despite having two narrators, it was hard to tell who's chapter I was reading at times. Riordan did this much better in the Heroes of Olympus.</li>

        <li>The BAD GUYS were BAD just for the sake of BEING BAD. Even from a kid's book, I would like a little more depth. Although I guess there's something to be said for gods playing a role.</li>
</ul>
<p>On a more positive note:</p>
<ul>
        <li>Egyptian mythology is weird! The flavor does play through several points of the story. Where the Greek and Roman gods felt 'human', the Egyptian gods feel weird. That's a good thing. The hieroglyphics in particular were a neat touch.</li>

        <li>There are hints at a shared universe (the western bank belongs to ... others) without it being overbearing. I don't think I would ever like to see a crossover with the Greek/Roman books, but the possibility is neat in and of itself.</li>

        <li>SUMMON BIGGER BAD. The ending was fairly obvious from early on (and once again strongly echoes Percy Jackson), but it did leave me wanting more.</li>
</ul>
<p>Still. A fun read. Relatively quick. I'll finish the series.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/9067850-the-throne-of-fire"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/2-the-throne-of-fire.jpg" /></a></p>
<p>I don't really have particularly much to add for Throne of Fire that I didn't already say for The Red Pyramid.</p>
<p>Basically, more of the same. The Kanes have five days to save the world (it's impressive how even something like that can start to get old after a dozen novels...). They proceed to do so.</p>
<p>One particularly weird part this time: Sadie takes the time in the second day of the novel to go to Londor for her birthday. The fate of the world hangs in the balance... And you can teleport around the world. You can go to London later.</p>
<p>Another slight downside is that this very much feels like the middle book of a trilogy (which of course it is). It works more to set up the third and final book rather than being able to stand by itself. That doesn't necessarily make it bad, but it's not great when it's that obvious.</p>
<p>On the up side, the cast of characters has expanded a bit with a few new trainee godlings brought into the fold, apparently from that audio recording from the first novel.</p>
<p>Still, it was an entertaining enough read and kept me going enough that I still want to finish the trilogy.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/12893742-the-serpent-s-shadow"><img src="http://blog.jverkamp.com/2015/10/23/the-kane-chronicles/3-the-serpents-shadow.jpg" /></a></p>
<p>A solid ending to the series. Once again the world will end in <i>n</i> days and it's up to Sadie and Carter to save that day.</p>
<p>Really, it feels like the second half of The Throne of Fire. We have the same support characters, the same big bad, the same magic, and it doesn't feel like that terribly much time has passed. Honestly, it's not a bad thing; it's just a little bit weird.</p>
<p>One thing I did like is that the climactic battle did actually feel big. It was a bit rushed, but it was nice to see everything coming together in a bunch of ways. The afterwards with the gods withdrawing was odd, but made sense. There there was a paragraph or two dedicated to setting the stage for a potential Percy Jackson crossover. I mentioned in a previous review: it's neat to think about, but I'm not sure how well it could be done.</p>
<p>So far as downsides, really the same as the previous two books. The meta story of being a transcription of an audio recording is weird. I sometimes couldn't tell which sibling I was reading. But it felt a little less bad this time around. Perhaps I just got used to it?</p>
<p>As I've said before: the series isn't quite as good as either the Greek or Roman series, but stand alone it's still certainly enjoyable. I'm glad I read them.</p>
<hr />
<p>Next up, <a href="https://www.goodreads.com/book/show/2429135.The_Girl_with_the_Dragon_Tattoo">The Girl with the Dragon Tattoo</a> by <a href="https://www.goodreads.com/author/show/706255.Stieg_Larsson">Stieg Larsson</a>. Based on the reviews--everyone seems to either love it or hate it--and the genre--I tend not to like stories set in (or that could be set in) the modern real world... I have no idea if I'm going to like it.</p>
<p>We'll find out!</p>]]></content></entry><entry><title>First Birthday Weekend</title><link href="http://blog.jverkamp.com/2015/10/18/first-birthday-weekend" /><id>urn:uuid:ccff63ed-829e-870a-205d-a65987dd55a8</id><updated>2015-10-18T00:00:00Z</updated><summary type="html"><![CDATA[<p>My daughter's first birthday was this weekend. We spent Saturday at Pomponio State Beach and went to a pumpkin seller on Sunday. Lovely fun.</p>
<div><div class="flickr-gallery" data-set-id="72157657717114853" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157657717114853">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>My daughter's first birthday was this weekend. We spent Saturday at Pomponio State Beach and went to a pumpkin seller on Sunday. Lovely fun.</p>
<div><div class="flickr-gallery" data-set-id="72157657717114853" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157657717114853">View on Flickr</a></p></div>]]></content></entry><entry><title>Yosemite</title><link href="http://blog.jverkamp.com/2015/10/09/yosemite" /><id>urn:uuid:01817433-b4d9-cac5-d648-695922174b8b</id><updated>2015-10-09T00:00:00Z</updated><summary type="html"><![CDATA[<p>Back to Yosemite, this time in the fall. A bit drier, but still beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157659203053618" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659203053618">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Back to Yosemite, this time in the fall. A bit drier, but still beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157659203053618" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659203053618">View on Flickr</a></p></div>]]></content></entry><entry><title>Throne of the Crescent Moon</title><link href="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon" /><id>urn:uuid:e6d8363e-1056-6e43-dd61-f350164b74f0</id><updated>2015-10-04T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon"><img src="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon/throne-of-the-crescent-moon.jpg" /></a></p>
<p>I really liked this book.</p>
<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon">Throne of the Crescent Moon</a> (by <a href="https://www.goodreads.com/author/show/4025591.Saladin_Ahmed">Saladin Ahmed</a>) follows a band of somewhat unlikely heroes as they're off to save the day. You have an old ghul hunter (one of the last of his kind), a whirling dervish (I'd never before looked up what that actually meant), an alchemist and her mage of a husband, and a shape shifter who can take the form of a golden lion.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon"><img src="http://blog.jverkamp.com/2015/10/04/throne-of-the-crescent-moon/throne-of-the-crescent-moon.jpg" /></a></p>
<p>I really liked this book.</p>
<p><a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon">Throne of the Crescent Moon</a> (by <a href="https://www.goodreads.com/author/show/4025591.Saladin_Ahmed">Saladin Ahmed</a>) follows a band of somewhat unlikely heroes as they're off to save the day. You have an old ghul hunter (one of the last of his kind), a whirling dervish (I'd never before looked up what that actually meant), an alchemist and her mage of a husband, and a shape shifter who can take the form of a golden lion.</p>
<!--more-->
<p>Arrayed against them; a beastie from the time of the dead gods raising a whole bunch of ghuls. Also a corrupt all powerful ruler and the Robin Hood esqe figure who may or may not be any better in the end.</p>
<p>One thing that I really loved about this book: the world. It's based on Arabic influences rather than the pseudo-European that I've seen in most of the fantasy I've read. Better yet, the Arabic influence is woven throughout the story in a way that just makes it come alive. You have sights and sounds and history and magic, all with (to me) a very new feel to it. If you've read a similar selection to me, this is worth reading just for that.</p>
<p>On top of that, I liked the relatively large ensemble cast. Even though we had five main characters and a whole pile of supporting cast (see above), I really thought that each had their own voice and I was greatly amused and intrigued with how each of them interacted with one another.</p>
<p>All together, it's a neat book. Especially after everything shakes out in the end, I wish the sequel were out already (planned release in 2016). What I think I really need is to do is to go find other fantasy novels from non-European authors...</p>
<p>Excellent.</p>
<p>Next up on my <a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>, I'm going to re-read / finish the <a href="https://www.goodreads.com/series/49971-kane-chronicles">The Kane Chronicles</a> by <a href="https://www.goodreads.com/author/show/15872.Rick_Riordan">Rick Riordan</a>. A combination of Percy Jackson / <a href="http://blog.jverkamp.com/2015/01/18/the-heroes-of-olympus">The Heroes of Olympus</a> and Egyptian mythology? Count me in!</p>]]></content></entry><entry><title>Burlingame Gardens</title><link href="http://blog.jverkamp.com/2015/10/02/burlingame-gardens" /><id>urn:uuid:c851c1a3-24ea-4554-f678-4a163d4b6fed</id><updated>2015-10-02T00:00:00Z</updated><summary type="html"><![CDATA[<p>Took a walk with a around Burlingame Gardens. All sorts of neat moments.</p>
<div><div class="flickr-gallery" data-set-id="72157659331994936" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659331994936">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Took a walk with a around Burlingame Gardens. All sorts of neat moments.</p>
<div><div class="flickr-gallery" data-set-id="72157659331994936" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157659331994936">View on Flickr</a></p></div>]]></content></entry><entry><title>Writing Excuses 10.8: The Market - Planning</title><link href="http://blog.jverkamp.com/2015/10/01/writing-excuses-10-8-the-market-planning" /><id>urn:uuid:a4616ac5-c914-2560-3b20-675d2a0c5298</id><updated>2015-10-01T00:00:00Z</updated><summary type="html"><![CDATA[<p><strong><a href="http://www.writingexcuses.com/2015/02/22/writing-excuses-10-8-qa-on-character/">Writing Excuses 10.8</a> writing prompt</strong>: <em>Sketch out the events before and after your dead-drop scene from last week and three weeks ago.</em></p>
<hr />
<p><strong>What is in the packages?</strong></p>
<p>Black powder mixed with something that will create lots of smoke. It's an attack on the temple. When the packages are put into the flames (unopened, as is tradition), they will burn through and explode. As small as they are, it won't actually cause much damage, but that's not the point. Rather the point is to create confusion (especially with the smoke) so another agent can sneak into the temple and steal something.</p>
]]></summary><content type="html"><![CDATA[<p><strong><a href="http://www.writingexcuses.com/2015/02/22/writing-excuses-10-8-qa-on-character/">Writing Excuses 10.8</a> writing prompt</strong>: <em>Sketch out the events before and after your dead-drop scene from last week and three weeks ago.</em></p>
<hr />
<p><strong>What is in the packages?</strong></p>
<p>Black powder mixed with something that will create lots of smoke. It's an attack on the temple. When the packages are put into the flames (unopened, as is tradition), they will burn through and explode. As small as they are, it won't actually cause much damage, but that's not the point. Rather the point is to create confusion (especially with the smoke) so another agent can sneak into the temple and steal something.</p>
<!--more-->
<p><strong>Who sent the packages?</strong></p>
<p>The packages at first appear to be from a rival temple of another sun god. The two sun gods have a long rivalry (as might be expected). Both have enough in the terms of miracles that it's hard to prove that either is wrong, but which is the more important is up for grabs.</p>
<p>A further layer down though, the packages are actually from the Baron in charge of the city. He realizes that temple of Actris is growing too powerful, especially with the common people. He wants to play the two of them against one another without showing his own hands in things. Schemes within schemes, plots within plots.</p>
<p><strong>What are they trying to steal?</strong></p>
<p>The goal will be to steal the Staff of the Sun. It's a relic from a Holy War that took place over five centuries ago during the current empire's rise to power. The temple of Actris played a large part in that conflict and the Staff is supposed to have miraculous powers.</p>
<p><strong>Why did they choose who they did to send the packages?</strong></p>
<p>The choice of the noble was another level in the schemes on the part of the Baron. The noble gained his power from trading and is actually richer than the Baron himself (although not quite if you take into account the city's funds as well). Trying to take out a potentially powerful rival is just icing on the cake so far as the Baron is concerned.</p>
<p><strong>What will happen to the golem next?</strong></p>
<p>The golem is the only one of the three that is actually brought in for questioning in regards to this story. He tries to buy a replacement head directly, but finds that he cannot get the funds. So he's forced to return to the guild and ask for a replacement, something that no golem wants to do. They are already in the guild's clutches just by the nature of their existence, but this will require additional sacrifices. In this case, someone saw him deliver one of the packages which caused the chaos at the temple. The guild will look into it.</p>
<p>(Side note: the golem could be the serving girl from the original Shadows and Steam with only minor changes.)</p>
<p><strong>What will happen to the orphan next?</strong></p>
<p>No one seems to know that the orphan was involved in the explosion at the temple of Actris. Instead though, he runs into trouble when he tries to sell the golem's head that he picked up off the street. He doesn't at first, since he just wants to keep the shiny, but eventually he has to. At that point, he tries to sell it to the wrong person (a minor functionary in the Golemancy Guild) who can identify what it was and that there's both no way that the orphan should have it and--by city law--it already belongs to the guild anyways. All golems are guild property.</p>
<p><strong>What will happen to the noble next?</strong></p>
<p>The noble will figure out what is going on in term of the Baron trying to frame him. Initially at least though, he will not be able to figure out the other levels of the plan. Johanas (who is more than meets the eye) keeps subtly helping him behind the scenes for his own reasons, although the noble is oblivious to all of this. He does eventually manage to take power from the Baron, but only temporarily as the rivalry between the two temples of the sun gods erupts into an all out civil war.</p>]]></content></entry><entry><title>Newsflesh Trilogy</title><link href="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy" /><id>urn:uuid:54f77424-fa72-6fad-8d52-4a98f4391fe1</id><updated>2015-09-30T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7094569-feed"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/1-feed.jpg" /></a> <a href="https://www.goodreads.com/book/show/8429687-deadline"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/2-deadline.jpg" /></a> <a href="https://www.goodreads.com/book/show/11806716-blackout"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/3-blackout.jpg" /></a></p>
<p>Onwards and brainwards!</p>
<p>The <a href="https://www.goodreads.com/series/47749-newsflesh">Newsflesh Trilogy</a> by <a href="https://www.goodreads.com/author/show/3153776.Mira_Grant">Mira Grant</a>.</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>.</p>
<p>Brains...</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7094569-feed"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/1-feed.jpg" /></a> <a href="https://www.goodreads.com/book/show/8429687-deadline"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/2-deadline.jpg" /></a> <a href="https://www.goodreads.com/book/show/11806716-blackout"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/3-blackout.jpg" /></a></p>
<p>Onwards and brainwards!</p>
<p>The <a href="https://www.goodreads.com/series/47749-newsflesh">Newsflesh Trilogy</a> by <a href="https://www.goodreads.com/author/show/3153776.Mira_Grant">Mira Grant</a>.</p>
<p><a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>.</p>
<p>Brains...</p>
<!--more-->
<p>I find it vaguely amusing how relatively many zombie series I've read this year. <a href="http://blog.jverkamp.com/2015/03/27/white-trash-zombie">White Trash Zombie</a> (with the next October 6th!). <a href="http://blog.jverkamp.com/2015/03/31/precinct-13">Precinct 13</a>. <a href="http://blog.jverkamp.com/2015/09/18/elantris">Elantris</a> (Yeah--that doesn't really count.) Still, the more the merrier when you're hungry for flesh.</p>
<p>Overall, Newsflesh is an excellent series. Basically, in the future, zombies are here and bloggers have taken over the world. Where these stories really shine is their world building. The zombie plague is an infectious disease and society has changed as a result. It actually feels like something that could just happen, which really helped to draw me into the books.</p>
<p>Also positive, there are a goodly number of plot twists throughout the series. Some are obvious in hindsight, some even in foresight. And some... Ow. Some hit right where it hurts.</p>
<p>Here are my individual reviews. Warning: <strong>spoilers</strong>. Each book's review should be relatively spoiler-free, but it's hard to talk about Deadline and Blackout without spoilers for Feed.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/7094569-feed"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/1-feed.jpg" /></a></p>
<p>Feed follows the story of George (yup), Shaun (also yup), and Buffy (not even kidding), three bloggers covering the story of a lifetime: a Republican Presidential candidate. Then, as it always goes in a zombie story, things go wrong.</p>
<p>I liked the characters. The bloggers are divided into a newsie (tells it like it is), an Irwin (basically the action stars of the blogging world) (yup), and a fictional (writes poetry); missing only a Stewart (satire in the news) (also yup). I really felt for all of them, even if at time they tended a bit towards caricatures of their roles. Also: evil bad guy is evil and obvious, but sometimes that's not a bad thing.</p>
<p>This is also one of the best treatments of a 'realistic' zombie outbreak that I think I've read. Society has mostly adapted to everyone being a carrier with a system of restrictions (no one can go to Yosemite) and near constant blood tests. The CDC is far more powerful and people have adapted to the idea that any mammal over 40 pounds could be your death.</p>
<p>Therein lies the first oddity with this book: Feed doesn't actually feel like a zombie novel. More than anything it feels like a novel about journalism, politics, and freedom of speech... which just so happens to happen during after the zombie apocalypse. It took me a while to realize this, but I think it makes the novel stronger as a result.</p>
<p>And then there's the twists, oh the twists. I get it, it's a zombie story. People are going to die. Just... I didn't see that coming... Wow. That's certainly one way to get me to read the sequel.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/8429687-deadline"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/2-deadline.jpg" /></a></p>
<p>I was curious to see where Grant would take this, after killing off a small pile of main characters in the first book. It turns out: somewhere right between what I expected and what I didn't expect at all.</p>
<p>On one hand, Shaun is crazy now. He hears George's voice in his head and answers her out loud. Everyone around him of course thinks he's crazy, but they mostly seem to give him space. I'm not sure what I think about that. Shaun is still probably my least favorite of the main characters from the first book, which is certainly suboptimal, given that he's the only one to survive... (Also, the Coke fixation is weird.) But why does everyone else keep him around?</p>
<p>On the other hand, the world building continues to be excellent. We get a few neat twists (like what the reservoir conditions might actually mean) and dig a little deeper into the conspiracy behind it all. Given that there's still one more book, we don't get quite as much of that as I'd like, but so it goes. Still though, it feels like Grant really did her homework. The zombie threat feels real. That's saying something.</p>
<p>And then... The ending. One thing I don't care about in second books of trilogies is when they don't have an ending of their own. If Deadline had ended around 80%, it would have been fine. Instead, we get the ALL NEW BIGGER AND BETTER THREAT in the last 20% or so. Don't get me wrong, I really want to know how it all shakes out, but it's still annoying.</p>
<p>And then and then... That last sentence. Say <b>what!?</b></p>
<p>Needless to say, onwards to Blackout.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/11806716-blackout"><img src="http://blog.jverkamp.com/2015/09/30/newsflesh-trilogy/3-blackout.jpg" /></a></p>
<p>A solid ending to a solid series. I think that I liked it more than Deadline, but less than Feed, owing entirely to one thing: George.</p>
<p>Yup, she's back. Literally the last thing that happens in Deadline gets fleshed out (heh) in Blackout as we alternate once again between Shaun's and Georgia's viewpoints. It's fairly obvious what's happened (and a neat extension of what we already know about the zombie virus), but that doesn't mean I was still rooting for her nevertheless.</p>
<p>That being said, her being back complicates Shaun's situation somewhat. He's not any less crazy and as odd as it sounds, his underlings are still just dealing with it. <spoiler>What's more, it's made explicit here that Georgia and Shaun have been sleeping together. I get it, and they're adopted rather than blood siblings, but it still feels a little off.</spoiler></p>
<p>Other than that, it's a solid conclusion to the series. We finally learn who the big bads are--although it's not a huge twist. We get a few more complications with the zombie virus with several nice showdowns across the country. The ending is less 'they all lived happily ever after' and more 'we may just survive this', but given the events of the stories, that's good enough for me. At least it's not a cliffhanger like Deadline...</p>
<p>Overall, great book, great series. Not quite on my list of favorites ever, but I'm glad I read it.</p>
<hr />
<p>Next up, we get a nice fantasy adventure based on Arabic history, rather than the European fantasy I've read piles of: <a href="https://www.goodreads.com/book/show/11487807-throne-of-the-crescent-moon">Throne of the Crescent Moon</a> by <a href="https://www.goodreads.com/author/show/4025591.Saladin_Ahmed">Saladin Ahmed</a></p>
<p>I'm looking forward to it.</p>]]></content></entry></feed>