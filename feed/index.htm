<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2015-12-18T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:b26bbc31-d1d1-3557-055d-3c47073ed3bd</id><entry><title>Advent of Code: Day 18</title><link href="//blog.jverkamp.com/2015/12/18/advent-of-code-day-18" /><id>urn:uuid:51c1619c-25fa-1ae9-d84b-101769bddbc2</id><updated>2015-12-18T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/18">Source</a></p>
<p><strong>Part 1:</strong> Simulate <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. Count how many lights are on after 100 iterations.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/18">Source</a></p>
<p><strong>Part 1:</strong> Simulate <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. Count how many lights are on after 100 iterations.</p>
<!--more-->
<pre class="python"><code>class Grid(object):
    def __init__(self, str):
        self.data = [
            [(char == '#') for char in line]
            for line in str.split()
        ]
        self.width = len(self.data)
        self.height = len(self.data[0])

    def __getitem__(self, pt):
        row, col = pt
        if 0 &lt;= row &lt; self.height and 0 &lt;= col &lt; self.width:
            return self.data[row][col]
        else:
            return False

    def neighbors(self, row, col):
        return sum(
            (1 if self[row + row_delta, col + col_delta] else 0)
            for row_delta in range(-1, 2)
            for col_delta in range(-1, 2)
        ) - (1 if self[row, col] else 0)

    def step(self):
        new_data = copy.deepcopy(self.data)

        for row in range(self.height):
            for col in range(self.width):
                if self[row, col]:
                    new_data[row][col] = (2 &lt;= self.neighbors(row, col) &lt;= 3)
                else:
                    new_data[row][col] = (self.neighbors(row, col) == 3)

        self.data = new_data

    def __repr__(self):
        return '\n'.join(
            ''.join(
                '#' if self[row, col] else '.'
                for col in range(self.width)
            )
            for row in range(self.height)
        )

    def __len__(self):
        return sum(
            1 if self[row, col] else 0
            for row in range(self.height)
            for col in range(self.width)
        )

if __name__ == '__main__':
    grid = Grid(sys.stdin.read())

    for i in range(int(sys.argv[1])):
        grid.step()

    print(grid)
    print(len(grid))</code></pre>
<p>I don't use actually use <a href="https://en.wikipedia.org/wiki/object_oriented programming">object oriented programming</a> that much, but this problem just called for it. It let me abstract away the counting of accessing of elements while dealing with edge cases. Also, it will be even more helpful in part 2<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p>The three interesting bits are the <code>__getitem__</code>, <code>neighbors</code>, and <code>step</code> functions. The first is interesting, since it actually takes a tuple as as argument, but looks like it takes two parameters: <code>grid[row, col]</code> is actually equivalent to <code>grid[(row, col)]</code>, since it's actually the <code>,</code> that makes a tuple, not the parenthesis.</p>
<p>Next, <code>neighbors</code> will count up the positive neighboring elements using <code>__getitem__</code>. We subtract the one at the end if the node is enabled to account for the fact that we counted the node as its own neighbor.</p>
<p>With all of that, <code>step</code> becomes much easier. We just have to loop and using the <code>neighbors</code> function. Shiny.</p>
<p><strong>Part 2:</strong> Repeat, but this time the four lights in the corners will be stuck on.</p>
<p>This is another reason why I wanted to write this in an object oriented style (in highsight):</p>
<pre class="python"><code>part1 = imp.load_source('part1', 'part-1.py')

class FixedCornerGrid(part1.Grid):
    def __getitem__(self, pt):
        row, col = pt
        if (row in (0, self.width - 1) and col in (0, self.height - 1)):
            return True
        else:
            return part1.Grid.__getitem__(self, pt)

if __name__ == '__main__':
    grid = FixedCornerGrid(sys.stdin.read())

    for i in range(int(sys.argv[1])):
        grid.step()

    print(grid)
    print(len(grid))</code></pre>
<p>The weirdness comes from the fact that I for some reason decided to use dashes in my filenames. Otherwise, I could just have done <code>import part1</code>. But other than that, we only have to slightly tweak the <code>__getitem__</code> behavior for the four corners. Other than that, we just directly reuse all of the code from the original <code>Grid</code> class.</p>
<p>I actually really like how this turned out. It brings a slightly new twist to a problem I've solved a half dozen or more times before.</p>]]></content></entry><entry><title>Advent of Code: Day 17</title><link href="//blog.jverkamp.com/2015/12/17/advent-of-code-day-17" /><id>urn:uuid:4af56322-37f0-f74b-baf8-a837b63f521f</id><updated>2015-12-17T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/17">Source</a></p>
<p><strong>Part 1:</strong> Given a list of containers of varying sizes and a total volume to contain, determine how many different combinations of containers match exactly the given volume.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/17">Source</a></p>
<p><strong>Part 1:</strong> Given a list of containers of varying sizes and a total volume to contain, determine how many different combinations of containers match exactly the given volume.</p>
<!--more-->
<pre class="python"><code>containers = list(map(int, sys.stdin.readlines()))
quantity = int(sys.argv[1])

def fills(quantity, containers):
    if quantity == 0:
        yield []
    else:
        for index, container in enumerate(containers):
            if container &lt;= quantity:
                for sub_fill in fills(quantity - container, containers[index+1:]):
                    yield [container] + sub_fill

print(len(list(fills(quantity, containers))))</code></pre>
<p>Basically, <code>fills</code> will recursively build a generator for a given amount and containers remaining. For each step, it will try each of the containers and recursively determine any solutions that use that container.</p>
<p>On interesting aspect is the recursive call uses <code>containers[index+1:]</code>. That will guarantee that the containers used are always in the same order as the input list, rather than including all possible orderings for any set of containers.</p>
<p><strong>Part 2:</strong> How many of these combinations use the minimum number of containers?</p>
<p>The <code>fills</code> function still does what we need; we just need to <code>filter</code> it so that it only includes orderings that are the proper minimum length:</p>
<pre class="python"><code>smallest_fill = min(map(len, fills(quantity, containers)))

print(len(list(filter(
    lambda fill : len(fill) == smallest_fill,
    fills(quantity, containers)
))))</code></pre>]]></content></entry><entry><title>Advent of Code: Day 16</title><link href="//blog.jverkamp.com/2015/12/16/advent-of-code-day-16" /><id>urn:uuid:03ff5f24-7cd0-f74f-d7bd-db34d25cf913</id><updated>2015-12-16T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/16">Source</a></p>
<p><strong>Part 1:</strong> Given a list of target values of the form:</p>
<pre class="text"><code>children: 3
cats: 7
samoyeds: 2</code></pre>
<p>And a list of 'Aunt Sues', each with known values:</p>
<pre class="text"><code>Sue 1: children: 1, cars: 8, vizslas: 7
Sue 2: akitas: 10, perfumes: 10, children: 5
Sue 3: cars: 5, pomeranians: 4, vizslas: 1</code></pre>
<p>Determine which Sue has no unset but matching values.</p>
<p>For example, Sue 1 is invalid because <code>children</code> is 1 versus 3 and Sue 2 because <code>children</code> is 5 versus 3. Given only the values above, Sue 3 would be valid since there are no contradictions.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/16">Source</a></p>
<p><strong>Part 1:</strong> Given a list of target values of the form:</p>
<pre class="text"><code>children: 3
cats: 7
samoyeds: 2</code></pre>
<p>And a list of 'Aunt Sues', each with known values:</p>
<pre class="text"><code>Sue 1: children: 1, cars: 8, vizslas: 7
Sue 2: akitas: 10, perfumes: 10, children: 5
Sue 3: cars: 5, pomeranians: 4, vizslas: 1</code></pre>
<p>Determine which Sue has no unset but matching values.</p>
<p>For example, Sue 1 is invalid because <code>children</code> is 1 versus 3 and Sue 2 because <code>children</code> is 5 versus 3. Given only the values above, Sue 3 would be valid since there are no contradictions.</p>
<!--more-->
<p>I think understanding this problem took longer than solving it. Originally, I thought that missing values should be treated as <code>float('inf')</code>, but they should just be ignored entirely:</p>
<pre class="python"><code>targets = {}
sues = collections.defaultdict(dict)

loading_targets = True
for line in sys.stdin:
    line = line.strip()

    if not line:
        loading_targets = False

    elif loading_targets:
        key, val = line.split(': ')
        targets[key] = int(val)

    else:
        sue, things = line.strip().split(': ', 1)
        for thing in things.split(', '):
            key, val = thing.split(': ')
            sues[sue][key] = int(val)

for sue in sues:
    valid = True

    for key in targets:
        if key in sues[sue] and sues[sue][key] != targets[key]:
            valid = False
            break

    if valid:
        print(sue)</code></pre>
<p>The longer half is correctly parsing and loading the data. For my case, I put both inputs in the same stream, separated by an empty line (similar to <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> and other protocols actually).</p>
<p>After that, it was just a matter of checking each Sue for the first existent but non-matching value.</p>
<p><strong>Part 2:</strong> Repeat the same algorithm, however assume that a Sue must have strictly more <code>cats</code> and <code>trees</code> than listed and strictly less <code>pomeranians</code> and <code>goldfish</code>.</p>
<p>For this, I introduced another <code>defaultdict</code> which contains the <code>comparators</code> to use for any given value:</p>
<pre class="python"><code>comparators = collections.defaultdict(lambda : operator.eq)
comparators['cats'] = comparators['trees'] = operator.gt
comparators['pomeranians'] = comparators['goldfish'] = operator.lt</code></pre>
<p>After that, we can change the <code>for sue in sues</code> loop to take the comparator into account:</p>
<pre class="python"><code>for sue in sues:
    valid = True

    for key in targets:
        if key in sues[sue] and not comparators[key](sues[sue][key], targets[key]):
                valid = False
                break

    if valid:
        print(sue)</code></pre>
<p>Neat.</p>]]></content></entry><entry><title>Advent of Code: Day 15</title><link href="//blog.jverkamp.com/2015/12/15/advent-of-code-day-15" /><id>urn:uuid:cc3ed765-8159-4ad1-c41d-de1fae535ee2</id><updated>2015-12-15T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/15">Source</a></p>
<p><strong>Part 1:</strong> Input is a list of ingredients of the form:</p>
<pre class="text"><code>Frosting: capacity 4, durability -2, flavor 0, texture 0, calories 5
Candy: capacity 0, durability 5, flavor -1, texture 0, calories 8</code></pre>
<p>A recipe score is a product of the positive quantity scores (ignoring calories), where each quantity score is the product of the quantity and that product for each product.</p>
<p>For example, 4 Frosting and 2 Candy above, would have a score of of <code>-2 * 4 + 5 * 2 = 2</code> for durability and <code>0 * 4 + -1 * 2 = -2</code> (and thus ignored as we only accept positive scores) for a total thus far of 2.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/15">Source</a></p>
<p><strong>Part 1:</strong> Input is a list of ingredients of the form:</p>
<pre class="text"><code>Frosting: capacity 4, durability -2, flavor 0, texture 0, calories 5
Candy: capacity 0, durability 5, flavor -1, texture 0, calories 8</code></pre>
<p>A recipe score is a product of the positive quantity scores (ignoring calories), where each quantity score is the product of the quantity and that product for each product.</p>
<p>For example, 4 Frosting and 2 Candy above, would have a score of of <code>-2 * 4 + 5 * 2 = 2</code> for durability and <code>0 * 4 + -1 * 2 = -2</code> (and thus ignored as we only accept positive scores) for a total thus far of 2.</p>
<!--more-->
<p>The code is getting a bit longer, but a brute force solution still works great:</p>
<pre class="python"><code>try:
    TOTAL_QUANTITY = int(sys.argv[1])
except:
    print('Usage: cat input.txt | ./part-1.py [TOTAL_QUANTITY]')
    sys.exit(0)

ingredients = collections.defaultdict(lambda : collections.defaultdict(lambda : 0))
properties = set()

for line in sys.stdin:
    item, pairs = line.split(':')
    for pair in pairs.split(','):
        property, amount = pair.strip().split(' ')
        ingredients[item.lower()][property] = int(amount)
        properties.add(property)

items = list(sorted(ingredients.keys()))
properties.remove('calories')

def calculate_score(quantities):
    score = 1

    for property in properties:
        property_score = sum(
            quantities[item] * ingredients[item][property]
            for item in quantities
        )

        if property_score &gt; 0:
            score *= property_score

    return score

def splits(amount, count):
    if count &lt;= 1:
        yield [amount]
    else:
        for i in range(amount + 1):
            for subsplit in splits(amount - i, count - 1):
                yield [i] + subsplit

best_score = 0
best_quantities = None

for split in splits(TOTAL_QUANTITY, len(items)):
    quantities = dict(zip(items, split))
    score = calculate_score(quantities)

    if score &gt; best_score:
        best_score = score
        best_quantities = quantities

print(best_score)
print(best_quantities)]</code></pre>
<p>Essentially, there are four parts. First, we load all of the ingredients and their scores into memory. Then, <code>calculate_score</code> will take the logic described in the problem and return a score for any given quantities. Third, <code>splits</code> is a generator that will return all possible ways to divide <code>amount</code> items into <code>count</code> buckets:</p>
<pre class="python"><code>print(list(splits(5, 3)))
[[0, 0, 5],
 [0, 1, 4],
 [0, 2, 3],
 [0, 3, 2],
 [0, 4, 1],
 [0, 5, 0],
 [1, 0, 4],
 [1, 1, 3],
 [1, 2, 2],
 [1, 3, 1],
 [1, 4, 0],
 [2, 0, 3],
 [2, 1, 2],
 [2, 2, 1],
 [2, 3, 0],
 [3, 0, 2],
 [3, 1, 1],
 [3, 2, 0],
 [4, 0, 1],
 [4, 1, 0],
 [5, 0, 0]]</code></pre>
<p>Finally, we use all of those pieces to iterate over all of the possible scores. <code>dict(zip(items, split))</code> is a quick way to take two lists (of keys and values) and combine them into a dictionary.</p>
<p>I also tried to work out a solution using a <a href="https://en.wikipedia.org/wiki/genetic_algorithm">genetic algorithm</a>: <a href="https://github.com/jpverkamp/advent-of-code/blob/master/day-15/part-1-genetic.py">part-1-genetic.py</a>. It does work (in that it finds a pretty good solution), but the solution isn't optimal and it takes just as long as just brute forcing the problem. It's interesting though.</p>
<p><strong>Part 2:</strong> Do the same thing, only throw out any solutions that do not have a sum calorie count of exactly 500.</p>
<p>The tweak for this part is actually fairly elegant:</p>
<pre class="python"><code>def calculate_score(quantities):
    ...

    calorie_count = sum(
        quantities[item] * ingredients[item]['calories']
        for item in quantities
    )
    if calorie_count != TOTAL_CALORIES:
        return float("-inf")

    ...</code></pre>
<p>Since we're looking for the largest score, returning a score that is infinitely low will skip over any invalid solutions. Other than that (and a new <code>try</code> block at the top), everything remains the same.</p>
<p>This was an interesting problem. Not quite as elegant a solution as I'd like, but it's still well within my self imposed (originally from Project Euler) 1 minute limit.</p>]]></content></entry><entry><title>Advent of Code: Day 14</title><link href="//blog.jverkamp.com/2015/12/14/advent-of-code-day-14" /><id>urn:uuid:842a50a1-1a7f-6edb-ecb9-efaf989b031f</id><updated>2015-12-14T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/14">Source</a></p>
<p><strong>Part 1:</strong> Given a list of running patterns of the form <code>Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds.</code>, determine who will be in the lead after <code>2503</code> seconds.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/14">Source</a></p>
<p><strong>Part 1:</strong> Given a list of running patterns of the form <code>Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds.</code>, determine who will be in the lead after <code>2503</code> seconds.</p>
<!--more-->
<pre class="python"><code>simulation_time = int(sys.argv[1])
data = {}

for line in sys.stdin:
    name, speed, time, rest = re.match(
        r'(\w+) can fly (\d+) km/s for (\d+) seconds, but then must rest for (\d+) seconds.',
        line
    ).groups()

    data[name] = {
        'speed': int(speed),
        'running_time': int(time),
        'resting_time': int(rest),
        'distance': 0,
        'resting': False,
        'timer': int(time),
    }

for tick in range(1, simulation_time + 1):
    for key in data:
        if data[key]['timer'] == 0:
            data[key]['resting'] = not data[key]['resting']
            data[key]['timer'] = (
                data[key]['resting_time']
                if data[key]['resting']
                else data[key]['running_time']
            )

        if not data[key]['resting']:
            data[key]['distance'] += data[key]['speed']

        data[key]['timer'] -= 1

print(max(
    (data[key]['distance'], key)
    for key in data
))</code></pre>
<p>Originally, I was going to use a <a href="https://en.wikipedia.org/wiki/priority_queue">priority queue</a> for this one. That would have let me put each next event (switching from running to resting or vice versa) in the queue and always pull off the next one to happen. Unfortunately, that made the code path right around stopping a bit complicated, since if one was running at the moment the race ends, they only update partially.</p>
<p>Instead, we just have a simulation that once per second will update the state (when <code>data[key]['timer'] == 0</code>), the distance (when )<code>not data[key]['resting']</code>), and the <code>timer</code>. Relatively straight forward. The one remaining amusing part is the ordering of the two <code>if</code> statements. If they're in the other order, you have an off-by-one problem where you should be running but have already changed state to <code>resting</code>.</p>
<p><strong>Part 2:</strong> Run the same simulation, but after each round award one point to whoever is in first place (one to each in the case of ties). Determine who has the highest score.</p>
<p>For the most part, the code doesn't change. Basically, we're going to add one more field to each entry in <code>data</code>:</p>
<pre class="python"><code>data[name] = {
    ...
    'score': 0,
}</code></pre>
<p>Then we can use the same code that we had earlier to find the highest distance. Unfortunately, we cannot just increment that one because of ties; instead we have to loop:</p>
<pre class="python"><code>for tick in range(1, simulation_time + 1):
  ...

  max_distance, max_name = max((data[key]['distance'], key) for key in data)

  for key in data:
      if data[key]['distance'] == max_distance:
          data[key]['score'] += 1</code></pre>
<p>Then at the end, we print out the maximum <code>score</code> rather than <code>distance</code>.</p>]]></content></entry><entry><title>Advent of Code: Day 13</title><link href="//blog.jverkamp.com/2015/12/13/advent-of-code-day-13" /><id>urn:uuid:3ba54996-2c7e-6568-0680-2a19a63ad1c0</id><updated>2015-12-13T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/13">Source</a></p>
<p><strong>Part 1:</strong> Given a list of seating preferences of the form <code>Alice would gain 54 happiness units by sitting next to Bob.</code> find the seating arrangement which maximizes total happiness.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/13">Source</a></p>
<p><strong>Part 1:</strong> Given a list of seating preferences of the form <code>Alice would gain 54 happiness units by sitting next to Bob.</code> find the seating arrangement which maximizes total happiness.</p>
<!--more-->
<pre class="python"><code>happiness = collections.defaultdict(lambda : collections.defaultdict(lambda : 0))
for line in sys.stdin:
    self, gain_lose, amount, other = re.match(
        r'(\w+) would (gain|lose) (\d+) happiness units by sitting next to (\w+).',
        line
    ).groups()

    amount = int(amount)
    if gain_lose == 'lose':
        amount *= -1

    happiness[self][other] = amount

best_score, best_ordering = max(
    (
        sum(
            happiness[a][b] + happiness[b][a]
            for a, b in zip(ordering, ordering[1:] + (ordering[0],))
        ),
        ordering
    )
    for ordering in itertools.permutations(happiness.keys())
)

print(best_ordering)
print(best_score)</code></pre>
<p>I think I may have over functional'ed this one. <img alt="smile" class="emoji" src="/emoji/smile.svg" /> Basically, we parse everything first into a nested dictionary of happiness scores. Since we always have to add both directions in, it doesn't matter which is which in the indicies so long as it's consistent.</p>
<p>After that, we'll use the same trick as in <a href="//blog.jverkamp.com/2015/12/09/advent-of-code-day-9">Advent of Code: Day 9</a>: calculate pairs of scores and orderings and find the largest one. To specifically calculate the total score, we add the happiness in both directions for every pair of neighbors once again using <code>zip</code>. The only difference is that we add <code>(ordering[0],)</code> back onto the end so that we don't lose the first/last pairing of the list.</p>
<p><strong>Part 2:</strong> Add one more person <code>me</code>, who has a mutual happiness score of ±0 with every other person.</p>
<p>There's not actually terribly much different here, since the <code>happiness</code> structure already contains a default of 0 for any missing user. Because of that, we can just change this line:</p>
<pre class="python"><code>for ordering in itertools.permutations(happiness.keys())</code></pre>
<p>to this:</p>
<pre class="python"><code>for ordering in itertools.permutations(list(happiness.keys()) + ['me'])</code></pre>
<p>It takes a bit longer since the number of permutations grows rather quickly, but still not more than a few seconds total runtime.</p>
<p>Shiny.</p>]]></content></entry><entry><title>Advent of Code: Day 12</title><link href="//blog.jverkamp.com/2015/12/12/advent-of-code-day-12" /><id>urn:uuid:7064b41b-df01-5a75-1da9-ab651b846820</id><updated>2015-12-12T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/12">Source</a></p>
<p><strong>Part 1:</strong> Sum all integer values in a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> object.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/12">Source</a></p>
<p><strong>Part 1:</strong> Sum all integer values in a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> object.</p>
<!--more-->
<pre class="python"><code>def js_sum(js):
    if isinstance(js, dict):
        return sum(map(js_sum, js.values()))
    elif isinstance(js, list):
        return sum(map(js_sum, js))
    elif isinstance(js, int):
        return js
    else:
        return 0

print(js_sum(json.load(sys.stdin)))</code></pre>
<p>Due to the nature of JSON, this is very much a recursive problem. There's really not much else to say. If you have a complex data structure (<code>dict</code> or <code>list</code>), recur into it. Otherwise, if it's a number add it, if not don't.</p>
<p><strong>Part 2:</strong> Do not recur into any <code>dict</code> that contains the value <code>"red"</code>.</p>
<p>Given the structure we already had, the tweak for this is straight forward (if not terribly efficient):</p>
<pre class="python"><code>def js_sum(js):
    if isinstance(js, dict) and not 'red' in js.values():
        return sum(map(js_sum, js.values()))
    elif isinstance(js, list):
        return sum(map(js_sum, js))
    elif isinstance(js, int):
        return js
    else:
        return 0

print(js_sum(json.load(sys.stdin)))</code></pre>]]></content></entry><entry><title>Zoo City</title><link href="//blog.jverkamp.com/2015/12/11/zoo-city" /><id>urn:uuid:328319d3-b13a-d305-4e78-a28bce9b8585</id><updated>2015-12-11T23:55:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7163862-zoo-city"><img src="//blog.jverkamp.com/2015/12/11/zoo-city/zoo-city.jpg" /></a></p>
<p>Basically, in <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> (<a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>), if you kill someone (is that the only way?) you end up with a literal animal manifestation of your guilt. On the plus side, they come with free magical abilities (like the main character's ability to find lost things). On the down side, people know how you got your animal (your zoo) and discrimination is rampant.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7163862-zoo-city"><img src="//blog.jverkamp.com/2015/12/11/zoo-city/zoo-city.jpg" /></a></p>
<p>Basically, in <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> (<a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>), if you kill someone (is that the only way?) you end up with a literal animal manifestation of your guilt. On the plus side, they come with free magical abilities (like the main character's ability to find lost things). On the down side, people know how you got your animal (your zoo) and discrimination is rampant.</p>
<!--more-->
<p>It's a really interesting concept; something that I haven't quite seen anywhere else (The Golden Compass is vaguely similar, at least in the animal companions). And the world is just gritty and dark enough that it felt like a dark echo of what our world could be / have been. Unfortunately, a lot of details are left unclear. What exactly is the Undertow? How do people get which animals? What did the main character actually do to get her Sloth? How different are the animals from their wild brethren?</p>
<p>Unfortunately, as interesting as the world building is, the plot isn't that great. I'll admit, I actually stopped paying as close attention to what was going on about halfway through. Then some more things happened and the story was over and unfortunately I didn't feel any particular urge to go back and figure out how we'd gotten from point B to point Z.</p>
<p>On top of that, I didn't particularly care for the main character. When you open the first few chapters by writing scam emails and stealing people's money, you know there's a bit of an ethical conundrum going on. A character like that can work perfectly well as a main character in a book, but at least for me, you have to work twice as hard for it. Zoo City didn't quite make it.</p>
<p>So it goes. It was interesting enough to read.</p>
<p>Back on track for the final series in my original <a href="//blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/40853-necroscope">Necroscope</a> by <a href="https://www.goodreads.com/author/show/20602.Brian_Lumley">Brian Lumley</a></p>]]></content></entry><entry><title>CSV to JSON</title><link href="//blog.jverkamp.com/2015/12/11/csv-to-json" /><id>urn:uuid:a19dc458-070c-e75e-8fdf-ee6884430831</id><updated>2015-12-11T00:05:00Z</updated><summary type="html"><![CDATA[<p>Today at work, I had to process a bunch of CSV data. Realizing that I don't have any particularly nice tools to work with streaming CSV data (although I did write about <a href="//blog.jverkamp.com/2012/10/04/querying-csv-files-with-sql">querying CSV files with SQL</a>), I decided to write one:</p>
<pre class="bash"><code>$ cat users.csv

"user_id","name","email","password"
"1","Luke Skywalker","luke@rebel-alliance.io","$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq"
"2","Han Solo","han@rebel-alliance.io","$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92"

$ cat users.csv | csv2json | jq '.'

{
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "name": "Luke Skywalker",
  "user_id": "1",
  "email": "luke@rebel-alliance.io"
}
{
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "name": "Han Solo",
  "user_id": "2",
  "email": "han@rebel-alliance.io"
}</code></pre>
]]></summary><content type="html"><![CDATA[<p>Today at work, I had to process a bunch of CSV data. Realizing that I don't have any particularly nice tools to work with streaming CSV data (although I did write about <a href="//blog.jverkamp.com/2012/10/04/querying-csv-files-with-sql">querying CSV files with SQL</a>), I decided to write one:</p>
<pre class="bash"><code>$ cat users.csv

"user_id","name","email","password"
"1","Luke Skywalker","luke@rebel-alliance.io","$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq"
"2","Han Solo","han@rebel-alliance.io","$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92"

$ cat users.csv | csv2json | jq '.'

{
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "name": "Luke Skywalker",
  "user_id": "1",
  "email": "luke@rebel-alliance.io"
}
{
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "name": "Han Solo",
  "user_id": "2",
  "email": "han@rebel-alliance.io"
}</code></pre>
<!--more-->
<p>Luckily, Python has nice CSV and JSON libraries built in:</p>
<pre class="python"><code># If --parse is set, try to parse each entry as json
def parse(thing):
    try:
        return json.loads(thing)
    except:
        return thing

# Assume that headers are the first row
reader = csv.reader(sys.stdin)
headers = None
for row in reader:
    if not headers:
        headers = row
        continue

    if '--parse' in sys.argv:
        row = [parse(thing) for thing in row]

    # Recombine the headers with each row (no one said this was saving space)
    row = dict(zip(headers, row))
    print(json.dumps(row, default = str))</code></pre>
<p>Basically, assume that the first row of the CSV data is headers (converting to a JSON dict doesn't make much sense if it isn't) and then combine that with each additional row to write out a dictionary. In addition, I put a bit of code in there to assume that you might be storing JSON in your CSV fields. If so, you can <code>--parse</code> the data automagically:</p>
<pre class="bash"><code>$ cat users-with-preferences.csv | csv2json --parse | jq '.'

{
  "preferences": {
    "force-user": true
  },
  "name": "Luke Skywalker",
  "user_id": 1,
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "email": "luke@rebel-alliance.io"
}
{
  "preferences": {
    "ship": "Millennium Falcon"
  },
  "name": "Han Solo",
  "user_id": 2,
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "email": "han@rebel-alliance.io"
}</code></pre>
<p>Note that the <code>user_id</code>s are actually numbers, the <code>preferences</code> field has been unpacked, and Luke's <code>force-user</code> status is a boolean. It's neat how you get all of that more or less for free.</p>
<p>Also, have I mentioned how nice <a href="https://stedolan.github.io/jq/">jq</a> is for working with JSON?</p>
<p>And that's it. The full source is part of my dotfiles now: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/csv2json">github:jpverkamp/dotfiles</a> (although all that's missing above is the <a href="https://en.wikipedia.org/wiki/shebang">shebang</a> and the imports). Enjoy!</p>]]></content></entry><entry><title>Advent of Code: Day 11</title><link href="//blog.jverkamp.com/2015/12/11/advent-of-code-day-11" /><id>urn:uuid:3ef4590d-8e71-7616-0cda-b3673c191da9</id><updated>2015-12-11T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/11">Source</a></p>
<p><strong>Part 1:</strong> Find the next string in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical_order</a> that matches these rules:</p>
<ol>
  <li>Must contain three neighboring, ascending letters (<code>ghi</code>)</li>
  <li>Must not contain any of the letters <code>i</code>, <code>o</code>, or <code>l</code></li>
  <li>Must contain two distinct pairs of letters</li>
</ol>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/11">Source</a></p>
<p><strong>Part 1:</strong> Find the next string in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical_order</a> that matches these rules:</p>
<ol>
  <li>Must contain three neighboring, ascending letters (<code>ghi</code>)</li>
  <li>Must not contain any of the letters <code>i</code>, <code>o</code>, or <code>l</code></li>
  <li>Must contain two distinct pairs of letters</li>
</ol>
<!--more-->
<p>This is pretty similar to <a href="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5">Advent of Code: Day 5</a>, although it cannot <em>quite</em> be done with purely regular expressions.</p>
<pre class="python"><code>def is_valid(password):
    numeric = list(map(ord, password))

    return (
        # Include an increasing subsequence
        any(
            numeric[i] + 2 == numeric[i + 1] + 1 == numeric[i + 2]
            for i in range(len(password) - 2)
        )
        # May not contain i, o, or l
        and not any(c in password for c in 'iol')
        # Must have at least two different pairs
        and len(set(re.findall(r'(.)\1', password))) &gt;= 2
    )

def increment(password):
    numeric = list(map(ord, password))
    index = -1

    while True:
        numeric[index] += 1
        if numeric[index] &lt;= ord('z'):
            break
        else:
            numeric[index] = ord('a')
            index -= 1

    return ''.join(map(chr, numeric))

def next_valid(password):
    while True:
        password = increment(password)
        if is_valid(password):
            return password

print(next_valid(sys.argv[1]))</code></pre>
<p>Basically, there are two interesting problems: finding out if a string <code>is_valid</code> and <code>increment</code>ing one to the next value.</p>
<p>For the first, we check each of the three cases in order. We can tell if there is an ascending sequence by first converting to numeric values (<code>ord</code> will return the <a href="https://en.wikipedia.org/wiki/unicode_codepoint">unicode codepoint</a> for a character) the comparing three adjacent values. The second test just checks if <code>any</code> character is <code>in</code> the string. The last actually does use regular expressions again to find all pairs of letters; then, by converting them into a set removes duplicates and counts unique values.</p>
<p>For the second problem (<code>increment</code>), we use the numeric form again and start at the end of the string. We'll increment each character working back towards the front of the string, stopping as soon as we don't have to carry. Then, we convert the password back into a string using the inverse of <code>ord</code>: <code>chr</code>.</p>
<p>And, that's it. It's certainly not the most efficient code, but it still takes only a few seconds.</p>
<p><strong>Part 2:</strong> Find the next string matching the same rules after the one you found in part 1.</p>
<p>Just run the same program again on the first one's input.</p>]]></content></entry></feed>