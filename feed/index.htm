<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2014-11-04T09:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>Clockception</title><link href="http://blog.jverkamp.com/2014/11/04/clockception" /><id>urn:uuid:9a2e2d18-6c68-f33b-e456-aa1c1b531f62</id><updated>2014-11-04T09:00:00Z</updated><summary type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Let's talk about clocks.</p>
<p>We can draw traditional analog clocks<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>We can draw nice digital clocks:</p>
<pre>┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</pre>
<p>Or we can go downright mad and make clocks out of clocks:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>Even animated!</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<!--more-->
<p>I got the basic idea for this post from <a href="http://io9.com/these-stylish-minimalistic-clocks-let-you-tell-time-wit-1652202065">this post</a> on io9. That first clock ought to look awfully familiar (although theirs looks a bit better). Let's see how we can make one of our own.</p>
<p>First, some basic structure:</p>
<pre class="scheme"><code>(struct time-data (hour minute second) #:transparent)

(define (time hour minute [second #f])
  (time-data hour minute second))

(define current-size (make-parameter 30))</code></pre>
<p>This will represent the times that we are dealing with. I specifically broke the <code>time-data</code> structure and <code>time</code> function apart, since I wanted to have optional parameters. There is an <code>#:auto</code> option for struct fields, but it doesn't quite do what I want. Finally, <code>current-size</code> will be the width of each individual analog clock.</p>
<p>Speaking of which, let's draw some basic analog clocks. I went through several different Racket drawing libraries (<code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code>, (<code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>) before finally settling on <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/draw">racket/draw</a></code>. I'm sure any of them could be used, but I just kept running into odd issues with coordinates.</p>
<pre class="scheme"><code>; Render a clock at the current-size
(define (analog-clock when)
  (match-define (time-data hour minute second) when)

  (define size (current-size))
  (define target (make-bitmap size size))
  (define dc (new bitmap-dc% [bitmap target]))

  (send dc set-pen "lightgray" 1 'solid)
  (send dc draw-ellipse 0 0 size size)
  (send dc set-pen "black" 1 'solid)

  ; Helper to draw a hand given a radius [0, 1.0] and angle
  ; Angle of 0 is upright, positive angles are clockwise
  (define (draw-hand! r θ)
    (define c (/ size 2))
    (define x (+ c (* 0.5 r size (cos θ))))
    (define y (+ c (* 0.5 r size (sin θ))))
    (send dc draw-line c c x y))

  (draw-hand! 0.8 (+ (* pi 1.5) (* 2 pi (/ minute 60))))
  (draw-hand! 0.7 (+ (* pi 1.5) (* 2 pi (/ hour 12))))

  (and second
       (begin
         (draw-hand! 0.9 (+ (* pi 1.5) (* 2 pi (/ second 60))))))

  target)</code></pre>
<p>The basic idea of <code>racket/draw</code> is that you have a sort of canvas (<code>target</code>) on which you can draw. You then issue a series of commands that either change your state (<code><a href="http://docs.racket-lang.org/search/index.html?q=set-pen">set-pen</a></code>) or draw (<code><a href="http://docs.racket-lang.org/search/index.html?q=draw-ellipse">draw-ellipse</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=draw-line">draw-line</a></code>). I did abstract a little bit the function to create the clock hands: <code>draw-hand!</code>, mostly so I wouldn't have to redo the centering offset (<code>c</code>, since <code>0,0</code> is in the top left, not the center as I'd hoped) and the <a href="https://en.wikipedia.org/wiki/trigonometry">trigonometry</a> to convert a radius and angle to x and y.</p>
<p>And that's actually all you need to make a basic clock:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 4 10)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Straight forward enough. What's especially neat is that because radians cycle every two 2π rotations, you can put in some crazy times:</p>
<pre class="scheme"><code> &gt; (analog-clock (time 208 -350)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/analog.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/analog.png" /></a></p>
<p>Cool. Okay, next step. Let's figure out how to animate these, so we can transition from one time to another. In this, I had two options. Either I could move as a clock moves (where the minute hand has to move an entire rotation for the hour hand to move 1/12) or independently (such that both hands move at the same speed). Because it's both less code and honestly works better in the final result, I went with the second option:</p>
<pre class="scheme"><code>; Render a sequence of frames animating a clock spinnging from one time to another
; Hands will always move clockwise but will both move at once (not as a normal clock)
(define (analog-frames α β frames)
  (match-define (time-data α-hour α-minute α-second) α)
  (match-define (time-data β-hour β-minute β-second) β)

  (let ([β-hour   (if (&gt;= β-hour α-hour)     β-hour    (+ β-hour 12))]
        [β-minute (if (&gt;= β-minute α-minute) β-minute (+ β-minute 60))]
        [β-second (and α-second β-second
                       (if (&gt;= β-second α-second) β-second (+ β-second 60)))])

    (for/list ([i (in-range frames)])
      (define frame-multiplier (/ i frames))

      (define hour (+ α-hour (* frame-multiplier (- β-hour α-hour))))
      (define minute (+ α-minute (* frame-multiplier (- β-minute α-minute))))

      (define second
        (and α-second β-second
             (+ α-second (* frame-multiplier (- β-second α-second)))))

      (analog-clock (time hour minute second)))))</code></pre>
<p>Basically, we will loop through the frames and interpolate for each frame. The <code>frame-multiplier</code> will range evenly from 0 to 1 over the course of the frames. Also, the <code>let</code> block setting <code>β-hour</code> etc is to make sure that the clocks rotate clockwise. Since the second (<code>β</code>) value will always be higher, we always rotate right.</p>
<p>Okay, next let's switch gears and make some digital clocks. Since the eventual end goal was to make clocks out of clocks, I wanted a nice blocky font, built out of only a few different pieces. That way we could animate it more easily. Luckily the Unicode <a href="https://en.wikipedia.org/wiki/box-drawing_characters">box-drawing characters</a> will do exactly what we need:</p>
<p>I went with a 3x3 character map for each letter:</p>
<pre class="scheme"><code>(define digits
  (vector "┌─┐│ │└─┘" ; 0
          "─┐  │ ─┴─" ; 1
          " ─┐┌─┘└──" ; 2
          "──┐ ─┤──┘" ; 3
          "  │└─┤  │" ; 4
          "┌─ └─┐──┘" ; 5
          "│  ├─┐└─┘" ; 6
          "──┐  │  │" ; 7
          "┌─┐├─┤└─┘" ; 8
          "┌─┐└─┤  │" ; 9
          " │     │ " ; delimiter
          " ○     ○ "))</code></pre>
<p>If you straighten them out, you have things like this for 5 for example:</p>
<pre>┌─
└─┐
──┘</pre>
<p>They're not perfect, but I think they have a certain sort of charm.</p>
<p>Putting that all together, we can loop across all of the digits in the final clock and then each character that makes them up:</p>
<pre class="scheme"><code>; Render a digital clock using ascii bar graphics
(define (digital-clock when)
  (match-define (time-data hour minute second) when)

  (string-join
   (for/list ([line-index (in-range 3)])
     (list-&gt;string
      (for*/list ([digit
                   (in-list
                    (append (list (if (&lt; hour 10) 0 (quotient hour 10))
                                  (remainder hour 10)
                                  10
                                  (if (&lt; minute 10) 0 (quotient minute 10))
                                  (remainder minute 10))
                            (if second
                                (list 10
                                      (if (&lt; second 10) 0 (quotient second 10))
                                      (remainder second 10))
                                (list))))]
                  [char-index (in-range 3)])

        (define str (vector-ref digits digit))
        (define char (string-ref str (+ char-index (* line-index 3))))

        char)))
   "\n"))</code></pre>
<p>It's a bit ugly, but the bulk of the code is to make sure that we have enough digits for numbers less than 10. I bet I could do something nice with string formatting, but it works well enough. An example:</p>
<pre class="scheme"><code>&gt; (digital-clock (time 4 10))
"┌─┐  │ │ ─┐ ┌─┐\n│ │└─┤    │ │ │\n└─┘  │ │ ─┴─└─┘"</code></pre>
<p>Oops.</p>
<pre class="scheme"><code>&gt; (display (digital-clock (time 4 10)))
┌─┐  │ │ ─┐ ┌─┐
│ │└─┤    │ │ │
└─┘  │ │ ─┴─└─┘</code></pre>
<p>Much better.</p>
<p>Okay, now we're at the point of no return. How do we turn a digital clock with that 3x3 font into smaller clocks?</p>
<p>First, we need a map of the bar characters to times:</p>
<pre class="scheme"><code>; Convert the bar images used back into clocks
(define bar-&gt;clock
  (hash #\└ (time 3 0 0)
        #\┘ (time 9 0 0)
        #\┼ (time 6 0 30)
        #\─ (time 3 45 45)
        #\┴ (time 6 45 15)
        #\├ (time 3 0 30)
        #\┤ (time 9 30 0)
        #\┬ (time 6 15 45)
        #\┌ (time 3 30 30)
        #\┐ (time 9 30 30)
        #\│ (time 12 30 30)
        #\○ #f
        #\space #f))</code></pre>
<p>These could probably use a little more tuning. But what this does allow us to make is a very simple function to make a clock out of clocks:</p>
<pre class="scheme"><code>(define timeless (make-parameter (time 12 0 0)))

; Make a clock out of clocks!
(define (clock-clock when)
  (define chars (digital-clock when))
  (define empty-frame (analog-clock (timeless)))

  (define rows
    (for/list ([line (in-list (string-split chars "\n"))])
      (for/list ([char (in-string line)])
        (cond
          [(hash-ref bar-&gt;clock char) =&gt; analog-clock]
          [else empty-frame]))))

  (apply above (map (curry apply beside) rows)))</code></pre>
<p>In use:</p>
<pre class="scheme"><code> &gt; (clock-clock (time 4 10)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png"><img src="http://blog.jverkamp.com/2014/11/04/clockception/clockception.png" /></a></p>
<p>That right there is actually one of the parts of programming I love the most. Where you write a small pile of functions, each of which does one specific piece and then when you finally get to the big overall algorithm... bam. Simple.</p>
<p>But... back to being a little more complicated. How do we do the transition from one <code>clock-clock</code> to another? It would be nice if we could use the previous function, but we really can't. A similar idea will work though:</p>
<pre class="scheme"><code>; Animate a clock of clocks turning from one time to another
(define (tick-tock α β frames)
  (define α-chars (digital-clock α))
  (define β-chars (digital-clock β))

  (define rows*
    (for/list ([α-line (in-list (string-split α-chars "\n"))]
               [β-line (in-list (string-split β-chars "\n"))])
      (for/list ([α-char (in-string α-line)]
                 [β-char (in-string β-line)])
        (analog-frames (or (hash-ref bar-&gt;clock α-char) (timeless))
                       (or (hash-ref bar-&gt;clock β-char) (timeless))
                       frames))))

  (for/list ([i (in-range frames)])

    (define rows
      (for/list ([row (string-split α-chars "\n")]
                 [row-index (in-naturals)])
        (for/list ([char-index (in-range (string-length row))])
          (list-ref (list-ref (list-ref rows* row-index) char-index) i))))

    (apply above (map (curry apply beside) rows))))</code></pre>
<p>Basically, we have two steps. First we define <code>rows*</code> by generating each of the subclocks for each of the intermediate times. Then, that last is in the wrong order (indexed by row, column, then frame, rather than frame, row, then column) so we unpack it and put it back together. This is pretty terribly inefficient, but there will only ever be 3 rows and up to 20 columns, so it's not that bad.</p>
<p>With that, we can make simple animations:</p>
<pre class="scheme"><code>&gt; ; Fix bitmaps so that big-bang / run-movie / etc can render them
&gt; (define (fix img) (rotate 0 img))
&gt; (run-movie 0.1 (tick-tock (time 7 59) (time 8 0) 56))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif"><img src="http://blog.jverkamp.com/2014/11/04/clockception/animated.gif" /></a></p>
<p>I really wish that <code>fix</code> wasn't necessary, but for whatever reason, <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> / <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> / et al don't like <code><a href="http://docs.racket-lang.org/search/index.html?q=bitmap%">bitmap%</a></code>s. So it goes.</p>
<p>On the other hand though, <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is really cool. I've been doing things like this with <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> and the <code>stop-when</code> parameter, but this just needs a list of images and stops automatically. Another tool for my toolchest!</p>
<p>Okay, one more step. I know I just said <code><a href="http://docs.racket-lang.org/search/index.html?q=run-movie">run-movie</a></code> is the new shiny, but let's step back to <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> for a second. Given that we have a clock made of clocks, what would it take to actually render it in real time?</p>
<pre class="scheme"><code>; Make a tick-tock real time clock
(define (tick-tock-real-time-clock #:12-hour? [12-hour? #f])
  ; Get the current time in hours/minutes/seconds
  (define (now)
    (define date (current-date))
    (time (date-hour date) (date-minute date) #f))

  ; Generate a list of frames for the next transition
  ; Note: The big bang clock is supposed to tick 28 times per second
  (define (transition-frames)
    (match-define (time-data hour minute _) (now))

    (define next-minute (remainder (+ minute 1) 60))
    (define next-hour (remainder (if (= next-minute 60) (+ hour 1) hour) (if 12-hour? 12 24)))

    (tick-tock (time hour minute)
               (time next-hour next-minute)
               56)) ; Note: The big bang clock is supposed to
                    ; tick 28 times per second

  (big-bang (list (now) (transition-frames))
    [on-tick
     (λ (state)
       (match-define (list old-time frames) state)
       (define new-time (now))
       (cond
         ; We've advanced to the new time, jump ahead!
         [(not (equal? old-time new-time))
          (list new-time (transition-frames))]
         ; Freeze if we only have one frame left
         [(null? (rest frames))
          state]
         ; Otherwise, advance one frame
         [else
          (list old-time (rest frames))]))]
    [to-draw
     (λ (state)
       (match-define (list old-time frames) state)
       (fix (first frames)))]))</code></pre>
<p>Now that is a cool function. Basically, each minute we will generate the frames that will be used by the transition. Since <code>big-bang</code> runs at 28 frames per second, the 56 frames will takes 2 seconds to animate. Each minute, the next transition will be generated and then ticked down one frame at a time until only one is left, at which point we will just wait. Neat!</p>
<p>Originally I had it rendering seconds as well, but it was just a little bit too jittery. So minutes it is! I can't really do this thing justice in a gif (it actually looks just like <code>tick-tock</code> above, just with the current time), but it's still pretty cool.</p>
<p>And... that's it. Clocks made of clocks. Who would have thought? As always, the full code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/clockception.rkt">clockception.rkt</a></p>]]></content></entry><entry><title>NaNoWriMo 2014</title><link href="http://blog.jverkamp.com/2014/11/04/nanowrimo-2014" /><id>urn:uuid:15725cb2-faf4-5f17-7929-11afd884acc7</id><updated>2014-11-04T00:00:00Z</updated><summary type="html"><![CDATA[<p>Yup. Even with a new baby around, I'm mad enough to do it.</p>
<p><a data-toggle="lightbox" href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>So far I've been keeping up 2000 words per day, but I'm already starting to feel a drag. It just feels like the same sort of story I've written before... We'll see in the next day or two if I try to reboot or just go with it.</p>
<p>I haven't yet decided if I'm going to publish them online this year. It's good motivation and I know at least a few of you out there read it. We'll see. If I do, it won't be daily, but rather after finishing each chapter. So every 2-4 days?</p>
<p>Wish me luck!</p>]]></summary><content type="html"><![CDATA[<p>Yup. Even with a new baby around, I'm mad enough to do it.</p>
<p><a data-toggle="lightbox" href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>So far I've been keeping up 2000 words per day, but I'm already starting to feel a drag. It just feels like the same sort of story I've written before... We'll see in the next day or two if I try to reboot or just go with it.</p>
<p>I haven't yet decided if I'm going to publish them online this year. It's good motivation and I know at least a few of you out there read it. We'll see. If I do, it won't be daily, but rather after finishing each chapter. So every 2-4 days?</p>
<p>Wish me luck!</p>]]></content></entry><entry><title>I, Frankenstein (DVD)</title><link href="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd" /><id>urn:uuid:bede8e25-5906-da31-f610-01d2fcbb7529</id><updated>2014-11-01T00:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd/i-frankenstein.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd/i-frankenstein.jpg" /></a></p>
<p>Wait, is it <a href="http://www.imdb.com/title/tt0320691/?ref_=fn_al_tt_1">2003 again</a>?</p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd/i-frankenstein.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd/i-frankenstein.jpg" /></a></p>
<p>Wait, is it <a href="http://www.imdb.com/title/tt0320691/?ref_=fn_al_tt_1">2003 again</a>?</p>
<!--more-->
<p>We have a fairly straight forward urban fantasy action flick with <del>vampires</del> demons and <del>werewolves</del> gargoyles squaring off in a war that's been raging for years<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> Then there's the odd man out, one of a kind and more powerful than either of the main groups so of course everyone is looking for him. Seems awfully formulaic all around.</p>
<p>Don't get me wrong of course, it's still a solid action movie. The fights are beautiful to behold, even on the small screen. The fireworks when a gargoyle or demon is <del>killed</del> ascended/descended<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> are a sight to behold, really lighting up the otherwise thematically dark world.</p>
<p>On top of that, I really like seeing <a href="http://www.imdb.com/name/nm0631490/?ref_=tt_cl_t4">Bill Nighy</a> as <del>Viktor</del> Naberius and <a href="http://www.imdb.com/name/nm0340485/?ref_=tt_cl_t14">Kevin Grevioux</a> switches sides this time around as <del>Raze</del> Dekar. <a href="http://www.imdb.com/name/nm0001584/?ref_=tt_cl_t3">Miranda Otto</a> does a much better job (at least in my opinion) than her outing in the Lord of the Rings.</p>
<p>On the downside, the dialog is pretty bad. The world building is just weird at times (why gargoyles?). For a planet of 7 billion people, I could just about count the number of times a real flesh and blood human appears on one hand<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>. And if the demons can collect that many bodies... Why are they still in hiding?</p>
<p>I will give them one bit of credit at least. It's a personal nit of mine when people use the name Frankenstein to apply to the monster. While there's something to be said for a family name being passed on, Frankenstein is the creator. At least in I, Frankenstein, they have Naberius <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/LampshadeHanging">hang a lamp on it</a>.</p>
<p>Still. It's an okay action movie and it is really pretty. I'm glad that they took a chance at least on something a little outside of the normal tropes. If you've got a spare weekend and want to just veg for an hour and a half, this isn't a bad film for it.</p>
<div><h3 class="ranking-title">2014 Movie Rankings</h3><ol><li><a href="http://blog.jverkamp.com/2014/02/15/the-lego-movie">The Lego Movie</a></li><li><a href="http://blog.jverkamp.com/2014/04/05/captain-america-the-winter-soldier">Captain America: The Winter Soldier</a></li><li><a href="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd">Edge of Tomorrow (DVD)</a></li><li><a href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy">Guardians of the Galaxy</a></li><li><a href="http://blog.jverkamp.com/2014/06/08/x-men-days-of-future-past">X-Men: Days of Future Past</a></li><li><a href="http://blog.jverkamp.com/2014/06/14/maleficent">Maleficent</a></li><li><a href="http://blog.jverkamp.com/2014/11/01/i-frankenstein-dvd">I, Frankenstein (DVD)</a></li><li><a href="http://blog.jverkamp.com/2014/07/26/lucy">Lucy</a></li><li><a href="http://blog.jverkamp.com/2014/05/10/the-amazing-spider-man-2">The Amazing Spider-Man 2</a></li><li><a href="http://blog.jverkamp.com/2014/03/29/divergent">Divergent</a></li></ol></div>]]></content></entry><entry><title>Tile Puzzle</title><link href="http://blog.jverkamp.com/2014/10/28/tile-puzzle" /><id>urn:uuid:073afc5c-1121-544c-5879-486d124edb3c</id><updated>2014-10-28T00:00:00Z</updated><summary type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
]]></summary><content type="html"><![CDATA[<p>It's been a while<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but I'm back. Today's post is inspired by a post from /r/dailyprogrammer almost a month ago now: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ip1gj/10082014_challenge_183_intermediate_edge_matching/">Challenge #183 [Intermediate] Edge Matching Tile Puzzle</a>. Basically, we're going to solve puzzles like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>If you look carefully, the tiles are the same between the two, although they might be rotated.</p>
<!--more-->
<p>Okay, let's start at the beginning. How are we going to represent a puzzle? Well, let's go with the same basic idea that was described in the original post: sets of four letters (in the order north, east, south, west), one for each tile. Furthermore, the letters represent color. Originally CMYK for cyan, magenta, yellow, and black, but we'll also add RGB for red, green, and blue (it's easy enough to add colors). Next, we'll use upper case and lower case letters in order to represent the two halves of a matching image.</p>
<p>So take the unsolved image above:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-3x3.png" /></a></p>
<p>The first tile would be described as <code>cymK</code> for three circles and one rectangle. Continuing on, the entire puzzle would be:</p>
<pre class="scheme"><code>'("cymK" "KyCy" "ymkc" "mkYc" "MycK" "mCkY" "cmKY" "KYmC" "McMk")</code></pre>
<p>Now we'll want two helper functions:</p>
<pre class="scheme"><code>; Insert an item into the given location in a list
(define (insert-at ls item x)
  (for/list ([i (in-naturals)]
             [el (in-list ls)])
    (if (= x i) item el)))

; Return a list of all rotated versions of a string
(define (rotations str)
  (for/list ([i (in-range (string-length str))])
    (string-append (substring str i) (substring str 0 i))))</code></pre>
<p>Specifically, the first function allows us to insert a tile into a specified location in a list, while the second returns all possible rotations of our four character string. All around, things are going to be a little inefficient because we're working with lists rather than directly accessing something like a vector, but since the size of the puzzle is so small, the cost for these functions will be relatively cheap (especially compared to the crazy number of possible orderings of the tiles).</p>
<p>Okay, with that, we actually have enough of a framework to work out our solution. The basic plan of attack will be very much the same as when we worked on the <a href="http://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens">N Queens Puzzle</a>. Place each piece in order, backtracking as soon as we see a valid solution. This way we can cut out huge swaths of the potential solution space.</p>
<pre class="scheme"><code>; Solve a puzzle by ordering pieces so that they match
(define (solve puzzle)
  ; Start with an empty solution space (all null) and a list of pieces to place
  (let loop ([solution (make-list (length puzzle) "\0\0\0\0")]
             [to-place puzzle]
             [index    0])
    (cond
      ; If we've filled in all of the pieces, we have a solution
      [(= index (length puzzle))
       solution]
      ; Otherwise, try each piece, only recurring for those that fit
      ; Return the first that solves the puzzle from here,
      ; by recursion this will be a full solution
      [else
       (for*/first ([next-item (in-list to-place)]
                    [next-item-rotated (in-list (rotations next-item))]
                    [next-puzzle (in-value (insert-at solution
                                                      next-item-rotated
                                                      index))]
                    #:when (valid? next-puzzle)
                    [recur (in-value (loop next-puzzle
                                           (remove next-item to-place)
                                           (+ index 1)))]
                    #:when recur)
         recur)])))</code></pre>
<p>Basically there are two interesting parts: the <code>let loop</code> and the <code>for*/first</code> block. The main <code>loop</code> is the primary bit of the recursion. At any particular step, we have the solution that we've built thus far. We'll start with all <code>\0</code> strings (which we'll special case in <code>valid?</code>) and then fill in puzzle pieces one at a time. <code>to-place</code> will hold the pieces we've yet to place. The <code>index</code> is used primarily to insert new pieces at the proper location.</p>
<p>Next, we have the <code>for*/first</code> loop. This is designed to clean up the search, basically by returning the first recursion that makes it through all of the lists and conditionals. Specifically, we're going to do all of the following:</p>
<ul>
  <li>Loop through all remaining pieces to place as <code>next-item</code></li>
  <li>For each piece, try each rotation in turn</li>
  <li>Generate the <code>next-puzzle</code> by inserting that piece</li>
  <li>Check that the new insertion is <code>valid?</code></li>
  <li>Recur with the newly placed piece removed</li>
  <li>If there's a valid solution, continue to the body of the loop (and thus return, since we're looking for the <code>first</code>)</li>
</ul>
<p>All that combines (with the power of recursion!) to solve the puzzle:</p>
<pre class="scheme"><code>&gt; (solve '("cymK" "KyCy" "ymkc"
           "mkYc" "MycK" "mCkY"
           "cmKY" "KYmC" "McMk"))
'("cymK" "mCkY" "ymkc"
  "McMk" "KYmC" "KyCy"
  "mkYc" "MycK" "cmKY")</code></pre>
<p>Of course that's a little hard to see what in the world is going on. Let's write a few functions using Racket's <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code> library. First, a <code><a href="http://docs.racket-lang.org/search/index.html?q=parameter">parameter</a></code> to control how large each tile will be and a pair of functions to decode the letters into colors / shapes:</p>
<pre class="scheme"><code>(define current-tile-size (make-parameter 50))

(define (char-&gt;color c)
  (case c
    [(#\R #\r) "red"]
    [(#\G #\g) "green"]
    [(#\B #\b) "blue"]
    [(#\C #\c) "cyan"]
    [(#\M #\m) "magenta"]
    [(#\Y #\y) "yellow"]
    [(#\K #\k) "black"]
    [else      "white"]))

(define (char-&gt;shape c)
  (case c
    [(#\R #\G #\B #\C #\M #\Y #\K) filled-rectangle]
    [(#\r #\g #\b #\c #\m #\y #\k) filled-ellipse]
    [(#\null)                      (λ _ (filled-rectangle 0 0))]))</code></pre>
<p>With those, we can render an individual tile:</p>
<pre class="scheme"><code>; Render a single tile given a four character specifier
; Order is top, right, bottom, left
; Colors are cyan, magenta, yellow, red, green, blue, black (k for black)
; Uppercase are square, lowercase are circular
(define (render-tile tile)
  (match-define (list top right bottom left) (string-&gt;list tile))

  ; Size of the individual images
  (define quad-size (quotient (current-tile-size) 3))

  ; Offsets for pinning, zero/half/full size adjusted for quad size
  (define zs (- (quotient quad-size 2)))
  (define hs (- (quotient (current-tile-size) 2) (quotient quad-size 2)))
  (define fs (- (current-tile-size) (quotient quad-size 2)))

  ; Helper function to render a specific shape of the specific color
  (define (shape c)
    (colorize ((char-&gt;shape c) quad-size quad-size)
              (char-&gt;color c)))

  ; Construct the image by layering each of the four sides on the base
  (let* ([pict (rectangle (current-tile-size) (current-tile-size))]
         [pict (pin-under pict hs zs (shape top))]
         [pict (pin-under pict fs hs (shape right))]
         [pict (pin-under pict hs fs (shape bottom))]
         [pict [pin-under pict zs hs (shape left)]])
    (clip pict)))</code></pre>
<p>One part that took a bit here was getting the <code>zs</code>, <code>hs</code>, and <code>fs</code> functions correct. Since coordinates are based on the top left corner of each subimage, we need to correctly offset by half of the image sizes for each of the halfway points. Also, make sure you use the <code><a href="http://docs.racket-lang.org/search/index.html?q=clip">clip</a></code> function. It will look fine with just a single tile if you do not use it, but once you start merging them... Strange things happen.</p>
<p>Demo time:</p>
<pre class="scheme"><code> &gt; (render-tile "cymK") </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/single-tile-cymK.png" /></a></p>
<p>Nice!</p>
<p>Next, we can combine the <code>picts</code> into a single larger <code>pict</code>:</p>
<pre class="scheme"><code>; Render a puzzle of multiple tiles
; Puzzles are assumed to be square
(define (render puzzle)
  (define width (integer-sqrt (length puzzle)))

  (define tiles
    (for/list ([y (in-range width)])
      (for/list ([x (in-range width)])
        (render-tile (list-ref puzzle (+ x (* y width)))))))

  (define rows
    (map (λ (row) (apply (curry hc-append -1) row)) tiles))

  (apply (curry vc-append -1) rows))</code></pre>
<p>Bam:</p>
<pre class="scheme"><code>&gt; (render (solve '("cymK" "KyCy" "ymkc"
                   "mkYc" "MycK" "mCkY"
                   "cmKY" "KYmC" "McMk")))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-3x3.png" /></a></p>
<p>Neat! We can try it on larger puzzles as well:</p>
<p>...</p>
<p>Okay, that takes a really long time. Perhaps a 4x4 with more colors (more colors is actually easier to solve since there are less valid placements for each tile):</p>
<pre class="scheme"><code>&gt; (define p4x4 (random-puzzle 4 #:colors 7))
&gt; p4x4
'("yyMY" "mCKM" "Cgrr" "BMMy"
  "MrYB" "mGYK" "BRyG" "gRmc"
  "KCCm" "cyby" "mYbY" "BMcB"
  "Bmbm" "kbrr" "MkYc" "ybGY")
&gt; (render p4x4)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/unsolved-4x4.png" /></a></p>
<pre class="scheme"><code>&gt; (define p4x4-solution (solve p4x4))
&gt; p4x4-solution
'("rCgr" "BBMc" "YmYb" "yBMM"
  "GBRy" "mBmb" "ycyb" "mKCC"
  "rkbr" "MmCK" "YyyM" "cMkY"
  "BMrY" "cgRm" "YybG" "KmGY")
&gt; (render p4x4-solution)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png"><img src="http://blog.jverkamp.com/2014/10/28/tile-puzzle/solved-4x4.png" /></a></p>
<p>Shiny. :)</p>
<p>For those interested, here's how I generated random puzzles:</p>
<pre class="scheme"><code>; Generate random puzzles
(define (random-puzzle size #:colors [colors 4])
  ; Generate n+1 intersections (including those off the edges)
  ; Each value is the top left corner of a tile with the right then down edge
  (define intersections
    (for/list ([y (in-range (+ size 1))])
      (for/list ([x (in-range (+ size 1))])
        (for/list ([which (in-list '(right down))])
          (list (string-ref "CMYKRGB" (random (min colors 7)))
                (if (= 0 (random 2)) 'normal 'inverse))))))

  (define (@ x y w invert?)
    (match-define (list char mode)
      (list-ref (list-ref (list-ref intersections y) x)
                (if (eq? w 'right) 0 1)))

    ((if (xor invert? (eq? mode 'inverse))
         char-downcase
         identity)
     char))

  ; Fill out the tiles
  (shuffle
   (for*/list ([y (in-range size)]
               [x (in-range size)])
     (string (@ x       y       'right #f)
             (@ (+ x 1) y       'down  #f)
             (@ x       (+ y 1) 'right #t)
             (@ x       y       'down  #t)))))</code></pre>
<p>And that's it. Surprisingly simple<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> to solve, a little more to render. I love problems like this. :)</p>
<p>If you really want to go off the deep end though and, go download the full source from GitHub (<a href="https://github.com/jpverkamp/small-projects/blob/master/blog/tile-puzzles.rkt">tile-puzzles.rkt</a>). Therein lies solutions for using <a href="https://en.wikipedia.org/wiki/simulated_annealing">simulated annealing</a> or <a href="https://en.wikipedia.org/wiki/genetic_algorithms">genetic algorithms</a> in an effort to solve the problem more <a href="https://en.wikipedia.org/wiki/heurisitically">heurisitically</a>, but neither is working particularly well as of yet. If you want to take one of those and finish it up, I'd love to see it.</p>]]></content></entry><entry><title>Edge of Tomorrow (DVD)</title><link href="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd" /><id>urn:uuid:0be2bd6f-53c6-4a18-9ecb-4d77175a7354</id><updated>2014-10-28T00:00:00Z</updated><summary type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd/edge-of-tomorrow.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd/edge-of-tomorrow.jpg" /></a></p>
<p>Disclaimer time: I have a full time job now. And a baby at home. Some combination of these things means that I have nowhere near as much time to go see movies as I once did. So it goes.</p>
<p>But rather than let this particular part of my blog go to waste, I think that I'll go ahead and keep writing up movies. Just instead of movies in theaters, I'll aim for new releases on DVD / VOD.</p>
<p>Why?</p>
<p>Edge of Tomorrow.</p>
]]></summary><content type="html"><![CDATA[<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd/edge-of-tomorrow.jpg" class="pull-left"><img src="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd/edge-of-tomorrow.jpg" /></a></p>
<p>Disclaimer time: I have a full time job now. And a baby at home. Some combination of these things means that I have nowhere near as much time to go see movies as I once did. So it goes.</p>
<p>But rather than let this particular part of my blog go to waste, I think that I'll go ahead and keep writing up movies. Just instead of movies in theaters, I'll aim for new releases on DVD / VOD.</p>
<p>Why?</p>
<p>Edge of Tomorrow.</p>
<!--more-->
<p>Edge of Tomorrow (aka Live Die Repeat<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>) is a surprisingly solid movie. Looking back, I would say that it's probably Tom Cruise's best film in more than a decade--heck, I might even put it above Minority Report, in which case I'd actually call it his best film ever.</p>
<p>The aliens are downright alien--and pretty cool looking--the effects are well done, and the Groundhog Day applied to war<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> concent works out really well. But what really carried the movie were <a href="http://www.imdb.com/name/nm0000129/?ref_=tt_cl_t1">Tom Cruise</a> and <a href="http://www.imdb.com/name/nm1289434/?ref_=tt_cl_t2">Emily Blunt</a>. Lovely performances.</p>
<p>If you're looking for a solid sci-fi action flick with a touch of what-if inducing thought behind the scenes, you could do far worse than Edge of Tomorrow. I really wish that I'd gotten a chance to see it in theaters. It seems like exactly the sort of movie that would benefit from the big screen treatment.</p>
<div><h3 class="ranking-title">2014 Movie Rankings</h3><ol><li><a href="http://blog.jverkamp.com/2014/02/15/the-lego-movie">The Lego Movie</a></li><li><a href="http://blog.jverkamp.com/2014/04/05/captain-america-the-winter-soldier">Captain America: The Winter Soldier</a></li><li><a href="http://blog.jverkamp.com/2014/10/28/edge-of-tomorrow-dvd">Edge of Tomorrow (DVD)</a></li><li><a href="http://blog.jverkamp.com/2014/08/05/guardians-of-the-galaxy">Guardians of the Galaxy</a></li><li><a href="http://blog.jverkamp.com/2014/06/08/x-men-days-of-future-past">X-Men: Days of Future Past</a></li><li><a href="http://blog.jverkamp.com/2014/06/14/maleficent">Maleficent</a></li><li><a href="http://blog.jverkamp.com/2014/07/26/lucy">Lucy</a></li><li><a href="http://blog.jverkamp.com/2014/05/10/the-amazing-spider-man-2">The Amazing Spider-Man 2</a></li><li><a href="http://blog.jverkamp.com/2014/03/29/divergent">Divergent</a></li></ol></div>]]></content></entry><entry><title>Regular Expression Fractals</title><link href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals" /><id>urn:uuid:32f94d69-d55a-a14d-ef3c-5252a500522e</id><updated>2014-10-05T00:00:00Z</updated><summary type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Oops, turns out I haven't had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p>
<p>Today's post was inspired by this post on /r/dailyprogrammer a month ago today: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/">Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-3.png" /></a></p>
<!--more-->
<p>At the end, each point in the image will have a 'path' of decisions that got you there, making a string of the numbers 1, 2, 3, and 4.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-4.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-5.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/step-6.png" /></a></p>
<p>How does that translate into code?</p>
<pre class="scheme"><code>; Generate a fractal by matching a recursive path into an image
(define (regex-fractal regex size)
  (flomap-&gt;bitmap
   (build-flomap*
    3 size size
    (λ (x y)
      (let loop ([t 0] [l 0] [s size] [path ""])
        (cond
          ; If we're at the last level, white, otherwise black
          [(&lt;= s 1)
           (cond
             [(regexp-match regex path) '#(1 1 1)]
             [else                      '#(0 0 0)])]
          ; Otherwise, divide the region into four subregions
          ; Recur into whichever our current pixel is in
          [else
           (define s/2 (quotient s 2))
           (define x-mid (+ l s/2))
           (define y-mid (+ t s/2))
           (loop
            (if (&lt; y y-mid) t y-mid)
            (if (&lt; x x-mid) l x-mid)
            s/2
            (~a path
                (match (list (&lt; y y-mid) (&lt; x x-mid))
                  ['(#t #t) 2]
                  ['(#t #f) 1]
                  ['(#f #t) 3]
                  ['(#f #f) 4])))]))))))</code></pre>
<p>That's actually pretty close to a lot of the fractal code we've been writing recently. And it generates some pretty cool images already:</p>
<pre class="scheme"><code> &gt; (regex-fractal #px"(13|31|24|42)" 256) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/example-256.png" /></a></p>
<p>But we can do a little better than that. Let's parameterize a few things:</p>
<pre class="scheme"><code>(define current-size     (make-parameter 64))
(define current-coloring (make-parameter (thunk* '#(1 1 1))))
(define current-mode     (make-parameter 'short))</code></pre>
<p>Specifically, we'll pull the size out, but also add two more parameters. A mode to short circuit (so that as soon as the pattern matches, return, rather than calculating the entire depth of the image) and another to color the pixel based on a specific match. As an example coloring, consider this:</p>
<pre class="scheme"><code>; Get the maximum path length; useful for making gradients
(define (size-&gt;path-length size)
  (inexact-&gt;exact (floor (/ (log size) (log 2)))))

; Color a pixel based on how long of a match group we have
(define (color-by-length m)
  (define l (string-length (car m)))
  (define p (size-&gt;path-length (current-size)))
  (if (= l p)
      '#(1 1 1)
      (vector
       (if (&gt;= (length m) 3) (/ (string-length (list-ref m 2)) p) 0)
       (if (&gt;= (length m) 2) (/ (string-length (list-ref m 1)) p) 0)
       (if (&gt;= (length m) 4) (/ (string-length (list-ref m 3)) p) 0))))</code></pre>
<p>Now, let's take another example, one where the matching group must contain a 1. But now, color based on how much of the path is before the one:</p>
<pre class="scheme"><code>(parameterize ([current-size 256]
               [current-coloring color-by-length]
               [current-mode 'short])
  (regex-fractal #px"(.*)1"))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/color-example-256.png" /></a></p>
<p>Very cool.</p>
<p>After that, I just collected and made up a bunch of colorings and regular expressions and generate all of the images. Check the <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">full source</a> on GitHub for details, but basically I have three colorings: a default white only, the length based coloring above, and another which matches the most common color in a match. Then I have about two dozen regular expression.</p>
<p>Then I wrote a quick loop that will generate all images in both modes (short circuiting and long), with all three colorings. It's a lot of images... Here are some of my favorites:</p>
<pre class="scheme"><code> (demo "test256" 256) </code></pre>
<p>First, a basic <a href="https://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski triangle</a> <code>1</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_by-length_256.png" /></a></p>
<p>But if you turn on most common color, you see that each color sticks to it's own color (a pattern we'll see oft repeated):</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_full_common-voting_256.png" /></a></p>
<p>What's even more interesting is when you switch to 'short mode'. Since we'll stop recurring as soon as we see a 1, you get blocks rather than each individual pixel colored:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/sierpinski_short_common-voting_256.png" /></a></p>
<p>Next, four corners. Basically, look for repeated patterns of a single digit: <code>((.)(\\2*))</code>. That should mean that we go out to the four corners, each with its own color:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/four-corners_full_common-voting_256.png" /></a></p>
<p>Next, split the region into left and right halves, by checking if a 1 or 2 appears first: <code>^[34]*2(.*)</code>. If it's a 2, mark it, if it's a 1, do not.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/left-right_full_by-length_256.png" /></a></p>
<p>Next, a nice jagged change on the original Sierpinski, match anything with either a 1 or a 2 (or both): <code>(12)</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/jagged_full_default_256.png" /></a></p>
<p>Or, similarly, make two Sierpinskis by matching patterns where there's both a 1 and a 2: <code>(1.*2|2.*1)</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_default_256.png" /></a></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/double-sierpinski_full_by-length_256.png" /></a></p>
<p>Next, match patterns where all 1s (if any) occur before all 2s: <code>^[34]*[134]*[34]*[234]*[34]*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/ones-then-twos_full_default_256.png" /></a></p>
<p>Or you can invert the Sierpinski triangle by making sure there are <em>no</em> ones at all: <code>^[^1]*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/no-one_full_common-voting_256.png" /></a></p>
<p>Or go really crazy and do some math. For example, finding all sequences with an even sum: <code>^(2|4|[13][24]*[13])*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/even-sum_full_by-length_256.png" /></a></p>
<p>Next, we have a few from the comments on the <a href="https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/">original post</a>.</p>
<p>Some nice curls: <code>[13][24][^1][^2][^3][^4]</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/curls_full_common-voting_256.png" /></a></p>
<p>Patterns where you have the same pattern repeated at least three times, but with other random bits in between: <code>(.)\\1..\\1</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_default_256.png" /></a>\ <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/self-similar_full_common-voting_256.png" /></a></p>
<p>Or you can draw some nice boxes: <code>(?:13|31)(.*)</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_short_default_256.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/boxes_full_by-length_256.png" /></a></p>
<p>A nice recursive outline (reminds me of the <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>): <code>^(1[124]|2[14]|4[12]|31)*$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/outlined_full_by-length_256.png" /></a></p>
<p>Figure eights: <code>^(?:..)*(?:[13][13]|[24][24])((?:..)*)$</code></p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/figure-eights_full_by-length_256.png" /></a></p>
<p>And finally, some nice diagonal lines, by making sure the top left/bottom right are before the top right/bottom left: <code>^[13]*[24]*$</code>:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png"><img src="http://blog.jverkamp.com/2014/10/05/regular-expression-fractals/scanlines_full_common-voting_256.png" /></a></p>
<p>And there you have it. Any other awesome patterns you come up with? Share them below. I'd love to see them.</p>
<p>As always, the full source is available on GitHub if you'd like to play with it: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt">regex-fractal.rkt</a></p>]]></content></entry><entry><title>Invader Fractals</title><link href="http://blog.jverkamp.com/2014/09/17/invader-fractals" /><id>urn:uuid:15d5a345-5571-4706-dc96-ad512081f006</id><updated>2014-09-17T09:00:00Z</updated><summary type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>First we had <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. Then we used them fill up space with <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. But we're not <em>quite</em> done yet! This time, let's mix things up a bit and make Invader Fractals.</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<!--more-->
<p>Specifically, here's the algorithm that we want to use to build an invader fractal:</p>
<ol>
    <li>Generate an invader</li>
    <li>Within that image:
        <ul>
            <li>For each white pixel, stop</li>
            <li>For each black pixel, recur with a smaller invader</li>
        </ul>
    </li>
    <li>Once the invader is small enough, stop recurring</li>
</ol>
<p>Sounds straight forward enough, but what does that look like in code?</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal depth)
  (let loop ([depth depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= depth 1)
                #t
                (loop (- depth 1)))
            #f)))))</code></pre>
<p>That's actually a lot more concise than I first expected. In the end, we get exactly that nice nested structure we're looking for:</p>
<pre class="scheme"><code>&gt; (make-invader-fractal 2)
'#(#(#f #f #f #f #f #f #f)
   #(#f
     #(#(#f #f #f #f #f #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #t #f #f)
       #(#f #t #t #f #f #t #f)
       #(#f #f #f #f #t #f #f)
       #(#f #f #t #f #t #f #f)
       #(#f #f #f #f #f #f #f))
     #f
     #(#(#f #f #f #f #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #t #t #f #f #f)
       #(#f #f #f #t #t #f #f)
       #(#f #f #t #t #f #f #f)
       #(#f #t #t #f #t #t #f)
       #(#f #f #f #f #f #f #f))
     #f
...
     #f
     #f
     #f)
   #(#f #f #f #f #f #f #f))
&gt;</code></pre>
<p>We could probably do away with representing the margins (the outermost layer is always going to be <code>#f</code>), but at the moment it makes the code easier to reason about.</p>
<p>Okay, next we need the rendering function:</p>
<pre class="scheme"><code>; Render an invader fractal as defined above
; Crop off the margin on the outmost layer
; Final size will be 5*7^{depth-1}
(define (render-invader-fractal fi)
  (define depth
    (let loop ([fi fi])
      (cond
        [(boolean? fi) 0]
        [else
         (+ 1 (for*/fold ([deepest 0]) ([col (in-vector fi)]
                                        [el (in-vector col)])
                (max (loop el) deepest)))])))

  (define size (expt 7 depth))

  (flomap-&gt;bitmap
   (flomap-crop
    (build-flomap*
     1 size size
     (λ (x y)
       (let loop ([t 0] [l 0] [s size] [fi fi])
         (cond
           [(eq? fi #t) '#(0.0)]
           [(eq? fi #f) '#(1.0)]
           [else
            ; xi and yi are the points within the current level invader
            (define xi (quotient (* 7 (- x l)) s))
            (define yi (quotient (* 7 (- y t)) s))
            (loop (+ t (* yi (/ s 7)))
                  (+ l (* xi (/ s 7)))
                  (/ s 7)
                  (vector-ref (vector-ref fi xi) yi))]))))
    (* size 5/7)
    (* size 5/7)
    1/2
    1/2)))</code></pre>
<p>Unfortunately, that first bit is a little bit hacky. Since we've split apart the functions that create and render this fractal, we don't know how large of an image to make. Still, it's quick enough to calculate. Then, we get into actually making the image. It's much the same as the code in <a href="http://blog.jverkamp.com/2014/09/16/fractal-invaders">Fractal Invaders</a>. We recur down, keeping two different sets of coordinates: image coorcinates <code>x</code>, <code>y</code>, <code>t</code>, <code>l</code>, and <code>s</code> and then coordinates within the current level <code>xi</code> and <code>yi</code>. There is a lot of dividing and multiplying by that <a href="https://en.wikipedia.org/wiki/magic_number">magic number</a>, but os it goes.</p>
<p>And that's really it. There's a call to <code><a href="http://docs.racket-lang.org/search/index.html?q=flomap-crop">flomap-crop</a></code>, but that's just to cut off the outermost margin (since it will (1) always be empty and (2) the second level's margin will still include some spacing). So how does it look?</p>
<pre class="scheme"><code> &gt; (render-invader-fractal (make-invader-fractal 3)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-3.png" /></a></p>
<p>That's about it. One more trick that I want to do though is to make these reproducable. That we can do some neat tricks with zooming in:</p>
<pre class="scheme"><code>(define-syntax-rule (with-seed seed body* ...)
  (parameterize ([current-pseudo-random-generator
                  (make-pseudo-random-generator)])
    (random-seed seed)
    body* ...))

(define (invader-fractal i depth)
  (with-seed i
    (render-invader-fractal (make-invader-fractal depth))))</code></pre>
<p>Because we reset the random seed at the beginning of the calculate and always generate the random numbers from top to bottom, we ned up with some neat effects. The top level with the same seed is always the same shape:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 8675309 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-seeded-4.png" /></a> <span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
<p>:)</p>
<p>Unfortunately, the lower levels aren't the same pattern, since we're generating the images using a <a href="https://en.wikipedia.org/wiki/depth_first search">depth first search</a> rather than the <a href="https://en.wikipedia.org/wiki/breadth_first search">breadth first search</a>. More specifically, we're generating the invaders in this order:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/depth-first.png" /></a></p>
<p>In that case, the ordering is: generate the image for the given level, then the first subimage, then the first subimage of that. Generating the <em>depth first</em> as it were. What we want instead is to generate generate the top level, then all of the next level, then all of the next level, more like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/breadth-first.png" /></a></p>
<p>Unfortunately, that doesn't work out well in our specific code, since we're working recursively, working with a <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">stack</a> (implicitly via function calls). To do a breadth first search, we would need instead to create a explicit <a href="https://en.wikipedia.org/wiki/Stack_(computer science)">queue</a>, which would require some fairly major refactoring.</p>
<p>There's another option though:</p>
<pre class="scheme"><code>; An invader fractal is nested 5x5 2d vectors, each element is either
; #t/#f - a white/black region
; a recursive 5x5 structure
(define (make-invader-fractal/seeded seed depth)
  (define (mod-random-seed! i)
    (random-seed (+ 1 (remainder i 2147483646))))

  (mod-random-seed! seed)
  (let loop ([d depth])
    (define invader (flomap-add-margin (procedural-invader (random 32768)) 1))
    (for/vector ([x (in-range 7)])
      (for/vector ([y (in-range 7)])
        (if (&gt; 0.5 (flomap-ref invader 0 x y))
            (if (&lt;= d 1)
                #t
                (begin
                  (mod-random-seed! (+ (* (- depth d) 49) (* x 7) y seed))
                  (loop (- d 1))))
            #f)))))

(define (invader-fractal seed depth)
  (render-invader-fractal (make-invader-fractal/seeded seed depth)))</code></pre>
<p>With the addition of <code>mod-random-seed!</code>, we can set the seed at each level. And we've got the amusing notion of non-random random seeds. :) But since they're generated as a function of the current <code>depth</code> and <code>x</code> and <code>y</code> coordinates of the parent image, we'll always get the same images at each level:</p>
<pre class="scheme"><code>&gt; (for/list ([depth (in-range 1 5)])
    (invader-fractal 42 depth))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-1.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-2.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png"><img src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-3.png" /></a> <a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png"><img width="245" height="245" src="http://blog.jverkamp.com/2014/09/17/invader-fractals/invader-fractal-better-seeded-4.png" /></a></p>
<p>Now that's what I was looking for. :)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/invader-fractals.rkt">invader-fractals.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>
<p>Challenge: Make fractal invaders from invader fractals. Maybe later... O:)</p>]]></content></entry><entry><title>Fractal Invaders</title><link href="http://blog.jverkamp.com/2014/09/16/fractal-invaders" /><id>urn:uuid:3af088a6-d121-00ae-e2c8-a557bb1c42b3</id><updated>2014-09-16T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post is a follow up to Sunday's post <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">Procedural Invaders</a>. This time around, we're going to work through two different space filling algorithms in order to eventually generate something like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<!--more-->
<p>But before we get to that image, let's start with where I was Sunday. We had something that looked like this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/random-invaders.png" /></a></p>
<p>That was my first take at a fractal invader algorithm, and in that case there really wasn't anything to do with fractals at all. The basic algorithm for that was simple:</p>
<ol>
  <li>Choose a random location and size for an invader</li>
  <li>If the new invader does not collide with any previous invader, place it</li>
  <li>Go to step 1</li>
</ol>
<p>If we failed 100 times in a row to place an invader, we made the assumption that the space was empty and bailed out. It actually worked well enough. You got to see a bunch of invaders of different sizes, all together on the map. Unfortunately though, it didn't work particularly well for filling the entire space, which is really what I was after. (If you'd like you can see the code for that on GitHub in Sunday's code: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a>).</p>
<p>After that though, I took a step back. How can we actually fill the space? More specifically, how can we use recursion / fractals to efficiently fill the space? Well, what we really need is actually really similar to another previous post of mine: <a href="http://blog.jverkamp.com/2014/05/28/quadtree-image-compression">Quadtree image compression</a>.</p>
<p>Basically, here's the new algorithm:</p>
<ol>
  <li>Given a rectangular region, choose a random location and size for an invader</li>
  <li>Recursively divide the remaining space into four sections: one above, one to the right, one below, and one to the left of the new invader</li>
  <li>If any region is small enough for only a single invader, place it and stop (base case)</li>
  <li>For each other region, start again at step 1</li>
</ol>
<p>The main odd step there is step 2 above. How can we split a region into five subregions (the center being square) like that? Well, we could do something like this:</p>
<pre class="text"><code>      | R
      | i
 Top  | g
______| h
   |  | t
 L |__|____
 e |
 f | Bottom
 t |</code></pre>
<p>Making sure that you have all of the regions set up exactly right gets a little bit complicated, but if you draw a nice diagram, it should be fairly straight forward to make sure that you always generate this structure. And that's exactly what we have here:</p>
<pre class="scheme"><code>(struct rect (t l w h) #:transparent)
(struct node (bounds value-bounds value children) #:transparent)

; Create the recursive fractal structure
(define (made-fractal width height random-node)
  (let loop ([t 0] [l 0] [w width] [h height])
    (cond
      ; The next node is too small, do not place it
      [(or (&lt;= w 0) (&lt;= h 0) (&gt;= t height) (&gt;= l width))
       #f]
      ; Create a child node; recur four times as so:
      ;  T  |
      ; __  |
      ;   XX R
      ; L XX__
      ;   |
      ;   | B
      [else
       (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
       (define x (if (= w s)         0 (random (- w s))))
       (define y (if (= h s)         0 (random (- h s))))
       (node (rect t       l       w h) ; Bounds of this node
             (rect (+ t y) (+ l x) s s) ; Bounds of the value within this node
             (random-node)              ; The value of this node
             (list (loop t         l         (+ x s)   y        )
                   (loop t         (+ l x s) (- w x s) (+ y s)  )
                   (loop (+ t y s) (+ l x)   (- w x)   (- h y s))
                   (loop (+ t y)   l         x         (- h y)  )))])))</code></pre>
<p>Essentially, we want to create a nested structure made out of <code>node</code> structs. For each node, we have two bounding boxes, one for the entire recursive structure and one just for the central image (which in turn defines the four children). Then we have a value which I've already parameterized here as the <code>random-node</code> parameter and finally four children (ordered top, right, bottom, left, although it really doesn't matter).</p>
<p>What's neat about this is that the exact same code could theoretically be used for other structures. Say if we wanted 8 children for each of the orthagonal or diagonal directions. Just add more to the <code>node-children</code> list.</p>
<p>There are a few edge cases to watch out for that I did spend rather a while working out. For example, the base case deals with cases where either <code>w</code> or <code>h</code> is less than zero, but it also deals when we go off the right or bottom edge of the region. Likewise, we have to check if we only have exactly 1 square left in either width or height (which would mean we cannot generate an interesting random size) or if we only have exactly enough room for one shape.</p>
<p>After that, it's just a matter of getting the parameters right for the recursive calls. Let's try one out:</p>
<pre class="scheme"><code>&gt; (make-fractal 4 3 (const #t))
(node
 (rect 0 0 4 3)
 (rect 0 0 3 3)
 #t
 (list
  #f
  (node
   (rect 0 3 1 3)
   (rect 1 3 1 1)
   #t
   (list
    (node (rect 0 3 1 1) (rect 0 3 1 1) #t '(#f #f #f #f))
    #f
    (node (rect 2 3 1 1) (rect 2 3 1 1) #t '(#f #f #f #f))
    #f))
  #f
  #f))</code></pre>
<p>If you take each of those in order, you have the regions:</p>
<pre class="text"><code>AAAB
AAAC
AAAD</code></pre>
<p>So we generated a 3x3 region first and then filled in the rest with 1x1s. Of course that's not very nice to visualize. Let's make something a little prettier:</p>
<pre class="scheme"><code>(define (in? bounds x y)
  (match-define (rect t l w h) bounds)
  (and (&lt;= l x (+ l w -1))
       (&lt;= t y (+ t h -1))))

; Render a fractal image
(define (fractal-image
         width height
         #:random-color [random-color (thunk (vector (random) (random) (random)))])

  (define root (make-fractal width height random-color))

  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (λ (x y)
      (let loop ([node root])
        (cond
          [(in? (node-value-bounds node) x y) (node-value node)]
          [else
           (for*/first ([child (in-list (node-children node))]
                        #:when (and child (in? (node-bounds child) x y)))
             (loop child))]))))))</code></pre>
<p>That's surprisingly simple, but then again most of the work was already done in setting up the structure. The most complicated bit here is that we have two different usages of the <code>in?</code> function:</p>
<ul>
  <li><code>(in? (node-value-bounds node) x y)</code> - checks if the current point is in the current node's value box (the inner box); if that's the case, this is our base case</li>
  <li><code>(in? (node-bounds child) x y)</code> - if this is true for any of the child node's outer box; if that's true we know that our value is somewhere in that subtree</li>
</ul>
<p>That's all we need to make some pretty neat images, just changing how we generate colors:</p>
<pre class="scheme"><code>&gt; (fractal-image 200 200)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-random.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200 #:random-color (thunk (let ([g (random)]) (vector g g g))))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-gray.png" /></a></p>
<pre class="scheme"><code>&gt; (fractal-image 200 200
                 #:random-color (thunk
                                  (case (random 3)
                                    [(0) (vector (random) 0 0)]
                                    [(1) (vector 0 (random) 0)]
                                    [(2) (vector 0 0 (random))])))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-image-rgb.png" /></a></p>
<p>Which, honestly, would be a pretty neat post all by itself. But wasn't the entire point of this to made a fractal out of the <a href="http://blog.jverkamp.com/2014/09/14/procedural-invaders">procedural invaders</a>?</p>
<pre class="scheme"><code>; Render a fractal image made of invaders!
(define (fractal-invaders width height #:highlights? [highlights? #f])
  (define (random-invader)
    (flomap-add-margin
     (if highlights?
         (procedural-invader/highlight (random 524288))
         (procedural-invader (random 32768)))
     1))

  (define root (make-fractal (quotient width 7)
                             (quotient height 7)
                             random-invader))

  (flomap-&gt;bitmap
   (build-flomap*
    (if highlights? 3 1) width height
    (λ (x y)
      ; Correct for coordinates within the node
      (define nx (quotient x 7))
      (define ny (quotient y 7))

      (let loop ([n root])
        (cond
          [(in? (node-value-bounds n) nx ny)
           ; Calculate coordinates within the image
           (match-define (node _ (rect t l s _) img _) n)
           (define ix (quotient (- x (* 7 l)) s))
           (define iy (quotient (- y (* 7 t)) s))
           (flomap-ref* img ix iy)]
          [else
           (or
            (for*/first ([child (in-list (node-children n))]
                         #:when (and child (in? (node-bounds child) nx ny)))
              (loop child))
            (if highlights? '#(1 1 1) '#(1)))]))))))</code></pre>
<p>Okay, this code isn't quite as nice. Mostly, that's because of a simplifying requirement that I started with: we're going to be working with a grid where each 'pixel' is a single minimal size invader. With a 1 pixel margin, that means that our minimum image size is 7x7 (thus the 7s scattered throughout the code).</p>
<p>Unfortunately, that does make our base case a little more complicated, since we're working with two different coordinate systems: image coordinates <code>x</code> and <code>y</code> and fractal coordinates <code>nx</code> and <code>ny</code>. Still, add in some offsets by 7 and a bit of padding down at the end (for images not divisible by 7) and off we go:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100.png" /></a></p>
<p>It also works great for larger images:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200.png" /></a></p>
<p>It even supports highlights:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 400 200 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-highlights.png" /></a></p>
<p>Now that's what I'm talking about. Unfortunately, the process is still somewhat random:</p>
<pre class="scheme"><code> &gt; (fractal-invaders 100 100) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-100x100-big.png" /></a></p>
<p>Sometimes the first random image is a little on the annoyingly large size. Off the top of my head, there are two ways to deal with it: either add an option parameter that controls the maximum size of a block or just keep generating images until you get what you are looking for.</p>
<p>Guess which solution I prefer? :)</p>
<pre class="scheme"><code>(define (fractal-invaders ... #:maximum-invader-size [max-size #f])
  ...
  (define root
    (make-fractal
     (quotient width 7)
     (quotient height 7)
     random-invader
     #:maximum-block-size (and max-size (/ max-size 7))))
  ...)

(define (make-fractal width height random-node #:maximum-block-size [max-size #f])
  ...
      [else
       (define s
         (let loop ()
           (define s (if (= (min w h) 1) 1 (+ 1 (random (min w h)))))
           (cond
             [(or (not max-size) (&lt; s max-size)) s]
             [else (loop)])))
       ...])</code></pre>
<p>Simple!</p>
<pre class="scheme"><code>&gt; (fractal-invaders 400 200 #:highlights? #t #:maximum-invader-size 25)</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png"><img src="http://blog.jverkamp.com/2014/09/16/fractal-invaders/fractal-invaders-400x200-max-25.png" /></a></p>
<p>Beautiful!</p>
<p>I wonder what other sort of images I could make with a fractal space filling algorithm like this? O:)</p>
<p>As always, today's code is available on GitHub. Check it out: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/fractal-invaders.rkt">fractal-invaders.rkt</a> (Requires <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a> to run.)</p>]]></content></entry><entry><title>Look and Say</title><link href="http://blog.jverkamp.com/2014/09/15/look-and-say" /><id>urn:uuid:eac2659f-3660-3f5e-9ba1-540308c23093</id><updated>2014-09-15T00:00:00Z</updated><summary type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
]]></summary><content type="html"><![CDATA[<p>Random quick post today<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>. Basically, we want to write code to generate what's known as <a href="https://en.wikipedia.org/wiki/Look_and Say sequence">Look and Say sequence</a>:</p>
<blockquote>
    <p>To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:</p>

<ul>
    <li>1 is read off as "one 1" or 11.</li>
    <li>11 is read off as "two 1s" or 21.</li>
    <li>21 is read off as "one 2, then one 1" or 1211.</li>
    <li>1211 is read off as "one 1, then one 2, then two 1s" or 111221.</li>
    <li>111221 is read off as "three 1s, then two 2s, then one 1" or 312211.</li>
</ul>
</blockquote>
<!--more-->
<p>Originally, my interest in this came from a video on the excellent YouTube video series <a href="https://www.youtube.com/user/numberphile">Numberphile</a>:</p>
<p><iframe width="560" height="315" src="//www.youtube.com/embed/ea7lJkEhytA" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>Yes, that is <a href="https://en.wikipedia.org/wiki/John_Conway">John Conway</a> of <a href="https://en.wikipedia.org/wiki/Conway's_Game of Life">Conway's Game of Life</a>. It's well worth the watch.</p>
<p>Then this morning, /r/dailyprogrammer has a post: <a href="https://www.reddit.com/r/dailyprogrammer/comments/2ggy30/9152014_challenge180_easy_looknsay/">Challenge #180 [Easy] Look'n'Say</a>. Seems like it's about time. :)</p>
<p>So how do we do it? Well, essentially we're going to want a function that can recur down a list of, collecting groups of like numbers. So in the sequence <code>111221</code>, we want to collect that into <code>111 22 1</code>. Then we know how long each sequence is, <code>31 22 11</code>, which is the next number in the sequence. How's that look in code?</p>
<pre class="scheme"><code>; Create a look and see list by combining repeated values into count+number
; For example: 111221 becomes 3 1s, 2 2s, 1 1 =&gt; 312211
(define (look-and-say ls)
  (apply
   append
   (let count ([ls (rest ls)] [i 1] [v (first ls)])
     (cond
       [(null? ls)
        (list (list i v))]
       [(equal? (first ls) v)
        (count (rest ls) (+ i 1) v)]
       [else
        (list* (list i v) (count (rest ls) 1 (first ls)))]))))</code></pre>
<p>The counting function will recur down the list, collecting the current count (<code>i</code>) and value (<code>v</code>) as we go. Within that recursion, there are three cases. In the first case (<code>(null? ls)</code>), we've reached the end. This makes sure that we output the last sequence. In the second (<code>(equal? (first ls) v)</code>), we have a matching number, so increment the current sequence. In the last (<code>else</code>), the number do not match. Output the current count and start a new sequence.</p>
<p>Let's try it out:</p>
<pre class="scheme"><code>&gt; (look-and-say '(1))
'(1 1)
&gt; (look-and-say '(1 1))
'(2 1)
&gt; (look-and-say '(2 1))
'(1 2 1 1)
&gt; (look-and-say '(1 2 1 1))
'(1 1 1 2 2 1)</code></pre>
<p>Looks good. It's annoying to have to keep calling it like that though. What I'd really like to see is a Racket <code><a href="http://docs.racket-lang.org/search/index.html?q=sequence">sequence</a></code>. Luckily, this is exactly the sort of thing we can make with <code><a href="http://docs.racket-lang.org/search/index.html?q=make-do-sequence">make-do-sequence</a></code>:</p>
<pre class="scheme"><code>; Make an infinite sequence that generates look-and-see lists
; Use the current look-and-say list itself as both the key and value
(define (in-look-and-say [ls '(1)])
  (make-do-sequence
   (thunk
    (values
     identity       ; Current
     look-and-say   ; Next
     ls             ; Initial
     (const #t)     ; Continue from this key/value/pair
     (const #t)
     (const #t)))))</code></pre>
<p>We're going to use the sequence itself as the 'count', which makes the first few arguments easy enough. Basically, we use <code>identity</code> to return the current value, and <code>look-and-say</code> (the function we just defined above) as the <code>next</code> function. The last three are easy as well. Since we want an infinite sequence: just always return <code>#t</code>. Done.</p>
<p>Given this, we can generate as long a seqence as we want:</p>
<pre class="scheme"><code>; Take the first chunk off of a sequence
(define (look-and-say* ls i)
  (for/list ([ls (in-look-and-say ls)]
             [_  (in-range i)])
    ls))</code></pre>
<p>Nice. :)</p>
<p>Or we can plot some interesting information about them, say the length:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say length '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-length.png" /></a></p>
<p>Or the maximum value:</p>
<pre class="scheme"><code> &gt; (plot-look-and-say (curry apply max) '(1) 20) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-max.png" /></a></p>
<p>It's interesting how it never gets beyond 3 up to 50 steps along the sequence. Unfortunately</p>
<p>Last thing last, pretty pictures!</p>
<pre class="scheme"><code>; Render a look and say sequence to a bitmap, stretching rows to the entire width
; Note: Values are clamped to between 0.0 and 1.0 before conversion. *rolls eyes*
(define (render-look-and-say ls bound)
  ; Precalculate the image data; figuring out what dimenions will we need from that
  (define ls* (look-and-say* ls bound))
  (define height (length ls*))
  (define width (length (last ls*)))

  ; Precalculated list of colors that are defined to be more visually distinct
  (define colors
    '#(#(1.00 0.70 0.00) #(0.50 0.24 0.46) #(1.00 0.41 0.00) #(0.65 0.74 0.84) #(0.75 0.00 0.12)
       #(0.80 0.63 0.38) #(0.50 0.44 0.40) #(0.00 0.49 0.20) #(0.96 0.46 0.55) #(0.00 0.32 0.54)
       #(1.00 0.48 0.36) #(0.32 0.21 0.48) #(1.00 0.55 0.00) #(0.70 0.16 0.32) #(0.95 0.78 0.00)
       #(0.50 0.09 0.05) #(0.57 0.66 0.00) #(0.35 0.20 0.08) #(0.94 0.23 0.07) #(0.14 0.17 0.09)))

  ; Generate the image, three channels are RGB
  ; Note: 4 channels is ARGB, not RGBA *rolls eyes again*
  (flomap-&gt;bitmap
   (build-flomap*
    3 width height
    (λ (x y)
      ; Pull out the correct row for the data, normalize entries to 'stretch' over the entire row
      (define row (list-ref ls* y))
      (define row-width (length row))
      (define index (quotient (* x row-width) width))
      (displayln `(,x ,y ,index ,(list-ref row index) ,row))

      (vector-ref colors (list-ref row index))))))</code></pre>
<p>That will encode each iteration into a line of the resulting image and each different value into its own color. Something like this:</p>
<pre class="scheme"><code> &gt; (scale-to 200 200 (render-look-and-say '(1) 20)) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png"><img src="http://blog.jverkamp.com/2014/09/15/look-and-say/look-and-say-20.png" /></a></p>
<p>Neat how there's a nice line right down the center. Although that makes sense, given that there are always an even number of values. On thing that I want to check out is those divisions that the video was talking about where two parts of a sequence can diverge and never interact again. Those would be fairly straight forward to find even, just 'tag' each part of the sequence with where it came from. Perhaps another day.</p>
<p>As always, code on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/look-and-say.rkt">look-and-say.rkt</a></p>
<p>As a side note, here's a neat trick:</p>
<pre class="scheme"><code>; Create a look and say sequence with regular expressions instead of lists
(define (look-and-say/regex str)
  (regexp-replace*
   #px"(.)(\\1*)"
   str
   (λ (match block repeat) (~a (string-length match) block))))</code></pre>
<p>Regular expressions for the win! Of course, it's an order of magnitude slower than the list version, but it's still neat.</p>]]></content></entry><entry><title>Procedural Invaders</title><link href="http://blog.jverkamp.com/2014/09/14/procedural-invaders" /><id>urn:uuid:41ac4ba4-e097-9023-3504-488ff41b9a68</id><updated>2014-09-14T09:00:00Z</updated><summary type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Today's post comes from a long line of 'inspired by posts' all pretty much leading back (so far as I can tell) to this post by j.tarbell: <a href="http://www.complexification.net/gallery/machines/invaderfractal/">invader.procedural</a> from 2003.</p>
<p>The basic idea is that we want to generate 'invaders' in the style of <a href="https://en.wikipedia.org/wiki/space_invaders">space invaders</a>. Except we don't want 10 or 20, we want tens of thousands. So how do we do it? Well, take a look at this:</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<!--more-->
<p>Despite the fact that it's scaled up, on the lowest level we actually have a 5x5 grid of pixels. In addition, it's mirrored to make it symmetrical, so (counting the non-mirrored center row), we actually only have 15 pixels:</p>
<pre class="text"><code>+----+----+----+----+----+
|  1 |  6 | 11 |  6 |  1 |
+----+----+----+----+----+
|  2 |  7 | 12 |  7 |  2 |
+----+----+----+----+----+
|  3 |  8 | 13 |  8 |  3 |
+----+----+----+----+----+
|  4 |  9 | 14 |  9 |  4 |
+----+----+----+----+----+
|  5 | 10 | 15 | 10 |  5 |
+----+----+----+----+----+</code></pre>
<p>Represent those 15 pixels as a 15 bit number. For example, the above image, we have bits 2, 4, 6, 7, 8, 10, 13, and 15 set, so we have the number:</p>
<pre class="scheme"><code>&gt; #b010101110100101
11173</code></pre>
<p>Given that there are over 32 thousand 15 bit numbers (<span>\(2^{15}=32768\)</span>), that's a lot of invaders. So how do we generate them?</p>
<pre class="scheme"><code>; Create a symmetric 5x5 image similar to a space invader with this bit pattern
; 0 5 10 5 0
; 1 6 11 6 1
; 2 7 12 7 2
; 3 8 13 8 3
; 4 9 14 9 4
(define (procedural-invader i)
  (define bits
    (for/vector ([c (in-string (~a (number-&gt;string i 2) #:width 15 #:pad-string "0" #:align 'right))])
      (eq? c #\1)))

  (build-flomap*
   1 5 5
   (λ (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (vector-ref bits i) '#(1.0) '#(0.0)))))</code></pre>
<p>There are really two parts here. First we covert the given integer into a vector of <code>#t</code> / <code>#f</code>. There are certainly far faster ways to do this (<code>bitwise-and</code> with the correct bit for example), but given that the size is set and small, this is good enough for the time being.</p>
<p>After that, we take those bits and use <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code> to create a 5x5 image where <code>#t</code> is white and <code>#f</code> is black. Shiny. Now unfortunately Dr. Racket will not display flomaps directly inline, but if we convert them to bitmaps it will:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (procedural-invader 11173))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-tiny.png" /></a></p>
<p>Oof. Tiny. Let's make it bigger:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big-blurry.png" /></a></p>
<p>Well that's not what I was looking for. The problem is that flomaps by default are designed for interpolated values. So that if you have a black pixel right next to a white pixel, you can actually ask for the 'pixel' halfway between the two, getting a gray value. But in this case, that's not what we want. We want sharp (<a href="https://en.wikipedia.org/wiki/nearest_neighbor">nearest neighbor</a>) scaling:</p>
<pre class="scheme"><code>; Resize a flomap using nearest-neighbors to preserve sharp edges
(define (flomap-resize/nn img new-width [new-height new-width])
  (match-define (flomap _ components old-width old-height) img)

  (build-flomap*
   components new-width new-height
   (λ (new-x new-y)
     (flomap-ref* img
                  (floor (* old-width (/ new-x new-width)))
                  (floor (* old-height (/ new-y new-height)))))))</code></pre>
<p>Same as before, we are creating a new image. But this time, we covert the old coordinate system to the new and throw away any of the decimal part, getting an exact answer. That way we never interpolate:</p>
<pre class="scheme"><code>&gt; (flomap-&gt;bitmap (flomap-resize/nn (procedural-invader 11173) 50 50))</code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invader-big.png" /></a></p>
<p>Nice and sharp. That's exactly what we were looking for.</p>
<p>For the base of the problem, that's pretty much it. But we're not quite done. What if we want to make a nice display mode so that we can see a bunch of them at once?</p>
<pre class="scheme"><code>; Generate a demo shee\t of procedural invaders
(define (demo [rows 5] [cols rows] #:image-size [image-size 20] #:margins [margins 5])
  (define images
    (for/list ([row (in-range rows)])
      (for/list ([col (in-range cols)])
        (define r (random 32768))
        (define img (procedural-invader r))
        (flomap-&gt;bitmap (flomap-add-margin (flomap-resize/nn img image-size) margins)))))

  (cond
    [(and (= rows 1) (= cols 1))
     (caar images)]
    [(= rows 1)
     (car (map (curry apply beside) images))]
    [(= cols 1)
     (apply above (map car images))]
    [else
     (apply above (map (curry apply beside) images))]))</code></pre>
<p>That way we can make nice mixed sheets of the things:</p>
<pre class="scheme"><code> &gt; (demo) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40.png" /></a></p>
<p>Pop quiz: Find two identical invaders. What is the likelihood of that happening? Well using the same math as in <a href="http://blog.jverkamp.com/2012/10/01/the-birthday-paradox">The Birthday Paradox</a>, the chance of no duplicates is:</p>
<div>$$ B(n, x) = 1 - \prod_{i=1}^{(n-1)}(1-\frac{i}{x}) $$</div>
<p>Where <span>\(n\)</span> is the number of generated invaders and <span>\(x = 15^{2} = 32768\)</span> is the total number of possible invaders.</p>
<p>Specifically, for the 5x5 case:</p>
<div>$$B(25, 32768)
= 1 - \prod_{i=1}^{(25-1)}(1-\frac{i}{32768})
\approx 9.1\%$$</div>
<p>And for the 80x40 case:</p>
<div>$$B(3200, 32768)
= 1 - \prod_{i=1}^{(3200-1)}(1-\frac{i}{32768})
\approx 100\%$$</div>
<p>So it's (almost certainly) there... you just have to find it. :)</p>
<p>Okay, what else can we do with these things? Well, at the moment, they're a little bit bland. Let's add a few bits to the generation and spice them up a bit with highlights. Specifically, let's choose one of the 15 bits to be red instead of black or white. In order to do that (choose 1 of 15), we need 4 bits (with one left over). SOmething like this should work:</p>
<pre class="scheme"><code>; Create a procedural invader as above, but highlight the point specified by four highest bits
(define (procedural-invader/highlight i)
  (define highlight (bitwise-and i #b1111))
  (define img-w/o-highlight (procedural-invader (arithmetic-shift i -4)))

  (build-flomap*
   3 5 5
   (λ (x y)
     (define i (+ y (* 5 (if (&lt; x 3) x (- 4 x)))))
     (if (= highlight i)
         '#(1.0 0.0 0.0)
         (make-vector 3 (flomap-ref img-w/o-highlight 0 x y))))))</code></pre>
<p>Basically, we pull off the lowest four bits with a <a href="https://en.wikipedia.org/wiki/bitmask">bitmask</a> for the highlight then shift all the rest down and pass off to the original <code>procedural-invader</code> function. Then we build a new image from that, mostly copying but taking a single pixel and making it red. Adding an argument so that our <code>demo</code> function can handle highlighting:</p>
<pre class="scheme"><code> &gt; (demo #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-highlights.png" /></a></p>
<p>Or even giant sheets:</p>
<pre class="scheme"><code> &gt; (demo 40 80 #:image-size 5 #:margins 1 #:highlights? #t) </code></pre>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/procedural-invaders-80x40-highlights.png" /></a></p>
<p>Ooh. That's starting to look like a game. Perhaps I'll revist these for the next <a href="http://blog.jverkamp.com/category/programming/by-source/ludum-dare">Ludum Dare</a>...</p>
<p>What else can we do with these? Well, take the <a href="http://www.complexification.net/gallery/machines/invaderfractal/">post I was inspired by</a>. In that case, they fill up a space with procedural invaders of different sizes. That would be neat to check out. I've started implementing something...</p>
<p><a data-toggle="lightbox" href="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png"><img src="http://blog.jverkamp.com/2014/09/14/procedural-invaders/fractal-invaders.png" /></a></p>
<p>But it's not quite right yet. Perhaps next time...</p>
<p>If you'd like to check out the entire code for today's post, as always, it's available on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/procedural-invaders.rkt">procedural-invaders.rkt</a></p>]]></content></entry></feed>