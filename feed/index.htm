<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="//blog.jverkamp.com" /><link rel="self" href="//blog.jverkamp.com/feed/" /><updated>2015-12-12T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:b26bbc31-d1d1-3557-055d-3c47073ed3bd</id><entry><title>Advent of Code: Day 12</title><link href="//blog.jverkamp.com/2015/12/12/advent-of-code-day-12" /><id>urn:uuid:7064b41b-df01-5a75-1da9-ab651b846820</id><updated>2015-12-12T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/12">Source</a></p>
<p><strong>Part 1:</strong> Sum all integer values in a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> object.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/12">Source</a></p>
<p><strong>Part 1:</strong> Sum all integer values in a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> object.</p>
<!--more-->
<pre class="python"><code>def js_sum(js):
    if isinstance(js, dict):
        return sum(map(js_sum, js.values()))
    elif isinstance(js, list):
        return sum(map(js_sum, js))
    elif isinstance(js, int):
        return js
    else:
        return 0

print(js_sum(json.load(sys.stdin)))</code></pre>
<p>Due to the nature of JSON, this is very much a recursive problem. There's really not much else to say. If you have a complex data structure (<code>dict</code> or <code>list</code>), recur into it. Otherwise, if it's a number add it, if not don't.</p>
<p><strong>Part 2:</strong> Do not recur into any <code>dict</code> that contains the value <code>"red"</code>.</p>
<p>Given the structure we already had, the tweak for this is straight forward (if not terribly efficient):</p>
<pre class="python"><code>def js_sum(js):
    if isinstance(js, dict) and not 'red' in js.values():
        return sum(map(js_sum, js.values()))
    elif isinstance(js, list):
        return sum(map(js_sum, js))
    elif isinstance(js, int):
        return js
    else:
        return 0

print(js_sum(json.load(sys.stdin)))</code></pre>]]></content></entry><entry><title>Zoo City</title><link href="//blog.jverkamp.com/2015/12/11/zoo-city" /><id>urn:uuid:328319d3-b13a-d305-4e78-a28bce9b8585</id><updated>2015-12-11T23:55:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7163862-zoo-city"><img src="//blog.jverkamp.com/2015/12/11/zoo-city/zoo-city.jpg" /></a></p>
<p>Basically, in <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> (<a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>), if you kill someone (is that the only way?) you end up with a literal animal manifestation of your guilt. On the plus side, they come with free magical abilities (like the main character's ability to find lost things). On the down side, people know how you got your animal (your zoo) and discrimination is rampant.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/7163862-zoo-city"><img src="//blog.jverkamp.com/2015/12/11/zoo-city/zoo-city.jpg" /></a></p>
<p>Basically, in <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> (<a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>), if you kill someone (is that the only way?) you end up with a literal animal manifestation of your guilt. On the plus side, they come with free magical abilities (like the main character's ability to find lost things). On the down side, people know how you got your animal (your zoo) and discrimination is rampant.</p>
<!--more-->
<p>It's a really interesting concept; something that I haven't quite seen anywhere else (The Golden Compass is vaguely similar, at least in the animal companions). And the world is just gritty and dark enough that it felt like a dark echo of what our world could be / have been. Unfortunately, a lot of details are left unclear. What exactly is the Undertow? How do people get which animals? What did the main character actually do to get her Sloth? How different are the animals from their wild brethren?</p>
<p>Unfortunately, as interesting as the world building is, the plot isn't that great. I'll admit, I actually stopped paying as close attention to what was going on about halfway through. Then some more things happened and the story was over and unfortunately I didn't feel any particular urge to go back and figure out how we'd gotten from point B to point Z.</p>
<p>On top of that, I didn't particularly care for the main character. When you open the first few chapters by writing scam emails and stealing people's money, you know there's a bit of an ethical conundrum going on. A character like that can work perfectly well as a main character in a book, but at least for me, you have to work twice as hard for it. Zoo City didn't quite make it.</p>
<p>So it goes. It was interesting enough to read.</p>
<p>Back on track for the final series in my original <a href="//blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List</a>: <a href="https://www.goodreads.com/series/40853-necroscope">Necroscope</a> by <a href="https://www.goodreads.com/author/show/20602.Brian_Lumley">Brian Lumley</a></p>]]></content></entry><entry><title>CSV to JSON</title><link href="//blog.jverkamp.com/2015/12/11/csv-to-json" /><id>urn:uuid:a19dc458-070c-e75e-8fdf-ee6884430831</id><updated>2015-12-11T00:05:00Z</updated><summary type="html"><![CDATA[<p>Today at work, I had to process a bunch of CSV data. Realizing that I don't have any particularly nice tools to work with streaming CSV data (although I did write about <a href="//blog.jverkamp.com/2012/10/04/querying-csv-files-with-sql">querying CSV files with SQL</a>), I decided to write one:</p>
<pre class="bash"><code>$ cat users.csv

"user_id","name","email","password"
"1","Luke Skywalker","luke@rebel-alliance.io","$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq"
"2","Han Solo","han@rebel-alliance.io","$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92"

$ cat users.csv | csv2json | jq '.'

{
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "name": "Luke Skywalker",
  "user_id": "1",
  "email": "luke@rebel-alliance.io"
}
{
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "name": "Han Solo",
  "user_id": "2",
  "email": "han@rebel-alliance.io"
}</code></pre>
]]></summary><content type="html"><![CDATA[<p>Today at work, I had to process a bunch of CSV data. Realizing that I don't have any particularly nice tools to work with streaming CSV data (although I did write about <a href="//blog.jverkamp.com/2012/10/04/querying-csv-files-with-sql">querying CSV files with SQL</a>), I decided to write one:</p>
<pre class="bash"><code>$ cat users.csv

"user_id","name","email","password"
"1","Luke Skywalker","luke@rebel-alliance.io","$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq"
"2","Han Solo","han@rebel-alliance.io","$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92"

$ cat users.csv | csv2json | jq '.'

{
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "name": "Luke Skywalker",
  "user_id": "1",
  "email": "luke@rebel-alliance.io"
}
{
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "name": "Han Solo",
  "user_id": "2",
  "email": "han@rebel-alliance.io"
}</code></pre>
<!--more-->
<p>Luckily, Python has nice CSV and JSON libraries built in:</p>
<pre class="python"><code># If --parse is set, try to parse each entry as json
def parse(thing):
    try:
        return json.loads(thing)
    except:
        return thing

# Assume that headers are the first row
reader = csv.reader(sys.stdin)
headers = None
for row in reader:
    if not headers:
        headers = row
        continue

    if '--parse' in sys.argv:
        row = [parse(thing) for thing in row]

    # Recombine the headers with each row (no one said this was saving space)
    row = dict(zip(headers, row))
    print(json.dumps(row, default = str))</code></pre>
<p>Basically, assume that the first row of the CSV data is headers (converting to a JSON dict doesn't make much sense if it isn't) and then combine that with each additional row to write out a dictionary. In addition, I put a bit of code in there to assume that you might be storing JSON in your CSV fields. If so, you can <code>--parse</code> the data automagically:</p>
<pre class="bash"><code>$ cat users-with-preferences.csv | csv2json --parse | jq '.'

{
  "preferences": {
    "force-user": true
  },
  "name": "Luke Skywalker",
  "user_id": 1,
  "password": "$2b$12$XQ1zDvl5PLS6g.K64H27xewPQMnkELa3LvzFSyay8p9kz0XXHVOFq",
  "email": "luke@rebel-alliance.io"
}
{
  "preferences": {
    "ship": "Millennium Falcon"
  },
  "name": "Han Solo",
  "user_id": 2,
  "password": "$2b$12$eKJGP.tt9u77PeXgMMFmlOyFWSuRZBUZLvmzuLlrum3vWPoRYgr92",
  "email": "han@rebel-alliance.io"
}</code></pre>
<p>Note that the <code>user_id</code>s are actually numbers, the <code>preferences</code> field has been unpacked, and Luke's <code>force-user</code> status is a boolean. It's neat how you get all of that more or less for free.</p>
<p>Also, have I mentioned how nice <a href="https://stedolan.github.io/jq/">jq</a> is for working with JSON?</p>
<p>And that's it. The full source is part of my dotfiles now: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/csv2json">github:jpverkamp/dotfiles</a> (although all that's missing above is the <a href="https://en.wikipedia.org/wiki/shebang">shebang</a> and the imports). Enjoy!</p>]]></content></entry><entry><title>Advent of Code: Day 11</title><link href="//blog.jverkamp.com/2015/12/11/advent-of-code-day-11" /><id>urn:uuid:3ef4590d-8e71-7616-0cda-b3673c191da9</id><updated>2015-12-11T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/11">Source</a></p>
<p><strong>Part 1:</strong> Find the next string in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical_order</a> that matches these rules:</p>
<ol>
  <li>Must contain three neighboring, ascending letters (<code>ghi</code>)</li>
  <li>Must not contain any of the letters <code>i</code>, <code>o</code>, or <code>l</code></li>
  <li>Must contain two distinct pairs of letters</li>
</ol>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/11">Source</a></p>
<p><strong>Part 1:</strong> Find the next string in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical_order</a> that matches these rules:</p>
<ol>
  <li>Must contain three neighboring, ascending letters (<code>ghi</code>)</li>
  <li>Must not contain any of the letters <code>i</code>, <code>o</code>, or <code>l</code></li>
  <li>Must contain two distinct pairs of letters</li>
</ol>
<!--more-->
<p>This is pretty similar to <a href="//blog.jverkamp.com/2015/12/05/advent-of-code-day-5">Advent of Code: Day 5</a>, although it cannot <em>quite</em> be done with purely regular expressions.</p>
<pre class="python"><code>def is_valid(password):
    numeric = list(map(ord, password))

    return (
        # Include an increasing subsequence
        any(
            numeric[i] + 2 == numeric[i + 1] + 1 == numeric[i + 2]
            for i in range(len(password) - 2)
        )
        # May not contain i, o, or l
        and not any(c in password for c in 'iol')
        # Must have at least two different pairs
        and len(set(re.findall(r'(.)\1', password))) &gt;= 2
    )

def increment(password):
    numeric = list(map(ord, password))
    index = -1

    while True:
        numeric[index] += 1
        if numeric[index] &lt;= ord('z'):
            break
        else:
            numeric[index] = ord('a')
            index -= 1

    return ''.join(map(chr, numeric))

def next_valid(password):
    while True:
        password = increment(password)
        if is_valid(password):
            return password

print(next_valid(sys.argv[1]))</code></pre>
<p>Basically, there are two interesting problems: finding out if a string <code>is_valid</code> and <code>increment</code>ing one to the next value.</p>
<p>For the first, we check each of the three cases in order. We can tell if there is an ascending sequence by first converting to numeric values (<code>ord</code> will return the <a href="https://en.wikipedia.org/wiki/unicode_codepoint">unicode codepoint</a> for a character) the comparing three adjacent values. The second test just checks if <code>any</code> character is <code>in</code> the string. The last actually does use regular expressions again to find all pairs of letters; then, by converting them into a set removes duplicates and counts unique values.</p>
<p>For the second problem (<code>increment</code>), we use the numeric form again and start at the end of the string. We'll increment each character working back towards the front of the string, stopping as soon as we don't have to carry. Then, we convert the password back into a string using the inverse of <code>ord</code>: <code>chr</code>.</p>
<p>And, that's it. It's certainly not the most efficient code, but it still takes only a few seconds.</p>
<p><strong>Part 2:</strong> Find the next string matching the same rules after the one you found in part 1.</p>
<p>Just run the same program again on the first one's input.</p>]]></content></entry><entry><title>Advent of Code: Day 10</title><link href="//blog.jverkamp.com/2015/12/10/advent-of-code-day-10" /><id>urn:uuid:f36a3b14-d73a-1afd-d434-17fee29644cf</id><updated>2015-12-10T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/10">Source</a></p>
<p><strong>Part 1:</strong> Repeat a <a href="https://en.wikipedia.org/wiki/Look-and-say_sequence">Look-and-say sequence</a> 40 times. Return the length.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/10">Source</a></p>
<p><strong>Part 1:</strong> Repeat a <a href="https://en.wikipedia.org/wiki/Look-and-say_sequence">Look-and-say sequence</a> 40 times. Return the length.</p>
<!--more-->
<pre class="python"><code>def look_and_say(seq):
    result = ''
    index = 0
    count = 0
    buffer = None

    for c in seq:
        if c == buffer:
            count += 1
        else:
            if buffer:
                result += '{}{}'.format(count, buffer)
            count = 1
            buffer = c

    result += '{}{}'.format(count, buffer)
    return result

def repeat(f, n, seq):
    for i in range(n):
        seq = f(seq)
    return seq

print(len(repeat(look_and_say, int(sys.argv[2]), sys.argv[1])))</code></pre>
<p>I've already gone into far more detail on <a href="//blog.jverkamp.com/2014/09/15/look-and-say">Look and Say</a> sequences before. But this time, we're doing it iteratively in Python! Basically, we just maintain a bit of state for which character we are currently counting. When we change, output; otherwise, incrememnt the change.</p>
<p>There are some interesting tricks you could do with regular expressions, but I doubt you can find something faster or much more elegant than this.</p>
<p><strong>Part 2:</strong> Repeat 50 times.</p>
<p>There's nothing particular interesting about this one. I've already accounted for this by passing in the second paramter on the command line.</p>]]></content></entry><entry><title>The Golem and the Jinni</title><link href="//blog.jverkamp.com/2015/12/09/the-golem-and-the-jinni" /><id>urn:uuid:d2df3156-7c90-f14f-07ba-4585dc7ef17e</id><updated>2015-12-09T23:55:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/15819028-the-golem-and-the-jinni"><img src="//blog.jverkamp.com/2015/12/09/the-golem-and-the-jinni/the-golem-and-the-jinni.jpg" /></a></p>
<p><a href="https://www.goodreads.com/book/show/15819028-the-golem-and-the-jinni">The Golem and the Jinni</a> by <a href="https://www.goodreads.com/author/show/6466778.Helene_Wecker">Helene Wecker</a> follows two parallel stories: that of a Golem and a Jinni (of course), each finding their way from fall flung shores to circa 1900 New York City.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/15819028-the-golem-and-the-jinni"><img src="//blog.jverkamp.com/2015/12/09/the-golem-and-the-jinni/the-golem-and-the-jinni.jpg" /></a></p>
<p><a href="https://www.goodreads.com/book/show/15819028-the-golem-and-the-jinni">The Golem and the Jinni</a> by <a href="https://www.goodreads.com/author/show/6466778.Helene_Wecker">Helene Wecker</a> follows two parallel stories: that of a Golem and a Jinni (of course), each finding their way from fall flung shores to circa 1900 New York City.</p>
<!--more-->
<p>It's a relatively complex narrative structure, jumping from the Golem to the Jinni and even to a few minor characters within the space of a chapter. Even in one viewpoint, there are multiple timelines, showing how events a thousand years apart all fit together. Yet despite all of this, I never got lost, never couldn't figure out where I was in the story. It took a while for the story lines to start coming together (for a while, it felt like reading two books), but once they do things just keep pushing towards the conclusion.</p>
<p>Two things in particular I enjoyed about the story were the characters and the magic. The Golem and the Jinni have very different personalities, down to the very core of the sorts of beings they are. There is some commentary about the idea of an unchanging nature and choosing your own fate which I particularly enjoyed. I really felt for both of them by the end of the book and could see why they made the choices they made (even if they didn't make any logical sense).</p>
<p>The magic of the world was also neat. It's fascinating to see the magic of real world traditions. I honestly don't know how much of it was 'real' and how much embellished, but it all stayed just close enough to reality that I could see such things happening just like that in a close cousin of our own world.</p>
<p>Overall, this is one of the best books I've read this year. I'm glad my book club choose it, otherwise it might have been a while before I got around to it.</p>
<p>Side note: It looks like there may be <a href="https://www.goodreads.com/book/show/27234491-the-iron-season">a sequel</a> in the works? Tentative release date in 2018 though... So it goes.</p>
<hr />
<p>One more book club offshoot before I get back to my original reading list: <a href="https://www.goodreads.com/book/show/7163862-zoo-city">Zoo City</a> by <a href="https://www.goodreads.com/author/show/426034.Lauren_Beukes">Lauren Beukes</a>. If it's anywhere near as good as The Golem and the Jinni, I cannot wait.</p>]]></content></entry><entry><title>Advent of Code: Day 9</title><link href="//blog.jverkamp.com/2015/12/09/advent-of-code-day-9" /><id>urn:uuid:3e5f9ba8-905e-0cbb-f48a-bb215e562fe1</id><updated>2015-12-09T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/9">Source</a></p>
<p><strong>Part 1:</strong> Given a list of distances between cities of the form <code>London to Dublin = 464</code>, calculate the shortest route that visits each city exactly once.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/9">Source</a></p>
<p><strong>Part 1:</strong> Given a list of distances between cities of the form <code>London to Dublin = 464</code>, calculate the shortest route that visits each city exactly once.</p>
<!--more-->
<pre class="python"><code>routes = collections.defaultdict(
  lambda : collections.defaultdict(
    lambda : float("inf")
  )
)

for line in sys.stdin:
    src, dst, dist = re.match(r'(\w+) to (\w+) = (\d+)', line).groups()
    dist = int(dist)

    routes[src][dst] = dist
    routes[dst][src] = dist

best_length, best_ordering = min(
    (sum(
      routes[src][dst]
      for src, dst in zip(ordering, ordering[1:])
    ), ordering)
    for ordering in itertools.permutations(routes.keys())
)

print(best_length)</code></pre>
<p>There are a few neat tricks here that I've used. First <code>routes</code> is defined as nested <code>defaultdict</code>, with an eventual default value of <code>float("inf")</code>. This solves two problems:</p>
<ol>
  <li>We don't have to explicitly check if a station exists before adding a route to it:

  <pre class="python"><code>routes[src][dst] = dist</code></pre>

  rather than

  <pre class="python"><code>if src in routes:
  routes[src][dst] = dist
else:
  routes[src] = {dst: dist}</code></pre>
  </li>
  <li>Any missing routes will have an infinite distance, which will work correctly with <code>+</code> and <code>min</code>.</li>
</ol>
<p>We add each distance to both <code>routes[src][dst]</code> and <code>routes[dst][src]</code> so that we don't have to worry about ordering when we calculate full routes. The other way to do this would be to sort <code>src</code> and <code>dst</code> so that <code>src < dst</code> is always true. I think this way is a little cleaner.</p>
<p>Next, we use a bunch of tools to calculate the shortest route.</p>
<p>First, <code>itertools.permutations</code> will give us every possible ordering:</p>
<pre class="python"><code>&gt;&gt;&gt; pprint.pprint(list(itertools.permutations(routes.keys())))
[('London', 'Belfast', 'Dublin'),
 ('London', 'Dublin', 'Belfast'),
 ('Belfast', 'London', 'Dublin'),
 ('Belfast', 'Dublin', 'London'),
 ('Dublin', 'London', 'Belfast'),
 ('Dublin', 'Belfast', 'London')]</code></pre>
<p>Next, <code>zip</code> over <code>ordering</code> and <code>ordering[1:]</code> will give us the pairs of stations (since <code>zip</code> after exhausting its shortest argument):</p>
<pre class="python"><code>&gt;&gt;&gt; ordering = ('Dublin', 'Belfast', 'London')
&gt;&gt;&gt; pprint.pprint(list(zip(ordering, ordering[1:])))
[('Dublin', 'Belfast'), ('Belfast', 'London')]</code></pre>
<p>Next, we can get the distance for each pairing and <code>sum</code> them all up. This is where <code>float("inf")</code> really comes in handy (although in this smaller example, we don't need it):</p>
<pre class="python"><code>&gt;&gt;&gt; orderings = (routes[src][dst] for src, dst in zip(ordering, ordering[1:]))
&gt;&gt;&gt; pprint.pprint(list(orderings))
[141, 518]
&gt;&gt;&gt; pprint.pprint(sum(orderings))
659</code></pre>
<p>That, we wrap up in a tuple of <code>(distance, ordering)</code> so that they are sortable. Then, apply <code>min</code> to that to find the route with the minimum distance and unpack the tuple again.</p>
<p>And that's it. Minimum distance.</p>
<p>It's certainly a brute force solution in that it will try every possible route to find the shortest one. There are probably a few dynamic programming tricks that could cut that down a bit. On the other hand, the input is relatively short (28 connections between 8 stations for a total of 40320 orderings), so just do them all.</p>
<p><strong>Part 2:</strong> Find the longest route.</p>
<p>Just change <code>min</code> to <code>max</code>.</p>
<p>This wouldn't work if there wasn't a connection listed between every possible station (there is in my given input, since 8 stations will have <code>8*7/2 = 28</code> connections). That's solveable though. Just use <code>float("-inf")</code> for the default distance, so that any routes with invalid stations will have an infinitely small distance.</p>
<p>This was a pretty cool problem again!</p>]]></content></entry><entry><title>Advent of Code: Day 8</title><link href="//blog.jverkamp.com/2015/12/08/advent-of-code-day-8" /><id>urn:uuid:843d447d-6189-6d67-4c59-7ce85e2a5d3c</id><updated>2015-12-08T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/8">Source</a></p>
<p><strong>Part 1:</strong> Given an escaped string of the form <code>"\xa8br\x8bjr\""</code>, convert it to the escaped form: <code>br js</code>. Calculate the total difference of lengths between the former (<code>16</code>) and the latter (<code>5</code>).</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/8">Source</a></p>
<p><strong>Part 1:</strong> Given an escaped string of the form <code>"\xa8br\x8bjr\""</code>, convert it to the escaped form: <code>br js</code>. Calculate the total difference of lengths between the former (<code>16</code>) and the latter (<code>5</code>).</p>
<!--more-->
<pre class="python"><code>memory_count = 0
raw_count = 0

for line in sys.stdin:
    raw = line.strip()
    parsed = ast.literal_eval(raw) # This is probably cheating

    raw_count += len(raw)
    memory_count += len(parsed)

print(raw_count - memory_count)</code></pre>
<p>For a basic solution, we can cheat and use the <code>ast</code> module. It can interpret any Python literal, which includes escaped strings. Free!</p>
<p>If we actually want to do it ourselves, it's straight forward enough to use regular expressions instead:</p>
<pre class="python"><code>memory_count = 0
raw_count = 0

patterns = [
    (r'\\"', '"'),
    (r'\\\\', r'\\'),
    (r'\\x(\d\d)', chr),
    (r'^"(.*)"$', r'\1'),
]

for line in sys.stdin:
    parsed = raw = line.strip()
    for src, dst in patterns:
        parsed = re.sub(src, dst, parsed)

    print(raw, parsed)

    raw_count += len(raw)
    memory_count += len(parsed)

print(raw_count - memory_count)</code></pre>
<p>One interesting aspect is <code>chr</code>. That will convert a number such as <code>\x65</code> into the corresponding character <code>A</code>. It doesn't really matter since we just want the count, but it's kind of elegant.</p>
<p>There is a subtle bug in this, bonus points to anyone that can figure it out. But for the moment, it works great on the given test cases.</p>
<p><strong>Part 2:</strong> Do the opposite. Add another level of encoding such that <code>"\xa8br\x8bjr\""</code> would become <code>\"\\xa8br\\x8bjr\\\"\"</code>.</p>
<pre class="python"><code>raw_count = 0
encoded_count = 0

for line in sys.stdin:
    raw = line.strip()
    encoded = re.sub(r'(["\\])', r'\\\1', raw)

    raw_count += len(raw)
    encoded_count += len(encoded) + 2 # Quotes are not included

print(encoded_count - raw_count)</code></pre>
<p>This time since we don't have different behavior for the different escaped characters, we can use a single regular expression.</p>
<p>Not quite as interesting as <a href="//blog.jverkamp.com/2015/12/07/advent-of-code-day-7">Day 7</a>, but still neat.</p>]]></content></entry><entry><title>Free² HTTPS blog hosting via GitHub and CloudFlare</title><link href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare" /><id>urn:uuid:e034b0e0-08d4-330c-6f0a-b7af6af134cd</id><updated>2015-12-07T00:00:00Z</updated><summary type="html"><![CDATA[<p>The eagle-eyed among you<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> may have noticed something a bit different since last night:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" /></a></p>
<p>That's right, I'm finally using HTTPS!</p>
]]></summary><content type="html"><![CDATA[<p>The eagle-eyed among you<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span> may have noticed something a bit different since last night:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/https.png" /></a></p>
<p>That's right, I'm finally using HTTPS!</p>
<!--more-->
<p>Coming on the heels of the <a href="https://letsencrypt.org/">Let's Encrypt</a> public beta, you might think I'm using that. If I were running this blog on my own servers, I probably would be. But since I'm actually (for the moment) using <a href="https://pages.github.com/">GitHub pages</a>, that's not actually the case. I'm actually using <a href="https://www.cloudflare.com/">CloudFlare's</a> free<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span> tier.</p>
<p>Basically, here is my tech stack:</p>
<p>Source files are written in Markdown(ish) stored in a GitHub git repo: <a href="https://github.com/jpverkamp/blog">github:jpverkamp/blog</a></p>
<p>Source files are translated into static HTML via my custom blog generator: <a href="https://github.com/jpverkamp/blog-generator">github:jpverkamp/blog-generator</a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span></li></p>
<p>Files are deployed to a GitHub pages repo: <a href="https://github.com/jpverkamp/jpverkamp.github.io">github:jpverkamp/jpverkamp.github.io</a>, which you used to be able to directly access in the browser at <a href="http://jpverkamp.github.io">jpverkamp.github.io</a><span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span></p>
<p>CloudFlare handles my DNS, with a <a href="https://en.wikipedia.org/wiki/CNAME">CNAME</a> directing <code>blog.jverkamp.com</code> to <code>jpverkamp.github.io</code>:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-options.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-options.png" /></a></p>
<p>A custom Page Rule tells CloudFlare to automatically redirect incoming HTTP traffic to HTTPS:</p>
<p><a href="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-page-rule.png" data-toggle="lightbox"><img src="//blog.jverkamp.com/2015/12/07/free-https-blog-hosting-via-github-and-cloudflare/cloudflare-page-rule.png" /></a></p>
<p>In order to ease this transaction, I changed my config file so that all internal links to my own blog now use a relative protocol: <code>//blog.jverkamp.com</code></p>
<p>And... that's it.</p>
<p>I only had one hiccup transferring my DNS entries to CloudFlare (it missed email records on a subdomain), but other than that it was rather easy to set up.</p>
<p>If you haven't given it a try, check it out! Between CloudFlare and now Let's Encrypt, there's really no good reason you shouldn't be encrypting just about everything.</p>]]></content></entry><entry><title>Advent of Code: Day 7</title><link href="//blog.jverkamp.com/2015/12/07/advent-of-code-day-7" /><id>urn:uuid:43df33f1-13b4-5b4b-cbce-a7118aadaadd</id><updated>2015-12-07T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://adventofcode.com/day/7">Source</a></p>
<p><strong>Part 1:</strong> Given a list of definitions of the form <code>123 -> x</code>, <code>NOT e -> f</code>, and <code>x AND y -> z</code>, with possible operations <code>NOT</code>, <code>AND</code>, <code>OR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, find the value of <code>a</code>. Assume all values are 16-bit integers.</p>
<!--more-->
<p>This one is actually really cool. It's basically a full <a href="https://en.wikipedia.org/wiki/declarative_programming language">declarative programming language</a>.</p>
<pre class="python"><code>monops = {
    'NOT': lambda x : ~x & 0xFFFF,
}

binops = {
    'AND': operator.and_,
    'OR': operator.or_,
    'LSHIFT': operator.lshift,
    'RSHIFT': operator.rshift,
}

machine = {}

for line in sys.stdin:
    line = line.strip()

    m = (
        re.match(r'(\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) (\w+) -&gt; (\w+)', line)
        or re.match(r'(\w+) (\w+) -&gt; (\w+)', line)
    ).groups()

    machine[m[-1]] = m[:-1]

def evaluate(register_or_value):
    try:
        return int(register_or_value)
    except:
        return run(register_or_value)

def run(register, state = {}):
    if not register in state:
        command = machine[register]

        if len(command) == 1:
            value, = command
            state[register] = evaluate(value)

        elif len(command) == 2:
            monop, input = command
            state[register] = monops[monop](evaluate(input))

        elif len(command) == 3:
            input_1, binop, input_2 = command
            state[register] = binops[binop](evaluate(input_1), evaluate(input_2))

    return state[register]

print(run('a'))</code></pre>
<p>Basically, we have two interesting functions: <code>evaluate</code> and <code>run</code>. Each of those will be applied to any parameters. <code>evaulate</code> will check first if the parameter is an integer, if so return it directly. If not, fall back to <code>run</code>, which is a <a href="https://en.wikipedia.org/wiki/memoized">memoized</a> virtual machine.</p>
<p>If we have the values of any inputs (either because they are numeric or because we've already calculated them), it will directly calculate the value for that gate and cache it. If not, it will calculate any recursive outputs it needs (caching them as well), and then calculate it's own. Through the power of <a href="https://en.wikipedia.org/wiki/dynamic_programming">dynamic programming</a>, this will naturally resolve the order the gates need to be run in while still running in <code>O(n)</code> time to the number of gates. Very cool, in my opinion<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>.</p>
<p>The only other oddity is the definition of <code>NOT</code>. Since Python integers are not 16-bits, doing a bitwise and with <code>0xFFFF</code> (the maximum 16-bit value) will lock the result into that range.</p>
<p><strong>Part 2:</strong> Take the value of <code>a</code> after running part 1 and assign it to <code>b</code>. Run the simulation again.</p>
<p>Due to how I load in the instructions, this is as easy as adding a line of the form <code>14710 -> b</code> to the end of my input before running it. That will replace the previous command for <code>b</code>. You can do it in a <a href="http://www.zsh.org/"><code>zsh</code></a> one liner<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span> shells would work just as well}:</p>
<pre class="zsh"><code>{cat input.txt; (echo "\n" &#96;cat input.txt | python part-1.py&#96; "-&gt; b")} | python3 part-1.py</code></pre>]]></content></entry></feed>