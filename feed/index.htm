<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jverkamp.com</title><link href="http://blog.jverkamp.com" /><link rel="self" href="http://blog.jverkamp.com/feed/" /><updated>2015-11-29T00:00:00Z</updated><author><name>JP Verkamp</name></author><id>urn:uuid:f148b655-ada3-c720-0c01-ca384ab68088</id><entry><title>Spin Saga</title><link href="http://blog.jverkamp.com/2015/11/29/spin-saga" /><id>urn:uuid:7915d2dd-c892-c86c-ddbf-677b73870c5b</id><updated>2015-11-29T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/910863.Spin"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/1-spin.jpg" /></a> <a href="https://www.goodreads.com/book/show/116410.Axis"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/2-axis.jpg" /></a> <a href="https://www.goodreads.com/book/show/9359796-vortex"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/3-vortex.jpg" /></a></p>
<p>Back to a nice bit of science fiction: the <a href="https://www.goodreads.com/series/52279-spin-saga">Spin Saga</a> by <a href="https://www.goodreads.com/author/show/27276.Robert_Charles_Wilson">Robert Charles Wilson</a>.</p>
<p>It's an interesting trilogy, starting with big idea science fiction reflecting on the personal level of the characters (check out the individual review for Spin for a bit more detail). The second is quite a bit weaker, not quite as 'big' as the first book. The third is pretty solid again, although it's structurally odd.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/910863.Spin"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/1-spin.jpg" /></a> <a href="https://www.goodreads.com/book/show/116410.Axis"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/2-axis.jpg" /></a> <a href="https://www.goodreads.com/book/show/9359796-vortex"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/3-vortex.jpg" /></a></p>
<p>Back to a nice bit of science fiction: the <a href="https://www.goodreads.com/series/52279-spin-saga">Spin Saga</a> by <a href="https://www.goodreads.com/author/show/27276.Robert_Charles_Wilson">Robert Charles Wilson</a>.</p>
<p>It's an interesting trilogy, starting with big idea science fiction reflecting on the personal level of the characters (check out the individual review for Spin for a bit more detail). The second is quite a bit weaker, not quite as 'big' as the first book. The third is pretty solid again, although it's structurally odd.</p>
<!--more-->
<p>Individual reviews (minor spoilers):</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/910863.Spin"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/1-spin.jpg" /></a></p>
<p>(minor spoilers; although nothing more than used to be on the Goodreads summary)</p>
<p>I really enjoy science fiction where they take a really big / weird idea and just run with it. Spin is exactly that sort of book. In a nutshell, one night all of the stars seem to go out. Over the book, the protagonists discover that not the stars didn't actually go out, but rather the Earth was enveloped in a shell that is causing time on Earth to run roughly 100 million times slower, while at the same time preventing any ill effects therefrom.</p>
<p>It's a really cool idea and lets the author really jump through time in a way that not many novels can successfully pull off. On the level of the characters, we follow the main characters from the time the stars go out when they are children through the rest of their lives, jumping sometimes decades at a time (roughly in two different timeslines: one starting at age 10 and jumping forward, the other staying relatively constant towards the end of the timeline). On the scale of the rest of the universe, our sun grows old and warms the rest of the solar system, the stars all move about, and our galaxy even collides with another.</p>
<p>There is an interesting mix of high level science fiction on how the world changes as an impact of the Spin (the name of the shell enclosing the Earth for reasons that I never quite caught) with the low level lives of the characters. I didn't particularly like any of the characters, which is unfortunate, but having them ground the story was I still think a good choice.</p>
<p>Overall, solid big-idea science fiction. Well worth the read.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/116410.Axis"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/2-axis.jpg" /></a></p>
<p>Unfortunately, many of the other reviewers here are on point. In Spin, we followed the lives of a small groups of characters while <i>big ideas</i> happened around them, spanning either decades or billions of years, depending on your perspective. In Axis, the ideas are not nearly as big, the timespan isn't quite so vast, and the cast of characters has changed to ones I don't find myself caring about as much.</p>
<p>There is a bit of an interesting follow up here to the last chapter of Spin: what's on the other side of the arch and just what <i>are</i> the Hypotheticals. I think the first could make an interesting story all of itself, just following a series of explorers further and further through the worlds, but that's not what Axis is. And so far as the second--we don't really learn anything new. There are hints of something bigger (which is saying something, given something on a scale with the entire galaxy) and a few smaller neat ideas, but nothing quite comes together.</p>
<p>All together, I think one can either read just Spin or read the entire series (since from what I've read, Vortex is more of a sequel to Axis than either was directly to Spin). Looks like we'll give Vortex a chance.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/9359796-vortex"><img src="http://blog.jverkamp.com/2015/11/29/spin-saga/3-vortex.jpg" /></a></p>
<p>After the strong opening in Spin and the someone meh followup with Axis, I wasn't expecting particularly much from Vortex. Consider me pleasantly surprised.</p>
<p>Getting back to the huge events and big timespans of Spin, Vortex takes place ten thousand years after Axis, after the Temporal Arch discovered towards the end of that book ends its next cycle. Two of Axis' main characters (Turn and Isaac) are dumped out / recreated and picked up by a island sized ship that has been floating through arch after arch through the Eight Worlds (apparently the arches connecting Earth to Equatoria connect through several other worlds and finally end at Mars, which is a neat concept).</p>
<p>The far future society is interesting, as is the ruined Earth (global warming is bad). In the far future, societies seem to resolve around linked communities, either linking the thoughts of emotions of a community. The island they end up on is one of the latter, which has both its strengths but also a fair number of complexities, both of which I thought Vortex did an interesting job of exploring.</p>
<p>On the other hand, there is actually a second story line interwoven into Vortex, revealing the ten thousand year future as a story written by a possible mental health patient. Honestly, I'm not sure why this storyline is here; I thought those parts weren't nearly as interesting (we've already seen that part of the timeline after the Spin) and could have been left out. They did set up an interesting possibility for the very conclusion, but that could have done without as well.</p>
<p>We also do learn more about the Hypotheticals (not so hypothetical any more...), which remains a neat concept, even if one that doesn't always make terribly much sense (how do they communicate?).</p>
<p>Overall, my previous point from Axis remains: If you read Axis, read all three. Vortex is a solid conclusion and an interesting book on its own merits. If you're more pressed for time, you can read only Spin and be well off.</p>
<hr />
<p>That puts me at 89 for the year, slightly behind where I should be. Trying to read a book every 3.65 days on top of <a href="http://blog.jverkamp.com/2015/11/05/nanowrimo-2015">writing a novel</a> is... fun. Onwards though!</p>
<p>Next up, I'm going to finish the <a href="https://www.goodreads.com/series/99602-powder-mage">Powder Mage Trilogy</a>. The first book wasn't the best I've ever read, but it was good enough to give the other two a chance. Plus, I'm hoping for a few more answers. <img alt="smile" class="emoji" src="/emoji/smile.svg" /></p>]]></content></entry><entry><title>Peninsula Drive</title><link href="http://blog.jverkamp.com/2015/11/25/peninsula-drive" /><id>urn:uuid:1034e93a-2856-7a4e-d991-07c831d4ed71</id><updated>2015-11-25T00:00:00Z</updated><summary type="html"><![CDATA[<p>Another drive, this time mostly up and down the Pacific Coast.</p>
<div><div class="flickr-gallery" data-set-id="72157661105927050" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157661105927050">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Another drive, this time mostly up and down the Pacific Coast.</p>
<div><div class="flickr-gallery" data-set-id="72157661105927050" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157661105927050">View on Flickr</a></p></div>]]></content></entry><entry><title>NaNoWriMo 2015 Winner!</title><link href="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner" /><id>urn:uuid:ce9ed51c-167d-bb2d-37fb-68d0d8b84f38</id><updated>2015-11-24T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Winner-NaNoWriMo.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Winner-NaNoWriMo.jpg" /></a></p>
<p>This time around my goal was 2500 words per day.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Winner-NaNoWriMo.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Winner-NaNoWriMo.jpg" /></a></p>
<p>This time around my goal was 2500 words per day.</p>
<!--more-->
<p><a href="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Progress-NaNoWriMo.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/24/nanowrimo-2015-winner/2015-Progress-NaNoWriMo.png" /></a></p>
<p>I hit it more days than not, although I had a few days where I wrote little or even (twice) nothing. I had two great days, one of which was today, which pushed me over 50k. I'm also nowhere near the end of this book (I wouldn't be surprised if I cut close to half of what I've written thus far). It's certainly been an interesting journey.</p>]]></content></entry><entry><title>Sunday Drive</title><link href="http://blog.jverkamp.com/2015/11/22/sunday-drive" /><id>urn:uuid:adfd740c-438b-3d6d-7cb0-8cb396592c4d</id><updated>2015-11-22T00:00:00Z</updated><summary type="html"><![CDATA[<p>Family is in town, so we took a quick (relatively speaking) drive up to the Marin Highlands and caught the sunset at Ocean Beach on the way back. Beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157661489912326" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157661489912326">View on Flickr</a></p></div>]]></summary><content type="html"><![CDATA[<p>Family is in town, so we took a quick (relatively speaking) drive up to the Marin Highlands and caught the sunset at Ocean Beach on the way back. Beautiful.</p>
<div><div class="flickr-gallery" data-set-id="72157661489912326" data-per-page="30"></div><p><a href="https://flickr.com/photos/jpverkamp/sets/72157661489912326">View on Flickr</a></p></div>]]></content></entry><entry><title>The Girl with the Dragon Tattoo (The Millennium Trilogy)</title><link href="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo" /><id>urn:uuid:67be93f7-0aca-f00b-9251-5b6220058207</id><updated>2015-11-10T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/2429135.The_Girl_with_the_Dragon_Tattoo"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/1-with-the-dragon-tattoo.jpg" /></a> <a href="https://www.goodreads.com/book/show/5060378-the-girl-who-played-with-fire"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/2-played-with-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/6892870-the-girl-who-kicked-the-hornet-s-nest"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/3-kicked-the-hornets-nest.jpg" /></a></p>
<p>And now for something a little different (for me): <a href="https://www.goodreads.com/series/44598-millennium-trilogy">The Girl with the Dragon Tattoo / (The Millennium Trilogy)</a> by <a href="https://www.goodreads.com/author/show/706255.Stieg_Larsson">Stieg Larsson</a> (translated by <a href="https://www.goodreads.com/author/show/2565625.Reg_Keeland">Reg Keeland</a>). Almost all of my reading is science fiction or fantasy. The Millennium Trilogy is more of an investigative / thriller set more or less in the real world.</p>
]]></summary><content type="html"><![CDATA[<p><a href="https://www.goodreads.com/book/show/2429135.The_Girl_with_the_Dragon_Tattoo"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/1-with-the-dragon-tattoo.jpg" /></a> <a href="https://www.goodreads.com/book/show/5060378-the-girl-who-played-with-fire"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/2-played-with-fire.jpg" /></a> <a href="https://www.goodreads.com/book/show/6892870-the-girl-who-kicked-the-hornet-s-nest"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/3-kicked-the-hornets-nest.jpg" /></a></p>
<p>And now for something a little different (for me): <a href="https://www.goodreads.com/series/44598-millennium-trilogy">The Girl with the Dragon Tattoo / (The Millennium Trilogy)</a> by <a href="https://www.goodreads.com/author/show/706255.Stieg_Larsson">Stieg Larsson</a> (translated by <a href="https://www.goodreads.com/author/show/2565625.Reg_Keeland">Reg Keeland</a>). Almost all of my reading is science fiction or fantasy. The Millennium Trilogy is more of an investigative / thriller set more or less in the real world.</p>
<!--more-->
<p>Individual reviews (warning: there are spoilers in the latter reviews for the earlier books):</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/2429135.The_Girl_with_the_Dragon_Tattoo"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/1-with-the-dragon-tattoo.jpg" /></a></p>
<p>It's not that often any more that I finish a book in a day. That should tell you something about what I thought about the Girl with the Dragon Tattoo. Especially when it isn't fantasy. It isn't science fiction. It isn't horror (at least not the supernatural sort). Really, it's more of a investigation / thriller. Not a genre that I read that often.</p>
<p>Honestly, for the first half of the book, I wasn't sure that I was even going to finish it, let alone read the sequels. There were a few different story lines going on that I didn't really see how they fit together. Nothing overly much seemed to be happening. Then, around halfway through (when the main characters finally started to interact more), things really started moving. I read the rest of the book in one sitting.</p>
<p>It's certainly disturbing at times. It reminds me of Koontz style thrillers  (who's books I like, so that is a good thing) in shining a light into the darker corners of humanity--albeit without the supernatural angle Koontz usually has.</p>
<p>Then there's the rape scenes (Yes, that's probably a spoiler. But given the content, the fact that they're fairly well known, and that they don't end up having <i>that</i> large of an impact on the plot...).</p>
<p>They certainly bring another level of depth and pack a punch, but honestly I think the novel would be just as strong without them. There is plenty of other characterization for the characters involved and as mentioned, they don't seem to advance the plot. Honestly, I felt like they were included for the sake of including them, which is never particularly great writing, let alone for a rape scene.</p>
<p>That being said, it's an intense book. The second half drives to a powerful conclusion and there's a twist or two that I only saw coming in hindsight. I'm honestly surprised, but I'll definitely be moving on to the sequels.</p>
<p>Side note: There are points that you can tell this book was originally written in a different language. Some of the phrasing is odd along with parts of the setting (although that could have been done even in an English language novel). I don't think it detracted from the work, but it's something to keep in mind.</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/5060378-the-girl-who-played-with-fire"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/2-played-with-fire.jpg" /></a></p>
<p>The Girl with the Dragon Tattoo took a while to get into. It wasn't until Lisbeth and Blomkvist were finally in the same place perhaps halfway through the book that things really started moving.</p>
<p>The Girl Who Played with Fire is much the same.</p>
<p>Honestly, if I were to rate the first half of the book, I would give it three stars, maybe even two. There are just a lot of details that I just don't particularly care about. It's only halfway through, when Lisbeth stands accused of murder and various investigations are spinning once again out of control that the book starts getting good.</p>
<p>The second half? Five stars. I read it in one sitting. Things just keep getting more and more screwed up, with corruption and terrible people all over this place. I'll say that for Larsson. He can write terrible people.</p>
<p>One weird thing throughout is that there is entirely too much detail about mundane things. On several occasions you get essentially a stream of thought for everything that a character is doing... when they're really not doing anything interesting. Shopping, for example.</p>
<p>All together though, it's a strong book. Lisbeth has been through hell and emerged with a powerful combination of strength and brokenness. There are terrible people in the world, but they can be beaten. It's definitely the second of a trilogy, given that ending, and now I have to finish that. Hopefully, it doesn't take so long to speed up...</p>
<hr />
<p><a href="https://www.goodreads.com/book/show/6892870-the-girl-who-kicked-the-hornet-s-nest"><img src="http://blog.jverkamp.com/2015/11/10/the-girl-with-the-dragon-tattoo/3-kicked-the-hornets-nest.jpg" /></a></p>
<p>Given that Hornet's Nest kicks off immediately following the events of Played with Fire, I was hoping that it could keep up the momentum of the previous book and avoid the slow first half / crazy second half that the previous two books had suffered from. Unfortunately, no such luck. If anything, it takes even longer to get moving and the conclusion isn't quite as action packed as the previous novels.</p>
<p>On the other hand, I do feel like this was a solid conclusion to the series. It wrapped up a lot of loose ends that I hadn't even realized I was missing and finished character arcs, particularly for Lisbeth. She's still odd, but I'm really starting to understand where she comes from. And in the end, she wins. I would have been rather grumpy with the author (even if he is dead) had she not come out all right in the end.</p>
<p>One bit that I thought was odd was the subplot about Erika Berger changing jobs and being stalked. Just like the rape in the first book (which did turn out to have a much larger impact on the latter two books), I don't feel like it adds particularly much to the story. It does fit the theme about systematic corruption and victimization of women, but I feel like the story would have been just as strong without it.</p>
<p>As I've mentioned before, I don't read particularly much that's this close to the real world, but I did enjoy all three books in this series. Even though I would consider it the weakest of the three; if you've read the first two, you should read this one as well.</p>
<hr />
<p>Overall, it's hard to say that I actually 'liked' the books. They're certainly well written, although you can tell at times that they were written in Swedish and translated. But the subject matter is rough to read about, especially given that it's entirely possible for such things to be happening in the here and now. I do recommend at least the first though. It's something that people should read, if just for another perspective on life.</p>
<p>On another note, it's a little strange to know that you are reading a series published posthumously. I'm not sure if it actually would have changed how I read the stories or how I think about them had the author still been alive, but it is still something to think about.</p>
<p>Next up, back to science fiction: <a href="https://www.goodreads.com/book/show/910863.Spin">Spin</a> by <a href="https://www.goodreads.com/author/show/27276.Robert_Charles_Wilson">Robert Charles Wilson</a>. The premise is that one night the stars went out and now time on the Earth is running roughly 100 million times slower than the rest of the universe. It's a really neat idea; I hope the execution is as good.</p>]]></content></entry><entry><title>NaNoWriMo 2015</title><link href="http://blog.jverkamp.com/2015/11/05/nanowrimo-2015" /><id>urn:uuid:1cebb79e-a448-08da-2796-1af10dc2c2cf</id><updated>2015-11-05T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2014/11/04/nanowrimo-2014">Last year</a> I had a two week old; this year, I have a one year old. I'm honestly not sure yet which is more distracting!</p>
<p><a href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" data-toggle="lightbox"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>This year, I've been going for 2500 words per day (I know). It's an intense pace, but I've done it so far. And, if all goes well, I'll be done before Thanksgiving. Of course, I won't actually stop then...</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2014/11/04/nanowrimo-2014">Last year</a> I had a two week old; this year, I have a one year old. I'm honestly not sure yet which is more distracting!</p>
<p><a href="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" data-toggle="lightbox"><img src="http://nanowrimo.org/widget/MyMonth/jpverkamp.png" /></a></p>
<p>This year, I've been going for 2500 words per day (I know). It's an intense pace, but I've done it so far. And, if all goes well, I'll be done before Thanksgiving. Of course, I won't actually stop then...</p>
<!--more-->
<blockquote>
    <p>Title: <strong>The Last John Smith</strong></p>

    <p>Premise: <em>Among a thousand parallel realities, everyone has a thousand twins. Except for John Smith. Someone has been systematically killing all of the alternate John Smiths on all of the worlds.</em><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></p>
</blockquote>
<p>Eventually, I'll probably publish the first chapter online. If anyone wants to read the story as I go or after I'm done though, just <a href="mailto:me@jverkamp.com">email me</a>. I'd be happy to have more beta readers.</p>]]></content></entry><entry><title>Mostly homemade pumpkin pie</title><link href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie" /><id>urn:uuid:a8effba5-c1cc-f361-f262-5673a40cf49c</id><updated>2015-11-02T00:00:00Z</updated><summary type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>
<p>Pumpkin pie, truly the reason for the season.</p>
<p>Other than the crust, everything is made from scratch! Including the whipped cream.</p>
]]></summary><content type="html"><![CDATA[<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>
<p>Pumpkin pie, truly the reason for the season.</p>
<p>Other than the crust, everything is made from scratch! Including the whipped cream.</p>
<!--more-->
<h3>Pumpkin pie</h3>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Pumpkins</li>
    <li>1 pie crust</li>
    <li>2 large eggs</li>
    <li>1 cup heavy cream</li>
    <li>1 teaspoon ground cinnamon</li>
    <li>1/4 teaspoon ground cardamom</li>
    <li>1/4 teaspoon ground nutmeg</li>
    <li>1/4 teaspoon ground cloves</li>
    <li>1/2 cup sugar</li>
    <li>1/2 cup maple extract</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
        <li>Cut pumpkin in half; remove seeds</li>
    <li>Bake at 425℉ for 40-50 minutes</li>
    <li>Remove from oven and allow to cool</li>
    <li>Scoop out flesh and puree</li>
    <li>Mix puree, maple syrup, and vanilla</li>
    <li>Add eggs, spices and sugar, and cream</li>
    <li>Bake for 15 minutes at 425℉</li>
    <li>Turn oven down to 350℉ minutes, bake for 90 more minutes</li>
    <li>Cool and serve</li>
</ol>
<h3>Whipped cream</h3>
<p><strong>Ingredients</strong></p>
<ul>
        <li>1 cup heavy whipping cream<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>2 tablespoons sugar</li>
        <li>Optional: vanilla</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
        <li>Whisk for 10-15 minutes</li>
</ol>
<p>And now pictures, because pictures are awesome!</p>
<p>First, you cut up the pumpkins and scoop out the guts:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/1-cut-up-and-scoop.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/1-cut-up-and-scoop.jpg" /></a></p>
<p>My daughter is helping. She decorated hers:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/2-daughter-is-helping.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/2-daughter-is-helping.jpg" /></a></p>
<p>Next, you cook them for a while (see above). The nice bit is that once you've cooked them, the skin comes right off. That is glorious, since it's so much easier to peel than with a knife.</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/3-peel.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/3-peel.jpg" /></a></p>
<p>See, the skin just comes right off:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/4-peel-easy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/4-peel-easy.jpg" /></a></p>
<p>Next, mix everything except the spices into the pumpkin puree:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/5-mix.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/5-mix.jpg" /></a></p>
<p>And now mix in the spices. The spices really make the pie:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/6-add-spices.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/6-add-spices.jpg" /></a></p>
<p>Then... bake! It's odd that it's at two different temperatures, but so it goes:</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/7-bake.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/7-bake.jpg" /></a></p>
<p>And, we're done!</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/8-all-done.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/8-all-done.jpg" /></a></p>
<p>Mmm, top with homemade whipped cream and nom away.</p>
<p><a href="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/11/02/mostly-homemade-pumpkin-pie/9-enjoy.jpg" /></a></p>]]></content></entry><entry><title>Finding EC2 instances by tag</title><link href="http://blog.jverkamp.com/2015/10/30/finding-ec2-instances-by-tag" /><id>urn:uuid:dcd71490-1abf-0503-d116-70fb4eeb29cd</id><updated>2015-10-30T00:00:00Z</updated><summary type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
]]></summary><content type="html"><![CDATA[<p>Another script similar to my previous post about <a href="http://blog.jverkamp.com/2015/07/22/finding-aws-iam-users-by-access-key">Finding AWS IAM users by access key</a>. This time, we want to do much the same thing for EC2 instances by tag.</p>
<!--more-->
<pre class="python"><code>#!/usr/bin/env python3

import argparse
import boto.ec2
import json
import re
import sys

parser = argparse.ArgumentParser(description = 'Find out information about EC2 instances')
parser.add_argument('--region', default = 'us-west-2', help = 'The AWS region to search')
parser.add_argument('--limit', type = int, default = 1, help = 'How many results to report, 0 will return all')
parser.add_argument('--output', default = 'private_ip_address', help = 'The output to fetch for each instance; json will output a json object will all of the outputs')
parser.add_argument('filters', nargs = argparse.REMAINDER, help = 'Regular expressions to apply to each tag')
args = parser.parse_args()

ec2 = boto.ec2.connect_to_region('us-west-2')

if not args.filters:
    raise Exception('You must specify at least one instance')

def include_instance(instance):
    if instance.state != 'running':
        return

    if not args.filters:
        return instance

    for filter in args.filters:
        for tag_key in instance.tags:
            tag_value = instance.tags[tag_key]
            tag = '{}={}'.format(tag_key, tag_value).lower()

            if re.search(filter, tag_value):
                return instance

def filter():
    for reservation in ec2.get_all_instances():
        for instance in reservation.instances:
            if include_instance(instance):
                yield instance

for i, instance in enumerate(filter(), 1):
    if args.output == 'json':
        print(json.dumps(instance.__dict__, default = str))
    else:
        print(getattr(instance, args.output))

    if args.limit and i &gt;= args.limit:
        break</code></pre>
<p>It's original goal was to get a single IP from a group of servers with a specific tag so that I could log in and poke around:</p>
<pre class="bash"><code>$ ssh &grave;ec2 prod-server&grave;</code></pre>
<p>There are a few other uses though, especially when combined with other tools such as <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.</p>
<pre class="bash"><code>ec2 --limit 0 --output json | jq '.instance_type' | sort | uniq -c | sort -nr

  27 "t2.micro"
   5 "m3.medium"
   1 "c4.xlarge"</code></pre>
<p>That's neat.</p>
<p>Much as <code>who-iam</code> it's a bit slow, but it still works great.</p>
<p>If you'd like to download the script, it's available in my <a href="https://github.com/jpverkamp/dotfiles">dotfiles</a>: <a href="https://github.com/jpverkamp/dotfiles/blob/master/bin/ec2">ec2</a></p>]]></content></entry><entry><title>Takuzu solver</title><link href="http://blog.jverkamp.com/2015/10/29/takuzu-solver" /><id>urn:uuid:db1688ed-6c5a-fd87-ce8b-71c39075285b</id><updated>2015-10-29T00:00:00Z</updated><summary type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
]]></summary><content type="html"><![CDATA[<p>Based on a <a href="">/r/dailyprogrammer</a> puzzle: <a href="https://www.reddit.com/r/dailyprogrammer/comments/3pwf17/20151023_challenge_237_hard_takuzu_solver/">Takuzu solver</a>.</p>
<p>Basically, Takuzu is a logic puzzle similar to Sudoku. You are given a grid partially filled with 0s and 1s. You have to fill in the rest of the grid according to three simple rules:</p>
<ul>
    <li>You cannot have more than three of the same number in a line</li>
    <li>Each column must have an equal number of 0s and 1s<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span></li>
    <li>No two rows or no two columns can be identical</li>
</ul>
<p>Thus, if you have a puzzle like this:</p>
<pre class="text"><code>0.01.1
0....1
..00..
..00..
1....0
10.0.0</code></pre>
<p>One valid solution (most puzzles should have only a single valid answer, but that doesn't always seem to be the case):</p>
<pre class="text"><code>010101
001101
110010
010011
101100
101010</code></pre>
<p>Let's do it!</p>
<!--more-->
<p>First, we need some sort of structure to represent and read in a Takuzu board. I think I'm going to over-engineer a little bit here, since I think it will be helpful in the long run.</p>
<p>My basic idea is to represent it in a way without mutation, that is to say once I've created a board, that board will never change. That will make it easier to write a backtracking solution, since when we need to back up to a previous state, we just throw away any of the derivative boards.</p>
<p>Taking that a level further, let's represent the Takuzu board as a base board with an essentially a 'changelog' on top of it, storing any differences from the boards 'under' it. Something like this:</p>
<pre class="text"><code>....    ..1.    ....    ..1.
0.0. {- .... {- .... == 0.0.
..0.    ....    ....    ..0.
...1    ..1.    .0..    .011</code></pre>
<p>In that diagram, the board on the far left is the first layer, then the second is the next layer up, and the third is the final layer. The fourth image is the virtual board that any user of the program would actually see.</p>
<p>So how do we turn that into code?</p>
<pre class="python"><code>class Takuzu(object):

    def __init__(self, filename = None, parent = None):
        '''
        Represent a Takuzu puzzle (a grid of 0, 1, and .)

        If filename is set, load from file.
        If parent is set, extend that Takuzu puzzle.

        If neither or both is set, that is an error.
        '''

        if not (filename or parent) or (filename and parent):
            raise Exception('Set exactly one of filename and parent')

        self.size = 0
        self.tiles = collections.defaultdict(lambda : False)
        self.parent = False

        if parent:
            self.size = parent.size
            self.parent = parent

        elif filename:
            with open(filename, 'r') as fin:
                for row, line in enumerate(fin):
                    for col, char in enumerate(line.strip()):
                        if char in '01':
                            self.tiles[row, col] = char

                        self.size = col + 1

    def get(self, row = None, col = None):
        '''
        Access a tile in the current puzzle, return False for unset values

        If the current puzzle doesn't have a value set, recur to parents.
        If either row or col is set to None, return that entire row or column.
        If neither is set, return nested lists containing all current values.
        '''

        # Note: We need the ugly != None to correctly deal with row or col = 0.
        # Sometimes truthiness is annoying.

        if row != None and col != None:
            return self.tiles[row, col] or (self.parent and self.parent.get(row, col))
        elif row != None:
            return [self.get(row, col) for col in range(self.size)]
        elif col != None:
            return [self.get(row, col) for row in range(self.size)]
        else:
            return [
                [self.get(row, col) for col in range(self.size)]
                for row in range(self.size)
            ]

    def set(self, row, col, val):
        '''
        Create a child Takuzu object with the specific value set.

        If either row or column is set to None, fill any empty elements in that entire row
        with the given value.
        '''

        child = Takuzu(parent = self)

        if row != None and col != None:
            child.tiles[row, col] = val
        elif row != None:
            for col in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        elif col != None:
            for row in range(self.size):
                if not child.get(row, col):
                    child.tiles[row, col] = val
        else:
            raise Exception('Must set at least one of row and column')

        return child</code></pre>
<p>The interesting bits here are the <code>get</code> and <code>set</code> methods. <code>get</code>, as mentioned, assumes the layered structure above. It will start on the topmost layer (the actual object the program has a reference to) and try to look up the given point. If that fails (we're using a <code>collections.defaultdict</code>, so every reference will either by <code>'0'</code>, <code>'1'</code>, or <code>False</code>), fall back to the next layer up (the <code>parent</code>) until we either find one or run out of <code>parent</code> nodes.</p>
<p>Similarly, <code>set</code> doesn't actually change the current Takuzu object. Instead, it creates a new object with the current one as its parent, setting the new value in the child. This means that any values that were previously set are transparently available in the child, but we can at any point backtrack so long as we keep a reference to the now parent object around.</p>
<p>In addition, I've gone ahead and built in a bit of functionality that I know we're going to need into <code>get</code> and <code>set</code>. In either case, if you only specify either the <code>row</code> or <code>col</code> and leave the other empty (<code>None</code>), then we will return that entire row or column (or <code>set</code> any empty values). That's easy enough to code and it has the advantage of making it easy to compare rows to one another (for the third requirement above).</p>
<p>Okay, up next, we'll probably want a few more helper functions in this class in order to actually tell when we've solved one of these puzzles so the algorithms we eventually write can actually terminate:</p>
<pre class="python"><code>class Takuzu(object):
    ...

    def __eq__(self, other):
        '''Check if two Takuzu puzzles are equal.'''

        for row in range(self.size):
            for col in range(self.size):
                if self.get(row, col) != other.get(row, col):
                    return False

        return True

    def __str__(self):
        '''Return a string representation the same as can be read from a file.'''

        out = ''

        for row in range(self.size):
            for col in range(self.size):
                out += str(self.get(row, col) or '.')
            out += '\n'

        return out

    def is_full(self):
        '''If all values have been filled in.'''

        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    return False

        return True

    def is_valid(self):
        '''Test if the current is still possibly a valid solution. If it also is_full,
        the board is solved.'''

        # Cannot have three identical numbers in a line
        # Ignore unset pieces
        for row in range(self.size):
            for col in range(self.size):
                if not self.get(row, col):
                    continue

                if self.get(row - 1, col) == self.get(row, col) == self.get(row + 1, col):
                    return False

                if self.get(row, col - 1) == self.get(row, col) == self.get(row, col + 1):
                    return False

        # All rows and columns must have no more than the maximum (size/2) number of 0s or 1s
        for index in range(self.size):
            if (
                self.get(index, None).count('0') &gt; self.size / 2
                or self.get(index, None).count('1') &gt; self.size / 2
                or self.get(None, index).count('0') &gt; self.size / 2
                or self.get(None, index).count('1') &gt; self.size / 2
            ):
                return False

        # No two rows or columns can be equal (ignore rows/columns that contain unset values)
        # all(...) on a row or column will be true iff all values are set
        for first_index in range(self.size):
            for second_index in range(first_index):
                if (
                    all(self.get(first_index, None))
                    and all(self.get(None, first_index))
                    and (
                        self.get(first_index, None) == self.get(second_index, None)
                        or self.get(None, first_index) == self.get(None, second_index)
                    )
                ):
                    return False

        # Whee passed all three conditions!
        return True

    def is_solved(self):
        '''Return True iff this puzzle is solved.'''

        return self.is_full() and self.is_valid()</code></pre>
<p><code>__eq__</code> and <code>__str__</code> are 'magic' methods in Python that will define equality and converting this object to a string respectively. This will be nice to make sure we don't investigate the same board more than once later.</p>
<p>After that, we have <code>is_full</code>, <code>is_valid</code>, and <code>is_solved</code><span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>. In the first case, we're checking if a puzzle has everything filled in. That way we know if we can stop recurring one way or the other.</p>
<p><code>is_valid</code> is actually a relatively new method. Before that, I could only check if a puzzle <code>is_solved</code>, but this way we can eliminate entire branches of the search space much earlier. For example, as soon as a backtracking solution places the third <code>0</code> in a row, it can stop looking down that path since <code>is_valid</code> will return <code>False</code>. Finally, <code>is_solved</code>. It used to have most of the <code>is_valid</code> code, but once that method existed, a puzzle <code>is_solved</code> simply if both it <code>is_full</code> and it <code>is_valid</code>. Easy enough.</p>
<p>So how do we actually solve a puzzle with this?</p>
<p>Let's start with the simple (relatively speaking, since we've done it before) backtracking solution. Given everything that we have in the Takuzu class, the actual solver is actually really simple:</p>
<pre class="python"><code>def solve(takuzu):
    '''Solve a puzzle using backtracking (also a fall back for the human solver).'''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Otherwise, find one empty spot and try both possiblities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.insert(takuzu.set(row, col, value), 0)
                        return
        enqueue()

    return False</code></pre>
<p>Basically, we keep a stack of solutions, which will allow us to perform a <a href="https://en.wikipedia.org/wiki/depth-first_search">depth-first search</a><span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>.</p>
<p>Basically, create a branch, trying first a <code>0</code> in the first empty spot. Looking down that path, if we find a solution, we're done. If we don't try a <code>1</code> instead. That's really it. And it's actually relatively fast.</p>
<p>Given the input:</p>
<pre class="test"><code>0..1.0
0.11..
......
......
1..1..
.....0</code></pre>
<p>We can solve it easily enough:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.15 seconds</code></pre>
<p>Nice. (You can check out the <a href="https://github.com/jpverkamp/takuzu">full source</a> if you'd like to see how I'm handling the command line parameters along with a few other goodies.<span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>)</p>
<p>Unfortunately, as puzzles get a bit larger, that runtime isn't so great:</p>
<pre class="bash"><code>$ python3 takuzu.py --method backtracker sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 47.03 seconds</code></pre>
<p>Yeah...</p>
<p>We can do better.</p>
<p>How about instead of trying to solve the puzzle like a computer (brute forcing it), let's apply some heuristics more like a human would solve the puzzle. For example, if we see a pair of 0s next to each other, we know the tile on either side of it is a 1 (likewise for a pair of 0s separated by a single space and said space):</p>
<pre class="python"><code>def __third_of_a_kind__(takuzu):
    '''If adding a value would make three in a row, add the other.'''

    for row in range(takuzu.size):
        for col in range(takuzu.size):
            if takuzu.get(row, col):
                continue

            for ((offset1_row, offset1_col), (offset2_row, offset2_col)) in [
                # Two already in a line
                (( 0,  1), ( 0,  2)),
                (( 0, -1), ( 0, -2)),
                (( 1,  0), ( 2,  0)),
                ((-1,  0), (-2,  0)),
                # Two with a hole in between
                (( 0,  1), ( 0, -1)),
                (( 1,  0), (-1,  0)),
            ]:

                val1 = takuzu.get(row + offset1_row, col + offset1_col)
                val2 = takuzu.get(row + offset2_row, col + offset2_col)

                if val1 and val2 and val1 == val2:
                    return takuzu.set(row, col, invert(val1))

    return False</code></pre>
<p>Basically, for each empty tile in the current puzzle, compare each of six pairs. Either those in the four cardinal directions or the pair on either side horizontally or vertically.</p>
<p>Next rule, let's look for rows where we already have the necessary number of 0s and only need 1s. We can just fill those out:</p>
<pre class="python"><code>def __fill_rows__(takuzu):
    '''If we can figure out how many 0s and 1s we need for each and any row/col needs
    only 0s or 1s, add them'''

    # Try to fill any rows that have all of the needed 0s/1s but not the other
    for index in range(takuzu.size):
        for row, col in [(index, None), (None, index)]:
            for value in '01':
                # Have enough of 'value'
                if takuzu.get(row, col).count(value) == takuzu.size / 2:
                    # Not enough of the other one
                    if takuzu.get(row, col).count(invert(value)) &lt; takuzu.size / 2:
                        return takuzu.set(row, col, invert(value))

    return False</code></pre>
<p>It's neat how short that code is.</p>
<p>Finally (for the moment at least), let's write a slightly more complicated method. This time, let's take a single row or column and generate all the possible ways we can fill it out. Then remove those that would either lead to a duplicate or three in a row. If we have only exactly one row left, then we're golden. That's our row:</p>
<pre class="python"><code>def __fill_by_duplicates__(takuzu):
    '''Fill a puzzle by checking if any rows/cols are near enough to done that only one
    possibility is left.'''

    def row_or_col(which, index):
        if which == 'row':
            return takuzu.get(index, None)
        else:
            return takuzu.get(None, index)

    for major in ('row', 'col'):
        # Completed rows/cols have no Nones (so are 'all')
        completed = filter(all, [
            row_or_col(major, index)
            for index in range(takuzu.size)
        ])

        for index in range(takuzu.size):
            current = row_or_col(major, index)

            # Already a complete row/col, skip it
            if all(current):
                continue

            # Generate all posibilities, removing any that we already see
            possibilities = [
                option
                for option in permute_nones(current)
                if (
                    option not in completed
                    and option.count('0') == takuzu.size / 2
                    and option.count('1') == takuzu.size / 2
                    and '000' not in ''.join(option)
                    and '111' not in ''.join(option)
                )
            ]

            # If we have exactly one, set that one
            if len(possibilities) == 1:
                for other_index, value in enumerate(possibilities[0]):
                    if major == 'row':
                        takuzu = takuzu.set(index, other_index, value)
                    else:
                        takuzu = takuzu.set(other_index, index, value)

                return takuzu

    # Never found one
    return False</code></pre>
<p>I'm not nearly as happy with this rule as I am with the other two. Mostly because of the difference between rows and columns, the code is a little strange. The core of it is the <code>permute_nones</code> helper, which will take a list containing some number of <code>None</code> entries and fill them each with either a <code>0</code> or <code>1</code>, generating all possibilities:</p>
<pre class="python"><code>def permute_nones(ls):
    '''Helper function to generate all permutations from filling in 0s and 1s into a list'''

    if ls == []:
        yield []
    elif ls[0]:
        for recur in permute_nones(ls[1:]):
            yield [ls[0]] + recur
    else:
        for value in '01':
            for recur in permute_nones(ls[1:]):
                yield [value] + recur</code></pre>
<p>And that's all of my rules from now. The basic algorithm will be to apply each of those three rules in turn (since even after one has stopped working, another may 'unblock it'). If we get to the point where none of those three rules work, fall back to the backtracker we discussed above:</p>
<pre class="python"><code>RULES = [
    __third_of_a_kind__,
    __fill_rows__,
    __fill_by_duplicates__,
    solvers.backtracker.solve,
]

def solve(takuzu):
    '''Solve a Takuzu puzzle much as a human would: by applying a series of logical rules.'''

    while True:
        updated = False

        # If we've already solved it, return
        if takuzu.is_solved():
            return takuzu

        # Try to apply each rule in turn; if any rule works start over
        for rule in RULES:
            next_takuzu = rule(takuzu)

            if next_takuzu:
                takuzu = next_takuzu
                updated = True
                break

        # If we didn't apply any rule this iteration, done trying
        if not updated:
            break

    return takuzu</code></pre>
<p>Since we don't have to use the much slower (runtime <span>\(O(2^n)\)</span>) backtracking solution for the entire puzzle, this should run significantly faster:</p>
<pre class="python"><code>$ python3 takuzu.py --method human sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.13 seconds

$ python3 takuzu.py --method human sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 37.23 seconds</code></pre>
<p>Okay. So 0.13 seconds isn't <em>that</em> much faster than 0.15 seconds, and 37.23 seconds is only a bit faster than 47.03 seconds. For easier puzzles (those where a human wouldn't have to guess), you'll get a better improvement. These were considered 'hard'.</p>
<p>We can do better though.</p>
<p>Right now, we fall back to a pure backtracking solution rather than the faster human rules if we ever fail to advance. What if we combined the two models? Use the human solution until you get stuck; then advance exactly one step with the backtracking model; then switch back to the human model. If that branch fails, you reset back to the backtracking step, the human steps can be skipped for this.</p>
<p>Let's try it:</p>
<pre class="python"><code>RULES = copy.copy(solvers.human.RULES)
RULES.remove(solvers.backtracker.solve)

def solve(takuzu):
    '''
    Solve a puzzle using a hybrid model.

    Start with the human solver.
    Every time you get stuck, guess at a spot.
    Switch back to the human solver (backtracking to step 2 on failures).
    '''

    queue = [takuzu]

    while queue:
        takuzu = queue.pop()

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # If we don't have a valid solution, stop looking on this branch
        if not takuzu.is_valid():
            continue

        # Try to advance using the human rules until they all fail
        while True:
            updated = False
            for rule in RULES:
                next_takuzu = rule(takuzu)

                if next_takuzu:
                    takuzu = next_takuzu
                    updated = True
                    break

            if not updated:
                break

        # Solved, we're done!
        if takuzu.is_solved():
            return takuzu

        # Once they've failed, find one empty spot and try both possibilities
        def enqueue():
            for row in range(takuzu.size):
                for col in range(takuzu.size):
                    if not takuzu.get(row, col):
                        for value in '01':
                            queue.append(takuzu.set(row, col, value))
                        return
        enqueue()

    return False</code></pre>
<p>So how much does that buy us?</p>
<pre class="python"><code>$ python3 takuzu.py --method hybrid sample_6x6.takuzu

010110
001101
110010
011001
100101
101010

Solved in 0.05 seconds

$ python3 takuzu.py --method hybrid sample_8x8.takuzu

10011010
11001100
01100101
10110010
01011001
01001101
10100110
00110011

Solved in 0.67 seconds</code></pre>
<p>Hah! That's more like it!</p>
<p>For now, that's it<span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span>. If you'd like to see how I structured the code (it's big enough to spread into multiple files), how I parsed command line parameters, or how I dynamically load the various solvers, you can see the entire code on GitHub: <a href="https://github.com/jpverkamp/takuzu">jpverkamp/takuzu</a>.</p>
<p>I like puzzles. Perhaps I'll try <a href="https://en.wikipedia.org/wiki/Suduko">Suduko</a> next. Or maybe <a href="https://en.wikipedia.org/wiki/Hashiwokakero">Hashi puzzles</a><span class="footnote"><sup><a href="#footnote-6">[6]</a></sup></span>. Onwards!<span class="footnote"><sup><a href="#footnote-7">[7]</a></sup></span></p>]]></content></entry><entry><title>Oven sheet omelette</title><link href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette" /><id>urn:uuid:36c66318-9491-65aa-3cab-e1762b4bcf49</id><updated>2015-10-27T00:00:00Z</updated><summary type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
]]></summary><content type="html"><![CDATA[<p>Cooked something worth blogging about, if only because it's so easy.</p>
<p><strong>Ingredients</strong></p>
<ul>
        <li>Ground beef (cooked and seasoned)</li>
    <li>3 small potatoes</li>
        <li>A dozen eggs</li>
        <li>An onion</li>
        <li>Cheese</li>
</ul>
<p><strong>Recipe</strong></p>
<ol>
    <li>Preheat oven to 425℉</li>
        <li>Slice the potatoes thinly (I used a food processor)</li>
        <li>Pre-cook the potatoes for 5 minutes in the microwave</li>
    <li>Spray a deep oven sheet</li>
    <li>Put down a layer of potatoes and onions, then the beef</li>
    <li>Pour eggs over the whole thing</li>
    <li>Bake for 10 minutes</li>
    <li>Slice and server</li>
</ol>
<p>In progress, we have everything ready to go in the oven:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/1-ready-to-cook.jpg" /></a></p>
<!--more-->
<p>(Keen-eyed observers will note I may have forgotten the onions...)</p>
<p>And done / partially eaten:</p>
<p><a href="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2015/10/27/oven-sheet-omelette/2-finished-dig-in.jpg" /></a></p>
<p>It's really easy with only a couple minutes of prep and 15 minutes of waiting time. Nice for when you have only limited supplies and want a breakfasty dish.</p>]]></content></entry></feed>