<!doctype html><html><head><title>Cyclic equality – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Cyclic equality</h1><div class=entry-meta><span class=entry-date>2013-04-09</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/04/04/racket-roguelike-1-a-gui-screens-i/o-and-you/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2013/04/11/perlin-and-simplex-noise-in-racket/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/03/28/path-to-philosophy/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2013/04/11/perlin-and-simplex-noise-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/03/18/approximating-pi-with-buffons-needle/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2013/06/26/swap-list-nodes/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/01/24/splay-heaps-redux-imperative-model/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2013/04/04/racket-roguelike-1-a-gui-screens-i/o-and-you/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/04/11/perlin-and-simplex-noise-in-racket/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2013/04/09/the-croods/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/04/11/perlin-and-simplex-noise-in-racket/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>In <a title="Cyclic equality on Programming Praxis" href=http://programmingpraxis.com/2013/04/09/cyclic-equality/>today&rsquo;s post</a> from Programming Praxis, the goal is to check if two cyclic lists are equal. So if you have the cycles <code>↻(1 2 3 4 5)</code> and <code>↻(3 4 5 1 2)</code>, they&rsquo;re equal. Likewise, <code>↻(1 2 2 1)</code> and <code>↻(2 1 1 2)</code> are equal. But <code>↻(1 2 3 4)</code> and <code>↻(1 2 3 5)</code> are not since they have different elements while <code>↻(1 1 1)</code> and <code>↻(1 1 1 1)</code> aren&rsquo;t since they have different elements.</p><p>Basically, there are two ways that you can solve this problem. First, you actually use the cyclic structure and recursively check each start in one list for a matching cycle in the other. Alternatively, so long as the lengths are equal you can just double one list and search for the other as a subset. We&rsquo;ll go ahead and code up both.</p><p>First, we want to write a semi-straight forward comparison. The function will take two lists. It will recur across each in both for a start and loop in the second until either a match is confirmed or not. One thing that I want to do is make a cycle structure. We could use mutation to set the last <code>cdr</code>/<code>tail</code> of the list to the head, but instead I&rsquo;ll make the following structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Store a cycle as the current head and original (reset) head</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>define-struct</span> cycle (<span style=color:#a6e22e>current</span> original))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Convert a list to a cycle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>list-&gt;cycle</span> ls)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-cycle</span> ls ls))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Convert a cycle to a list</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-&gt;list</span> c)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cycle-take</span> (<span style=color:#a6e22e>cycle-length</span> c) c))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Return the first item of a cycle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-head</span> c)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>(null? (<span style=color:#a6e22e>cycle-current</span> c))
</span></span><span style=display:flex><span>      (car (<span style=color:#a6e22e>cycle-original</span> c))
</span></span><span style=display:flex><span>      (car (<span style=color:#a6e22e>cycle-current</span> c))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Return all but the first item of a cycle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-tail</span> c)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>(null? (<span style=color:#a6e22e>cycle-current</span> c))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>make-cycle</span> (cdr (<span style=color:#a6e22e>cycle-original</span> c)) (<span style=color:#a6e22e>cycle-original</span> c))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>make-cycle</span> (cdr (<span style=color:#a6e22e>cycle-current</span> c)) (<span style=color:#a6e22e>cycle-original</span> c))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Get the length of a cycle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-length</span> c)
</span></span><span style=display:flex><span>  (length (<span style=color:#a6e22e>cycle-original</span> c)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Take the first n items from a cycle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-take</span> n c)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([i <span style=color:#ae81ff>0</span>] [c c])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(= i n)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>        (cons (<span style=color:#a6e22e>cycle-head</span> c) (<span style=color:#a6e22e>loop</span> (+ i <span style=color:#ae81ff>1</span>) (<span style=color:#a6e22e>cycle-tail</span> c))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Test if a cycle is about to reset</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-reset?</span> c)
</span></span><span style=display:flex><span>  (null? (<span style=color:#a6e22e>cycle-current</span> c)))
</span></span></code></pre></div><p>Essentially, we&rsquo;ll keep a pointer to the original list and reset when the current pointer runs out. All of this is of course transparent to anyone using the API, so we could switch it out for another (using a vector and a current pointer for example) if we wanted. The most useful function yet potentially non-standard function is <code>cycle-reset?</code>. Essentially, it fills what would have been <code>cycle-null?</code>, except a cycle will never be null. This tests when we&rsquo;re about to reset to the beginning of the cycle.</p><p>There are a bunch of unit tests in the <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/cycle-equality.rkt title="cycle equality source on GitHub">source on GitHub</a>, but reset assured it works.</p><p>Now that we have that, the function it relatively straight forward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Test if two cycles are equal</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-equal?</span> c1 c2)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Check the lengths first</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>len (<span style=color:#a6e22e>cycle-length</span> c1))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(= len (<span style=color:#a6e22e>cycle-length</span> c2))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>let </span>loop ([ci1 c1] [ci2 c2])
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>           <span style=color:#75715e>; No matches found</span>
</span></span><span style=display:flex><span>           [(<span style=color:#a6e22e>cycle-reset?</span> ci1)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>#f</span>]
</span></span><span style=display:flex><span>           <span style=color:#75715e>; No match found for this start in c1</span>
</span></span><span style=display:flex><span>           <span style=color:#75715e>; Advance c1, reset c2</span>
</span></span><span style=display:flex><span>           [(<span style=color:#a6e22e>cycle-reset?</span> ci2)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>cycle-tail</span> ci1) c2)]
</span></span><span style=display:flex><span>           <span style=color:#75715e>; Match found at the current element!</span>
</span></span><span style=display:flex><span>           [(equal? (<span style=color:#a6e22e>cycle-take</span> len ci1)
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>cycle-take</span> len ci2))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>#t</span>]
</span></span><span style=display:flex><span>           <span style=color:#75715e>; Otherwise, no match, advance c2</span>
</span></span><span style=display:flex><span>           [else
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>loop</span> ci1 (<span style=color:#a6e22e>cycle-tail</span> ci2))]))))
</span></span></code></pre></div><p>Theoretically, the comments should be pretty straight forward. For each starting pair, test if we have matching cycles using <code>cycle-take</code>. That could bail out early to make the code more efficient, but at the cost of being rather less clean. Really, if you wanted to make this code efficient you&rsquo;d most likely use a vector and a head pointer anyways.</p><p>And here we have a few tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>5</span>)))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span></code></pre></div><p>The next solution is a bit more straight forward if not quite as efficient. Essentially, double one of the lists and then check if the other is in it. For equal cycles, this will be equal but not others. You do have to check the length first though.</p><p>First, we need to write code to check if one given list is a subset anywhere in another. Here&rsquo;s one way to do that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Check if p is a prefix of ls</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>prefix?</span> ls p)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>or </span>(null? p)
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>and </span>(equal? (car ls) (car p))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>prefix?</span> (cdr ls) (cdr p)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Check if a list needle is in the list haystack</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>contains?</span> haystack needle)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(not (null? haystack))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>or </span>(<span style=color:#a6e22e>prefix?</span> haystack needle)
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>contains?</span> (cdr haystack) needle))))
</span></span></code></pre></div><p>And with that, checking for equal is a rather minimal function (we&rsquo;re taking the cycles as lists this time):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Check if two cycles (as lists) are equal by doubling one</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>list-cycle-equal?</span> lsc1 lsc2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(= (length lsc1) (length lsc2))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>contains?</span> (append lsc1 lsc1) lsc2)))
</span></span></code></pre></div><p>And to check that we can use the same tests. We just don&rsquo;t convert to cycles first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>list-cycle-equal?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>list-cycle-equal?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>list-cycle-equal?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>list-cycle-equal?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>list-cycle-equal?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span></code></pre></div><p>And that&rsquo;s it. If you&rsquo;d like, you can see the entire code on GitHub (<a href=https://github.com/jpverkamp/small-projects/blob/master/blog/cycle-equality.rkt title="cycle equality source on GitHub">cycle equality source</a>). All of the functions are already in this post, but there are a bunch of unit tests that might be of interest.</p><p><strong>Edit 9 April 2013</strong>: A comment from Maurits on the Programming Praxis post got me wondering if it could be done in <em>O(m + n)</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Basically, their idea was to lexically order both cycles and then check if they are equal as lists.</p><p>To lexically order them, we want to advance the cycle so that the smallest element in the cycle is first. If there is a tie, break it with the element right after each smallest and so on. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Advance a cycle to the lexically minimum position</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-lexical-min</span> c [&lt; &lt;] [= =])
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Check if one cycle is less than another</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>cycle-&lt;</span> c1 c2)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([c1 c1] [c1-cnt (<span style=color:#a6e22e>cycle-length</span> c1)]
</span></span><span style=display:flex><span>               [c2 c2] [c2-cnt (<span style=color:#a6e22e>cycle-length</span> c2)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>and </span>(&gt; c1-cnt <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>           (&gt; c2-cnt <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>or </span>(&lt; (<span style=color:#a6e22e>cycle-head</span> c1) (<span style=color:#a6e22e>cycle-head</span> c2))
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>and </span>(= (<span style=color:#a6e22e>cycle-head</span> c1) (<span style=color:#a6e22e>cycle-head</span> c2))
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>cycle-tail</span> c1) (- c1-cnt <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                          (<span style=color:#a6e22e>cycle-tail</span> c2) (- c2-cnt <span style=color:#ae81ff>1</span>)))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Lexically sort by storing minimum</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([min c] [c (<span style=color:#a6e22e>cycle-tail</span> c)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>cycle-reset?</span> c) min]
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>cycle-&lt;</span> c min) (<span style=color:#a6e22e>loop</span> c (<span style=color:#a6e22e>cycle-tail</span> c))]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else </span>(<span style=color:#a6e22e>loop</span> min (<span style=color:#a6e22e>cycle-tail</span> c))])))
</span></span></code></pre></div><p>Note: This code uses an updated version of <code>cycle-length</code> that is <a href=https://en.wikipedia.org/wiki/amortized>amortized</a> <em>O(1)</em> (it caches the length). You can see the code for that on <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/cycle-equality.rkt title="cycle equality source on GitHub">GitHub</a>.</p><p>One you have the sort, the actual comparison is easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Compare cycles by lexical comparison</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>lexical-cycle-equal?</span> c1 c2 [&lt; &lt;] [= =])
</span></span><span style=display:flex><span>  (equal? (<span style=color:#a6e22e>cycle-take</span> (<span style=color:#a6e22e>cycle-length</span> c1) (<span style=color:#a6e22e>cycle-lexical-min</span> c1 &lt; =))
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>cycle-take</span> (<span style=color:#a6e22e>cycle-length</span> c2) (<span style=color:#a6e22e>cycle-lexical-min</span> c2 &lt; =))))
</span></span></code></pre></div><p>I’m not completely sure about the runtime of finding the lexical minimum. In the general case (with few duplicates), it’ll be <em>O(n)</em> though. Then there’s another <em>O(n + n)</em> for the cycle-length and cycle-take, plus a final additional <em>O(max(m, n))</em> for the equal?. So overall it would be <em>O(3m + 3n + max(m, n))</em> which is <em>O(m + n)</em>. The constant could be improved with a better abstraction, but not the big-O time.</p><p>And of course all of the previous tests still work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>lexical-cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)) &lt; =)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>lexical-cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)) &lt; =)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>lexical-cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)) &lt; =)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>lexical-cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)) &lt; =)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>lexical-cycle-equal?</span> (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>)) (<span style=color:#a6e22e>list-&gt;cycle</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>5</span>)) &lt; =)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The previous two solutions are <em>O(mn)</em> because they have to compare each starting point pairwise&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>