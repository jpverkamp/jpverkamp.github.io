<!doctype html><html><head><title>Visualizing the Monkey Grid â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet><link rel=stylesheet href=/custom.css defer><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Visualizing the Monkey Grid</h1><div class=entry-meta><span class=entry-date>2013-08-30</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/08/22/tiny-turing-completeness-without-mmov/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2013/09/14/diffie-hellman-key-exchange/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/08/26/wombat-ide-new-semester-/-bug-fixes/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2013/09/14/diffie-hellman-key-exchange/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/06/26/swap-list-nodes/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2013/09/19/smallest-consecutive-four-factor-composites/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/visualiziation>Visualiziation</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2013/08/26/wombat-ide-new-semester-/-bug-fixes/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/14/diffie-hellman-key-exchange/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2013/08/30/elysium/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/10/the-mortal-instruments-city-of-bones/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>I&rsquo;m a bit behind the times, but <a href=http://programmingpraxis.com/2013/08/16/monkey-grid-puzzle/>this post</a> from Programming Praxis intrigued me enough that I kept it in my todo list for rather a while. So let&rsquo;s get around to it.</p><p>I&rsquo;ll just copy the description straight from the Programming Praxis website (although there are at least two previous version:<a href=http://stackoverflow.com/questions/9762953/planar-grid-puzzle>[1]</a><a href=http://stackoverflow.com/questions/18133918/improve-the-solution-to-monkey-grid-puzzle>[2]</a>):</p><blockquote><p>There is a monkey which can walk around on a planar grid. The monkey can move one space at a time left, right, up or down. That is, from (x, y) the monkey can go to (x+1, y), (x-1, y), (x, y+1), and (x, y-1). Points where the sum of the digits of the absolute value of the x coordinate plus the sum of the digits of the absolute value of the y coordinate are lesser than or equal to 19 are accessible to the monkey. For example, the point (59, 79) is inaccessible because 5 + 9 + 7 + 9 = 30, which is greater than 19. Another example: the point (-5, -7) is accessible because abs(-5) + abs(-7) = 5 + 7 = 12, which is less than 19. How many points can the monkey access if it starts at (0, 0), including (0, 0) itself?</p></blockquote><p>I&rsquo;m going to take a slightly different take since the problem itself isn&rsquo;t that terribly difficult; it&rsquo;s mostly a matter of optimization. You can never go past 300 on either axis since 2+9+9 = 20, so that forms a wall. ~360,000 nodes can be checked rather quickly to begin with and you can further optimize that by only checking a single quadrant because we&rsquo;re always taking the absolute values. But ignore all that. First, we want to actually write the function. And to that, we want to make up a brand new data structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-infinite-grid</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-hasheq</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>infinite-grid-ref</span> grid x y [default (<span style=color:#a6e22e>void</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-ref</span> (<span style=color:#a6e22e>hash-ref!</span> grid x (<span style=color:#a6e22e>make-hasheq</span>)) y default))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>infinite-grid-set!</span> grid x y value)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-set!</span> (<span style=color:#a6e22e>hash-ref!</span> grid x (<span style=color:#a6e22e>make-hasheq</span>)) y value))
</span></span></code></pre></div><p>Check out the source for a few more helper functions: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/monkey-grid.rkt>GitHub: jpverkamp/small-projects/monkey-grid.rkt</a></p><p>Essentially, it&rsquo;s a <a href=https://en.wikipedia.org/wiki/Cartesian%20coordinate%20system>Cartesian grid</a> that can stretch off arbitrarily far without having to pre-allocate the memory and without dealing with the pesky problems of manually doing the nested hashes all of the time. Granted, this particular problem will be pretty dense, so something more like an extensible <a href=https://en.wikipedia.org/wiki/quadtree>quadtree</a> might have worked better, but this is what I went for first.</p><p>So that being said, how do we want to approach the actual problem?</p><p>My first thought was that we&rsquo;re working in Racket. We should abstract it over the actual generating function, because <a href=https://en.wikipedia.org/wiki/first%20order%20functions>first order functions</a> are awesome. So we can solve the problem for any sort of function, just just the given one.</p><p>My second thought was let&rsquo;s just do it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>monkey-grid-df</span> rule)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>grid (<span style=color:#a6e22e>make-infinite-grid</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([x <span style=color:#ae81ff>0</span>] [y <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; We&#39;ve already visited this point, skip it</span>
</span></span><span style=display:flex><span>      [(boolean? (<span style=color:#a6e22e>infinite-grid-ref</span> grid x y))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>void</span>)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The monkey can walk here</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>rule</span> x y)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (- x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (+ x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> x (- y <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> x (+ y <span style=color:#ae81ff>1</span>))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The monkey cannot walk here, skip it</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y <span style=color:#66d9ef>#f</span>)]))
</span></span><span style=display:flex><span>  grid)
</span></span></code></pre></div><p>Here we have a nice <a href=https://en.wikipedia.org/wiki/depth-first%20search>depth-first search</a>that will set each point that the monkey can reach to true (the second case) and ones it cannot to false (the third). The first case there is to stop the monkey from moving west then immediately east again. Once we&rsquo;ve visited a point, we&rsquo;ll not recur from it again. We&rsquo;ll still visit points up to five times (the original time and potentially once coming back from each direction), but writing this way is much cleaner than checking before you move.</p><p>So how does it work? Well, let&rsquo;s write a quick function to visualize an infinite grid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>infinite-grid-&gt;bitmap</span> grid mapping [default (<span style=color:#a6e22e>void</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>let-values</span> ([(<span style=color:#a6e22e>min-x</span> max-x min-y max-y) (<span style=color:#a6e22e>infinite-grid-range</span> grid)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>flomap-&gt;bitmap</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>build-flomap*</span> 
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>3</span> (- max-x min-x) (- max-y min-y)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>x</span> y)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>mapping</span> (<span style=color:#a6e22e>infinite-grid-ref</span> grid (+ x min-x) (+ y min-y) default)))))))
</span></span></code></pre></div><p>This is basically the same technique that we used to draw noise in the <a href=https://blog.jverkamp.com/2013/04/11/perlin-and-simplex-noise-in-racket/>Perlin/Simplex noise post</a> and the technique used in the Wombat <a title="(c211 image) API" href=http://blog.jverkamp.com/wombat-ide/c211-image-api/>(c211 image)</a> library. In this case, we pass a generating function to<code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code>
that returns the color at each point. Using a simple coloring where <code>#t</code> is red, <code>#f</code> is black, and <code>(void)</code> (the points we don&rsquo;t visit) is white, we get this:</p><figure><img src=/embeds/2013/131072.png></figure><p>That&rsquo;s actually a pretty cool looking image. If you think about it, the triangular patterns make perfect sense. The sides are where the digits of <code>x</code> or <code>y</code> are pushing the total over 19 while the angle in between is where the combination matters. And of course since we&rsquo;re taking absolute values, the entire thing is mirrored over both the <code>x</code> and <code>y</code> axes (the output is automatically scaled the same way the <a title="(c211 turtle) API" href=http://blog.jverkamp.com/wombat-ide/c211-turtle-api/>(c211 turtle)</a> library is).</p><p>If that&rsquo;s all there was to it though, this would be a pretty boring post though. So let&rsquo;s take it up a notch.</p><p>I mentioned earlier that this is a depth first solution to the problem. That means that we&rsquo;re going to completely exhaust each approach, then back track point by point and keep branching out. In this case, we&rsquo;re looking at <code>(x-1, y)</code> first, so we&rsquo;ll first build the left side of the image. But how can we visualize this?</p><p>One option would be to count the number of steps that we&rsquo;ve taken and allow the function to bail out early. That way we can generate several images and watch as the entire picture is filled in. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>monkey-grid-df</span> rule [maximum-steps <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>grid (<span style=color:#a6e22e>make-infinite-grid</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>steps (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([x <span style=color:#ae81ff>0</span>] [y <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; We&#39;re out of steps or points</span>
</span></span><span style=display:flex><span>      [(<span style=color:#66d9ef>and </span>(number? maximum-steps) (&gt;= (<span style=color:#a6e22e>steps</span>) maximum-steps))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>void</span>)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; We&#39;ve already visited this point, skip it</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>infinite-grid-ref</span> grid x y <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>void</span>)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The monkey can walk here</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>rule</span> x y)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>steps</span> (+ (<span style=color:#a6e22e>steps</span>) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y (<span style=color:#a6e22e>steps</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (- x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (+ x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> x (- y <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> x (+ y <span style=color:#ae81ff>1</span>))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The monkey cannot walk here, skip it</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y <span style=color:#66d9ef>#f</span>)]))
</span></span><span style=display:flex><span>  grid)
</span></span></code></pre></div><p>Intuitively, it would probably be more obvious to thread the number of <code>steps</code> through the loop as a variable, but that wouldn&rsquo;t actually do what we want because the four branches don&rsquo;t share state. We could have each call to loop return the number of steps it took, but then it wouldn&rsquo;t be <a href=https://en.wikipedia.org/wiki/tail%20recursive>tail recursive</a>, so we&rsquo;d lose a bit in performance and make the code messier. So instead, we use a<code><a href="http://docs.racket-lang.org/search/index.html?q=parameter">parameter</a></code>
, giving us a variable with <a href=https://en.wikipedia.org/wiki/Dynamic%20scope#Dynamic%20scoping>dynamic</a>rather than <a href=https://en.wikipedia.org/wiki/Lexical%20scope#Lexical%20scoping>lexical</a>scope.</p><p>Now we can generate a whole sequence of images (click any image to biggify):</p><table><thead><tr><th>Steps</th><th>Image</th></tr></thead><tbody><tr><td>29 = 512</td><td><figure><img src=/embeds/2013/512.png></figure></td></tr><tr><td>210 = 1,024</td><td><figure><img src=/embeds/2013/1024.png></figure></td></tr><tr><td>211 = 2,048</td><td><figure><img src=/embeds/2013/2048.png></figure></td></tr><tr><td>212 = 4,096</td><td><figure><img src=/embeds/2013/4096.png></figure></td></tr><tr><td>213 = 8,192</td><td><figure><img src=/embeds/2013/8192.png></figure></td></tr><tr><td>214 = 16,384</td><td><figure><img src=/embeds/2013/16384.png></figure></td></tr><tr><td>215 = 32,768</td><td><figure><img src=/embeds/2013/32768.png></figure></td></tr><tr><td>216 = 65,536</td><td><figure><img src=/embeds/2013/65536.png></figure></td></tr></tbody></table><p>We start out by going to the left as expected. After we reach the far end (that 299 limit), we start filling out by right from there (which just doubles back so it&rsquo;s skipped), then we go down and up to fill out that far left triangle. We see the right lines because we&rsquo;ll move up/down and then have a space to go left (which has the second level of priority). From there, we just fill out the whole image.</p><p>This is all well and good, but couldn&rsquo;t we fill it in from the inside out?</p><p>To do that, we need to take a different approach. Rather than a depth-first search, we want to go <a href=https://en.wikipedia.org/wiki/Breadth-first%20search>breadth-first</a>. Essentially the idea will be to use a <a href=https://en.wikipedia.org/wiki/Queue%20%28abstract%20data%20type%29>queue</a>(so that the first points we think to study are the first we do rather than following a branch to the end) rather than the implicit <a href=https://en.wikipedia.org/wiki/Stack%20%28computer%20science%29>stack</a>we get from recurring.</p><p>Here&rsquo;s one way to do that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>monkey-grid-bf</span> rule [maximum-steps <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>grid (<span style=color:#a6e22e>make-infinite-grid</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>steps (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>let/ec</span> return
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([points <span style=color:#f92672>&#39;</span>((<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>))])
</span></span><span style=display:flex><span>      <span style=color:#75715e>; We&#39;re out of steps or points</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>or </span>(null? points)
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>and </span>(number? maximum-steps) (&gt;= (<span style=color:#a6e22e>steps</span>) maximum-steps)))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>return</span> grid))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Otherwise, unpack and process the next point</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>x (<span style=color:#a6e22e>first</span> (<span style=color:#a6e22e>first</span> points)))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>y (<span style=color:#a6e22e>second</span> (<span style=color:#a6e22e>first</span> points)))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>; We&#39;ve already visited this point, skip it</span>
</span></span><span style=display:flex><span>        [(boolean? (<span style=color:#a6e22e>infinite-grid-ref</span> grid x y))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> points))]
</span></span><span style=display:flex><span>        <span style=color:#75715e>; The monkey can walk here</span>
</span></span><span style=display:flex><span>        [(<span style=color:#a6e22e>rule</span> x y)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>steps</span> (+ <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>steps</span>)))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (append (<span style=color:#a6e22e>rest</span> points)
</span></span><span style=display:flex><span>                       (list (list (- x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>                             (list (+ x <span style=color:#ae81ff>1</span>) y) 
</span></span><span style=display:flex><span>                             (list x (- y <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                             (list x (+ y <span style=color:#ae81ff>1</span>)))))]
</span></span><span style=display:flex><span>        <span style=color:#75715e>; The monkey cannot walk here, skip it</span>
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> points))]))))
</span></span></code></pre></div><p>We can already see that it&rsquo;s going to be far slower since we&rsquo;re <code>append</code>ing to the end of the list (and maintaining the list explicitly in the first place), but it&rsquo;s still worth doing from a learning perspective. The main odd part is <code><a href="http://docs.racket-lang.org/search/index.html?q=let/ec">let/ec</a></code>
(it&rsquo;s a short form of <code><a href="http://docs.racket-lang.org/search/index.html?q=call-with-escape-continuation">call-with-escape-continuation</a></code>
), but basically that&rsquo;s giving us an escape route. Once we&rsquo;ve made enough steps, no matter where we are, we can stop recurring. So what would these in progress shots look like?</p><table><thead><tr><th>Steps</th><th>Image</th></tr></thead><tbody><tr><td>29 = 512</td><td><figure><img src=/embeds/2013/bf-512.png></figure></td></tr><tr><td>213 = 8,192</td><td><figure><img src=/embeds/2013/bf-8192.png></figure></td></tr><tr><td>215 = 32,768</td><td><figure><img src=/embeds/2013/bf-32768.png></figure></td></tr></tbody></table><p>Exactly as expected, the image is built from the inside out. We process the first four points, then the nine from those and so on. Nice!</p><p>But generating all of these images is a bit of a pain. What if we could color them based on how many steps it took to get to them?The change is actually relatively minimal. First, store the number of steps rather than just <code>#t</code> in the grid. Second, we have to change the <code>boolean?</code> check (we can use the fact that numbers are true though). Finally, we need a slightly more complex coloring function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Store the number of steps in the grid</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> (<span style=color:#a6e22e>infinite-grid-set!</span> grid x y (<span style=color:#a6e22e>steps</span>)) <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Don&#39;t revisit using the fact that numbers are true</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> (<span style=color:#a6e22e>infinite-grid-ref</span> grid x y <span style=color:#66d9ef>#f</span>) <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-gradient-coloring</span> grid)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>max-value (apply max (cons <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>filter</span> number? (<span style=color:#a6e22e>infinite-grid-values</span> grid)))))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(number? value) 
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>g (/ value max-value))
</span></span><span style=display:flex><span>       (vector g <span style=color:#ae81ff>0</span> (- <span style=color:#ae81ff>1</span> g))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (vector <span style=color:#ae81ff>0.0</span> <span style=color:#ae81ff>0.0</span> <span style=color:#ae81ff>0.0</span>)])))
</span></span></code></pre></div><p><code>make-gradient-coloring</code> is interesting because it&rsquo;s a function that returns the actual coloring function. We have to do this because we don&rsquo;t actually know how many steps it took to generate the image (although we could easily restructure the function to return that). Then we use the gradient <code>(g)</code> and <code>(- 1 g)</code> to smoothly blend from blue at low step numbers to red at the highest.</p><p>So, what does it look like?</p><table><thead><tr><th>Depth-first</th><th>Breadth-first</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2013/df-gradient.png></figure></td><td><figure><img src=/embeds/2013/bf-gradient.png></figure></td></tr></tbody></table><p>We see the same patterns here as we did in the sequential images: the depth first starts to the left then rotates counter-clockwise. Breadth-first starts in the middle and works out.</p><p>So we&rsquo;ve solved the problem (more or less, we haven&rsquo;t actually counted the number of points in the grid). But what else can we use this framework for? Well, first let&rsquo;s build a helper function to abstract anything we might want to do with these:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-grid</span> default-param function)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>Î»</span> (              [param default-param]
</span></span><span style=display:flex><span>      <span style=color:#f92672>#</span>:steps       [steps (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>)]
</span></span><span style=display:flex><span>      <span style=color:#f92672>#</span>:depth-first [depth-first <span style=color:#66d9ef>#t</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>#</span>:gradient    [gradient    <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>grid
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>monkey-grid</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>function</span> param)
</span></span><span style=display:flex><span>       steps
</span></span><span style=display:flex><span>       <span style=color:#f92672>#</span>:depth-first depth-first))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>infinite-grid-&gt;bitmap</span>
</span></span><span style=display:flex><span>     grid
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if </span>gradient (<span style=color:#a6e22e>make-gradient-coloring</span> grid) default-coloring))))
</span></span></code></pre></div><p>This is another function generating function. In this case we want a default parameter and a function of the form <code>(number? number? -> boolean?)</code>. For the inner function, we have that parameter we defaulted earlier and three optional keyword parameters: the maximum number of steps to run (in case we want to generate a potentially infinite function), if we want to use the breadth- or depth-first, and if we want to use the gradient coloring or the original coloring. All together, it makes defining test functions much cleaner. I used this function to generate all of the images thus far in the post:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>monkey
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([digits 
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>let </span>loop ([n n] [ls <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>               [(= n <span style=color:#ae81ff>0</span>) ls]
</span></span><span style=display:flex><span>               [<span style=color:#66d9ef>else </span>   (<span style=color:#a6e22e>loop</span> (quotient n <span style=color:#ae81ff>10</span>) (cons (remainder n <span style=color:#ae81ff>10</span>) ls))])))])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>make-grid</span> 
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>19</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>max-digit-sum</span>) 
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>x</span> y) (&lt;= (apply + (append (<span style=color:#a6e22e>digits</span> (abs x)) (<span style=color:#a6e22e>digits</span> (abs y)))) max-digit-sum))))))
</span></span></code></pre></div><p>This way the default will be to sum digits no greater than 19, but we can easily generate other values. Say&mldr; 10 (we end up with a border at 19):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>monkey</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>#</span>:steps <span style=color:#66d9ef>#f</span> <span style=color:#f92672>#</span>:gradient <span style=color:#66d9ef>#t</span> <span style=color:#f92672>#</span>:depth-first <span style=color:#66d9ef>#f</span>)
</span></span></code></pre></div><figure><img src=/embeds/2013/monkey-10.png></figure><p>Alternatively, we can generate all sorts of nice shapes:</p><table><thead><tr><th><code>scheme (define circle (make-grid 50 (Î» (radius) (define r^2 (* radius radius)) (Î» (x y) (&lt;= (+ (* x x) (* y y)) r^2)))))</code></th><th><code>scheme (define square (make-grid 50 (Î» (radius) (Î» (x y) (and (&lt;= (abs x) radius) (&lt;= (abs y) radius))))))</code></th></tr></thead><tbody><tr><td><figure><img src=/embeds/2013/monkey-circle.png></figure></td><td><figure><img src=/embeds/2013/monkey-square1.png></figure></td></tr></tbody></table><p>Let&rsquo;s get a little crazier. What if we randomly decide at each tile if it&rsquo;s viable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>squiggle 
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-grid</span> 
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>variation</span>) 
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>x</span> y) 
</span></span><span style=display:flex><span>       (positive? (<span style=color:#a6e22e>random</span> variation))))))
</span></span></code></pre></div><p>Try with the default 50% change:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>squiggle</span> <span style=color:#f92672>#</span>:gradient <span style=color:#66d9ef>#t</span>)
</span></span></code></pre></div><figure><img src=/embeds/2013/monkey-squiggle.png></figure><p>We actually got really lucky with this one. There&rsquo;s a 50/50 chance that the origin itself won&rsquo;t be visited, so we tend to generate a lot of empty images&mldr; (And of course each one will depend on the current <code>random-seed</code>. That was the default depth first version, so we (more or less) see the continual forward motion. Here&rsquo;s one that&rsquo;s breadth-first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>squiggle</span> <span style=color:#f92672>#</span>:depth-first <span style=color:#66d9ef>#f</span> <span style=color:#f92672>#</span>:gradient <span style=color:#66d9ef>#t</span>)
</span></span></code></pre></div><figure><img src=/embeds/2013/monkey-squiggle-bf.png></figure><p>We can still see the definite outwards pattern here, along with which branches it generate later (those to the left in this case).</p><p>Next, how about visualizing prime numbers?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>require</span> math/number-theory)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>either-prime
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-grid</span>
</span></span><span style=display:flex><span>   +inf<span style=color:#f92672>.</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>bound</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>x</span> y)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>and </span>(&lt;= (abs x) bound) (&lt;= (abs y) bound)
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>or </span>(&lt;= <span style=color:#ae81ff>-2</span> x <span style=color:#ae81ff>2</span>) (&lt;= <span style=color:#ae81ff>-2</span> y <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>prime?</span> x)  (<span style=color:#a6e22e>prime?</span> y)))))))
</span></span></code></pre></div><p>We have to allow numbers less than 2 or we&rsquo;ll never get away from the origin. In this case, <code><a href="http://docs.racket-lang.org/search/index.html?q=math/number-theory">math/number-theory</a></code>
considers negative numbers to be <code>prime?</code> if their <code>abs</code> is <code>prime?</code>, so we get some nice symmetry.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>either-prime</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>#</span>:gradient <span style=color:#66d9ef>#t</span> <span style=color:#f92672>#</span>:depth-first <span style=color:#66d9ef>#f</span>)
</span></span></code></pre></div><figure><img src=/embeds/2013/monkey-prime.png></figure><p>For those playing at home, here&rsquo;s a bigger one (remember, click to embiggen):</p><figure><img src=/embeds/2013/monkey-prime-large.png></figure><p>Another option would be to check if x and y are <a href=https://en.wikipedia.org/wiki/coprime>coprime</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>coprime</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>#</span>:gradient <span style=color:#66d9ef>#t</span> <span style=color:#f92672>#</span>:depth-first <span style=color:#66d9ef>#f</span>)
</span></span></code></pre></div><table><thead><tr><th>Depth-first</th><th>Breadth-first</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2013/monkey-coprime-df.png></figure></td><td><figure><img src=/embeds/2013/monkey-coprime-bf.png></figure></td></tr></tbody></table><p>There is definitely some interesting structure going on. ðŸ˜„</p><p>I think that&rsquo;s about it for now. If you have any other interesting functions you&rsquo;d like to check out, go ahead and give the code a spin (<a href=https://github.com/jpverkamp/small-projects/blob/master/blog/monkey-grid.rkt>GitHub: jpverkamp/small-projects/monkey-grid.rkt</a>) and/or drop me a line in the comments. I&rsquo;d love to see what else people come up with!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer src=/custom.js></script></body></html>