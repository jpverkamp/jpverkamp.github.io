<!doctype html><html><head><title>Large scale asynchronous DNS scans – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Large scale asynchronous DNS scans</h1><div class=entry-meta><span class=entry-date>2013-09-27</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2013/10/09/functions-as-lists/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2013/10/09/functions-as-lists/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/bitfields>Bitfields</a><a href=https://blog.jverkamp.com/2021/12/03/aoc-2021-day-3-binary-contraption/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2013/10/09/functions-as-lists/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/dns>DNS</a><a href=https://blog.jverkamp.com/2018/03/12/generating-zone-files-from-route53/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/networks>Networks</a><a href=https://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/10/09/functions-as-lists/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/10/09/functions-as-lists/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>On Monday we <a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/>laid out a framework</a> for converting structures into bytes. On Wednesday, we used that to <a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/>enhance Racket&amp;rsquo;s UDP and DNS capabilities</a>. Today, we&rsquo;re going to take that all one step further and scan large portions of the Internet. The end goal will be to look for <a href=https://blog.jverkamp.com/2013/02/09/isma-2013-aims-5-dns-based-censorship/>DNS-based</a> on a worldwide scale.</p><p>To that end, there are several steps that we&rsquo;re going to want to go through:</p><ul><li>Process any command line parameters (so I can tune the results)</li><li>Load lists of targets, resolvers, and IP to country mappings</li><li>Find a set of active resolvers in as many countries as we can</li><li>Scan each target at each active resolver</li><li>Analyze results, looking for signs of censorship</li></ul><p>Let&rsquo;s start at the top. First, we&rsquo;re going to be using <a href=http://www.alexa.com/>Alexa Top sites</a> for our targets. This should give us at least a list of sites that would be popular enough to attract a censor&rsquo;s notice, although by no means an obvious one. Second, we&rsquo;ll be using the <a href=http://dev.maxmind.com/geoip/legacy/geolite/>MaxMind GeoLite free database</a> to look up the country for a given IP address. They&rsquo;re all fine data sources, but we do want to tune a few parameters. Racket&rsquo;s <code><a href="http://docs.racket-lang.org/search/index.html?q=command-line">command-line</a></code>
function will do exactly what we want:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; ----- ----- ----- ----- -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 0) Get command line parameters</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>alexa-top-n (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>100</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>resolvers/country (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>timeout (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>5.0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>command-line</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>#</span>:program <span style=color:#e6db74>&#34;scan.rkt&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>#</span>:once-each
</span></span><span style=display:flex><span> [(<span style=color:#e6db74>&#34;-n&#34;</span> <span style=color:#e6db74>&#34;--alexa-top-n&#34;</span>)
</span></span><span style=display:flex><span>  n
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Scan the top n Alexa ranked sites (default = 100)&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>alexa-top-n</span> (string-&gt;number n))]
</span></span><span style=display:flex><span> [(<span style=color:#e6db74>&#34;-r&#34;</span> <span style=color:#e6db74>&#34;--resolvers&#34;</span>)
</span></span><span style=display:flex><span>  r
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;The maximum number of resolvers to use per country (default = 5)&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>resolvers/country</span> (string-&gt;number r))]
</span></span><span style=display:flex><span> [(<span style=color:#e6db74>&#34;-t&#34;</span> <span style=color:#e6db74>&#34;--timeout&#34;</span>)
</span></span><span style=display:flex><span>  t
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Timeout for DNS requests (default = 5.0 seconds)&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>timeout</span> (string-&gt;number t))])
</span></span></code></pre></div><p>The structure of each part within <code>#:once-each</code> block has four parts:</p><ul><li>A list containing the short and long forms of the argument</li><li>The variable that will be bound to the arguments value (as a string)</li><li>Help text to display when the user requests <code>--help</code></li><li>Code to run with the aforementioned parameter</li></ul><p><code><a href="http://docs.racket-lang.org/search/index.html?q=Parameters">Parameters</a></code>
do help with this, allowing for mutation of a sort. Straight forward. Next we load the data. First, check to make sure that the definitions we need exist:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; ----- ----- ----- ----- -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 1) Load data</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>unless</span> (<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>file-exists?</span> <span style=color:#e6db74>&#34;targets.txt&#34;</span>)
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>file-exists?</span> <span style=color:#e6db74>&#34;resolvers.txt&#34;</span>)
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>file-exists?</span> <span style=color:#e6db74>&#34;ip-mappings.csv&#34;</span>))
</span></span><span style=display:flex><span>  (for-each displayln
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;Error: Data file(s) not found. Please ensure that the following files exist:&#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;- targets.txt - a list of hostnames (one per line) to scan&#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;- resolvers.txt - a list of open DNS resolvers (one per line) to scan with&#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;- ip-mappings.csv - a list of IP -&gt; country mappings (numeric-ip-from, numeric-ip-to, ip-from, ip-to, country)&#34;</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>exit</span>))
</span></span></code></pre></div><p>Next, let&rsquo;s load in the list of targets. This isn&rsquo;t strictly the file you can get from Alexa, but rather a list of hostnames, one per line. We could read them in directly with the <code><a href="http://docs.racket-lang.org/search/index.html?q=file-%3elines">file->lines</a></code>
function, but that does more work that strictly speaking we need (since we only want the first <code>alexa-top-n</code> of them). So instead, we&rsquo;ll use a <code>for</code> loop with multiple conditions&ndash;with this form, they stop as soon as the first iterator to run out does:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; 1a) Load list of targets (dynamically?) (Alexa Top n)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Loading list of targets, keeping top ~a&#34;</span> (<span style=color:#a6e22e>alexa-top-n</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>targets
</span></span><span style=display:flex><span>  (call-with-input-file <span style=color:#e6db74>&#34;targets.txt&#34;</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>fin</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> (<span style=color:#a6e22e>alexa-top-n</span>))]
</span></span><span style=display:flex><span>                 [line (<span style=color:#a6e22e>in-lines</span> fin)])
</span></span><span style=display:flex><span>        line))))
</span></span></code></pre></div><p>Resolvers is going to be much the same. It will be a list of IPs, one per line. This time we can use <code><a href="http://docs.racket-lang.org/search/index.html?q=file-%3elines">file->lines</a></code>
:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; 1b) Load list of resolvers (from Drew)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Loading resolvers&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>resolvers (<span style=color:#a6e22e>file-&gt;lines</span> <span style=color:#e6db74>&#34;resolvers.txt&#34;</span>))
</span></span></code></pre></div><p>Finally, we want to be able to map IPs to countries. We&rsquo;ll use MaxMind&rsquo;s data for this. Their file (at least the one we&rsquo;ll use) is a list of comma-separated values of the following form:</p><p><code>from-ip, to-ip, numeric-from, numeric-to, country code, country</code></p><p>The third and fourth entries are the IPs from the first and second, just in a numeric form. If you have the IP 8.7.245.0, you get 8<em>256<sup>3</sup>+7</em>256<sup>2</sup>+245*256+0 = 134739200. For example:</p><p><code>"8.7.245.0","8.10.6.242","134739200","134874866","US","United States"</code></p><p>It&rsquo;s not perfect, but it&rsquo;s certainly something we can massage into shape. But what we really want is a lookup to turn an IP into a country. If we turn the data into a sorted vector, we can do a <a href=https://en.wikipedia.org/wiki/binary%20search>binary search</a> to perform the lookups much more quickly.</p><p>The format isn&rsquo;t particularly optimal, but we can massage it easily enough. What we really want though is to be able to search it. So what we&rsquo;ll do is build a function that contains the data as a sorted vector. That way we can use a <a href=https://en.wikipedia.org/wiki/binary%20search>binary search</a> to (much) more quickly scan through</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; 1c) Load list of IP/country mappings (dynamically?) (GeoMind Lite)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; format is csv: ip-from, ip-to, numeric-from, numeric-to, code, country</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Lookup using a binary search</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Loading IP -&gt; country database&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>ip-&gt;country
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Load data into a sorted vector of lists: numeric-from, numeric-to, country</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([data
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>list-&gt;vector</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>sort</span>
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>for/list</span> ([line (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>file-&gt;lines</span> <span style=color:#e6db74>&#34;ip-mappings.csv&#34;</span>))])
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>list-rest</span> _ _ ip-from ip-to cc country)
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>string-split</span> line <span style=color:#e6db74>&#34;,&#34;</span>))
</span></span><span style=display:flex><span>             (list (string-&gt;number (<span style=color:#a6e22e>string-trim</span> ip-from <span style=color:#e6db74>&#34;\&#34;&#34;</span>))
</span></span><span style=display:flex><span>                   (string-&gt;number (<span style=color:#a6e22e>string-trim</span> ip-to <span style=color:#e6db74>&#34;\&#34;&#34;</span>))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>string-trim</span>
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>string-join</span>
</span></span><span style=display:flex><span>                     (reverse (map (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>x</span>) (<span style=color:#a6e22e>string-trim</span> x <span style=color:#e6db74>&#34;\&#34;&#34;</span>)) country)) <span style=color:#e6db74>&#34; &#34;</span>))))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>a</span> b)
</span></span><span style=display:flex><span>             (&lt; (<span style=color:#a6e22e>first</span> a) (<span style=color:#a6e22e>first</span> b)))))])
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Perform a binary search for the given IP</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>ip</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        [(string? ip) (<span style=color:#a6e22e>ip-&gt;country</span> (<span style=color:#a6e22e>ip-&gt;number</span> ip))]
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>let </span>loop ([lo <span style=color:#ae81ff>0</span>] [hi (vector-length data)])
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>define </span>mid (quotient (+ lo hi) <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>match-define</span> (list ip-from ip-to country) (vector-ref data mid))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>             [(&lt;= ip-from ip ip-to) country]
</span></span><span style=display:flex><span>             [(<span style=color:#66d9ef>or </span>(= lo mid)
</span></span><span style=display:flex><span>                  (= mid hi))       <span style=color:#66d9ef>#f</span>]
</span></span><span style=display:flex><span>             [(&lt; ip ip-from)        (<span style=color:#a6e22e>loop</span> lo mid)]
</span></span><span style=display:flex><span>             [(&gt; ip ip-to)          (<span style=color:#a6e22e>loop</span> mid hi)]
</span></span><span style=display:flex><span>             [<span style=color:#66d9ef>else </span>                 (<span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#39;ip-&gt;country</span> <span style=color:#e6db74>&#34;unknown ip ~a&#34;</span> ip)]))]))))
</span></span></code></pre></div><p>Now we get to the interesting part. The next part that we want to do is to narrow the full list of resolvers. No matter how quickly our code runs, it&rsquo;s not going to be easily able to run tens of thousands of queries on tens of millions of resolvers in a reasonable amount of time. All we really want is ~5 resolvers per country.</p><p>First, let&rsquo;s reorganize our list of resolvers by country. Technically, we could have done this as we loaded them, but it&rsquo;s quick enough, let&rsquo;s do it now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; ----- ----- ----- ----- -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2) Find a small set of resolvers per country</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2a) Split the list of resolvers by country</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Reorganizing resolvers by country&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>resolvers-by-country (<span style=color:#a6e22e>make-hash</span>))
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>for</span> ([ip (<span style=color:#a6e22e>in-list</span> resolvers)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>with-handlers</span> ([exn? (<span style=color:#a6e22e>λ</span> _ (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;skipping ~an&#34;</span> ip))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>country (<span style=color:#a6e22e>ip-&gt;country</span> ip))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>when</span> country
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>new-set (<span style=color:#a6e22e>set-add</span> (<span style=color:#a6e22e>hash-ref!</span> resolvers-by-country country (<span style=color:#a6e22e>set</span>)) ip))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>hash-set!</span> resolvers-by-country country new-set))))
</span></span></code></pre></div><p>The <code><a href="http://docs.racket-lang.org/search/index.html?q=with-handlers">with-handlers</a></code>
part isn&rsquo;t strictly speaking necessary, but my list of resolvers has a few non-IPs in it. Rather than filtering them out beforehand, this will just ignore them as we go.</p><p>Next, we&rsquo;ll scan them using a reference hostname. For our purposes, we&rsquo;re using <code>www.google.com</code>, seeing as it&rsquo;s likely to be well known enough to always resolved. There are cases where Google is censored, but for the moment, that doesn&rsquo;t actually matter. We&rsquo;re not looking to see if we get a correct response back, but rather any (valid) response at all. If a resolver times out or returns any return code than <code>no-error</code>, ignore it and move on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; 2b) Query random IPs in each country</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2b-i)  If it returns a valid response, add it to the list</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;        Remove any other IPs within the same /n prefix (avoid same ISPs etc)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2b-ii) If it doesn&#39;t, try the next IP in that country</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2c) If we have n resolvers for a country, stop looking; if not, go to 2a for them</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Narrowing resolver list to ~a per country&#34;</span> (<span style=color:#a6e22e>resolvers/country</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>let </span>([threads-finished <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for-each</span>
</span></span><span style=display:flex><span>   thread-wait
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/list</span> ([(<span style=color:#a6e22e>country</span> ips) (<span style=color:#a6e22e>in-hash</span> resolvers-by-country)])
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>thread</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>parameterize</span> ([current-dns-timeout (<span style=color:#a6e22e>timeout</span>)])
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>let </span>loop ([ips (<span style=color:#a6e22e>shuffle</span> (<span style=color:#a6e22e>set-&gt;list</span> ips))]
</span></span><span style=display:flex><span>                    [active <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; No more IPs to scan or found enough</span>
</span></span><span style=display:flex><span>             [(<span style=color:#66d9ef>or </span>(null? ips)
</span></span><span style=display:flex><span>                  (&gt;= (length active) (<span style=color:#a6e22e>resolvers/country</span>)))
</span></span><span style=display:flex><span>              (<span style=color:#66d9ef>set! </span>threads-finished (+ threads-finished <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;~a/~a: ~a is ~a (~a active) -- ~a&#34;</span> threads-finished (<span style=color:#a6e22e>hash-count</span> resolvers-by-country) country (<span style=color:#66d9ef>if </span>(&gt;= (length active) (<span style=color:#a6e22e>resolvers/country</span>)) <span style=color:#e6db74>&#34;out&#34;</span> <span style=color:#e6db74>&#34;full&#34;</span>) (length active) active)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-set!</span> resolvers-by-country country active)]
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Got a response, check for no-error and record</span>
</span></span><span style=display:flex><span>             [(<span style=color:#a6e22e>dns-request</span> (<span style=color:#a6e22e>first</span> ips) <span style=color:#f92672>#</span>:a <span style=color:#e6db74>&#34;www.google.com&#34;</span>)
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>=&gt; </span>(<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>response</span>)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>match-define</span> (list who what where result) response)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>                     [(<span style=color:#66d9ef>and </span>(eq? (<span style=color:#a6e22e>first</span> result) <span style=color:#e6db74>&#39;no-error</span>)
</span></span><span style=display:flex><span>                           (not (null? (<span style=color:#a6e22e>rest</span> result))))
</span></span><span style=display:flex><span>                      (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> ips) (cons (<span style=color:#a6e22e>first</span> ips) active))]
</span></span><span style=display:flex><span>                     [else
</span></span><span style=display:flex><span>                      (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> ips) active)]))]
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Response timed out</span>
</span></span><span style=display:flex><span>             [else
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> ips) active)]))))))))
</span></span></code></pre></div><p>We&rsquo;re using the same technique as several times before with the <code>cond</code> and <code>=></code> clause. Since <code>dns-request</code> returns <code>#f</code> if it times out, it will fall through to the last case, removing that IP but not recording it as active. The first clause is our base case&ndash;if we either run out of IPs to check for a given country or find enough, we can stop.</p><p>One bit that&rsquo;s interesting is the first few lines. <code>(for-each thread-wait (for/list ...))</code> will build up the list of threads first (since parameters are evaluated before being sent to the function in Scheme/Racket) and then wait for each of them to finish in turn. This way, we&rsquo;re scanning all of the known countries at once (there are almost 200 of them in the list of resolvers I have) while each country is done sequentially. This does slow the code down a bit when we get to a particularly troublesome country, but it still runs quickly enough.</p><p>Finally, we have the actual body of the code. After all of that set up, the code is actually pretty short:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; ----- ----- ----- ----- -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 3) Query targets on each resolver</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;    Group by target, for Alexa Top 100 and 5 resolvers/country:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;      100 requests/resolver</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;      1000 requests/pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>output-filename (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;output-~a.txt&#34;</span> (<span style=color:#a6e22e>current-milliseconds</span>)))
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;Running queries (output to ~a):&#34;</span> output-filename)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(call-with-output-file output-filename
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>fout</span>)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>s (<span style=color:#a6e22e>make-semaphore</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>parameterize</span> ([current-dns-timeout (<span style=color:#a6e22e>timeout</span>)])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for</span> ([i (<span style=color:#a6e22e>in-naturals</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>            [target (<span style=color:#a6e22e>in-list</span> targets)])
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>debug</span> <span style=color:#e6db74>&#34;tScanning ~a/~a: ~a&#34;</span> i (<span style=color:#a6e22e>alexa-top-n</span>) target)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>for*</span> ([(<span style=color:#a6e22e>country</span> ips) (<span style=color:#a6e22e>in-hash</span> resolvers-by-country)]
</span></span><span style=display:flex><span>               [ip (<span style=color:#a6e22e>in-list</span> ips)])
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>dns-request/async</span>
</span></span><span style=display:flex><span>           ip <span style=color:#f92672>#</span>:a target
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>host</span> type query response)
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>define </span>result (<span style=color:#a6e22e>list*</span> host country query response))
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>call-with-semaphore</span>
</span></span><span style=display:flex><span>              s
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>               (write result fout)
</span></span><span style=display:flex><span>               (newline fout)
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>flush-output</span> fout))))))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>sleep</span> (+ <span style=color:#ae81ff>1.0</span> (<span style=color:#a6e22e>timeout</span>)))))))
</span></span></code></pre></div><p>Rather than parallelizing by country, this time we will be target. We&rsquo;ll take all of the resolvers we&rsquo;ve found (up to a thousand) and ask all of them at once about a given target asynchronously. Any responses we get will call the provided callback, writing them to file (with a semaphore to make sure we don&rsquo;t mix lines in the output).</p><p>And that&rsquo;s really all there is to it. I&rsquo;m still analyzing the results, but I&rsquo;ve already found a few interesting cases. I&rsquo;ll have another post up about that early next week.</p><p>If you’d like to see the entire code for this project thus far (I&rsquo;ve added the scanning code now), you can see it on GitHub: <a href=https://github.com/jpverkamp/dns-world-scan>jpverkamp/dns-world-scan</a>. It’s still a work in progress, but it may just be useful.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>