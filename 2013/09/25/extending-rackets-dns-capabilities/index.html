<!doctype html><html><head><title>Extending Racket's DNS capabilities – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Extending Racket's DNS capabilities</h1><div class=entry-meta><span class=entry-date>2013-09-25</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2013/09/27/large-scale-asynchronous-dns-scans/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/bitfields>Bitfields</a><a href=https://blog.jverkamp.com/2013/09/27/large-scale-asynchronous-dns-scans/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2013/09/27/large-scale-asynchronous-dns-scans/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/02/09/isma-2013-aims-5-dns-based-censorship/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/dns>DNS</a><a href=https://blog.jverkamp.com/2013/09/27/large-scale-asynchronous-dns-scans/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/02/09/isma-2013-aims-5-dns-based-censorship/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/networks>Networks</a><a href=https://blog.jverkamp.com/2013/09/27/large-scale-asynchronous-dns-scans/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/27/wombat-ide-is-moving-to-github/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>As I <a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/>mentioned</a> on Monday, I wrote my <a href=https://blog.jverkamp.com/2013/02/09/isma-2013-aims-5-dns-based-censorship/>DNS-based censorship</a> around the world&ndash;and to do that, I need a fair bit of control over the DNS packets that I&rsquo;m sending back and over parsing the ones that I get back.</p><p>Originally, I was writing this code in Python. Python doesn&rsquo;t have a built in DNS library, but <a href=http://www.dnspython.org/>dnspython</a> works is rather solid and does all that I want it to. On the other hand though, I&rsquo;m starting to move more and more of my code over to Racket&ndash;I&rsquo;ve found it to be more expressive in a lot of cases (particularly when creating <a href=https://en.wikipedia.org/wiki/domain%20specific%20languages>domain specific languages</a> for solving a problem<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and (in my experience) it performs a lot better on bigger, easily parallelizable tasks.</p><p>So what does Racket have in terms of DNS? Well, unfortunately all I&rsquo;ve been able to find is the built in <code><a href="http://docs.racket-lang.org/search/index.html?q=net/dns">net/dns</a></code>
module. It works well enough for simple queries (<code><a href="http://docs.racket-lang.org/search/index.html?q=dns-get-address">dns-get-address</a></code>
is certainly straight forward and far easier to direct towards arbitrary DNS servers than I found with dnspython. But unfortunately, that&rsquo;s about all it has. There&rsquo;s no way to control how long the method takes to timeout (without something like <code><a href="http://docs.racket-lang.org/search/index.html?q=sync/timeout">sync/timeout</a></code>
), there&rsquo;s no way to see the full set of addresses returned (it seems to just return the first <a href=https://en.wikipedia.org/wiki/A%20record%20%28DNS%29#A>A record</a> in the response), and no support for asynchronous scans. Essentially, it just won&rsquo;t work on the scale that I&rsquo;ll be working with.</p><p>So what do we need? Well, first I want to build some sort of unified framework on top of the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/udp">racket/udp</a></code>
module<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. In this case, it already does everything that I want, but I&rsquo;d rather keep the details as seperated as I can. What I want is these three functions:</p><ul><li><code>(get-socket port)</code> - returns a UDP socket for the given port, reusing sockets if the same port is requested more than once</li><li><code>(add-socket-listener! port f)</code> - attach a function to a given socket/port so that any incoming traffic on that port will go to the given callback function</li><li><code>(remove-socket-listener! port f)</code> - remove a previously attached functions (it will only work if you pass the exact same function, <code>eq?</code> can tell)</li></ul><p>Let&rsquo;s start with the latter two, since the code for those is much simpler. Essentially, we&rsquo;ll have a hash from port numbers to a set of listeners. We&rsquo;ll use a set so that we can add the same listener as many times as we want without actually having to keep copies, although I&rsquo;m not sure that would actually end up being a problem. In addition, the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/set">racket/set</a></code>
module has versions for <code><a href="http://docs.racket-lang.org/search/index.html?q=set">set</a></code>
(using <code>equal?</code>), <code><a href="http://docs.racket-lang.org/search/index.html?q=seteqv">seteqv</a></code>
, and <code><a href="http://docs.racket-lang.org/search/index.html?q=seteq">seteq</a></code>
.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Listeners sorted by port</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; (hash/c port (set/c (remote-host remote-port bytes? -&gt; void)))</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>listeners (<span style=color:#a6e22e>make-hasheq</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>add-socket-listener!</span> port listener)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>new-set (<span style=color:#a6e22e>set-add</span> (<span style=color:#a6e22e>hash-ref</span> listeners port (<span style=color:#a6e22e>seteq</span>)) listener))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-set!</span> listeners port new-set))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>remove-socket-listener!</span> port listener)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>new-set (<span style=color:#a6e22e>set-remove</span> (<span style=color:#a6e22e>hash-ref</span> listeners port (<span style=color:#a6e22e>seteq</span>)) listener))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>set-empty?</span> new-set)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>hash-remove!</span> listeners port)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>hash-set!</span> listeners port new-set)))
</span></span></code></pre></div><p>As an added bonus, here we can see the contract that a listener will have to have (although we&rsquo;re not enforcing the contracts at the moment). Any function that will work as a listener has to take three arguments: the remote host as a string (will generally be an IP address), the remote port, and the bytes that make up the packet received. The function itself will be in charge of making sure that the packet is actually directed towards our application, since UDP itself doesn&rsquo;t provide any of the guarantees that TCP does to that end.</p><p>Now that we have that, how will <code>get-socket</code> work? Here&rsquo;s what I have, although as you might notice I have a few comments that I&rsquo;ll want to work on later already. But it works well enough for what I need.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Get the socket associated with a port, reusing sockets if possible</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; (port -&gt; void)</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>get-socket</span> port)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>unless</span> (<span style=color:#a6e22e>hash-has-key?</span> sockets port)
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Create the new socket, bind it to the given port</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>s (<span style=color:#a6e22e>udp-open-socket</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>udp-bind!</span> s <span style=color:#66d9ef>#f</span> port <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Create a listening thread for it</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; TODO: Allow some way to clean these up?</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; TODO: Print out any errors we catch rather than ignoring them</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>thread</span> 
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>b (<span style=color:#a6e22e>make-bytes</span> <span style=color:#ae81ff>1024</span>))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>let </span>loop ()
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>sync</span> 
</span></span><span style=display:flex><span>         [handle-evt 
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>udp-receive!-evt</span> s b)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>event</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Unpacket the event</span>
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>bytes-received</span> source-hostname source-port)
</span></span><span style=display:flex><span>              (apply values event))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Send the results to any listeners for that port</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Hope they can deal with anything else random to this port 😄</span>
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>for</span> ([listener (<span style=color:#a6e22e>in-set</span> (<span style=color:#a6e22e>hash-ref</span> listeners port (<span style=color:#a6e22e>set</span>)))])
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>listener</span> source-hostname
</span></span><span style=display:flex><span>                        source-port
</span></span><span style=display:flex><span>                        (<span style=color:#a6e22e>subbytes</span> b <span style=color:#ae81ff>0</span> bytes-received)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Wait for another event</span>
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>loop</span>))]))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Record it</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>hash-set!</span> sockets port s))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Return the old socket if we had one, new otherwise</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-ref</span> sockets port))
</span></span></code></pre></div><p>First, we check if the port already has a socket in the <code>sockets</code> hash (it&rsquo;s just a straightforward <code>hasheq</code>). If not, we have to create on. The arguments to <code><a href="http://docs.racket-lang.org/search/index.html?q=udp-bind!">udp-bind!</a></code>
mean that we aren&rsquo;t sending to a specific host (yet&ndash;we&rsquo;ll do that with <code><a href="http://docs.racket-lang.org/search/index.html?q=udp-send-to">udp-send-to</a></code>
) and the last <code>#t</code> means that the port can be reused. This is mostly because I&rsquo;m going to be taking up rather a lot of ports, although I might change this in future versions.</p><p>The second part is the new thread. Basically, each socket has a single listening thread that uses <code><a href="http://docs.racket-lang.org/search/index.html?q=sync">sync</a></code>
with <code><a href="http://docs.racket-lang.org/search/index.html?q=udp-receive!-evt">udp-receive!-evt</a></code>
to listen for incoming UDP packets (and block until we get one). When we get a packet, go through every listener for that port and send it out. We&rsquo;ll pass along the remote host and port, although passing along the number of bytes isn&rsquo;t actually necessary since we go ahead and cut off the buffer anyways.</p><p>And there you have it. With that, we should be able to write fairly straight forward UDP code. Now we have to build a DNS layer.</p><p>To start out with, we want to be able to provide these two methods and one parameter:</p><ul><li><code>(dns-request server [#:type value] ...)</code> - make a synchronous DNS request (or more than one) of the given type(s) to the given server (as hostname or IP), return the first response</li><li><code>(dns-request/async server [#:type value] ... callback)</code> - make an asynchronous DNS request (or more than one) to the given server, calling callback with any responses</li><li><code>(current-dns-timeout [new-timeout])</code> - get/set the current timeout value; synchronous requests will return <code>'timeout</code> after this time while asynchronous requests will only return during this period; set to <code>#f</code> to disable; default is 5.0 seconds</li></ul><p>On oddity already is the idea that you can make more than one kind of DNS request using keyword paramters. Mainly, I want this library to be more flexible (if I want to use it to look up mail servers for example), and also because it sounded like it would be interesting to implement. And that it was. In the end, we&rsquo;ll be making calls like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>dns-request</span> <span style=color:#e6db74>&#34;8.8.4.4&#34;</span> <span style=color:#f92672>#</span>:a <span style=color:#e6db74>&#34;google.com&#34;</span>)
</span></span></code></pre></div><p>If we wanted to find the mailserver for a domain, we should be able to just do this (although it&rsquo;s not implemented as of yet, implementation should be trivial):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>dns-request</span> <span style=color:#e6db74>&#34;8.8.4.4&#34;</span> <span style=color:#f92672>#</span>:mx <span style=color:#e6db74>&#34;google.com&#34;</span>)
</span></span></code></pre></div><p>How does it work? Well, <code>dns-request</code> is actually implemented via <code>dns-request/async</code> (it just waits for the response for you), so we&rsquo;ll start with that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Make an async DNS request</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>dns-request/async
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-keyword-procedure</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>keys</span> vals server callback)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>for</span> ([key (<span style=color:#a6e22e>in-list</span> (map keyword-&gt;symbol keys))]
</span></span><span style=display:flex><span>           [val (<span style=color:#a6e22e>in-list</span> vals)])
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>))))
</span></span></code></pre></div><p>So far as I can tell, <code><a href="http://docs.racket-lang.org/search/index.html?q=make-keyword-procedure">make-keyword-procedure</a></code>
is the easiest / only way to make a procedure that will accept arbitrary keyword parameters. It will pass the keywords and their values as two seperate lists to the procedure given. Any other (non-keyword) parameters will be passed through directly, as is the case here with the <code>server</code> and <code>callback</code>. Interestingly, the order doesn&rsquo;t matter. The keywords will be pulled out and the order will be saved for the rest.</p><p>The for loop will go across the given requests and send each one out in turn. In this case, there&rsquo;s only a single request, setting <code>key</code> to <code>a</code> and <code>val</code> to <code>"google.com"</code>. For some reason, <code>keyword->symbol</code> doesn&rsquo;t actually exist; however, you can create it easily enough with <code>keyword->string</code> and <code>string->symbol</code>.</p><p>After that, we want to choose a random port and ID for the DNS request. The port will be used in the UDP response listeners and the ID will be used to confirm that the request actually came from us.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Choose a random port and id for this request</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>local-port (+ <span style=color:#ae81ff>10000</span> (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>1000</span>)))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>request-id (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>65536</span>))
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>After that, we&rsquo;ll use the <a href=https://blog.jverkamp.com/2013/09/23/extending-racket-structs-to-bitfields/>bit-struct</a> library to build the actual request.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Create the request (error on types we don&#39;t deal with yet)</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>request-packet
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>case </span>key
</span></span><span style=display:flex><span>           [(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>dns-&gt;bytes</span>
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>build-dns</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:id request-id
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:rd <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:qdcount <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:data
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>bytes-append</span>          <span style=color:#75715e>; query / question</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>encode-hostname</span> val) <span style=color:#75715e>; query is the hostname</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>bytes</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>)           <span style=color:#75715e>; query type  (1 = Type A, host address)</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>bytes</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>)           <span style=color:#75715e>; query class (1 = IN, Internet address)</span>
</span></span><span style=display:flex><span>               )))]
</span></span><span style=display:flex><span>           [else
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#39;dns-request</span> <span style=color:#e6db74>&#34;unknown dns type: ~a&#34;</span> key)]))
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Here&rsquo;s the DNS bit-struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; DNS packets</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>define-bit-struct</span> dns
</span></span><span style=display:flex><span>  ([id      <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [qr      <span style=color:#ae81ff>1</span>]  [opcode  <span style=color:#ae81ff>4</span>]  [aa      <span style=color:#ae81ff>1</span>]  [tc      <span style=color:#ae81ff>1</span>]  [rd      <span style=color:#ae81ff>1</span>] 
</span></span><span style=display:flex><span>   [ra      <span style=color:#ae81ff>1</span>]  [z       <span style=color:#ae81ff>3</span>]  [rcode   <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>   [qdcount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [ancount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [nscount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [arcount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [data    _]))
</span></span></code></pre></div><p>Most of these values can be set to 0 (which is the default if they aren&rsquo;t specified). The only ones we need are the ID we specified earlier, <code>#:rd 1</code> which states that we want a recursive query, and <code>#:qdcount 1</code> showing that we have a single question.</p><p>The data format is a bit strange, but since it was specified with <code>_</code>, it wants <code>bytes</code> rather than an integer. In this case, the hostname encoded in a particular manner, than the query type and class (2-byte one for an IPv4 A record).</p><p>The hostname encoding is a sequence of bytes. For each part of the hostname, return one byte that signifies the number of bytes following, then those bytes. So to encode <code>www.google.com</code>, we&rsquo;ll need:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#ae81ff>3</span>www<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#ae81ff>6</span>google<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#ae81ff>3</span>com<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Here&rsquo;s how to do that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Encode a hostname in the way DNS expects</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>encode-hostname</span> hostname)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>bytes-append</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>apply</span>
</span></span><span style=display:flex><span>    bytes-append
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for/list</span> ([part (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>string-split</span> hostname <span style=color:#e6db74>&#34;.&#34;</span>))])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>bytes-append</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>bytes</span> (string-length part))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>string-&gt;bytes/latin-1</span> part))))
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>bytes</span> <span style=color:#ae81ff>0</span>)))
</span></span></code></pre></div><p>After we have the packet, we&rsquo;ll get a UDP port using the code we defined earlier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Get a socket</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>socket (<span style=color:#a6e22e>get-socket</span> local-port))
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Next we want to fix the callback this library is expecting and convert it to the form that the UDP library is expecting. Essentially, we want to parse any results from the UDP listener as a DNS packet and verify that it matches the ID we sent. If that&rsquo;s all true, we also want to try to parse any answers returned:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Enhance the callback to make sure the response is actually DNS</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>real-callback</span> remote-host remote-port buffer)
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>define </span>dns-packet
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>with-handlers</span> ([exn? (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>err</span>) <span style=color:#66d9ef>#f</span>)])
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>bytes-&gt;dns</span> buffer)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>dns-packet
</span></span><span style=display:flex><span>                    (= (<span style=color:#a6e22e>dns-id</span> dns-packet) request-id)
</span></span><span style=display:flex><span>                    (= (<span style=color:#a6e22e>dns-qr</span> dns-packet) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    (= (<span style=color:#a6e22e>dns-z</span> dns-packet) <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>callback</span> remote-host key val (<span style=color:#a6e22e>parse-dns-response</span> dns-packet))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Listen for that on the UDP response</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>add-socket-listener!</span> local-port real-callback)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; After the given timeout, remove it again</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>when</span> (<span style=color:#a6e22e>current-dns-timeout</span>)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>thread</span> 
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>thunk</span> 
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>sleep</span> (<span style=color:#a6e22e>current-dns-timeout</span>))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>remove-socket-listener!</span> local-port real-callback))))
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>If the packet doesn&rsquo;t match, the <code>callback</code> simply isn&rsquo;t called. We&rsquo;ll come back to the <code>parse-dns-response</code> function in a moment. After that, attached the listener to the UDP library. If we have a timeout set, create a new thread here that will automatically remove it after the given time has passed.</p><p>And with that, all that&rsquo;s left is to actually send the packet. <code>udp-send-to</code> will set the destination for us, everything else has already been done in <code>get-socket</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Send the packet</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>udp-send-to</span> socket server <span style=color:#ae81ff>53</span> request-packet)))))
</span></span></code></pre></div><p>53 is the standard port for UDP DNS requests.</p><p>That&rsquo;s actually all we need. Granted, we still want to write the synchronous version and deal with parsing the responses. But we&rsquo;re well on the way.</p><p>First, the synchronous version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Make a DNS request, block until the first response is received</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; If multiple requests are specified only the first to return will be returned</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Timeouts after `current-dns-timeout` seconds</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>dns-request
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-keyword-procedure</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>keys</span> vals server)
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Values to set in the callback</span>
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>define </span>response (<span style=color:#a6e22e>void</span>))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>define </span>response-semaphore (<span style=color:#a6e22e>make-semaphore</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Make the async request, pass callback setting our values</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>keyword-apply</span> 
</span></span><span style=display:flex><span>      dns-request/async
</span></span><span style=display:flex><span>      keys vals
</span></span><span style=display:flex><span>      (list server
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>λ</span> response-data
</span></span><span style=display:flex><span>              (<span style=color:#66d9ef>set! </span>response response-data)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>semaphore-post</span> response-semaphore))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Wait until we have a response</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>sync/timeout</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>current-dns-timeout</span>)
</span></span><span style=display:flex><span>      [handle-evt
</span></span><span style=display:flex><span>       response-semaphore
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>λ</span> _ response)]))))
</span></span></code></pre></div><p>Essentially, we create our own callback (the second starting <code>(λ response-data ...)</code>). Since our semaphore starts at 0, it will block the <code>sync/timeout</code> until it has a non-zero value&ndash;as incremented by <code>semaphore-post</code>. If <code>(current-dns-timeout)</code> happens to be <code>#f</code>, <code>sync/timeout</code> will do exactly what we want and never time out. In all cases, we directly return the response if we get one. Otherwise, <code>sync/timeout</code> will return <code>#f</code>.</p><p>Finally, we need to actually deal with the parsing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Parse a DNS response</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>parse-dns-response</span> packet)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Get the hostname out of the query (which theoretically we sent)</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>query-length</span> query-hostname)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>decode-hostname</span> (<span style=color:#a6e22e>dns-data</span> packet) <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Make sure we got a response</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>rcode (<span style=color:#a6e22e>decode-rcode</span> (<span style=color:#a6e22e>dns-rcode</span> packet)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>answers (<span style=color:#a6e22e>dns-ancount</span> packet))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Valid response with at least one answer</span>
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and </span>(eq? rcode <span style=color:#e6db74>&#39;no-error</span>) (&gt; answers <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>define </span>data (<span style=color:#a6e22e>dns-data</span> packet))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>loop ([c <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>                [i (+ query-length <span style=color:#ae81ff>4</span>)]
</span></span><span style=display:flex><span>                [answers <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Done, return</span>
</span></span><span style=display:flex><span>         [(<span style=color:#66d9ef>or </span>(&gt;= c (<span style=color:#a6e22e>dns-ancount</span> packet))
</span></span><span style=display:flex><span>              (&gt;= i (<span style=color:#a6e22e>bytes-length</span> data)))
</span></span><span style=display:flex><span>          (cons rcode (reverse answers))]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Add another response</span>
</span></span><span style=display:flex><span>         [else
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>answer-length</span> answer-hostname) (<span style=color:#a6e22e>decode-hostname</span> data i))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>answer-type     (<span style=color:#a6e22e>bytes-&gt;number</span> data (+ i answer-length <span style=color:#ae81ff>0</span>) (+ i answer-length <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>answer-class    (<span style=color:#a6e22e>bytes-&gt;number</span> data (+ i answer-length <span style=color:#ae81ff>2</span>) (+ i answer-length <span style=color:#ae81ff>4</span>)))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>answer-ttl      (<span style=color:#a6e22e>bytes-&gt;number</span> data (+ i answer-length <span style=color:#ae81ff>4</span>) (+ i answer-length <span style=color:#ae81ff>8</span>)))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>answer-rdlength (<span style=color:#a6e22e>bytes-&gt;number</span> data (+ i answer-length <span style=color:#ae81ff>8</span>) (+ i answer-length <span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>answer-rdata    (<span style=color:#a6e22e>subbytes</span>      data (+ i answer-length <span style=color:#ae81ff>10</span>) (+ i answer-length <span style=color:#ae81ff>10</span> answer-rdlength)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; We&#39;re only interested in A records</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Got an a record</span>
</span></span><span style=display:flex><span>            [(= answer-type <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Decode the answer IP address</span>
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>define </span>answer-ip (<span style=color:#a6e22e>string-join</span> (map number-&gt;string (<span style=color:#a6e22e>bytes-&gt;list</span> answer-rdata)) <span style=color:#e6db74>&#34;.&#34;</span>))
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>loop</span> (+ c <span style=color:#ae81ff>1</span>) 
</span></span><span style=display:flex><span>                   (+ i answer-length <span style=color:#ae81ff>10</span> answer-rdlength)
</span></span><span style=display:flex><span>                   (cons (list <span style=color:#e6db74>&#39;A</span> answer-class answer-ip) answers))]
</span></span><span style=display:flex><span>            <span style=color:#75715e>; Got something else, just record it</span>
</span></span><span style=display:flex><span>            [else
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>loop</span> (+ c <span style=color:#ae81ff>1</span>) 
</span></span><span style=display:flex><span>                   (+ i answer-length <span style=color:#ae81ff>10</span> answer-rdlength)
</span></span><span style=display:flex><span>                   (cons (list answer-type answer-class answer-rdata)))])]))]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Reponse is not data</span>
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     (list rcode)]))
</span></span></code></pre></div><p>That&rsquo;s certainly a sizeable chunk of code, but it should be relatively straight forward. Essentially, we&rsquo;ll make sure we actually have answers. If we do, loop through processing one at a time. It&rsquo;s not as clean as I would like, since the the answers can be of variable length, but it&rsquo;s still relatively straight forward. We could also re-use the <code>bit-struct</code> library to parse the type, class, TTL, and data length, but because the answer name is a variable length (it uses the same format we discussed earlier), it&rsquo;s not particularly straight forward<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>Other than that, we&rsquo;re just returning a list of pairs, where each pair is the record type and the decoded data. So far, we only know how to deal with class 1 A records and their IPs, but I&rsquo;ll add more as I go. For the most part, data will be IPv4 / IPv6 addresses, hostnames, and occasionally raw text.</p><p>One oddity here that I hadn&rsquo;t previously mentioned is that you don&rsquo;t always have to encode the hostname as I mentioned above. Since DNS packets are generally limited to only 512 bytes, every bit saved is worth it. To that end, they have pointers that allow you to reference other hostnames previously defined. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Read a DNS encoded hostname, return bytes read and the name</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>decode-hostname</span> buffer [start <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Not enough data</span>
</span></span><span style=display:flex><span>    [(&gt;= start (<span style=color:#a6e22e>bytes-length</span> buffer))
</span></span><span style=display:flex><span>     (values <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>#f</span>)]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Pointer based hostname</span>
</span></span><span style=display:flex><span>    [(&gt;= (<span style=color:#a6e22e>bytes-ref</span> buffer start) <span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>     (values <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;pointer: ~x~x&#34;</span>
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>bytes-ref</span> buffer start)
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>bytes-ref</span> buffer (+ start <span style=color:#ae81ff>1</span>))))]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Normal hostname</span>
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>loop ([i start] [chunks <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>         [(= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>bytes-ref</span> buffer i))
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>values</span>
</span></span><span style=display:flex><span>           (+ <span style=color:#ae81ff>1</span> (length chunks) (apply + (map bytes-length chunks)))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>string-join</span> (reverse (map bytes-&gt;string/utf-8 chunks)) <span style=color:#e6db74>&#34;.&#34;</span>))]
</span></span><span style=display:flex><span>         [else
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>length (<span style=color:#a6e22e>bytes-ref</span> buffer i))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>chunk (<span style=color:#a6e22e>subbytes</span> buffer (+ i <span style=color:#ae81ff>1</span>) (+ i <span style=color:#ae81ff>1</span> length)))
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>loop</span> (+ i <span style=color:#ae81ff>1</span> length) (cons chunk chunks))]))]))
</span></span></code></pre></div><p>And that&rsquo;s all we need to get everything working. Let&rsquo;s try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>dns-request</span> <span style=color:#e6db74>&#34;8.8.4.4&#34;</span> <span style=color:#f92672>#</span>:a <span style=color:#e6db74>&#34;google.com&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;8.8.4.4&#34;</span>
</span></span><span style=display:flex><span>  a
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;google.com&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>no-error</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.68&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.71&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.72&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.78&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.67&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.73&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.64&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.69&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.66&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.70&#34;</span>) (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;74.125.225.65&#34;</span>)))
</span></span></code></pre></div><p>That&rsquo;s a fair few IP addresses. 😄 What if we try the asyncronous version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>callback</span> host type query response)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;~a says ~a for ~a is at ~a\n&#34;</span> host query type response))
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>dns-request/async</span> <span style=color:#e6db74>&#34;8.8.4.4&#34;</span> <span style=color:#f92672>#</span>:a <span style=color:#e6db74>&#34;google.com&#34;</span> callback)
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>dns-request/async</span> <span style=color:#e6db74>&#34;8.8.4.4&#34;</span> <span style=color:#f92672>#</span>:a <span style=color:#e6db74>&#34;facebook.com&#34;</span> callback)
</span></span><span style=display:flex><span><span style=color:#ae81ff>8.8</span><span style=color:#f92672>.</span><span style=color:#ae81ff>4.4</span> says google<span style=color:#f92672>.</span>com for a is at (<span style=color:#a6e22e>no-error</span> (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>74.125</span><span style=color:#f92672>.</span><span style=color:#ae81ff>225.69</span>) <span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>8.8</span><span style=color:#f92672>.</span><span style=color:#ae81ff>4.4</span> says facebook<span style=color:#f92672>.</span>com for a is at (<span style=color:#a6e22e>no-error</span> (<span style=color:#a6e22e>A</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>173.252</span><span style=color:#f92672>.</span><span style=color:#ae81ff>110.27</span>))
</span></span></code></pre></div><p>That way we can send more than one request at a time and deal with them as we come back. Perfect for what I&rsquo;m working on. I&rsquo;ll have another post about that when it&rsquo;s done&ndash;either later this week or early next. <em>fingers crossed</em></p><p>If you&rsquo;d like to see the entire code for this project thus far, you can see it on GitHub: <a href=https://github.com/jpverkamp/dns-world-scan>jpverkamp/dns-world-scan</a>. It&rsquo;s still very much a work in progress, but it may just be useful.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>It&rsquo;s my programming languages background coming out. 😄&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Why is it racket/udp rather than net/udp?&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>I should add some sort of way to add simple parsing functionality at some point&mldr;&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>