<!doctype html><html><head><title>Extending Racket structs to bitfields â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script defer src=/jquery_6894410585563545744.min.cc1cade18c999752b7befe111634889dca8d89b24923775954ecebc68c54fcd3.js></script>
<script defer src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js></script>
<script defer src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js></script>
<script defer src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js></script>
<script defer src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js></script>
<script defer src=/custom.js></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="></script><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="></script><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="></script><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="></script><link rel=stylesheet href=/custom.css><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Extending Racket structs to bitfields</h1><div class=entry-meta><span class=entry-date>2013-09-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/09/20/deploy-racket-libraries-to-planet-2/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/09/20/deploy-racket-libraries-to-planet-2/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/bitfields>Bitfields</a><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/04/09/cyclic-equality/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2013/09/20/deploy-racket-libraries-to-planet-2/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2013/09/20/deploy-racket-libraries-to-planet-2/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2013/09/25/extending-rackets-dns-capabilities/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Keen eyed observers may have noticed that last Friday when I <a href=https://blog.jverkamp.com/2013/09/20/deploy-racket-libraries-to-planet-2/>posted about converting</a> my various Racket libraries to Planet 2 packages, that there was a new package there I haven&rsquo;t otherwise talked about: <a href=http://racket.jverkamp.com/bit-struct/>bit-struct</a>. Today seems like a good time to talk about that. Theoretically, I&rsquo;ll also have another post or two this week showing exactly what I&rsquo;m doing with it (spoilers: it involves sending on the order of billions of DNS requests<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>).</p><p>If you&rsquo;d like to go straight to the code, it&rsquo;s available on GitHub: <a href=https://github.com/jpverkamp/bit-struct>jpverkamp/bit-struct</a>. Along with the new Planet 2 packages, I also have documentation now, available here: <a href=http://racket.jverkamp.com/bit-struct/>bit-struct documentation</a>.</p><p>The basic idea is we want to take straight forward Racket structs (already rather useful in their own right), limit them to only numeric values, and extend them to convert the structs to bit fields (as RacketÂ <code><a href="http://docs.racket-lang.org/search/index.html?q=bytes">bytes</a></code>
) and back. In theory<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, this will allow interaction with systems that have very specific memory layouts, such as networking packets. As a bit of a spoiler, this should be both completely valid and do exactly what you might expect<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>define-bit-struct</span> dns
</span></span><span style=display:flex><span>  ([id      <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [qr      <span style=color:#ae81ff>1</span>]  [opcode  <span style=color:#ae81ff>4</span>]  [aa      <span style=color:#ae81ff>1</span>]  [tc      <span style=color:#ae81ff>1</span>]  [rd      <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>   [ra      <span style=color:#ae81ff>1</span>]  [z       <span style=color:#ae81ff>3</span>]  [rcode   <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>   [qdcount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [ancount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [nscount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [arcount <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>   [data    _]))
</span></span></code></pre></div><p>The extra advantage in this case is that (via the magic of macros) three additional functions are also defined:</p><ul><li><code>(build-dns #:key val ...)</code> - take any number of keyword arguments matching the struct fields above and create the struct, any unspecified values are set to 0</li><li><code>(dns->bytes data)</code> - convert a struct into a bit field, using the given bit widths</li><li><code>(bytes->dns buffer)</code> - convert a bit field back into a struct, again using the bit widths</li></ul><p>Here are some more examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#66d9ef>define </span>packet
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>build-dns</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>#</span>:id (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>65536</span>)
</span></span><span style=display:flex><span>     <span style=color:#f92672>#</span>:tc <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>#</span>:qdcount <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>#</span>:data
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>bytes-append</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;\3www\6google\3com\0&#34;</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>bytes</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>bytes</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>&gt; packet
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>dns</span> <span style=color:#ae81ff>3202</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;\3www\6google\3com\0\0\1\0\1&#34;</span>)
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>dns-&gt;bytes</span> packet)
</span></span><span style=display:flex><span><span style=color:#f92672>#</span><span style=color:#e6db74>&#34;\f\202\2\0\0\1\0\0\0\0\0\0\3www\6google\3com\0\0\1\0\1&#34;</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>bytes-&gt;dns</span> (<span style=color:#a6e22e>dns-&gt;bytes</span> packet))
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>dns</span> <span style=color:#ae81ff>3202</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;\3www\6google\3com\0\0\1\0\1&#34;</span>)
</span></span></code></pre></div><p>Nice and straight forward. The real question though is what sort of magic did we need to get this all working? Just as useful as having the package itself is the additional experience with a relative complicated macro.</p><p>First, we need to introduce some more names. Normally, that isn&rsquo;t particularly straight forward, since we have to bend the rules of <a href=https://en.wikipedia.org/wiki/Hygienic%20macro>hygienic macros</a> just a bit. Luckily though, Racket provides the tools to do just that:Â <code><a href="http://docs.racket-lang.org/search/index.html?q=with-syntax">with-syntax</a></code>
Â andÂ <code><a href="http://docs.racket-lang.org/search/index.html?q=format-id">format-id</a></code>
. Essentially, <code>with-syntax</code> is similar to <code>syntax-case</code> in that it binds more syntax variables. <code>format-id</code> is basically an extension to format that attaches scope to the new <code>id</code> in order to make cleaner error message. Always a plus. ðŸ˜„ Here&rsquo;s how all of that looks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Bind a struct (and normal functions) plus these new functions:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; build-* takes keyword arguments for parameters (default = 0)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; *-&gt;bytes turns a struct into bytes</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; bytes-&gt;* takes bytes and returns a struct</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define-syntax </span>(<span style=color:#a6e22e>define-bit-struct</span> stx)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>syntax-case</span> stx ()
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>_</span> struct-name ([name* bits*] <span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Get some identifiers we&#39;ll need</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>with-syntax</span> ([builder-name (<span style=color:#a6e22e>format-id</span> stx <span style=color:#e6db74>&#34;build-~a&#34;</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#39;struct-name</span>)]
</span></span><span style=display:flex><span>                   [bytes-&gt;-name (<span style=color:#a6e22e>format-id</span> stx <span style=color:#e6db74>&#34;bytes-&gt;~a&#34;</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#39;struct-name</span>)]
</span></span><span style=display:flex><span>                   [-&gt;bytes-name (<span style=color:#a6e22e>format-id</span> stx <span style=color:#e6db74>&#34;~a-&gt;bytes&#34;</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#39;struct-name</span>)])
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>)]))
</span></span></code></pre></div><p>More or less straight forward. It does require <a href="http://docs.racket-lang.org/reference/stx-patterns.html?q=with-syntax#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax-case))" data-pltdoc=x>syntax-<wbr>case</a>Â rather than <a href="http://docs.racket-lang.org/reference/stx-patterns.html?q=with-syntax#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax-rules))" data-pltdoc=x>syntax-<wbr>rules</a>Â which I normally use (in order to have access to the raw <code>stx</code> to pass to <code>format-id</code>, but other than that, a pretty normal macro. Now each function in turn.</p><p>First, <code>build-*</code>.Â This one does the magic of creating a function with dynamic keyword parameters that match whatever fields the struct has. To do that, we need the functionÂ <code><a href="http://docs.racket-lang.org/search/index.html?q=make-keyword-procedure">make-keyword-procedure</a></code>
, whichÂ takes a procedure of the formÂ <code>((Listof keys) (Listof values) any ... . -> . any)</code>. So if you define a functionÂ <code>(Î» (keys vals . args) ...)</code>, keys and values are lists of the same length, the first containing the keywords and the latter containing the associated values. You could easily make it into an association list if you wanted just by callingÂ <code>(map list keys vals)</code>Â (or with <code>for</code> as I did below). I did have to convert them though. As given, they are keywords but I wanted symbols. I&rsquo;m not sure there&rsquo;s a direct way to convert between those two, but it&rsquo;s easy enough via an intermediate string.</p><p>In this case, I&rsquo;m ignoring theÂ <code>rest</code>Â parameter so only keyword parameters are allowed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Create the builder function</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>builder-name
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>make-keyword-procedure</span>
</span></span><span style=display:flex><span>   (<span style=color:#960050;background-color:#1e0010>Î»</span> (<span style=color:#a6e22e>keys</span> vals)
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Create an association map from the new values</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>new-values
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>for/list</span> ([k (<span style=color:#a6e22e>in-list</span> (map string-&gt;symbol 
</span></span><span style=display:flex><span>                                    (map keyword-&gt;string keys)))]
</span></span><span style=display:flex><span>                   [v (<span style=color:#a6e22e>in-list</span> vals)])
</span></span><span style=display:flex><span>          (list k v)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Build a new structure</span>
</span></span><span style=display:flex><span>      (apply 
</span></span><span style=display:flex><span>       maker-name
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>for/list</span> ([name (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(name* <span style=color:#f92672>...</span>))]
</span></span><span style=display:flex><span>                  [bits (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(bits* <span style=color:#f92672>...</span>))])
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>           [(assoc name new-values)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>=&gt; </span>(<span style=color:#960050;background-color:#1e0010>Î»</span> (<span style=color:#a6e22e>kv</span>) (<span style=color:#a6e22e>second</span> kv))]
</span></span><span style=display:flex><span>           [(eq? bits <span style=color:#e6db74>&#39;_</span>) <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;&#34;</span>]
</span></span><span style=display:flex><span>           [<span style=color:#66d9ef>else </span>           <span style=color:#ae81ff>0</span>]))))))
</span></span></code></pre></div><p>After we have that association list, we&rsquo;ll use a second loop to create the structure. Since we&rsquo;re inside of the macro, <code>'(name* ...)</code> expands to a list of whatever was in the first position for each argument when <code>define-bit-struct</code> was called. Likewise, bits is a list of the bit widths. With all of that, we can loop across these values. Another neat trick in this code is the use of <code>=></code> in the <code>cond</code>. Essentially, <code>assoc</code> will take the association list we created and query it. If the key is there, it will call the given function, passing the key/value pair as an argument (<code>kv</code>). If it&rsquo;s not there, use the <code>else</code> case to set the value to 0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Create the parser function</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>bytes-&gt;-name</span> buffer)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Set names with parameters (easier than making lots of ids)</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>name* (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Unpack fields into those parameters as integers</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; _ is different, it stores any remaining bytes</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>_
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for/fold</span> ([offset <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>              ([name (<span style=color:#a6e22e>in-list</span> (list name* <span style=color:#f92672>...</span>))]
</span></span><span style=display:flex><span>               [bits (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(bits* <span style=color:#f92672>...</span>))])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        [(number? bits)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>name</span> (<span style=color:#a6e22e>extract-bytes</span> buffer offset (+ offset bits)))
</span></span><span style=display:flex><span>         (+ offset bits)]
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>name</span> (<span style=color:#a6e22e>subbytes</span> buffer (quotient offset <span style=color:#ae81ff>8</span>)))
</span></span><span style=display:flex><span>         offset])))
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Create the structure</span>
</span></span><span style=display:flex><span>  (apply 
</span></span><span style=display:flex><span>   maker-name
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/list</span> ([name (list name* <span style=color:#f92672>...</span>)])
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>name</span>))))
</span></span></code></pre></div><p>For the second function, we want to be able to take a sequence of bytes and pull one of these structures out of it. If we need to get only part of a byte or extend over multiple bytes (both of which happen in the DNS example), the function <code>extract-bytes</code> will do just that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Extract bits from a bit field</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>extract-bytes</span> buffer from [to <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Extract the bytes we&#39;re interested in</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>f (quotient from <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>t (<span style=color:#66d9ef>if </span>to 
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>let </span>([q (quotient to <span style=color:#ae81ff>8</span>)])
</span></span><span style=display:flex><span>                  (<span style=color:#66d9ef>if </span>(zero? (remainder to <span style=color:#ae81ff>8</span>)) q (+ <span style=color:#ae81ff>1</span> q)))
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>bytes-length</span> buffer)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>chunk (<span style=color:#a6e22e>subbytes</span> buffer f t))
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Convert to a base 256 number</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>numeric
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for/fold</span> ([total <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>              ([byte (<span style=color:#a6e22e>in-bytes</span> chunk)])
</span></span><span style=display:flex><span>      (+ byte (* total <span style=color:#ae81ff>256</span>))))
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Shift off the ends</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>bitwise-and</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>arithmetic-shift</span> numeric 
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>if </span>to 
</span></span><span style=display:flex><span>                         (<span style=color:#66d9ef>let </span>([r (remainder to <span style=color:#ae81ff>8</span>)])
</span></span><span style=display:flex><span>                           (<span style=color:#66d9ef>if </span>(zero? r) r (- r <span style=color:#ae81ff>8</span>)))
</span></span><span style=display:flex><span>                         <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>   (- (<span style=color:#a6e22e>arithmetic-shift</span> <span style=color:#ae81ff>1</span> (- to from)) <span style=color:#ae81ff>1</span>)))
</span></span></code></pre></div><p>First, we get just the bytes we&rsquo;re interested in as a list. Then, we convert that to a single number by treating the list as a &lsquo;base 256&rsquo; number. Finally, we use an <code>arithmetic-shift</code> to pull off bits at one end and a <code>bitwise-and</code> with a mask to select only the ones from the other end that we want. The bit twiddling gets a bit complicated here, but once it all works, you don&rsquo;t have to think about it any more&ndash;just use it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Create the -&gt;bytes function</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>-&gt;bytes-name</span> data-struct)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>data (<span style=color:#a6e22e>struct-&gt;vector</span> data-struct))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([bits <span style=color:#f92672>&#39;</span>(bits* <span style=color:#f92672>...</span>)]
</span></span><span style=display:flex><span>             [buffer <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>             [buffer-bits <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>             [index <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Full buffer, transfer it</span>
</span></span><span style=display:flex><span>      [(<span style=color:#66d9ef>and </span>(&gt; buffer-bits <span style=color:#ae81ff>0</span>) (zero? (remainder buffer-bits <span style=color:#ae81ff>8</span>)))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>bytes-append</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>number-&gt;bytes</span> buffer (quotient buffer-bits <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> bits <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> index))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Nothing left</span>
</span></span><span style=display:flex><span>      [(null? bits)
</span></span><span style=display:flex><span>       <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;&#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Current value is bytes, copy directly</span>
</span></span><span style=display:flex><span>      [(eq? (<span style=color:#a6e22e>first</span> bits) <span style=color:#e6db74>&#39;_</span>)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>bytes-append</span>
</span></span><span style=display:flex><span>        (vector-ref data index)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>rest</span> bits) buffer buffer-bits (+ index <span style=color:#ae81ff>1</span>)))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Otherwise, add to buffer</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>rest</span> bits)
</span></span><span style=display:flex><span>        (+ (* buffer (<span style=color:#a6e22e>arithmetic-shift</span> <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>first</span> bits)))
</span></span><span style=display:flex><span>           (vector-ref data index))
</span></span><span style=display:flex><span>        (+ buffer-bits (<span style=color:#a6e22e>first</span> bits))
</span></span><span style=display:flex><span>        (+ index <span style=color:#ae81ff>1</span>))])))
</span></span></code></pre></div><p>The third and final function&rsquo;s code is actually fairly similar, in that it has to loop over the names/bit widths. One additional part that it does is that it uses a <code>named let</code> to collect the current offset within a byte. That way we collect partial bytes in a <code>buffer</code> until we have some multiple of 8. Then we use the dual to <code>extract-bytes</code> (<code>number-></code>) to convert back to bytes.</p><p>And that&rsquo;s all there is to it. It&rsquo;s certainly not bullet proof just yet (for example, I know that negative values will probably do strange things to it, as will providing keywords that don&rsquo;t exist to <code>build-*</code>), but it&rsquo;s certainly a good first step. It should be useful later this week.</p><p>As always, today&rsquo;s code is available on GitHub: <a href=https://github.com/jpverkamp/bit-struct>jpverkamp/bit-struct</a>. This time, there&rsquo;s also documentation available here: <a href=http://racket.jverkamp.com/bit-struct/>bit-struct documentation</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Not to DoSing anyone though (at least not on purpose)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>In practice as well actually; we&rsquo;ll see that later this week&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>If what you expect is a struct with the given names and ordered fields each containing the given number of bits&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>