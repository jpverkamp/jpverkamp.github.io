<!doctype html><html><head><title>AoC 2022 Day 18: Lavinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet><link rel=stylesheet href=/custom.css defer><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2022 Day 18: Lavinator</h1><div class=entry-meta><span class=entry-date>2022-12-18</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/data-structure>Data Structure</a></li><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphs>Graphs</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-boiling-bouldershttpsadventofcodecom2022day18>Source: <a href=https://adventofcode.com/2022/day/18>Boiling Boulders</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>Given a list of 1x1x1 cubes, determine the total surface area of the cubes.</p></blockquote><p>Sweet. Let&rsquo;s make a <code>Point3D</code> class to match the earlier <code>Point</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>/* ----- A 3D version of the point ----- */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point3D</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> z: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Add <span style=color:#66d9ef>for</span> Point3D {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point3D;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(self, rhs: <span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point3D::new(self.x <span style=color:#f92672>+</span> rhs.x, self.y <span style=color:#f92672>+</span> rhs.y, self.z <span style=color:#f92672>+</span> rhs.z)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Sub <span style=color:#66d9ef>for</span> Point3D {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> Point3D;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sub</span>(self, rhs: <span style=color:#a6e22e>Self</span>) -&gt; <span style=color:#a6e22e>Self</span>::Output {
</span></span><span style=display:flex><span>        Point3D::new(self.x <span style=color:#f92672>-</span> rhs.x, self.y <span style=color:#f92672>-</span> rhs.y, self.z <span style=color:#f92672>-</span> rhs.z)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point3D {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> UNITS: [Point3D; <span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span>, z: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span>, z: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, z: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span>, z: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span>, z: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>        Point3D { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span>, z: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(x: <span style=color:#66d9ef>isize</span>, y: <span style=color:#66d9ef>isize</span>, z: <span style=color:#66d9ef>isize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Point3D { x, y, z }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>adjacent_to</span>(self, other: <span style=color:#a6e22e>Point3D</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> delta <span style=color:#f92672>=</span> self <span style=color:#f92672>-</span> other;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        delta.x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> delta.y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> delta.z.abs() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> delta.x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> delta.y.abs() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> delta.z <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> delta.x.abs() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> delta.y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> delta.z <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>adjacent_to</code> is something we&rsquo;ll need just for this problem, but let&rsquo;s go ahead and write it. <code>Point3D::UNITS</code> is the six unit vectors. We&rsquo;ll use that to get the six cubes that might touch a given cube</p><p>Next, a collection struct of <code>Point3D</code>: <code>Point3DCloud</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point3DCloud</span> {
</span></span><span style=display:flex><span>    points: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>Point3D<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point3DCloud {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contains</span>(<span style=color:#f92672>&amp;</span>self, p: <span style=color:#a6e22e>Point3D</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.points.contains(<span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Point3DCloud
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(iter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> I) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Point3DCloud {
</span></span><span style=display:flex><span>            points: <span style=color:#a6e22e>iter</span>
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> (x, y, z) <span style=color:#f92672>=</span> line
</span></span><span style=display:flex><span>                        .split(<span style=color:#e6db74>&#39;,&#39;</span>)
</span></span><span style=display:flex><span>                        .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;must be numbers&#34;</span>))
</span></span><span style=display:flex><span>                        .collect_tuple()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;must have three elements&#34;</span>);
</span></span><span style=display:flex><span>                    Point3D::new(x, y, z)
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>HashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Easy enough, once again <code>HashSet</code> to contain a bunch of points with arbitrary bounds that is quick to check <code>contains</code>.</p><p>That should be enough:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cloud <span style=color:#f92672>=</span> Point3DCloud::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cloud
</span></span><span style=display:flex><span>        .points
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            Point3D::UNITS
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>cloud.contains(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>s))
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>v)
</span></span><span style=display:flex><span>                .count()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>        .to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Elegant. Great the point cloud, than for each point, for each side of that point, if the cube to the side of the point is not itself in the cloud, the side counts for surface area.</p><p>I&rsquo;m not sure that was any easier to read than the code honestly. ðŸ˜„</p><h2 id=part-2>Part 2</h2><blockquote><p>The collection of points is hollow. Calculate only the external surface area.</p></blockquote><p>Well that&rsquo;s neat.</p><p>To do this, the first thing I want to do is to create a second set of points: <code>external</code>. For this, I want all points that are &lsquo;outside&rsquo; of the <code>cloud</code>. To generate this list, I need <code>Point3DCloud::bounds</code>, a bound outside of the <code>bounds</code>, and to <a href=https://en.wikipedia.org/wiki/flood%20fill>flood fill</a> from that point to fill the bounds.</p><p>Once I&rsquo;ve done that, any points in the flood fill are <code>external</code>, so we can use very nearly the same code as above. If for each cube, for each side, if the next cube on that side is <code>external</code>, this is an external surface.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Point3DCloud {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bounds</span>(<span style=color:#f92672>&amp;</span>self) -&gt; (Point3D, Point3D) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> min_bound <span style=color:#f92672>=</span> Point3D::new(<span style=color:#66d9ef>isize</span>::MAX, <span style=color:#66d9ef>isize</span>::MAX, <span style=color:#66d9ef>isize</span>::MAX);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_bound <span style=color:#f92672>=</span> Point3D::new(<span style=color:#66d9ef>isize</span>::MIN, <span style=color:#66d9ef>isize</span>::MIN, <span style=color:#66d9ef>isize</span>::MIN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.points.iter().for_each(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            min_bound.x <span style=color:#f92672>=</span> min_bound.x.min(p.x);
</span></span><span style=display:flex><span>            min_bound.y <span style=color:#f92672>=</span> min_bound.y.min(p.y);
</span></span><span style=display:flex><span>            min_bound.z <span style=color:#f92672>=</span> min_bound.z.min(p.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            max_bound.x <span style=color:#f92672>=</span> max_bound.x.max(p.x);
</span></span><span style=display:flex><span>            max_bound.y <span style=color:#f92672>=</span> max_bound.y.max(p.y);
</span></span><span style=display:flex><span>            max_bound.z <span style=color:#f92672>=</span> max_bound.z.max(p.z);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (min_bound, max_bound)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cloud <span style=color:#f92672>=</span> Point3DCloud::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (<span style=color:#66d9ef>mut</span> min_bound, <span style=color:#66d9ef>mut</span> max_bound) <span style=color:#f92672>=</span> cloud.bounds();
</span></span><span style=display:flex><span>    min_bound <span style=color:#f92672>=</span> min_bound <span style=color:#f92672>-</span> Point3D::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    max_bound <span style=color:#f92672>=</span> max_bound <span style=color:#f92672>+</span> Point3D::new(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Calculate all cubes within bounds (expand by one) that are &#39;external&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Do this by starting in one corner and flood filling from the bounds inwards
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> external <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> q <span style=color:#f92672>=</span> VecDeque::new();
</span></span><span style=display:flex><span>    q.push_back(min_bound);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>q.is_empty() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> q.pop_front().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Ignore points we&#39;ve already explored
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> external.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Points in the cloud are not external
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> cloud.contains(p) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Points out of bounds are ignored
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> p.x <span style=color:#f92672>&lt;</span> min_bound.x
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&lt;</span> min_bound.y
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> p.z <span style=color:#f92672>&lt;</span> min_bound.z
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> p.x <span style=color:#f92672>&gt;</span> max_bound.x
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> p.y <span style=color:#f92672>&gt;</span> max_bound.y
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> p.z <span style=color:#f92672>&gt;</span> max_bound.z
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Otherwise, mark as external
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        external.insert(p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check all neighbors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point3D::UNITS.iter().for_each(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> q.push_back(p <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>s));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Any side adjacent to an external cube is external
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cloud
</span></span><span style=display:flex><span>        .points
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            Point3D::UNITS
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> external.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> <span style=color:#f92672>*</span>s)))
</span></span><span style=display:flex><span>                .filter(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>v)
</span></span><span style=display:flex><span>                .count()
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>        .to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The flood fill should be straight forward enough:</p><ul><li>Create a queue of points, seed it with one point you&rsquo;re flood filling from</li><li>While the queue isn&rsquo;t empty, take a point:<ul><li>If that point is outside of the bounds, skip it</li><li>If that point has already been scanned (it&rsquo;s in <code>external</code>) skip it</li><li>If that point is in the <code>cloud</code>, it&rsquo;s not part of the fill, skip it</li><li>Otherwise, add the point to the flood fill and then for each neighbor:<ul><li>Add the neighbor to the queue; note: most of these will be skipped and that&rsquo;s fine, just so long as we don&rsquo;t oscillate back and forth</li></ul></li></ul></li></ul><p>And that&rsquo;s it. Two parts in much less time than <a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/>Pressurinator</a>.</p><h2 id=performance>Performance</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/18-lavinator <span style=color:#ae81ff>1</span> data/18.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4548</span>
</span></span><span style=display:flex><span>took 5.440583ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/18-lavinator <span style=color:#ae81ff>2</span> data/18.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2588</span>
</span></span><span style=display:flex><span>took 6.8895ms
</span></span></code></pre></div><p>The runtime is completely bounded by the number of points (for part 1) and the bounds of the points (part 2). Since the shape is very roughly a sphere, it&rsquo;s pretty quick. I really should visualize this one, it&rsquo;d be neat. Perhaps I&rsquo;ll come back to it.</p><p>Onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer src=/custom.js></script></body></html>