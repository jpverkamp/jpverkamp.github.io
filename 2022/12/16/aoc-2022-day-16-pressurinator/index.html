<!doctype html><html><head><title>AoC 2022 Day 16: Pressurinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet><link rel=stylesheet href=/custom.css defer><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2022 Day 16: Pressurinator</h1><div class=entry-meta><span class=entry-date>2022-12-16</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-proboscidea-volcaniumhttpsadventofcodecom2022day16>Source: <a href=https://adventofcode.com/2022/day/16>Proboscidea Volcanium</a></h3><h2 id=part-1>Part 1</h2><blockquote><p>Given a graph of nodes, some of which have a <code>pressure</code> (per tick output value) and an agent that can move through the graph and activate specific nodes (so that they output their per tick value every future tick), what is the maximum total output possible in 30 steps?</p></blockquote><p>Oooh, that&rsquo;s fun. I took a <em>long</em> time optimizing this one over and over again to get it to actually solve even part 1. I have to admit&mldr; I don&rsquo;t actually have a part 2 solution yet that will run in a reasonable amount of time (and more importantly with a reasonable amount of RAM). I&rsquo;ll update this post when I do&mldr;</p><p>But in any case, on to the solution.</p><p>As always, the first goal is to store the cave:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Store the description of the cave as a directed graph with flow rates at the nodes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cave</span> {
</span></span><span style=display:flex><span>    size: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    names: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    indexes: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, <span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    flow_rates: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    distances: <span style=color:#a6e22e>Matrix</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;re using the <code>Matrix</code> class we defined earlier, otherwise nothing out of the ordinary. Parsing uses the regex tricks from yesterday:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Parse a graph from a string iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Cave
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(iter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> I) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> names <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> indexes <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> flow_rates <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> neighbors <span style=color:#f92672>=</span> HashMap::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> re <span style=color:#f92672>=</span> Regex::new(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>r&#34;Valve (\w+) has flow rate=(\d+); tunnels? leads? to valves? ((?:\w+)(?:, \w+)*)&#34;</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .expect(<span style=color:#e6db74>&#34;regex creation failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (index, line) <span style=color:#66d9ef>in</span> iter.enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> caps <span style=color:#f92672>=</span> re.captures(<span style=color:#f92672>&amp;</span>line).expect(<span style=color:#e6db74>&#34;regex doesn&#39;t match line&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> String::from(<span style=color:#f92672>&amp;</span>caps[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            neighbors.insert(
</span></span><span style=display:flex><span>                name.clone(),
</span></span><span style=display:flex><span>                caps[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>                    .split(<span style=color:#e6db74>&#34;, &#34;</span>)
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span>, String::from(s)))
</span></span><span style=display:flex><span>                    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            indexes.insert(name.clone(), index);
</span></span><span style=display:flex><span>            names.push(name);
</span></span><span style=display:flex><span>            flow_rates.push(caps[<span style=color:#ae81ff>2</span>].parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> names.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Write distances as a matrix
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> distances <span style=color:#f92672>=</span> Matrix::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>::new(size, size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>size {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>size {
</span></span><span style=display:flex><span>                distances[[i, j]] <span style=color:#f92672>=</span> <span style=color:#66d9ef>usize</span>::MAX;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (src, neighbors) <span style=color:#66d9ef>in</span> neighbors.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (distance, dst) <span style=color:#66d9ef>in</span> neighbors.iter() {
</span></span><span style=display:flex><span>                distances[[indexes[src], indexes[dst]]] <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>distance;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Cave {
</span></span><span style=display:flex><span>            size: <span style=color:#a6e22e>names</span>.len(),
</span></span><span style=display:flex><span>            names,
</span></span><span style=display:flex><span>            indexes,
</span></span><span style=display:flex><span>            flow_rates,
</span></span><span style=display:flex><span>            distances,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So originally, I define a single step as:</p><ul><li>moving between any two connected nodes</li><li>enabling the current node</li></ul><p>There&rsquo;s a much better way to do this, but we&rsquo;ll come back to that.</p><p>The basic idea of the original solution was:</p><ul><li>Define a function <code>recur</code> that takes in the current location, remaining fuel, and which locations are enabled</li><li>Calculate a base case result of doing nothing for the rest of the simulation (<code>result</code>)</li><li>If the current location isn&rsquo;t enabled, fire off a <code>recur</code>sive solution that does an <code>Enable</code> step now and then finds the best recursive solution; if this is better than <code>result</code>, it becomes <code>result</code></li><li>For each neighboring node, do the same, calculate <code>recur</code> for <code>Move(node)</code> and if the recursive solution there is better, then take that result</li></ul><p>Technically correct&mldr; but very slow. I don&rsquo;t actually even have runtimes for this one.</p><p>I did have one way that I could at least make it bearable though: <a href=https://en.wikipedia.org/wiki/memoization>memoization</a>. Essentially, cache the result of each recursive call, that way if I end up in the same state through another branch (such as if A -> B -> C, A -> D -> C, then moving down either path results in the same <code>recur</code> calls.)</p><p>To implement that, I added this to my <code>max_flow</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Flow algorithms for a cave
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> Cave {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the steps for maximizing flow from a single location with a single agent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_flow</span>(self, location: String, fuel: <span style=color:#66d9ef>usize</span>) -&gt; (<span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span>Step<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheKey</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheValue</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span>Step<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The memoized recursive function that actually does the work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// cave and cache don&#39;t change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// index is where the agent currently is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// fuel is how much fuel is left in the simulation (stop at 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// enabled is a list of which cave pumps are currently enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(
</span></span><span style=display:flex><span>            cave: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>Cave<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>CacheKey, CacheValue<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>            index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            enabled: <span style=color:#a6e22e>Vector</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ) -&gt; <span style=color:#a6e22e>CacheValue</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we have already calculated a result at this index/fuel/enabled, return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (index, fuel, enabled.clone());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cache.borrow().contains_key(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> cache.borrow_mut()[<span style=color:#f92672>&amp;</span>cache_key].clone();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Store the result in the cache and return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            cache.borrow_mut().insert(cache_key, result.clone());
</span></span><span style=display:flex><span>            result
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fire off the recursive function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> cave <span style=color:#f92672>=</span> Rc::new(self);
</span></span><span style=display:flex><span>        recur(
</span></span><span style=display:flex><span>            cave.clone(),
</span></span><span style=display:flex><span>            Rc::new(RefCell::new(HashMap::new())),
</span></span><span style=display:flex><span>            cave.clone().indexes[<span style=color:#f92672>&amp;</span>location],
</span></span><span style=display:flex><span>            fuel,
</span></span><span style=display:flex><span>            Vector::from(vec![<span style=color:#66d9ef>false</span>; cave.clone().size]),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Don&rsquo;t worry, we&rsquo;ll get to the core of the algorithm. In a nutshell though, we pass around the <code>cache</code> (with <code>Rc</code>, so it&rsquo;s cheap enough) and if we&rsquo;ve already seen the same <code>(index, fuel, enabled)</code>, we just return it.</p><p>Does this still work? Absolutely:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span> 1<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 2<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 3<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 4<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 5<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 6<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 7<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 8<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> 9<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>10<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>11<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>12<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>13<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>16<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>17<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>18<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>19<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>20<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>21<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>22<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>23<span style=color:#f92672>]</span> Move<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>24<span style=color:#f92672>]</span> Enable
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>25<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>26<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>27<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>28<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>29<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>30<span style=color:#f92672>]</span> DoNothing
</span></span><span style=display:flex><span><span style=color:#ae81ff>1651</span>
</span></span><span style=display:flex><span>took 7.661355375s
</span></span></code></pre></div><p>This isn&rsquo;t on my full data (with 59 nodes), this is just on the given test data (with only 10 nodes). And it already takes 7 seconds. With the full data, I think it took a few minutes to solve? Still perfectly reasonable, but&mldr; I knew I could do better.</p><h3 id=optimized-version-with-multiple-steps-and-no-repeats>Optimized version with multiple steps and no-repeats</h3><p>Okay, the next way I attacked the problem was to optimize the number of choices we make at any given step to keep branching under control. To do that, I wanted to do a few things:</p><ul><li>Improve the <code>distance</code> map. If we can get <code>a -> b -> c</code>, then we can assume we can go <code>a -> c</code> using 2 fuel. We can account for that.</li><li>Don&rsquo;t go to nodes that are already enabled; anytime we go to a node, assume we&rsquo;ll enable it, since the above accounts for moving through enabled nodes.</li><li>Don&rsquo;t go to nodes that have 0 flow; they&rsquo;re functionally just connectors.</li></ul><p>With all of this, there are only 7 branches at first, 6 after that, 5 after that and so on. A total of <span class=latex-inline>7! = 5040</span>
cases instead of 10 at every step.</p><p>Running on the test case:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./target/release/16-pressurinator <span style=color:#ae81ff>1</span> data/16-test.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>7, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>4, <span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1651</span>
</span></span><span style=display:flex><span>took 40.906083ms
</span></span></code></pre></div><p>Ahyup, that&rsquo;s much faster. Even on the full 59 nodes, there are only 23 that have a flow rate, so <span class=latex-inline>23! = 2.58 * 10^22</span>
. Yeah, okay that&rsquo;s still a huge number. But remember the caching? Because of the relatively limited number of cases, it caches <em>much</em> better:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./target/release/16-pressurinator <span style=color:#ae81ff>1</span> data/16.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;CA&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;JF&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;LE&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;FP&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;YH&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;UX&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;AR&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>4, <span style=color:#e6db74>&#34;DM&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1720</span>
</span></span><span style=display:flex><span>took 175.448208ms
</span></span></code></pre></div><p>That&mldr; is acceptable.</p><h3 id=the-actual-code>The actual code</h3><p>So&mldr; how does that work? First, expand the <code>from</code> function to calculate all distances:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Parse a graph from a string iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Cave
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(iter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> I) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Expand to calculate the minimum possible distance between nodes (of any number of steps)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// For any pair of nodes, if we don&#39;t have a distance:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - Find a third node between them with a sum of of i-&gt;k-&gt;l == distance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Because distance is increasing from 2 up, this will always fill in minimal values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>size {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>size {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>size {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> j <span style=color:#f92672>||</span> j <span style=color:#f92672>==</span> k <span style=color:#f92672>||</span> i <span style=color:#f92672>==</span> k {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> distances[[i, j]] <span style=color:#f92672>==</span> <span style=color:#66d9ef>usize</span>::MAX <span style=color:#f92672>||</span> distances[[j, k]] <span style=color:#f92672>==</span> <span style=color:#66d9ef>usize</span>::MAX {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> old_d <span style=color:#f92672>=</span> distances[[i, k]];
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> new_d <span style=color:#f92672>=</span> distances[[i, j]] <span style=color:#f92672>+</span> distances[[j, k]];
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> new_d <span style=color:#f92672>&lt;</span> old_d {
</span></span><span style=display:flex><span>                            changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                            distances[[i, k]] <span style=color:#f92672>=</span> new_d;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>changed {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Cave {
</span></span><span style=display:flex><span>            size: <span style=color:#a6e22e>names</span>.len(),
</span></span><span style=display:flex><span>            names,
</span></span><span style=display:flex><span>            indexes,
</span></span><span style=display:flex><span>            flow_rates,
</span></span><span style=display:flex><span>            distances,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For each possible triple of nodes <code>(i, j, k)</code>, see if we can add a new node <code>i, k</code> distance via <code>j</code> / update the previous one with a better answer.</p><p>Now, we can use that do show the whole algorithm:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// A single step of the single agent simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Clone, Debug, Hash, Eq, PartialEq, Ord, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Step</span>(<span style=color:#66d9ef>usize</span>, String);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Flow algorithms for a cave
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> Cave {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the steps for maximizing flow from a single location with a single agent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_flow</span>(self, location: String, fuel: <span style=color:#66d9ef>usize</span>) -&gt; (<span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span>Step<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheKey</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheValue</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, Vector<span style=color:#f92672>&lt;</span>Step<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The memoized recursive function that actually does the work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// cave and cache don&#39;t change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// index is where the agent currently is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// fuel is how much fuel is left in the simulation (stop at 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// enabled is a list of which cave pumps are currently enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(
</span></span><span style=display:flex><span>            cave: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>Cave<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>CacheKey, CacheValue<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>            index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            enabled: <span style=color:#a6e22e>Vector</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ) -&gt; <span style=color:#a6e22e>CacheValue</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we have already calculated a result at this index/fuel/enabled, return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (index, fuel, enabled.clone());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cache.borrow().contains_key(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> cache.borrow_mut()[<span style=color:#f92672>&amp;</span>cache_key].clone();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Calculate the current flow based on the enabled gates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> per_tick_flow <span style=color:#f92672>=</span> cave
</span></span><span style=display:flex><span>                .clone()
</span></span><span style=display:flex><span>                .flow_rates
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .zip(enabled.clone().iter())
</span></span><span style=display:flex><span>                .filter_map(<span style=color:#f92672>|</span>(f, c)<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>c { Some(<span style=color:#f92672>*</span>f) } <span style=color:#66d9ef>else</span> { None })
</span></span><span style=display:flex><span>                .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Base case: try doing nothing for the rest of the simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> (fuel <span style=color:#f92672>*</span> per_tick_flow, Vector::new());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try each possible move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// A move is move to a node (inc multiple hops) + enable that node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> next_index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>cave.clone().size {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Don&#39;t bother moving to something that&#39;s already on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Don&#39;t bother moving to nodes with 0 flow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> next_index
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> enabled[next_index]
</span></span><span style=display:flex><span>                    <span style=color:#f92672>||</span> cave.clone().flow_rates[next_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Calculate the distance to this new node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// If we don&#39;t have enough fuel to make that trip, this isn&#39;t valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> cave.clone().distances[[index, next_index]];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> fuel {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Calculate which nodes will be enabled after this step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_enabled <span style=color:#f92672>=</span> enabled.clone();
</span></span><span style=display:flex><span>                next_enabled[next_index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Recursively calculate the result from taking this step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sub_result <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>                    cave.clone(),
</span></span><span style=display:flex><span>                    cache.clone(),
</span></span><span style=display:flex><span>                    next_index,
</span></span><span style=display:flex><span>                    fuel <span style=color:#f92672>-</span> d <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                    next_enabled,
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update that result with the total flow from moving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// And the instruction for output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                sub_result.<span style=color:#ae81ff>0</span> <span style=color:#f92672>+=</span> (d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> per_tick_flow;
</span></span><span style=display:flex><span>                sub_result
</span></span><span style=display:flex><span>                    .<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    .push_front(Step(d, cave.clone().names[next_index].clone()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If that result is better than what we have so far, update our best result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                result <span style=color:#f92672>=</span> result.max(sub_result);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Store the result in the cache and return it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            cache.borrow_mut().insert(cache_key, result.clone());
</span></span><span style=display:flex><span>            result
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fire off the recursive function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> cave <span style=color:#f92672>=</span> Rc::new(self);
</span></span><span style=display:flex><span>        recur(
</span></span><span style=display:flex><span>            cave.clone(),
</span></span><span style=display:flex><span>            Rc::new(RefCell::new(HashMap::new())),
</span></span><span style=display:flex><span>            cave.clone().indexes[<span style=color:#f92672>&amp;</span>location],
</span></span><span style=display:flex><span>            fuel,
</span></span><span style=display:flex><span>            Vector::from(vec![<span style=color:#66d9ef>false</span>; cave.clone().size]),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Everything is basically as I described above:</p><ul><li>Start with doing nothing</li><li>For each remaining neighbor:<ul><li>If it&rsquo;s not the current node</li><li>AND if it&rsquo;s not already enabled</li><li>AND if it has a non-zero flow rate</li><li>AND if we have enough fuel to get there</li><li>Then we <code>recur</code> down that branch and use the best of these results</li></ul></li></ul><p>That&rsquo;s really it.</p><p>One oddity is that there are a ton of <code>clone()</code> all over the place. This is actually perfectly fine, since I&rsquo;m doing <code>clone()</code> on <code>Rc</code>. That basically means I&rsquo;m making a new pointer to the same data structure and keeping track of all of them. There&rsquo;s some small overhead, but it keeps Rust happy.</p><p>Optimally, I would have preferred to make this a closure with a single <code>cave</code> and <code>cache</code> captured from the environment instead, but this works well enough. I suppose making a new struct with <code>cave</code> and <code>cache</code> on the struct and <code>recur</code> as a method on it would have worked as well. C&rsquo;est la vide.</p><h3 id=attempted-to-solve-via-30-steps-of-all-possibilities>Attempted to solve via 30 steps of all possibilities</h3><p>As a quick aside, for a while, I tried a parallel approach where I would start in each state and then keep track of the &lsquo;best&rsquo; way to get into each state for each step. The problem is, this doesn&rsquo;t include the cases of both moving through a node and enabling it and not. So it&rsquo;s not actually capable of optimizing this particular problem.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Tick <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tick <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tick <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 13, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>, Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tick <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 20, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 13, current: 13, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 20, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 20, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 20, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 21, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>, Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tick <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 22, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>, Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 23, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Enable<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> None
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 40, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 21, current: 21, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Tick <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 0<span style=color:#f92672>=</span>AA<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 60, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 1<span style=color:#f92672>=</span>BB<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 62, current: 22, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 2<span style=color:#f92672>=</span>CC<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 62, current: 22, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 3<span style=color:#f92672>=</span>DD<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 63, current: 23, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 4<span style=color:#f92672>=</span>EE<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 63, current: 23, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 5<span style=color:#f92672>=</span>FF<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 63, current: 23, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 6<span style=color:#f92672>=</span>GG<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 60, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 7<span style=color:#f92672>=</span>HH<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 0, current: 0, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;FF&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;GG&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 8<span style=color:#f92672>=</span>II<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 60, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, DoNothing, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)])</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>state 9<span style=color:#f92672>=</span>JJ<span style=color:#f92672>]</span> State<span style=color:#f92672>(</span>total: 60, current: 20, steps: <span style=color:#f92672>[</span>Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, Enable, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;AA&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;II&#34;</span><span style=color:#f92672>)</span>, Move<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)])</span>
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><blockquote><p>Do the same only with two agents and 26 steps.</p></blockquote><p>Now this is where things really got complicated. In a nutshell, I started out writing it with two <code>index</code> values plus adding a <code>ttl</code> value for each so that I knew how far along a given path we were. For that to work, I had essentially 4 blocks in my &lsquo;choose which <code>recur</code>&rsquo; function:</p><ul><li><p>If either agent had a <code>ttl = 0</code>, they needed to choose where to go next.</p><p>This was done the same way as above (try each node that isn&rsquo;t <code>enabled</code> and has a <code>flow_rate > 0</code>), I would set the <code>ttl = distance + 1</code>, since it would take <code>distance</code> to get to the node and <code>1</code> more to <code>enable</code> it.</p><p>The interesting bit of this one was that this branch <em>didn&rsquo;t</em> actually use any fuel. It changed the agent, but because it didn&rsquo;t use any fuel, I could do two of these (one for each agent) before moving on without breaking anything.</p></li><li><p>If either agent had a <code>ttl = 1</code>, they were at a node and needed to <code>enable</code> it.</p><p>This I did in a single case where I looped over all of the active agents and found all of them with <code>ttl = 1</code>, setting <code>enable</code> for all of them at once, then advancing 1 fuel for them and all the rest. This is also where I updated the flow (since flow doesn&rsquo;t happen until the tick after an <code>enable</code> this works). This would put any with <code>ttl = 1</code> into the <code>ttl = 0</code> case for the next tick.</p><p>I did have to do this one all at once, because I can&rsquo;t just tick some agents and not others, all agents had to tick at once.</p><p>One interesting thing is that this case only had one possible <code>recur</code> (advance by 1 + set some <code>enabled</code> flags). We&rsquo;ll come back to an implication of that in a bit.</p></li><li><p>Finally, if all <code>ttl > 1</code>, then we could advance time until we get to the <code>ttl = 1</code> case. So find the minimum ttl and advance by <code>minimum(ttl) - 1</code>. This just adds the current flow to the total and otherwise doesn&rsquo;t branch (like the above case).</p></li></ul><p>Now this worked, but I was getting some odd bugs and the code was annoying to reason about. So what I really wanted was something a bit more elegant.</p><h3 id=simulating-n-agents>Simulating <em>n</em> agents</h3><p>Enter the <code>n-agent</code> simulation. Instead of 2, we could have any number&mldr; even 1. For this, I made a <code>State</code> struct which contained the above <code>index</code> and <code>ttl</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// The state of an agent in the multi agent simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    ttl: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>        State { index, ttl: <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>tick</span>(self, ticks: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>        State {
</span></span><span style=display:flex><span>            index: <span style=color:#a6e22e>self</span>.index,
</span></span><span style=display:flex><span>            ttl: <span style=color:#a6e22e>self</span>.ttl <span style=color:#f92672>-</span> ticks,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the <code>max_flow_multi</code> function looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Cave {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The same simulation but with multiple agents
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_flow_multi</span>(
</span></span><span style=display:flex><span>        self,
</span></span><span style=display:flex><span>        location: String,
</span></span><span style=display:flex><span>        fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        agents: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    ) -&gt; (<span style=color:#66d9ef>usize</span>, Vec<span style=color:#f92672>&lt;</span>StepMulti<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheKey</span> <span style=color:#f92672>=</span> (Vec<span style=color:#f92672>&lt;</span>State<span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>usize</span>, BitVec);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheValue</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, Vec<span style=color:#f92672>&lt;</span>StepMulti<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Main recursive function with multiple agents
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// cave and cache still don&#39;t change (other than to cache values)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// agents is an im::Vector of agent states, can be any number (even 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - this contains the next index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - plus a new value ttl which is how long it will take the agent to get to the index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// fuel is how long the simulation can still run
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// enabled is the map of which flows are enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(
</span></span><span style=display:flex><span>            cave: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>Cave<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>CacheKey, CacheValue<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>            agents: <span style=color:#a6e22e>Vector</span><span style=color:#f92672>&lt;</span>State<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            enabled: <span style=color:#a6e22e>Vector</span><span style=color:#f92672>&lt;</span>Bool<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ) -&gt; <span style=color:#a6e22e>CacheValue</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cache based on the state of all agents/fuel/enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (agents.clone(), fuel, enabled.clone());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cache.borrow().contains_key(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> cache.borrow_mut()[<span style=color:#f92672>&amp;</span>cache_key].clone();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Init the agents and kick the recursive function off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> cave <span style=color:#f92672>=</span> Rc::new(self);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (total_flow, steps) <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>            cave.clone(),
</span></span><span style=display:flex><span>            Rc::new(RefCell::new(HashMap::new())),
</span></span><span style=display:flex><span>            Vector::from(vec![State::new(cave.clone().indexes[<span style=color:#f92672>&amp;</span>location]); agents]),
</span></span><span style=display:flex><span>            fuel,
</span></span><span style=display:flex><span>            Vector::from(vec![<span style=color:#ae81ff>0</span>; cave.clone().size]),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Because we&#39;re using Vec, the steps end up in reverse order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (total_flow, steps.into_iter().rev().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m still using <code>Rc</code> + <code>RefCell</code> for the <code>cave</code> and <code>cache</code>, but this time, I&rsquo;m using <code>im::Vector</code> for the agents and the <code>enabled</code> field. In theory, these data structures are able to share a low of their structure between all of the different calls, only spending memory for the changes.</p><h3 id=new-multi-agent-code-with-one-agent>New multi-agent code with one agent</h3><p>As a first case, I want to test if this actually works with a single agent. In theory, it should, because the scheduling will always be the same:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>1</span> data/16-test.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>7, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Step<span style=color:#f92672>(</span>2, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1651</span>
</span></span><span style=display:flex><span>took 5.135ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>2</span> data/16-test.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 30, agent: 0, distance: 1, target: <span style=color:#e6db74>&#34;DD&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 30, ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 29, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 28, agent: 0, distance: 2, target: <span style=color:#e6db74>&#34;BB&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 28, ticks: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 26, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 25, agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 25, ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 22, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 21, agent: 0, distance: 7, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 21, ticks: <span style=color:#ae81ff>7</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 14, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 13, agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;EE&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 13, ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 10, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Schedule <span style=color:#f92672>{</span> fuel: 9, agent: 0, distance: 2, target: <span style=color:#e6db74>&#34;CC&#34;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>AdvanceTime <span style=color:#f92672>{</span> fuel: 9, ticks: <span style=color:#ae81ff>2</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>EnableTick <span style=color:#f92672>{</span> fuel: 7, activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>DoNothing <span style=color:#f92672>{</span> fuel: <span style=color:#ae81ff>6</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1651</span>
</span></span><span style=display:flex><span>took 3.724916ms
</span></span></code></pre></div><p>That&rsquo;s a good sign! And it&rsquo;s actually faster somehow. It&rsquo;s short enough that I&rsquo;m not particularly worried about why for that now. So let&rsquo;s try 2 agents.</p><h3 id=checking-with-multiple-agents>Checking with multiple agents</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>2</span> data/16-test.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 1, target: <span style=color:#e6db74>&#34;DD&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 1, target: <span style=color:#e6db74>&#34;BB&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 25, per_tick_flow: 0, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)</span>, <span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 24, per_tick_flow: 33, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 4, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 24, per_tick_flow: 33, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 3, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 24, per_tick_flow: 33, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 21, per_tick_flow: 33, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 20, per_tick_flow: 54, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 4, target: <span style=color:#e6db74>&#34;CC&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 20, per_tick_flow: 54, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 19, per_tick_flow: 76, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;EE&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 19, per_tick_flow: 76, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 16, per_tick_flow: 76, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)</span>, <span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 15, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 4, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 15, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 5, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 15, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>4</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 11, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 10, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 4, target: <span style=color:#e6db74>&#34;EE&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 10, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 9, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 7, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 9, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 6, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 5, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 5, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 2, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)</span>, <span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 1, per_tick_flow: 81, data: DoNothing <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1705</span>
</span></span><span style=display:flex><span>took 85.591208ms
</span></span></code></pre></div><p>It&rsquo;s still pretty <em>fast</em>, even with the much larger search space! And it works! Almost.</p><p>But&mldr; that&rsquo;s not actually the right answer. It&rsquo;s really close, but I should be able to get a 1707 out of there instead of the 1705.</p><p>That&mldr; took some digging, but eventually, I figured it out. There&rsquo;s an edge case (which this thankfully exposes) in the last non-<code>enabled</code> valve. If the two agents are not scheduling on the same tick (and they&rsquo;re usually not), then whichever one finishes first will get scheduled to go to this node.</p><p><em>But</em> what if that agent is on the completely other side of the simulation&mldr; The other agent (that finishes later) should be able to route to that index instead and leave the first one done to just do nothing instead.</p><p>In this case, I solved it by considering a special case once the number of nodes that have a non-zero flow that are not enabled is less than the number of agents, I relax the <code>enabled[next_index]</code> check, allowing them to go to an enabled node again. Like this (I&rsquo;ll come back to the details for what else is going on here):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Once all useful flows are active, allow moving to anywhere
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> potential_enabled <span style=color:#f92672>=</span> cave
</span></span><span style=display:flex><span>    .clone()
</span></span><span style=display:flex><span>    .flow_rates
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .zip(enabled.clone())
</span></span><span style=display:flex><span>    .filter_map(<span style=color:#f92672>|</span>(f, e)<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>f <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>e { Some(<span style=color:#66d9ef>true</span>) } <span style=color:#66d9ef>else</span> { None })
</span></span><span style=display:flex><span>    .count();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If our TTL is 0, schedule our next move
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This doesn&#39;t advance time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((i, agent)) <span style=color:#f92672>=</span> agents.clone().iter().enumerate().find(<span style=color:#f92672>|</span>(_, a)<span style=color:#f92672>|</span> a.ttl <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> next_index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>cave.clone().size {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> agents.clone().iter().any(<span style=color:#f92672>|</span>a<span style=color:#f92672>|</span> next_inde
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> agents.clone().iter().any(<span style=color:#f92672>|</span>a<span style=color:#f92672>|</span> next_index <span style=color:#f92672>==</span> a.index)
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> (potential_enabled <span style=color:#f92672>&gt;=</span> agents.len() <span style=color:#f92672>&amp;&amp;</span> enabled[next_index])
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> cave.clone().flow_rates[next_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Because it&rsquo;s late in the process, the performance hit is fairly minimal and more importantly, it actually generates the right answer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>2</span> data/16-test.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 2, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 1, target: <span style=color:#e6db74>&#34;DD&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 26, per_tick_flow: 0, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 25, per_tick_flow: 0, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;DD&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 24, per_tick_flow: 20, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 4, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 24, per_tick_flow: 20, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 23, per_tick_flow: 41, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;BB&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 23, per_tick_flow: 41, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 20, per_tick_flow: 41, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)</span>, <span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 19, per_tick_flow: 76, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 1, target: <span style=color:#e6db74>&#34;CC&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 19, per_tick_flow: 76, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 3, target: <span style=color:#e6db74>&#34;EE&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 19, per_tick_flow: 76, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 18, per_tick_flow: 76, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;CC&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 17, per_tick_flow: 78, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 5, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 17, per_tick_flow: 78, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 16, per_tick_flow: 78, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;EE&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 15, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 4, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 15, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>3</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 12, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 11, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 6, target: <span style=color:#e6db74>&#34;BB&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 11, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;JJ&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 10, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 1, distance: 7, target: <span style=color:#e6db74>&#34;HH&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 10, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>5</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 5, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>0, <span style=color:#e6db74>&#34;BB&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 4, per_tick_flow: 81, data: Schedule <span style=color:#f92672>{</span> agent: 0, distance: 3, target: <span style=color:#e6db74>&#34;JJ&#34;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 4, per_tick_flow: 81, data: AdvanceTime <span style=color:#f92672>{</span> ticks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 3, per_tick_flow: 81, data: EnableTick <span style=color:#f92672>{</span> activations: <span style=color:#f92672>[(</span>1, <span style=color:#e6db74>&#34;HH&#34;</span><span style=color:#f92672>)]</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>Step2 <span style=color:#f92672>{</span> fuel: 2, per_tick_flow: 81, data: DoNothing <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1707</span>
</span></span><span style=display:flex><span>took 251.897791ms
</span></span></code></pre></div><p>Okay. That&rsquo;s great! Let&rsquo;s try it on the ~6 times larger (with factorially worse run time) input.</p><h3 id=problems-with-memory->Problems with memory (?)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>2</span> data/16.txt
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>   Compiling aoc2022 v0.1.0 <span style=color:#f92672>(</span>/Users/jp/Projects/advent-of-code/2022<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished release <span style=color:#f92672>[</span>optimized<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 37.41s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/release/16-pressurinator <span style=color:#ae81ff>2</span> data/16.txt<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>zsh: killed     cargo run --release --bin 16-pressurinator <span style=color:#ae81ff>2</span> data/16.txt
</span></span></code></pre></div><p>Yeah&mldr; that&rsquo;s not good. It would run for several minutes and just crash. I googled, tried <code>cargo clean</code>, tried a new browser, tried it in <code>debug</code> mode (that took longer and still crashed). On branch suggested <code>zld</code> might cause this issue, but I&rsquo;m not using it. I thought perhaps a Rust bug&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ rustc --version
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rustc 1.64.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ rustup update
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>info: syncing channel updates <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;stable-aarch64-apple-darwin&#39;</span>
</span></span><span style=display:flex><span>info: latest update on 2022-12-15, rust version 1.66.0 <span style=color:#f92672>(</span>69f9c33d7 2022-12-12<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>info: checking <span style=color:#66d9ef>for</span> self-updates
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stable-aarch64-apple-darwin updated - rustc 1.66.0 <span style=color:#f92672>(</span>69f9c33d7 2022-12-12<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>from rustc 1.62.1 <span style=color:#f92672>(</span>e092d0b6b 2022-07-16<span style=color:#f92672>))</span>
</span></span></code></pre></div><p>Unfortunately that didn&rsquo;t help. Either. So &mldr; what&rsquo;s going on?</p><h3 id=improving-memory-usage>Improving memory usage</h3><p>Well, remember how I talked about <code>Vector</code> sharing structs and saving me a bunch of memory? Well, in practice&mldr; I&rsquo;m either using it wrong or don&rsquo;t quite understand it.</p><p>Exhibit A:</p><figure><img src=/embeds/2022/aoc16-2-ram.png></figure><p>Yup. That&rsquo;s the program (in release mode!) using <strong>45 GB</strong> of RAM. I&rsquo;m writing most of this on an M1 Mac Mini&mldr; with 16 GB of RAM. So most of that is in swap. It actually made it up to 60 GB of RAM before the OS killed it off.</p><p>Great.</p><p>So, how do we fix it?</p><p>Well, there are two big parts of the recursive calls that I should be able to optimize:</p><ul><li>The <code>im::Vector</code> of <code>enabled</code> valves</li><li>The <code>im::Vector</code> of <code>agents</code></li></ul><p>For the first, it&rsquo;s a <code>Vector&lt;bool></code>. I should be able to pack all of those values (even 59 of them) into a single 64-bit integer. Enter <a href=https://docs.rs/bitvec/latest/bitvec/><code>bitvec</code></a>. I&rsquo;ve given up on not using third party crates, there are some things that (after hours and hours of working on this) I don&rsquo;t want to reimplement just now.</p><p>For the conversion, we kick it off with this instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Init the agents and kick the recursive function off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> cave <span style=color:#f92672>=</span> Rc::new(self);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> (total_flow, steps) <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>    cave.clone(),
</span></span><span style=display:flex><span>    Rc::new(RefCell::new(HashMap::new())),
</span></span><span style=display:flex><span>    Vector::from(vec![State::new(cave.clone().indexes[<span style=color:#f92672>&amp;</span>location]); agents]),
</span></span><span style=display:flex><span>    fuel,
</span></span><span style=display:flex><span>    BitVec::from_vec(vec![<span style=color:#ae81ff>0</span>; cave.clone().size]),
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Then we need to change the various cache types and function signatures to expect this value and finally change the <code>enabled[agent.index] = true</code> to <code>enabled.set(agent.index, true)</code>. After that, it just works. We&rsquo;re still <code>clone</code>ing it, but it&rsquo;s a 64-bit integer being copied. Much better.</p><p>Next up, <code>agents</code>. This doesn&rsquo;t change much. Really for two, it&rsquo;s 4 <code>usize</code> values (an <code>index</code> and <code>ttl</code> for each). So instead of <code>Vector</code>, I just switched to <code>Vec</code>. It turns out it&rsquo;s optimized all to heck and cheap enough to copy those two bytes rather than all the extra bookkeeping from <code>Vector</code>.</p><p>All of that done and&mldr;</p><figure><img src=/embeds/2022/aoc16-2-better.png></figure><p>It&rsquo;s still taking up a chunk of my machine&mldr; but it&rsquo;s better!</p><p>I&rsquo;m &mldr; not 100% sure what the difference between <code>Real Memory Size</code> and <code>Virtual Memory Size</code> is there. I think <code>Real</code> is what it&rsquo;s actually using and <code>Virtual</code> is what it theoretically has access to? In that case, we should be good to go.</p><h3 id=improving-runtime>Improving runtime</h3><p>It&rsquo;s still very slow. So&mldr; how can we do better? Well, remember how I said that in both the <code>EnableTick</code> and <code>AdvanceTime</code> states there was only one possibility? Well branching (in this case) is expensive and takes even more memory. So let&rsquo;s see if we can clean everything up into a single case.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Cave {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The same simulation but with multiple agents
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_flow_multi</span>(
</span></span><span style=display:flex><span>        self,
</span></span><span style=display:flex><span>        location: String,
</span></span><span style=display:flex><span>        fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        agents: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    ) -&gt; (<span style=color:#66d9ef>usize</span>, Vec<span style=color:#f92672>&lt;</span>StepMulti<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheKey</span> <span style=color:#f92672>=</span> (Vec<span style=color:#f92672>&lt;</span>State<span style=color:#f92672>&gt;</span>, <span style=color:#66d9ef>usize</span>, BitVec);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CacheValue</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>usize</span>, Vec<span style=color:#f92672>&lt;</span>StepMulti<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Main recursive function with multiple agents
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// cave and cache still don&#39;t change (other than to cache values)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// agents is an im::Vector of agent states, can be any number (even 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - this contains the next index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// - plus a new value ttl which is how long it will take the agent to get to the index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// fuel is how long the simulation can still run
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// enabled is the map of which flows are enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>recur</span>(
</span></span><span style=display:flex><span>            cave: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>Cave<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            cache: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>HashMap<span style=color:#f92672>&lt;</span>CacheKey, CacheValue<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>            agents: Vec<span style=color:#f92672>&lt;</span>State<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>            fuel: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>            enabled: <span style=color:#a6e22e>BitVec</span>,
</span></span><span style=display:flex><span>        ) -&gt; <span style=color:#a6e22e>CacheValue</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Cache based on the state of all agents/fuel/enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> cache_key <span style=color:#f92672>=</span> (agents.clone(), fuel, enabled.clone());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cache.borrow().contains_key(<span style=color:#f92672>&amp;</span>cache_key) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> cache.borrow_mut()[<span style=color:#f92672>&amp;</span>cache_key].clone();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Calculate flow per tick (even if we won&#39;t actually tick)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> per_tick_flow <span style=color:#f92672>=</span> cave
</span></span><span style=display:flex><span>                .clone()
</span></span><span style=display:flex><span>                .flow_rates
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .zip(enabled.clone().iter())
</span></span><span style=display:flex><span>                .filter_map(<span style=color:#f92672>|</span>(f, c)<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>c { Some(<span style=color:#f92672>*</span>f) } <span style=color:#66d9ef>else</span> { None })
</span></span><span style=display:flex><span>                .sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Base case: try doing nothing for the rest of the simulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>                fuel <span style=color:#f92672>*</span> per_tick_flow,
</span></span><span style=display:flex><span>                vec![StepMulti {
</span></span><span style=display:flex><span>                    fuel,
</span></span><span style=display:flex><span>                    per_tick_flow,
</span></span><span style=display:flex><span>                    data: <span style=color:#a6e22e>StepMultiData</span>::DoNothing,
</span></span><span style=display:flex><span>                }],
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Once all useful flows are active, allow moving to anywhere
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This fixes a previous bug where the first free agent would claim the last valve even it was further away
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> potential_enabled <span style=color:#f92672>=</span> cave
</span></span><span style=display:flex><span>                .clone()
</span></span><span style=display:flex><span>                .flow_rates
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .zip(enabled.clone())
</span></span><span style=display:flex><span>                .filter_map(<span style=color:#f92672>|</span>(f, e)<span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>f <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>e { Some(<span style=color:#66d9ef>true</span>) } <span style=color:#66d9ef>else</span> { None })
</span></span><span style=display:flex><span>                .count();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If the TTL of any agent is 0, schedule it&#39;s next move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// This doesn&#39;t advance time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((i, agent)) <span style=color:#f92672>=</span> agents.clone().iter().enumerate().find(<span style=color:#f92672>|</span>(_, a)<span style=color:#f92672>|</span> a.ttl <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> next_index <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>cave.clone().size {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Not allowed to move to the same target as any other agent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Can only move to an already enabled valve if we&#39;re in the end state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> agents.clone().iter().any(<span style=color:#f92672>|</span>a<span style=color:#f92672>|</span> next_index <span style=color:#f92672>==</span> a.index)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> (potential_enabled <span style=color:#f92672>&gt;=</span> agents.len() <span style=color:#f92672>&amp;&amp;</span> enabled[next_index])
</span></span><span style=display:flex><span>                        <span style=color:#f92672>||</span> cave.clone().flow_rates[next_index] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Check that we have enough fuel to move there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> cave.clone().distances[[agent.index, next_index]];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> fuel {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Update the agent with where it&#39;s going + how long to get there and enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_agents <span style=color:#f92672>=</span> agents.clone();
</span></span><span style=display:flex><span>                    new_agents[i] <span style=color:#f92672>=</span> State {
</span></span><span style=display:flex><span>                        index: <span style=color:#a6e22e>next_index</span>,
</span></span><span style=display:flex><span>                        ttl: <span style=color:#a6e22e>d</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Make the recursive call and record that we did
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sub_result <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>                        cave.clone(),
</span></span><span style=display:flex><span>                        cache.clone(),
</span></span><span style=display:flex><span>                        new_agents,
</span></span><span style=display:flex><span>                        fuel,
</span></span><span style=display:flex><span>                        enabled.clone(),
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                    sub_result.<span style=color:#ae81ff>1.</span>push(StepMulti {
</span></span><span style=display:flex><span>                        fuel,
</span></span><span style=display:flex><span>                        per_tick_flow,
</span></span><span style=display:flex><span>                        data: <span style=color:#a6e22e>StepMultiData</span>::Schedule {
</span></span><span style=display:flex><span>                            agent: <span style=color:#a6e22e>i</span>,
</span></span><span style=display:flex><span>                            distance: <span style=color:#a6e22e>d</span>,
</span></span><span style=display:flex><span>                            target: <span style=color:#a6e22e>cave</span>.clone().names[next_index].clone(),
</span></span><span style=display:flex><span>                        },
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If making this call was better than the current result (of do nothing)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Use it instead
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    result <span style=color:#f92672>=</span> result.max(sub_result);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, advance by the ttl of the lowest agent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> activations <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Find time until the agent(s) that will finish moving soonest
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> ticks <span style=color:#f92672>=</span> agents
</span></span><span style=display:flex><span>                    .clone()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .min_by(<span style=color:#f92672>|</span>a, b<span style=color:#f92672>|</span> a.ttl.cmp(<span style=color:#f92672>&amp;</span>b.ttl))
</span></span><span style=display:flex><span>                    .expect(<span style=color:#e6db74>&#34;must have at least one agent&#34;</span>)
</span></span><span style=display:flex><span>                    .ttl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Enable any flows for agents with TTL=0 at the end of this move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_enabled <span style=color:#f92672>=</span> enabled.clone();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (i, agent) <span style=color:#66d9ef>in</span> agents.clone().iter().enumerate() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> agent.ttl <span style=color:#f92672>==</span> ticks {
</span></span><span style=display:flex><span>                        next_enabled.set(agent.index, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                        activations.push((i, cave.clone().names[agent.index].clone()));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update all agents (including those that will go to 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_agents <span style=color:#f92672>=</span> agents.clone();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (i, agent) <span style=color:#66d9ef>in</span> agents.clone().iter().enumerate() {
</span></span><span style=display:flex><span>                    next_agents[i] <span style=color:#f92672>=</span> agent.tick(ticks);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Make the recursive call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sub_result <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>                    cave.clone(),
</span></span><span style=display:flex><span>                    cache.clone(),
</span></span><span style=display:flex><span>                    next_agents,
</span></span><span style=display:flex><span>                    fuel <span style=color:#f92672>-</span> ticks,
</span></span><span style=display:flex><span>                    next_enabled,
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update flow by that many ticks + record what step we took
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// As always, if this result is better than nothing, record it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                sub_result.<span style=color:#ae81ff>0</span> <span style=color:#f92672>+=</span> ticks <span style=color:#f92672>*</span> per_tick_flow;
</span></span><span style=display:flex><span>                sub_result.<span style=color:#ae81ff>1.</span>push(StepMulti {
</span></span><span style=display:flex><span>                    fuel,
</span></span><span style=display:flex><span>                    per_tick_flow,
</span></span><span style=display:flex><span>                    data: <span style=color:#a6e22e>StepMultiData</span>::AdvanceTime { ticks, activations },
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>                result <span style=color:#f92672>=</span> result.max(sub_result);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Memoize the result and finally return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            cache.borrow_mut().insert(cache_key, result.clone());
</span></span><span style=display:flex><span>            result
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Init the agents and kick the recursive function off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> cave <span style=color:#f92672>=</span> Rc::new(self);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (total_flow, steps) <span style=color:#f92672>=</span> recur(
</span></span><span style=display:flex><span>            cave.clone(),
</span></span><span style=display:flex><span>            Rc::new(RefCell::new(HashMap::new())),
</span></span><span style=display:flex><span>            vec![State::new(cave.clone().indexes[<span style=color:#f92672>&amp;</span>location]); agents],
</span></span><span style=display:flex><span>            fuel,
</span></span><span style=display:flex><span>            BitVec::from_vec(vec![<span style=color:#ae81ff>0</span>; cave.clone().size]),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Because we&#39;re using Vec, the steps end up in reverse order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (total_flow, steps.into_iter().rev().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically I got rid of the relatively annoying <code>ttl = 1</code> state and instead handle that and the <code>advance</code> in the same tick. It&rsquo;s a bit cleaner code and a bit quicker.</p><h3 id=to-be-continued>To be continued&mldr;</h3><p>Unfortunately, a bit quicker is still way too slow. At this point, I&rsquo;ve been working on this problem for quite a while, so I&rsquo;m going to go ahead and move on to another. I&rsquo;ll let it run overnight to get an answer (if it does), but I still do want to try something better.</p><p>I think one option would be to give up on perfect and instead try a heuristic approach like <a href=https://en.wikipedia.org/wiki/simulated%20annealing>simulated annealing</a>. It won&rsquo;t be able to guarantee me the perfect answer, but I expect it will find one good enough in far less time.</p><p>Like I said, to be continued&mldr;</p><p>Certainly one of the most interesting problems so far this year!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer src=/custom.js></script></body></html>