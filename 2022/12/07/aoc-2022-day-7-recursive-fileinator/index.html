<!doctype html><html><head><title>AoC 2022 Day 7: Recursive Fileinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2022 Day 7: Recursive Fileinator</h1><div class=entry-meta><span class=entry-date>2022-12-07</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/file-systems>File Systems</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/07/trigun/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/08/aoc-2022-day-8-treetopinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-no-space-left-on-devicehttpsadventofcodecom2022day7>Source: <a href=https://adventofcode.com/2022/day/7 target=_blank rel=noopener>No Space Left On Device</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>Give the output of a very simple shell with only the commands <code>cd</code> and <code>ls</code> (the output of which is either <code>"dir" name</code> for directories or <code>size name</code> for files), find the largest directory (disk usage calculated recursively) with a size no greater than 100,000.</p></blockquote><p>Oh boy this one was crazy. Rust does some&mldr; <em>interesting</em> things when it comes to recursive/self-referential data structures.</p><p>Specifically, here&rsquo;s where I ended up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Represents a &#39;thing&#39; on a file system, either:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  - A named directory which can contain directories or files
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  - A named file which has a size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>FileSystemThing</span> {
</span></span><span style=display:flex><span>    Directory {
</span></span><span style=display:flex><span>        name: String,
</span></span><span style=display:flex><span>        parent: Option<span style=color:#f92672>&lt;</span>Arc<span style=color:#f92672>&lt;</span>FileSystemThing<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>        children: <span style=color:#a6e22e>RefCell</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Arc<span style=color:#f92672>&lt;</span>FileSystemThing<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    File {
</span></span><span style=display:flex><span>        name: String,
</span></span><span style=display:flex><span>        size: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The two interesting bits to deal with are:</p><ul><li><p>The <code>Arc</code> (atomic reference counter) wrappings on all <code>FileSystemThing</code>s. That&rsquo;s because I&rsquo;m going to be using <code>clone</code> a bunch to attach those same references to a single file system thing to different parts in the tree. Specifically, the parents of each child and the child nodes themselves.</p></li><li><p>The <code>RefCell</code> in a directory&rsquo;s children. This came about because I need to be able to <code>mut</code> the children to <code>push</code> to it. I can&rsquo;t otherwise figure out how that&rsquo;s going to work. I kept getting this error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>error[E0596]: cannot borrow `*children` as mutable, as it is behind a `&amp;` reference
</span></span><span style=display:flex><span>--&gt; src/bin/07-recursive-fileinator.rs:95:25
</span></span><span style=display:flex><span>|
</span></span><span style=display:flex><span>95 |                         children.push(child);
</span></span><span style=display:flex><span>|                         ^^^^^^^^^^^^^^^^^^^^ `children` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</span></span></code></pre></div><p>With the <code>RefCell</code> though, I can <code>borrow</code> or <code>borrow_mut</code> the value as I need.</p></li></ul><p>Okay, so we have the structure&mldr; how do we build it? Well, here&rsquo;s what I did:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileSystemThing {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Build a file system thing from an iter of commands run (cd and ls)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>mut</span> iter: <span style=color:#a6e22e>I</span>) -&gt; <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> FileSystemThing::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Build a special :ROOT: node to start with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> root <span style=color:#f92672>=</span> Arc::new(Directory {
</span></span><span style=display:flex><span>            name: String::from(<span style=color:#e6db74>&#34;:ROOT:&#34;</span>),
</span></span><span style=display:flex><span>            parent: None,
</span></span><span style=display:flex><span>            children: <span style=color:#a6e22e>RefCell</span>::new(Vec::new()),
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Keep track of where we currently are after cds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> current <span style=color:#f92672>=</span> RefCell::new(root.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(next) <span style=color:#f92672>=</span> iter.next() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> parts <span style=color:#f92672>=</span> next.split_ascii_whitespace();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> next.starts_with(<span style=color:#e6db74>&#34;$ cd&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// cd changes directory and has three cases:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//  &#34;/&#34; goes to root
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//  &#34;..&#34; goes up one level
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//  anything else goes into the named child directory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> path <span style=color:#f92672>=</span> String::from(parts.last().expect(<span style=color:#e6db74>&#34;cd must have a directory&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Build the next node depending on what we&#39;re cding too (&#34;/&#34;, &#34;..&#34;, or a name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> current.borrow().as_ref() {
</span></span><span style=display:flex><span>                    Directory { parent, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> path <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;..&#34;</span> {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>match</span> parent {
</span></span><span style=display:flex><span>                                Some(parent) <span style=color:#f92672>=&gt;</span> parent.clone(),
</span></span><span style=display:flex><span>                                _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;must have parent set to ..&#34;</span>),
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> path <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;/&#34;</span> {
</span></span><span style=display:flex><span>                            root.clone()
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(child) <span style=color:#f92672>=</span> current.borrow().get(path) {
</span></span><span style=display:flex><span>                            child
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            current.borrow().clone()
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> current.borrow().clone(),
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                current.replace(next);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> next.starts_with(<span style=color:#e6db74>&#34;$ ls&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Starting an LS, nothing to do on this line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> next.starts_with(<span style=color:#e6db74>&#34;dir&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If we see a line starting with dir we&#39;re in an ls, create the directory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> parts.last().expect(<span style=color:#e6db74>&#34;directory in ls must have a name&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If the file/directory already exists, we ran ls twice, ignore this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(_child) <span style=color:#f92672>=</span> current.borrow().get(String::from(name)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Build the new child directory referencing current as the parent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> child <span style=color:#f92672>=</span> Arc::new(Directory {
</span></span><span style=display:flex><span>                    name: String::from(name),
</span></span><span style=display:flex><span>                    parent: Some(current.borrow().clone()),
</span></span><span style=display:flex><span>                    children: <span style=color:#a6e22e>RefCell</span>::new(Vec::new()),
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Add a reference to the new directory to current&#39;s children
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>match</span> current.borrow().as_ref() {
</span></span><span style=display:flex><span>                    Directory { children, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        children.borrow_mut().push(child);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;somehow tried to ls a file&#34;</span>),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Otherwise, it&#39;s a line containing the size and name of a file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> parts
</span></span><span style=display:flex><span>                    .next()
</span></span><span style=display:flex><span>                    .expect(<span style=color:#e6db74>&#34;must have size&#34;</span>)
</span></span><span style=display:flex><span>                    .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                    .expect(<span style=color:#e6db74>&#34;size must be a usize&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> parts.next().expect(<span style=color:#e6db74>&#34;must have a name&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If the file/directory already exists, we ran ls twice, ignore this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(_child) <span style=color:#f92672>=</span> current.borrow().get(String::from(name)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Build the new file, doesn&#39;t need a parent at least
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> child <span style=color:#f92672>=</span> Arc::new(File {
</span></span><span style=display:flex><span>                    name: String::from(name),
</span></span><span style=display:flex><span>                    size,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Add a reference to the new file to current&#39;s children
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>match</span> current.borrow().as_ref() {
</span></span><span style=display:flex><span>                    Directory { children, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        children.borrow_mut().push(child);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;somehow tried to put a file into another file&#34;</span>),
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.clone()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Like I said, there are an awful lot of <code>clone</code> around, but that&rsquo;s fine. All that&rsquo;s essentially doing is telling <code>Arc</code> that we want more reference for it to count. Cheap.</p><p>To break down the code a bit:</p><ul><li>Create a special <code>:ROOT:</code> node with no parent, this is the only reason we have <code>Option</code> on that&mldr;</li><li>Set the <code>current</code> node to a <code>RefCell</code> of that, so we can update the reference</li><li>For each line in the input:<ul><li>If it&rsquo;s a <code>cd</code>:<ul><li>If it&rsquo;s <code>cd /</code>, change the <code>current</code> to the <code>:ROOT:</code> node; I don&rsquo;t think this actually happens</li><li>If it&rsquo;s <code>cd ..</code>, change to the parent directory of <code>current</code>; <code>panic</code> if we&rsquo;re at the root</li><li>If it&rsquo;s <code>cd $name</code>, change to that directory; assume that it&rsquo;s been &lsquo;created&rsquo; / revealed by a previous <code>ls</code> (see below)</li></ul></li><li>If it&rsquo;s an <code>ls</code>: we don&rsquo;t actually care, assume that all input not starting with <code>$</code> is part of an <code>ls</code></li><li>If it&rsquo;s <code>dir $name</code>, create a new directory with <code>$name</code> and no children and attach it to <code>current</code> by:<ul><li>Adding the new directory to <code>current.children</code> (with all the requisite indirection)</li><li>Set the <code>parent</code> of the new node to <code>current</code> (likewise)</li></ul></li><li>If it&rsquo;s <code>$size $filename</code>, create a file, add it to <code>current.children</code>, and store the size with it</li></ul></li></ul><p>Ooo-kay. That took a while to get working. I think I have a better handle for what Rust needs to make these complicated <code>structs</code> work, but &mldr; oh my is it a lot.</p><p>It took &mldr; a while to get to this. If you happen to be reading this and know of a more idiomatic / cleaner way to write the <code>from</code> code, I&rsquo;d love to hear it.</p><p>Okay, next we need the ability to recursively calculate the size at any given node:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileSystemThing {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get the size for a file or directory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Files directly have sizes, directories recursively sum their children&#39;s sizes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>size</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> FileSystemThing::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Directory { children, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> children
</span></span><span style=display:flex><span>                    .borrow()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>child<span style=color:#f92672>|</span> child.as_ref().size())
</span></span><span style=display:flex><span>                    .sum()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            File { size, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>*</span>size,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s not so bad. If it&rsquo;s a file, just return the size. If it&rsquo;s a directory, it doesn&rsquo;t have a size of it&rsquo;s own, so instead, borrow the children <code>RefCell</code>, <code>iter</code> through it, <code>map</code> each <code>child</code> to get the <code>size</code> (by calling this function, don&rsquo;t assume it&rsquo;s a file), and <code>sum</code>ing those. Clean, at least in my opinion.</p><p>Okay, so we can build the tree and calculate the size at any point&mldr; but how do we go through and &lsquo;iterate&rsquo; (as it were) over all of the nodes to find the ones that match our criteria?</p><p>Okay, this one was also kind of a pain. This time, so that I can store the state of the iterator, I made a second struct <code>FileSystemIterator</code> and had <code>FileSystemThing</code> build one of those:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileSystemThing {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return an iterator over all nodes in the tree
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>walk</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>FileSystemIterator</span> {
</span></span><span style=display:flex><span>        FileSystemIterator::new(Arc::new(self.clone()))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How I want to deal with this iterator is:</p><ul><li>Initialize a stack of <code>FileSystemThing</code> with the root node we&rsquo;re walking from</li><li>Whenever <code>next</code> is called:<ul><li>If the stack is empty: we&rsquo;re done, return <code>None</code> (stop iteration, I like doing it this way)</li><li>Otherwise, pop that thing off the stack and save it to return, but first:<ul><li>For each child node of that thing, add it to the stack in our <code>Iterator</code> state</li><li>Now, return the popped node</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Iterate recursively over file systems
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Keep a stack of the children we&#39;ve seen but not returned so far
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FileSystemIterator</span> {
</span></span><span style=display:flex><span>    stack: Vec<span style=color:#f92672>&lt;</span>Arc<span style=color:#f92672>&lt;</span>FileSystemThing<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> FileSystemIterator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(root: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>FileSystemThing<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        FileSystemIterator { stack: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[root] }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Iterator <span style=color:#66d9ef>for</span> FileSystemIterator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> Arc<span style=color:#f92672>&lt;</span>FileSystemThing<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> FileSystemThing::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.stack.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> None;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> self.stack.pop().unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Directory { children, <span style=color:#f92672>..</span> } <span style=color:#f92672>=</span> next.borrow() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> child <span style=color:#66d9ef>in</span> children.borrow().iter() {
</span></span><span style=display:flex><span>                self.stack.push(child.clone());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(next)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Getting the right combination of references in this took a bit too&mldr; eventually I fell back again on <code>Arc</code>. It&rsquo;s &mldr; actually the right tool for the job, no? Because I&rsquo;ll have at least two references kicking around at times, in children (and sometimes parents) and in the stack.</p><p>Neat.</p><p>Also note: because we&rsquo;re not reversing here, nodes at the same level will be returned in the opposite order they were seen on the input, you can add a <code>.rev()</code> at the end of the <code>children.borrow().iter()</code> line. But for these problems, it doesn&rsquo;t matter.</p><p>Okay. So, what was the problem even?</p><p>Right, iterate through the tree and sum up the recursive side (including overlaps) of all directories that have a size of no more than 100,000.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> root <span style=color:#f92672>=</span> FileSystemThing::from(iter_lines(filename));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> total_sizes <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> root.walk() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> node.borrow() {
</span></span><span style=display:flex><span>            FileSystemThing::Directory { <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> node.size();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> size <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>100000</span> {
</span></span><span style=display:flex><span>                    total_sizes <span style=color:#f92672>+=</span> size;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    total_sizes.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not so bad.</p><p>One thing probably worth mentioning is that I implemented (and used here) an <code>iter_lines</code> method. It&rsquo;s the same as <code>from_lines</code>, it just doesn&rsquo;t <code>collect</code>, making it lazy for free. It doesn&rsquo;t matter at all in this case, but would 1) save some memory by not loading an entire file into memory and 2) allow you to partially consume the input easily.</p><p>I may go back and change previous days over to this model.</p><h2 id=part-2>Part 2</h2><blockquote><p>Assume this virtual disk has total available space of <code>70,000,000</code>. You need <code>30,000,000</code> free. Find the smallest directory (recursively) you can delete that would leave you with <code>30,000,000</code> free and return it&rsquo;s size.</p></blockquote><p>I definitely made this more verbose than I needed to calculate this target. So it goes.</p><p>Essentially, I want to:</p><ul><li>Calculate what the <code>target_to_free</code> size is</li><li>Initialize how much is <code>freeable</code> to <code>usize::MAX</code> (since we want a minimum)</li><li>Walk the file system<ul><li>Skip files</li><li>For directories:<ul><li>If it&rsquo;s larger than <code>target_to_free</code> and smaller than <code>freeable</code>, update <code>freeable</code></li><li>Otherwise, skip it</li></ul></li></ul></li><li>Return the final <code>freeable</code> value</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> root <span style=color:#f92672>=</span> FileSystemThing::from(iter_lines(filename));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> total_disk <span style=color:#f92672>=</span> <span style=color:#ae81ff>70000000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> needed <span style=color:#f92672>=</span> <span style=color:#ae81ff>30000000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> used <span style=color:#f92672>=</span> root.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> available <span style=color:#f92672>=</span> total_disk <span style=color:#f92672>-</span> used;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> target_to_free <span style=color:#f92672>=</span> needed <span style=color:#f92672>-</span> available;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We need the smallest directory at least larger than target_to_free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> freeable <span style=color:#f92672>=</span> <span style=color:#66d9ef>usize</span>::<span style=color:#66d9ef>MAX</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> node <span style=color:#66d9ef>in</span> root.walk() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> node.borrow() {
</span></span><span style=display:flex><span>            FileSystemThing::Directory { <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> size <span style=color:#f92672>=</span> node.size();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> size <span style=color:#f92672>&gt;</span> target_to_free <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&lt;</span> freeable {
</span></span><span style=display:flex><span>                    freeable <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    freeable.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I do enjoy the programs where the final wrapper for part 2 is mostly done by properly engineering part 1. ðŸ˜„</p><h2 id=performance>Performance</h2><p>Fast:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>.<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span><span style=color:#ae81ff>07</span><span style=color:#f92672>-</span>recursive<span style=color:#f92672>-</span>fileinator <span style=color:#ae81ff>1</span> data<span style=color:#f92672>/</span><span style=color:#ae81ff>07.</span>txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1453349</span>
</span></span><span style=display:flex><span>took <span style=color:#ae81ff>403.291</span><span style=color:#960050;background-color:#1e0010>Âµ</span>s
</span></span><span style=display:flex><span>.<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span><span style=color:#ae81ff>07</span><span style=color:#f92672>-</span>recursive<span style=color:#f92672>-</span>fileinator <span style=color:#ae81ff>2</span> data<span style=color:#f92672>/</span><span style=color:#ae81ff>07.</span>txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2948823</span>
</span></span><span style=display:flex><span>took <span style=color:#ae81ff>421.666</span><span style=color:#960050;background-color:#1e0010>Âµ</span>s
</span></span></code></pre></div><p>Yeah&mldr; I don&rsquo;t really need to optimize that from a speed perspective.</p><p>Like I said though, If you happen to be reading this and know of a more idiomatic / cleaner way to write the <code>from</code> code, I&rsquo;d love to hear it.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>