<!doctype html><html><head><title>AoC 2022 Day 5: Stackinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2022 Day 5: Stackinator</h1><div class=entry-meta><span class=entry-date>2022-12-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/04/aoc-2022-day-4-overlapinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/04/aoc-2022-day-4-overlapinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/25/aoc-2021-day-25-cucumbinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/stacks>Stacks</a><a href=https://blog.jverkamp.com/2023/04/14/stacklang-part-i-the-idea/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/04/aoc-2022-day-4-overlapinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/04/aoc-2022-day-4-overlapinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/06/aoc-2022-day-6-ring-buffinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/04/aoc-2022-day-4-overlapinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/06/foundryside/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-supply-stackshttpsadventofcodecom2022day5>Source: <a href=https://adventofcode.com/2022/day/5 target=_blank rel=noopener>Supply Stacks</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>Given a list of stacks of <em>syntax 1</em> and instructions in the form <em>syntax 2</em>, apply each instruction to pop <code>qty</code> items from the stack <code>src</code> and put them on <code>dst</code> one at a time.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Syntax 1: Stacks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [D]    
</span></span><span style=display:flex><span>[N] [C]    
</span></span><span style=display:flex><span>[Z] [M] [P]
</span></span><span style=display:flex><span> 1   2   3 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Syntax 2: Instructions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>move 1 from 2 to 1
</span></span><span style=display:flex><span>move 3 from 1 to 3
</span></span><span style=display:flex><span>move 2 from 2 to 1
</span></span><span style=display:flex><span>move 1 from 1 to 2
</span></span></code></pre></div><p>Well that&rsquo;s an interesting format. I expect most of this problem is going to resolve around parsing rather than the actual mechanics of the problem itself. So let&rsquo;s start with structs for <code>Stack</code>, a <code>Warehouse</code> to hold all of the stacks, and <code>Instructions</code>. We could certainly just use <code>Vec&lt;Vec&lt;char>></code> as our <code>Stack</code>/<code>Warehouse</code>, but I like being able to attach functionality to the structs with <code>impl</code>. To each their own.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Warehouse</span> {
</span></span><span style=display:flex><span>    stacks: Vec<span style=color:#f92672>&lt;</span>Stack<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Instruction</span> {
</span></span><span style=display:flex><span>    qty: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    src: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    dst: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, parse a warehouse, assuming that we&rsquo;re only given the lines containing the boxes (as above).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Warehouse {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(lines: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Warehouse</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> lines {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>(line.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> center <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> line.chars().nth(center);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                    Some(c) <span style=color:#66d9ef>if</span> c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>while</span> data.len() <span style=color:#f92672>&lt;=</span> i {
</span></span><span style=display:flex><span>                            data.push( Vec::new() );
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        data[i].push(c);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ <span style=color:#f92672>=&gt;</span> {} <span style=color:#75715e>// No box in this stack, do nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stacks <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ls <span style=color:#66d9ef>in</span> data {
</span></span><span style=display:flex><span>            stacks.push(Stack { data: <span style=color:#a6e22e>ls</span>.into_iter().rev().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span>() });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Warehouse { stacks }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>To do this, I&rsquo;m going to actually build up that <code>Vec&lt;Vec&lt;char>></code> and convert it at the end. But that ends up being an implementation detail so far as anyone viewing this code would be considered. The <code>from</code> method would be <code>pub</code>, but the struct fields do not have to be.</p><p>A few interesting things to note:</p><ul><li>The <code>i in 0..=(line.len() / 3)</code> iterates across indexes within each string length, so you only loop to the rightmost <em>existing</em> char in each row</li><li>The <code>match</code> block deals with blocks that don&rsquo;t exist both by unwrapping the <code>nth</code> and checking <code>if c != ' '</code></li><li>The <code>mut stacks</code> loop at the bottom is because we read each stack top to bottom, but want them stored with the top value at the end (<code>Vec</code>s are <span class=latex-inline>O(1)</span>
from that end), so reverse them once here</li></ul><p>Now that we have all of that, we also want the ability to parse out a <code>Vec&lt;Instruction></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Instruction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>list_from</span>(lines: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Instruction<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> lines {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> parts <span style=color:#f92672>=</span> line.split_ascii_whitespace();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Note: nth consumes previous values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> qty <span style=color:#f92672>=</span> parts
</span></span><span style=display:flex><span>                .nth(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 2 is qty&#34;</span>)
</span></span><span style=display:flex><span>                .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 2 must be a uint&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> parts
</span></span><span style=display:flex><span>                .nth(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 4 is src&#34;</span>)
</span></span><span style=display:flex><span>                .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 4 must be a uint&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> dst <span style=color:#f92672>=</span> parts
</span></span><span style=display:flex><span>                .nth(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 6 is dst&#34;</span>)
</span></span><span style=display:flex><span>                .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;part 6 must be a uint&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            result.push(Instruction { qty, src, dst });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It took a bit to remember/notice that <code>nth</code> on an <code>Iter</code> consumes up to and through that value. So <code>.nth(1)</code> the first time skips <code>move</code> and consumes the number, the second time <code>from</code> and the number, and the third time <code>to</code> and the number. Pretty neat actually.</p><p>Now finally, a function to <code>apply</code> an <code>Instruction</code> to a <code>Warehouse</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Warehouse {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>apply</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, instruction: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Instruction</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>instruction.qty {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> self.stacks[instruction.src <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                .data
</span></span><span style=display:flex><span>                .pop()
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;tried to pop from empty stack&#34;</span>);
</span></span><span style=display:flex><span>            self.stacks[instruction.dst <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].data.push(value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a function to get the final result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>tops</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> stack <span style=color:#66d9ef>in</span> self.stacks.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> stack
</span></span><span style=display:flex><span>                .data
</span></span><span style=display:flex><span>                .last()
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;each stack should have at least one item&#34;</span>);
</span></span><span style=display:flex><span>            result.push(<span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Pretty clean. We do need one last bit of boilerplate to be able to split the input based on the two parts (separated by an empty line) though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; (Warehouse, Vec<span style=color:#f92672>&lt;</span>Instruction<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> lines <span style=color:#f92672>=</span> read_lines(filename);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> split_index <span style=color:#f92672>=</span> lines
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .position(<span style=color:#f92672>|</span>line<span style=color:#f92672>|</span> line.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        .expect(<span style=color:#e6db74>&#34;should have empty line&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> instruction_lines <span style=color:#f92672>=</span> lines.split_off(split_index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ignore the indexes and empty line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    lines.pop();
</span></span><span style=display:flex><span>    lines.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> warehouse <span style=color:#f92672>=</span> Warehouse::from(<span style=color:#f92672>&amp;</span>lines);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> instructions <span style=color:#f92672>=</span> Instruction::list_from(<span style=color:#f92672>&amp;</span>instruction_lines);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (warehouse, instructions)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Still looking for a better way to do that. I suppose I could use an <code>Iter&lt;String></code> instead, read off values until I see the empty line in the first parser and then read from the same <code>Iter</code> in the second? Perhaps I&rsquo;ll try that for another day.</p><p>In any case, all this means that the actual answer is very short (as it should be):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (<span style=color:#66d9ef>mut</span> warehouse, instructions) <span style=color:#f92672>=</span> parse(filename);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> instruction <span style=color:#66d9ef>in</span> instructions {
</span></span><span style=display:flex><span>        warehouse.apply(<span style=color:#f92672>&amp;</span>instruction);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    warehouse.tops()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Cool!</p><h2 id=part-2>Part 2</h2><blockquote><p>Do the same, except instead of moving <code>qty</code> items one at a time, pick up the entire <code>qty</code> items and move them all at once (thus preserving the original order).</p></blockquote><p>Just need a new apply function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Warehouse {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>apply_9001</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, instruction: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Instruction</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> values <span style=color:#f92672>=</span> LinkedList::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>instruction.qty {
</span></span><span style=display:flex><span>            values.push_back(
</span></span><span style=display:flex><span>                self.stacks[instruction.src <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                    .data
</span></span><span style=display:flex><span>                    .pop()
</span></span><span style=display:flex><span>                    .expect(<span style=color:#e6db74>&#34;tried to pop from empty stack&#34;</span>),
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>instruction.qty {
</span></span><span style=display:flex><span>            self.stacks[instruction.dst <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                .data
</span></span><span style=display:flex><span>                .push(values.pop_back().expect(<span style=color:#e6db74>&#34;must pop as many as we pushed&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (<span style=color:#66d9ef>mut</span> warehouse, instructions) <span style=color:#f92672>=</span> parse(filename);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> instruction <span style=color:#66d9ef>in</span> instructions {
</span></span><span style=display:flex><span>        warehouse.apply_9001(<span style=color:#f92672>&amp;</span>instruction);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    warehouse.tops()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And for this, we actually do want a <code>LinkedList</code>, since that allows <span class=latex-inline>O(1)</span>
push and pop from both ends, so we can have <a href=https://en.wikipedia.org/wiki/FIFO>FIFO</a> instead of <a href=https://en.wikipedia.org/wiki/FILO>FILO</a>.</p><h2 id=performance>Performance</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/05-stackinator <span style=color:#ae81ff>1</span> data/05.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TLFGBZHCN
</span></span><span style=display:flex><span>took 260.208µs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/05-stackinator <span style=color:#ae81ff>2</span> data/05.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>QRQFHFWCL
</span></span><span style=display:flex><span>took 367.333µs
</span></span></code></pre></div><p>Reading is <span class=latex-inline>O(n)</span>
in the number of stacks (since it has to read them all in and then flip them all, but that&rsquo;s still not a higher order of magnitude) and running is likewise <span class=latex-inline>O(n)</span>
in the number of instructions, it doesn&rsquo;t matter how big the actual data is. So it should (as expected) be lightning fast, no matter really how big the problem us (up until you get big enough to start worrying more about memory consumption and caching).</p><p>Pretty neat!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>