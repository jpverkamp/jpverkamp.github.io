<!doctype html><html><head><title>AoC 2022 Day 15: Beaconator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2022 Day 15: Beaconator</h1><div class=entry-meta><span class=entry-date>2022-12-15</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/14/aoc-2022-day-14-sandinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-beacon-exclusion-zone>Source: <a href=https://adventofcode.com/2022/day/15 target=_blank rel=noopener>Beacon Exclusion Zone</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>There are a collections of <code>Sensor</code>s and <code>Beacon</code>s. As input, you are given the <code>Beacon</code> closest to each <code>Sensor</code> (using <a href=https://en.wikipedia.org/wiki/Manhattan%20Distance>Manhattan Distance</a>). If a <code>Beacon</code> is not closest to any sensor, it will not appear in this list. Calculate how many points in the given row (<code>y=2000000</code>) cannot contain a <code>Beacon</code>.</p></blockquote><p>Once again with ranges. :D We&rsquo;ll come back to that.</p><p>To start with, we want to parse the input:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    sensors: Vec<span style=color:#f92672>&lt;</span>(Point, Point)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Map
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(iter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> I) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> re <span style=color:#f92672>=</span> Regex::new(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;Sensor at x=(-?\d+), y=(-?\d+): closest beacon is at x=(-?\d+), y=(-?\d+)&#34;</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .expect(<span style=color:#e6db74>&#34;regex creation failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sensors <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> iter {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> cap <span style=color:#f92672>=</span> re.captures(<span style=color:#f92672>&amp;</span>line).expect(<span style=color:#e6db74>&#34;regex doesn&#39;t match line&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            sensors.push((
</span></span><span style=display:flex><span>                Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>cap</span>[<span style=color:#ae81ff>1</span>].parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;sensor x must be number&#34;</span>),
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>cap</span>[<span style=color:#ae81ff>2</span>].parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;sensor y must be number&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>cap</span>[<span style=color:#ae81ff>3</span>].parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;beacon x must be number&#34;</span>),
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>cap</span>[<span style=color:#ae81ff>4</span>].parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;beacon y must be number&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            ))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map { sensors }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s easy enough. First time using <a href=https://docs.rs/regex/latest/regex/ target=_blank rel=noopener><code>regex</code></a>, and it works pretty much exactly as I&rsquo;d expect.</p><p>Next, what does it actually mean for a point to not be in the <code>Range</code> of any <code>Sensor</code>?</p><p>Well, I&rsquo;m going to borrow the diagram from the prompt:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>               1    1    2    2
</span></span><span style=display:flex><span>     0    5    0    5    0    5
</span></span><span style=display:flex><span>-2 ..........#.................
</span></span><span style=display:flex><span>-1 .........###................
</span></span><span style=display:flex><span> 0 ....S...#####...............
</span></span><span style=display:flex><span> 1 .......#######........S.....
</span></span><span style=display:flex><span> 2 ......#########S............
</span></span><span style=display:flex><span> 3 .....###########SB..........
</span></span><span style=display:flex><span> 4 ....#############...........
</span></span><span style=display:flex><span> 5 ...###############..........
</span></span><span style=display:flex><span> 6 ..#################.........
</span></span><span style=display:flex><span> 7 .#########S#######S#........
</span></span><span style=display:flex><span> 8 ..#################.........
</span></span><span style=display:flex><span> 9 ...###############..........
</span></span><span style=display:flex><span>10 ....B############...........
</span></span><span style=display:flex><span>11 ..S..###########............
</span></span><span style=display:flex><span>12 ......#########.............
</span></span><span style=display:flex><span>13 .......#######..............
</span></span><span style=display:flex><span>14 ........#####.S.......S.....
</span></span><span style=display:flex><span>15 B........###................
</span></span><span style=display:flex><span>16 ..........#SB...............
</span></span><span style=display:flex><span>17 ................S..........B
</span></span><span style=display:flex><span>18 ....S.......................
</span></span><span style=display:flex><span>19 ............................
</span></span><span style=display:flex><span>20 ............S......S........
</span></span><span style=display:flex><span>21 ............................
</span></span><span style=display:flex><span>22 .......................B....
</span></span></code></pre></div><p>We&rsquo;re specifically looking at the <code>S</code> (<code>Sensor</code>) in the middle which is related to the <code>B</code> (<code>Beacon</code>) long the lower left edge of the <code>#</code>. Because there is no closer <code>B</code> to <code>S</code> than that, we know that all the spaces in the diagram with <code>#</code> <em>cannot</em> be a <code>Beacon</code>. Now, take a slice of that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>               1    1    2    2
</span></span><span style=display:flex><span>     0    5    0    5    0    5
</span></span><span style=display:flex><span> 8 ..#################.........
</span></span></code></pre></div><p>That slice is all points that are within the <code>manhattan_distance(S, B)</code>. Another way to look at it though is if you go down 1 from <code>S</code> to get to this row, all of the points are within <code>manhattan_distance(S, B) - 1</code> of the <code>S</code>&rsquo;s X coordinate. Likewise:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>               1    1    2    2
</span></span><span style=display:flex><span>     0    5    0    5    0    5
</span></span><span style=display:flex><span>13 .......#######..............
</span></span></code></pre></div><p>We had to go down <code>6</code>, so all points are within <code>manhattan_distance(S, B) - 6</code>.</p><p>To turn that into code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>ranges_for</span>(<span style=color:#f92672>&amp;</span>self, target_row: <span style=color:#66d9ef>isize</span>) -&gt; <span style=color:#a6e22e>Ranges</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ranges <span style=color:#f92672>=</span> Ranges::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (sensor, beacon) <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>self.sensors {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Distance = Distance to beacon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Offset = How much of that is included in offset distance to target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Remaining = How much is in the side to side range
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> distance <span style=color:#f92672>=</span> sensor.manhattan_distance(<span style=color:#f92672>&amp;</span>beacon);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> offset <span style=color:#f92672>=</span> (sensor.y <span style=color:#f92672>-</span> target_row).abs();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> remaining <span style=color:#f92672>=</span> distance <span style=color:#f92672>-</span> offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we don&#39;t have any side to side, the beacon is too far from the target row
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> remaining <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Calculate the range of values in the target row a beacon could not be in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> min_x <span style=color:#f92672>=</span> sensor.x <span style=color:#f92672>-</span> remaining;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_x <span style=color:#f92672>=</span> sensor.x <span style=color:#f92672>+</span> remaining;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Special case if the beacon is in the target row
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> beacon.y <span style=color:#f92672>==</span> target_row <span style=color:#f92672>&amp;&amp;</span> beacon.x <span style=color:#f92672>==</span> min_x {
</span></span><span style=display:flex><span>                min_x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> beacon.y <span style=color:#f92672>==</span> target_row <span style=color:#f92672>&amp;&amp;</span> beacon.x <span style=color:#f92672>==</span> max_x {
</span></span><span style=display:flex><span>                max_x <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ranges.<span style=color:#66d9ef>union</span>(Range::new(min_x, max_x));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ranges
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We calculate the <code>distance</code>, <code>offset</code>, and <code>remaining</code> as above. The one caveat is that if a <code>Beacon</code> is exactly on an edge (and it will be somewhere, just not necessarily in the <code>target_row</code> we&rsquo;re looking at), then make sure not to include that.</p><p>All that&rsquo;s left is &mldr; what is <code>Range</code>? What is a <code>Ranges</code>? And how can you <code>union</code> them?</p><p>Well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Range</span> {
</span></span><span style=display:flex><span>    min: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    max: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Range {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(min: <span style=color:#66d9ef>isize</span>, max: <span style=color:#66d9ef>isize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Range { min, max }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>union</span>(self, other: <span style=color:#a6e22e>Range</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Range<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// One range completely includes the other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> other.min <span style=color:#f92672>&gt;=</span> self.min <span style=color:#f92672>&amp;&amp;</span> other.max <span style=color:#f92672>&lt;=</span> self.max {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(self);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.min <span style=color:#f92672>&gt;=</span> other.min <span style=color:#f92672>&amp;&amp;</span> self.max <span style=color:#f92672>&lt;=</span> other.max {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(other);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// One range is partially inside the other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> other.min <span style=color:#f92672>&gt;=</span> self.min <span style=color:#f92672>&amp;&amp;</span> other.max <span style=color:#f92672>&lt;=</span> self.max {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(Range {
</span></span><span style=display:flex><span>                min: <span style=color:#a6e22e>self</span>.min,
</span></span><span style=display:flex><span>                max: <span style=color:#a6e22e>other</span>.max,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> other.max <span style=color:#f92672>&gt;=</span> self.min <span style=color:#f92672>&amp;&amp;</span> other.max <span style=color:#f92672>&lt;=</span> self.max {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Some(Range {
</span></span><span style=display:flex><span>                min: <span style=color:#a6e22e>other</span>.min,
</span></span><span style=display:flex><span>                max: <span style=color:#a6e22e>self</span>.max,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// No overlap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> (self.max <span style=color:#f92672>-</span> self.min) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <code>Range</code> is a minimum and maximum (inclusive). The <code>union</code> of two ranges checks if they are nested or overlapping at all and returns a combined range if so, otherwise returns <code>None</code>.</p><p>This lets us make a combined <code>Ranges</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ranges</span> {
</span></span><span style=display:flex><span>    data: Vec<span style=color:#f92672>&lt;</span>Range<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ranges {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Ranges { data: Vec::new() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>union</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, r: <span style=color:#a6e22e>Range</span>) {
</span></span><span style=display:flex><span>        self.data.push(r);
</span></span><span style=display:flex><span>        self.collapse();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That will <code>push</code> the new <code>Range</code> into the list, but it might overlap any one of the elements. So perhaps the most interesting bit of the algorithm (to me at least), is the one where we want to <code>collapse</code> a given <code>Ranges</code> into as minimum number of <code>Range</code> as we can.</p><p>To do that, try every pair. Any that overlap, <code>union</code> them. As long as that keeps working, keep doing it. When we can&rsquo;t, we&rsquo;re done.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ranges {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>collapse</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> to_merge <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>&#39;find_merge</span>: <span style=color:#a6e22e>for</span> (i, a) <span style=color:#66d9ef>in</span> self.data.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (j, b) <span style=color:#66d9ef>in</span> self.data.iter().enumerate() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> j {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(c) <span style=color:#f92672>=</span> a.<span style=color:#66d9ef>union</span>(<span style=color:#f92672>*</span>b) {
</span></span><span style=display:flex><span>                        to_merge <span style=color:#f92672>=</span> Some((i, j, c));
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;find_merge;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((i, j, c)) <span style=color:#f92672>=</span> to_merge {
</span></span><span style=display:flex><span>                self.data.remove(i.max(j));
</span></span><span style=display:flex><span>                self.data.remove(i.min(j));
</span></span><span style=display:flex><span>                self.data.push(c);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        self.data.iter().map(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> r.len()).sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So we have the code necessary to build and <code>union</code> <code>Ranges</code>, let&rsquo;s use them!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> map <span style=color:#f92672>=</span> Map::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> target_row <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> filename
</span></span><span style=display:flex><span>        .file_name()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .to_str()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .contains(<span style=color:#e6db74>&#34;test&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2000000</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    map.ranges_for(target_row).len().to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it. We do have a special case, since the test data and &lsquo;real&rsquo; data care about different ranges. But other than that, we&rsquo;re really just building up the <code>Map</code>, getting the <code>ranges_for(target_row)</code> and finding out the <code>len()</code> (how many elements).</p><p>Nice.</p><h2 id=part-2>Part 2</h2><blockquote><p>For <code>0 &lt;= x &lt;= 4000000</code> and <code>0 &lt;= y &lt;= 4000000</code>, there is exactly one point that could be an additional beacon. Find that point and calculate <code>x * 4000000 + y</code>.</p></blockquote><p>Interesting. For this one, we don&rsquo;t actually want the unbounded ranges, we want to specifically limit them to the above. To do that, we don&rsquo;t want <code>union</code>, but rather <code>intersection</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Ranges {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Ranges { data: Vec::new() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>union</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, r: <span style=color:#a6e22e>Range</span>) {
</span></span><span style=display:flex><span>        self.data.push(r);
</span></span><span style=display:flex><span>        self.collapse();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>intersection</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, r: <span style=color:#a6e22e>Range</span>) {
</span></span><span style=display:flex><span>        self.data <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .data
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// One range completely includes the other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> r.min <span style=color:#f92672>&gt;=</span> c.min <span style=color:#f92672>&amp;&amp;</span> r.max <span style=color:#f92672>&lt;=</span> c.max {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(r);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> c.min <span style=color:#f92672>&gt;=</span> r.min <span style=color:#f92672>&amp;&amp;</span> c.max <span style=color:#f92672>&lt;=</span> r.max {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(<span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// One range is partially inside the other
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> r.min <span style=color:#f92672>&gt;=</span> c.min <span style=color:#f92672>&amp;&amp;</span> r.min <span style=color:#f92672>&lt;=</span> c.max {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(Range {
</span></span><span style=display:flex><span>                        min: <span style=color:#a6e22e>r</span>.min,
</span></span><span style=display:flex><span>                        max: <span style=color:#a6e22e>c</span>.max,
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> r.max <span style=color:#f92672>&gt;=</span> c.min <span style=color:#f92672>&amp;&amp;</span> r.max <span style=color:#f92672>&lt;=</span> c.max {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Some(Range {
</span></span><span style=display:flex><span>                        min: <span style=color:#a6e22e>c</span>.min,
</span></span><span style=display:flex><span>                        max: <span style=color:#a6e22e>r</span>.max,
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// No overlap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                None
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, we&rsquo;ll go through every point in the current <code>data</code> and apply the <code>intersection</code> to it. It will either shrink (if there&rsquo;s some overlap) or disappear entirely (if there&rsquo;s none). <code>filter_map</code> does that for us and removes the ones that are gone entirely. It&rsquo;s nice having all these functional functions.</p><p>With that in place, we can do part 2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> map <span style=color:#f92672>=</span> Map::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bound <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> filename
</span></span><span style=display:flex><span>        .file_name()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .to_str()
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>        .contains(<span style=color:#e6db74>&#34;test&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>4000000</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>bound {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ranges <span style=color:#f92672>=</span> map.ranges_for(y);
</span></span><span style=display:flex><span>        ranges.intersection(Range::new(<span style=color:#ae81ff>0</span>, bound));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we don&#39;t have a full range, we have a candidate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Candidates have exactly two Range, 0 to x-1 and x+1 to bound
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> ranges.data.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> ranges
</span></span><span style=display:flex><span>                .data
</span></span><span style=display:flex><span>                .into_iter()
</span></span><span style=display:flex><span>                .find(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> r.min <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                .expect(<span style=color:#e6db74>&#34;must have non-zero x&#34;</span>)
</span></span><span style=display:flex><span>                .min
</span></span><span style=display:flex><span>                <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check if the candidate is exactly equal to a beacon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> new_p <span style=color:#f92672>=</span> Point { x, y };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> map.sensors.iter().any(<span style=color:#f92672>|</span>(_, b)<span style=color:#f92672>|</span> new_p <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>b) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If not, we found the solution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            p <span style=color:#f92672>=</span> Some(new_p);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> p {
</span></span><span style=display:flex><span>        Some(Point { x, y }) <span style=color:#f92672>=&gt;</span> (x <span style=color:#f92672>*</span> <span style=color:#ae81ff>4000000</span> <span style=color:#f92672>+</span> y).to_string(),
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;no answer found&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I did have a gotcha, dealing with the <code>Beacon</code>s that were on the border again, thus the <code>map.sensors.iter().any</code>. It&rsquo;s not perfect, but I think it&rsquo;s clear enough. And it works!</p><h2 id=performance>Performance</h2><p>Still quick!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> .<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span><span style=color:#ae81ff>15</span><span style=color:#f92672>-</span>beaconator <span style=color:#ae81ff>1</span> data<span style=color:#f92672>/</span><span style=color:#ae81ff>15.</span>txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4724228</span>
</span></span><span style=display:flex><span>took <span style=color:#ae81ff>2.454416</span>ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>$</span> .<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span><span style=color:#ae81ff>15</span><span style=color:#f92672>-</span>beaconator <span style=color:#ae81ff>2</span> data<span style=color:#f92672>/</span><span style=color:#ae81ff>15.</span>txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>13622251246513</span>
</span></span><span style=display:flex><span>took <span style=color:#ae81ff>666.55525</span>ms
</span></span></code></pre></div><p>We do keep getting closer to a second, but still <em>well</em> under it. So&mldr; onward!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>