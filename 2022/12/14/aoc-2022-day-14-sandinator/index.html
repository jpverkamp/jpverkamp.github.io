<!doctype html><html><head><title>AoC 2022 Day 14: Sandinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet><link rel=stylesheet href=/custom.css defer><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2022 Day 14: Sandinator</h1><div class=entry-meta><span class=entry-date>2022-12-14</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/13/aoc-2022-day-13-list-parsinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/15/aoc-2022-day-15-beaconator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-regolith-reservoirhttpsadventofcodecom2022day14>Source: <a href=https://adventofcode.com/2022/day/14>Regolith Reservoir</a></h3><h4 id=part-1-given-a-series-of-walls-as-input-run-a-hahahugoshortcode-s0-hbhb-simulation-until-any-new-sand-falls-of-the-map-count-how-many-grains-of-sand-we-end-up-with><strong>Part 1:</strong> Given a series of walls as input, run a <a href=https://en.wikipedia.org/wiki/falling%20sand>falling sand</a> simulation until any new sand falls of the map. Count how many grains of sand we end up with.</h4><p>Oh, how I love falling sand.</p><p>First, the struct we&rsquo;re going to use to represent our current simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sandbox</span> {
</span></span><span style=display:flex><span>    active_sand: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    settled_sand: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    walls: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    min_x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    max_x: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    min_y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>    max_y: <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>(min|max)-(x|y)</code> are entirely for display purposes. Otherwise, <code>walls</code> are static pieces that stop the sand, <code>active_sand</code> is still falling, and <code>settled_sand</code> is not.</p><p>The original problem states:</p><blockquote><p>Sand is produced one unit at a time, and the next unit of sand is not produced until the previous unit of sand comes to rest. A unit of sand is large enough to fill one tile of air in your scan.</p></blockquote><p>But I had a feeling that wasn&rsquo;t going to be strictly necessary. So I made it possible for more than one grain to fall at a time. We&rsquo;ll come back to that.</p><p>Before that, parsing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I<span style=color:#f92672>&gt;</span> From<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> I<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Sandbox
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(iter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> I) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> walls <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> min_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::MAX;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::MIN;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> min_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::MAX;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::MIN;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> iter {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> p <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> first <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> part <span style=color:#66d9ef>in</span> line.split(<span style=color:#e6db74>&#34; -&gt; &#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> xy <span style=color:#f92672>=</span> part.split(<span style=color:#e6db74>&#34;,&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> new_p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                    x: <span style=color:#a6e22e>xy</span>
</span></span><span style=display:flex><span>                        .next()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;must have x&#34;</span>)
</span></span><span style=display:flex><span>                        .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;x must be numeric&#34;</span>),
</span></span><span style=display:flex><span>                    y: <span style=color:#a6e22e>xy</span>
</span></span><span style=display:flex><span>                        .next()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;must have x&#34;</span>)
</span></span><span style=display:flex><span>                        .parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>isize</span><span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;y must be numeric&#34;</span>),
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>first {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> delta <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                        x: (new_p.x <span style=color:#f92672>-</span> p.x).signum(),
</span></span><span style=display:flex><span>                        y: (new_p.y <span style=color:#f92672>-</span> p.y).signum(),
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Rather than while p != new_p, do this to get both edge cases
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> done <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>                        walls.insert(p);
</span></span><span style=display:flex><span>                        min_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::min(min_x, p.x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        max_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::max(max_x, p.x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        min_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::min(min_y, p.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        max_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::max(max_y, p.y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> done {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> delta;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> p <span style=color:#f92672>==</span> new_p {
</span></span><span style=display:flex><span>                            done <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> new_p;
</span></span><span style=display:flex><span>                first <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Sandbox {
</span></span><span style=display:flex><span>            active_sand: <span style=color:#a6e22e>HashSet</span>::new(),
</span></span><span style=display:flex><span>            settled_sand: <span style=color:#a6e22e>HashSet</span>::new(),
</span></span><span style=display:flex><span>            walls,
</span></span><span style=display:flex><span>            min_x,
</span></span><span style=display:flex><span>            max_x,
</span></span><span style=display:flex><span>            min_y,
</span></span><span style=display:flex><span>            max_y,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s a bit long, but the input is a little weird. Each input line is a sequence of straight lines and we have to iterate between them. But we only do this once, so it can be a bit heavy.</p><p>Next up, we actually implement the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Sandbox {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>occupied</span>(<span style=color:#f92672>&amp;</span>self, p: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        self.walls.contains(<span style=color:#f92672>&amp;</span>p) <span style=color:#f92672>||</span> self.settled_sand.contains(<span style=color:#f92672>&amp;</span>p) <span style=color:#f92672>||</span> self.active_sand.contains(<span style=color:#f92672>&amp;</span>p)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.occupied(p) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.min_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::min(self.min_x, p.x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        self.max_x <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::max(self.max_x, p.x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        self.min_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::min(self.min_y, p.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        self.max_y <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>::max(self.max_y, p.y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.active_sand.insert(p);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> next_active_sand <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> self.active_sand.iter() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we&#39;re past the lowest value, drop this point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> p.y <span style=color:#f92672>&gt;</span> self.max_y {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Otherwise, try to fall (first left than right)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> nexts <span style=color:#f92672>=</span> vec![
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::DOWN,
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::DOWN <span style=color:#f92672>+</span> Point::LEFT,
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> Point::DOWN <span style=color:#f92672>+</span> Point::RIGHT,
</span></span><span style=display:flex><span>            ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> moved <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> next <span style=color:#66d9ef>in</span> nexts.into_iter() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.occupied(next) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>next_active_sand.contains(<span style=color:#f92672>&amp;</span>next) {
</span></span><span style=display:flex><span>                    next_active_sand.insert(next);
</span></span><span style=display:flex><span>                    moved <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we can&#39;t fall, settle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>moved {
</span></span><span style=display:flex><span>                self.settled_sand.insert(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.active_sand <span style=color:#f92672>=</span> next_active_sand;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This doesn&rsquo;t actually care at all if there is one grain of sand or a million. The main idea is that we have a double buffer for <code>active_sand</code>. We&rsquo;re going to iterate over all the sand, but each point can collide with:</p><ul><li><code>walls</code></li><li><code>settled_sand</code></li><li><code>active_sand</code> - this is the sand that was there at the beginning of the frame</li><li><code>next_active_sand</code> - this is sand that has already moved this frame, to avoid two moving to the same spot</li></ul><p>Once we&rsquo;ve iterated over everything, we can swap <code>active_sand</code> and continue on the next frame.</p><p>Finally, <code>part1</code> to actually control the simulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sandbox <span style=color:#f92672>=</span> Sandbox::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> drop <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>500</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _frame <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> sandbox.active_sand.is_empty() {
</span></span><span style=display:flex><span>            sandbox.drop(drop);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> done <span style=color:#f92672>=</span> sandbox.step();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> done {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sandbox.settled_sand.len().to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not much there. And I can even make a pretty simulation:</p><p><video controls src=/embeds/2022/aoc14-old-1.mp4></video></p><p>I&rsquo;ll come back to how I actually made that.</p><p>But this does make me think&mldr; why in the world are we actually doing a single grain of sand at a time? They only interact if they&rsquo;re right behind each other, so why don&rsquo;t we:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sandbox <span style=color:#f92672>=</span> Sandbox::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> drop <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>500</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> frame <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> frame <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            sandbox.drop(drop);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> done <span style=color:#f92672>=</span> sandbox.step();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> done {
</span></span><span style=display:flex><span>            sandbox.active_sand.clear();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sandbox.settled_sand.len().to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><video controls src=/embeds/2022/aoc14-1.mp4></video></p><p>It turns out&mldr; exactly the same.</p><p>Once a single grain has fallen out of the simulation, we know all the rest of the <code>active_sand</code> will as well, so clear it and return. And we get the same thing, only much much faster.</p><p>Well, check <code>performance</code> for how much faster. It turns out Rust is <em>really</em> fast, so it&rsquo;s not actually that much better. But it really did help with rendering that movie up there. Since we have significantly fewer frames, it&rsquo;s much easier to deal with.</p><h4 id=part-2-add-an-infinite-floor-two-pixels-below-the-previous-lower-bound-count-the-settled-sand-again><strong>Part 2:</strong> Add an infinite floor two pixels below the previous lower bound. Count the settled sand again.</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sandbox <span style=color:#f92672>=</span> Sandbox::from(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> iter_lines(filename));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> drop <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>500</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We want a line from -infinity,max_y+1 to +infinity,max_y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We don&#39;t actually need that though, just out at a 45 angle from min_x,min_y and max_x,min_y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Add some buffer for the extra offsets we&#39;re dealing with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> sandbox.max_y <span style=color:#f92672>-</span> sandbox.min_y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> left_x <span style=color:#f92672>=</span> sandbox.min_x <span style=color:#f92672>-</span> height <span style=color:#f92672>-</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> right_x <span style=color:#f92672>=</span> sandbox.max_x <span style=color:#f92672>+</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> left_x<span style=color:#f92672>..=</span>right_x {
</span></span><span style=display:flex><span>        sandbox.walls.insert(Point {
</span></span><span style=display:flex><span>            x,
</span></span><span style=display:flex><span>            y: <span style=color:#a6e22e>sandbox</span>.max_y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    sandbox.min_x <span style=color:#f92672>=</span> left_x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    sandbox.max_x <span style=color:#f92672>=</span> right_x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    sandbox.max_y <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> frame <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> frame <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            sandbox.drop(drop);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> done <span style=color:#f92672>=</span> sandbox.step();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> done <span style=color:#f92672>||</span> sandbox.occupied(drop) {
</span></span><span style=display:flex><span>            sandbox.active_sand.clear();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sandbox.settled_sand.len().to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As noted, we don&rsquo;t actually need to make the infinite line. Because sand stacks at 45 degrees, we only need to go out from our current min and max by the total height (at worst case). So to handle all that, we add the new wall and update the bounds. Voila.</p><p>Here is where the optimization really comes in handy. It turns out that it takes roughly 1.5 million steps to solve one grain at a time. If you&rsquo;re rendering each of those to a single file&mldr; that&rsquo;s not going to go well. Well, it <em>didn&rsquo;t</em> go well. But if you do every other frame, it only takes ~50k frames. So much more feasible.</p><p><video controls width=100% src=/embeds/2022/aoc14-2.mp4></video></p><p>I <em>tried</em> to render the full thing to a video&mldr; but turning 1.5M pngs into a video&mldr; didn&rsquo;t go well. So only one for you this time. And it&rsquo;s still pretty slow once it gets to the final fill.</p><h4 id=performance>Performance</h4><p>Here are the numbers for both one at a time and every other frame.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Drop one sand at a time</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/14-sandinator <span style=color:#ae81ff>1</span> data/14.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>698</span>
</span></span><span style=display:flex><span>took 27.268ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/14-sandinator <span style=color:#ae81ff>2</span> data/14.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>28594</span>
</span></span><span style=display:flex><span>took 904.257791ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Drop one sand every other frame</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/14-sandinator <span style=color:#ae81ff>1</span> data/14.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>698</span>
</span></span><span style=display:flex><span>took 28.331666ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/14-sandinator <span style=color:#ae81ff>2</span> data/14.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>28594</span>
</span></span><span style=display:flex><span>took 633.109583ms
</span></span></code></pre></div><p>There&rsquo;s actually not much speed up in the small case, Rust is fast. But we do cut 1/3 of the runtime off in the longer case, since that&rsquo;s just a lot of sand. Still under a second though!</p><h4 id=pretty-moving-pictures>Pretty (moving) pictures</h4><p>Okay, let&rsquo;s actually talk about generating the images. In a nutshell, I pulled in the <a href=https://docs.rs/image/latest/image/><code>image</code></a> crate. That lets us render a pixel <code>from_fn</code>, something I&rsquo;ve done an awful lot in Racket:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Sandbox {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>render</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>RgbImage</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> (self.max_x <span style=color:#f92672>-</span> self.min_x) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> (self.max_y <span style=color:#f92672>-</span> self.min_y) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ImageBuffer::from_fn(width, height, <span style=color:#f92672>|</span>x, y<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>                x: (x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>) <span style=color:#f92672>+</span> self.min_x,
</span></span><span style=display:flex><span>                y: (y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>) <span style=color:#f92672>+</span> self.min_y,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self.walls.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                image::Rgb([<span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>127</span>])
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> self.settled_sand.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                image::Rgb([<span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>178</span>, <span style=color:#ae81ff>128</span>])
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> self.active_sand.contains(<span style=color:#f92672>&amp;</span>p) {
</span></span><span style=display:flex><span>                image::Rgb([<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>])
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                image::Rgb([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That really is it. To actually combine it into a video, I directly Shelled out to <code>ffmpeg</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>make_gif</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> std::process::Command;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> commands <span style=color:#f92672>=</span> vec![
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ffmpeg -y -framerate 240 -i %08d.png -vf scale=iw*4:ih*4:flags=neighbor -c:v libx264 -r 30 sandbox.mp4&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;find . -name &#39;*.png&#39; | xargs rm&#34;</span>
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> cmd <span style=color:#66d9ef>in</span> commands.into_iter() {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;$ {}&#34;</span>, cmd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> child <span style=color:#f92672>=</span> Command::new(<span style=color:#e6db74>&#34;bash&#34;</span>)
</span></span><span style=display:flex><span>            .arg(<span style=color:#e6db74>&#34;-c&#34;</span>)
</span></span><span style=display:flex><span>            .arg(cmd)
</span></span><span style=display:flex><span>            .spawn()
</span></span><span style=display:flex><span>            .expect(<span style=color:#e6db74>&#34;command failed&#34;</span>);
</span></span><span style=display:flex><span>        child.wait().expect(<span style=color:#e6db74>&#34;process didn&#39;t finish&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, using <code>bash -c</code> this way is a prime candidate for Shell injection, but&mldr; it&rsquo;s not like I&rsquo;m dealing with any non-constant params in this case, so it&rsquo;s really a pretty minimal risk. And much easier to write.</p><p>And that&rsquo;s it. Pretty (moving) pictures.</p><h4 id=a-lesson-in-filesystem-limitations>A lesson in filesystem limitations</h4><p>It turns out filesystems <em>really</em> don&rsquo;t like having 1.5M files in them. Finder freaked out, VS Code crashed, and I couldn&rsquo;t even <code>ls</code> or run <code>find</code> on the directory to delete the files.</p><p>What finally did end up working was installing <a href=https://github.com/sharkdp/fd><code>fd</code></a> (more Rust!) and using that to delete the files in batches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ <span style=color:#66d9ef>for</span> i in <span style=color:#66d9ef>$(</span>seq <span style=color:#ae81ff>1</span> 100<span style=color:#66d9ef>)</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    echo $i;
</span></span><span style=display:flex><span>    fd -g <span style=color:#e6db74>&#39;*.png&#39;</span> | head -n <span style=color:#ae81ff>10000</span> | xargs rm;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>That took a little while, but it didn&rsquo;t actually hang and I got my machine back. I&rsquo;ve done this before&mldr; but it&rsquo;s been a while.</p><h4 id=a-lesson-in-web-compatibility>A lesson in web compatibility</h4><p>So&mldr; the original videos (above) didn&rsquo;t render well at all. I had to run them through a bit more <code>ffmpeg</code> magic to get them to play in a browser:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ <span style=color:#66d9ef>for</span> f in *.mp4; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    echo $f;
</span></span><span style=display:flex><span>    bak $f;
</span></span><span style=display:flex><span>    ffmpeg -y 
</span></span><span style=display:flex><span>        -i $f.bak 
</span></span><span style=display:flex><span>        -c:v libx264 
</span></span><span style=display:flex><span>        -preset slow 
</span></span><span style=display:flex><span>        -crf <span style=color:#ae81ff>20</span> 
</span></span><span style=display:flex><span>        -vf format<span style=color:#f92672>=</span>yuv420p 
</span></span><span style=display:flex><span>        -movflags +faststart 
</span></span><span style=display:flex><span>        $f;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>Finally.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer src=/custom.js></script></body></html>