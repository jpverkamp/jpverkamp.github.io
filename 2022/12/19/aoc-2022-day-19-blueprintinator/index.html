<!doctype html><html><head><title>AoC 2022 Day 19: Blueprintinator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js defer></script>
<script src=/main.min.0385197289ca7627c4248fd97d030dabf0af1f0f9c467f85f05a5fb932a64882.js defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css><link rel=stylesheet href=/main.min.3af7142094623e482a03a6df125cd8566c32ad97300dc0ba3a9f2157f8d1ac8f.css></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2022 Day 19: Blueprintinator</h1><div class=entry-meta><span class=entry-date>2022-12-19</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/20/aoc-2022-day-20-deencryptinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/20/aoc-2022-day-20-deencryptinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2022/12/21/aoc-2022-day-21-yellinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2022/12/23/aoc-2022-day-23-elf-scattinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/17/aoc-2022-day-17-tetrisinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/20/aoc-2022-day-20-deencryptinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/20/aoc-2022-day-20-deencryptinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/20/the-wicked--the-divine-vol.-2-fandemonium/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-not-enough-mineralshttpsadventofcodecom2022day19>Source: <a href=https://adventofcode.com/2022/day/19>Not Enough Minerals</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>Given a series of given a series of <code>blueprints</code>, each of which gives instructions for how to build a single <code>robot</code> from a collection of <code>materials</code> that in turn will produce one of a given <code>material</code> per turn, determine the best order of builds to maximize your <code>geode</code> (the most valuable <code>material</code>) production for each <code>blueprint</code> given a time limit of <code>24 minutes</code>.</p></blockquote><p>Neat! I went a few different ways for this one, trying to make a more general solution at first that could handle multiple different ways to make each robot, but &mldr; that wasn&rsquo;t actually necessary. There are always exactly 4 resources and always exactly 4 kinds of robots that make them (one for each). So let&rsquo;s do that.</p><p>To start out, I&rsquo;m going to create some aliases for types, mostly so I can change how much memory I&rsquo;m using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ID</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Qty</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Qtys</span> <span style=color:#f92672>=</span> [Qty; Material::COUNT];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>make_qtys</span>() -&gt; <span style=color:#a6e22e>Qtys</span> {
</span></span><span style=display:flex><span>    [<span style=color:#ae81ff>0</span>; Material::COUNT]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Also a helper function to make our main data structure, a <code>Qtys</code>, which is (in this case) a <code>[Qty; 4]</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Material</span> {
</span></span><span style=display:flex><span>    Ore <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    Clay <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    Obsidian <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    Geode <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Material {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> COUNT: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Material {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(s: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> s.to_lowercase().as_str() {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;ore&#34;</span> <span style=color:#f92672>=&gt;</span> Material::Ore,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;clay&#34;</span> <span style=color:#f92672>=&gt;</span> Material::Clay,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;obsidian&#34;</span> <span style=color:#f92672>=&gt;</span> Material::Obsidian,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;geode&#34;</span> <span style=color:#f92672>=&gt;</span> Material::Geode,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;unknown material {s}&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I would rather be able to have something that automatically tells me how many options there actually are for an enum and it seems that there are crates that do that&mldr; but for now, this works well enough.</p><p>Next, up actually making the robots. So interestingly, I don&rsquo;t actually need to store the output, since the robots will always be in order, their index is actually the same as the input (that&rsquo;s why I put the values in the enum). So a robot is just:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Robot</span> {
</span></span><span style=display:flex><span>    inputs: <span style=color:#a6e22e>Qtys</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Not bad. Next up, the main parsing function for <code>Blueprint</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Blueprint</span> {
</span></span><span style=display:flex><span>    id: <span style=color:#a6e22e>ID</span>,
</span></span><span style=display:flex><span>    robots: Vec<span style=color:#f92672>&lt;</span>Robot<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Blueprint {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(line: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> id <span style=color:#f92672>=</span> line
</span></span><span style=display:flex><span>            .split_ascii_whitespace()
</span></span><span style=display:flex><span>            .nth(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            .expect(<span style=color:#e6db74>&#34;must have id&#34;</span>)
</span></span><span style=display:flex><span>            .strip_suffix(<span style=color:#e6db74>&#34;:&#34;</span>)
</span></span><span style=display:flex><span>            .expect(<span style=color:#e6db74>&#34;ID ends with :&#34;</span>)
</span></span><span style=display:flex><span>            .parse::<span style=color:#f92672>&lt;</span>ID<span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>            .expect(<span style=color:#e6db74>&#34;ID must be numeric&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> re <span style=color:#f92672>=</span> Regex::new(<span style=color:#e6db74>r&#34;Each (\w+) robot costs (.*?)\.&#34;).expect(&#34;regex creation failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> robots <span style=color:#f92672>=</span> re
</span></span><span style=display:flex><span>            .captures_iter(<span style=color:#f92672>&amp;</span>line)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>definition<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> inputs <span style=color:#f92672>=</span> make_qtys();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                definition[<span style=color:#ae81ff>2</span>].split(<span style=color:#e6db74>&#34; and &#34;</span>).for_each(<span style=color:#f92672>|</span>each<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> (qty, mat) <span style=color:#f92672>=</span> each
</span></span><span style=display:flex><span>                        .split_ascii_whitespace()
</span></span><span style=display:flex><span>                        .collect_tuple()
</span></span><span style=display:flex><span>                        .expect(<span style=color:#e6db74>&#34;must have qty and material&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> mat <span style=color:#f92672>=</span> Material::from(String::from(mat));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> qty <span style=color:#f92672>=</span> qty.parse::<span style=color:#f92672>&lt;</span>Qty<span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;qty must be numeric&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    inputs[mat <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>] <span style=color:#f92672>+=</span> qty;
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Robot { inputs }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Blueprint { id, robots }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time around I&rsquo;m using <a href=https://en.wikipedia.org/wiki/regular%20expressions>regular expressions</a> for parsing, which works out pretty well. I feel like my parsing is at least growing and changing. Whether it&rsquo;s idiomatic Rust&mldr; that I&rsquo;m not quite so sure about.</p><p>Now, for the actual solver, we&rsquo;re going to use the same general idea as I finally ended up using in <a href=https://en.wikipedia.org/wiki/AoC%202022%20Day%2016:%20Pressurinator>AoC 2022 Day 16: Pressurinator</a>. Create a stack of solutions and then for each step, bail out if it&rsquo;s worse than some possible upper bound, otherwise generate each possible next step. I really should implement an <a href=https://en.wikipedia.org/wiki/A*%20solver>A* solver</a> instead&mldr; but this works. And it&rsquo;s close.</p><p>Okay, the solver. It&rsquo;s certainly getting longer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Blueprint {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>solve</span>(<span style=color:#f92672>&amp;</span>self, max_time: <span style=color:#66d9ef>usize</span>) -&gt; (<span style=color:#66d9ef>u16</span>, Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u16</span><span style=color:#f92672>&gt;&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Clone, Debug)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>            time: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>            inventory: <span style=color:#a6e22e>Qtys</span>,
</span></span><span style=display:flex><span>            population: <span style=color:#a6e22e>Qtys</span>,
</span></span><span style=display:flex><span>            builds: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>ID<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Generate the initial state, no inventory but one of each material
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> inventory <span style=color:#f92672>=</span> make_qtys();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> population <span style=color:#f92672>=</span> make_qtys();
</span></span><span style=display:flex><span>        population[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        queue.push(State {
</span></span><span style=display:flex><span>            time: <span style=color:#a6e22e>max_time</span> <span style=color:#66d9ef>as</span> Qty,
</span></span><span style=display:flex><span>            inventory,
</span></span><span style=display:flex><span>            population,
</span></span><span style=display:flex><span>            builds: Vec::new(),
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Best case is # of geodes + the build order to get there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> best <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>as</span> ID, Vec::new());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>!</span>queue.is_empty() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> State {
</span></span><span style=display:flex><span>                time,
</span></span><span style=display:flex><span>                inventory,
</span></span><span style=display:flex><span>                population,
</span></span><span style=display:flex><span>                builds,
</span></span><span style=display:flex><span>            } <span style=color:#f92672>=</span> queue.pop().unwrap();
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> geode_qty <span style=color:#f92672>=</span> inventory[Material::Geode <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> geode_qty <span style=color:#f92672>&gt;</span> best.<span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                best <span style=color:#f92672>=</span> (geode_qty, builds.clone());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> time <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Best case: build a new geode robot each frame (ignore inputs)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> best_case_geodes <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                geode_qty <span style=color:#f92672>+</span> population[Material::Geode <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>] <span style=color:#f92672>*</span> time <span style=color:#f92672>+</span> time <span style=color:#f92672>*</span> (time <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> best_case_geodes <span style=color:#f92672>&lt;</span> best.<span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                skip_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For each kind of robot, try to build it next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (id, robot) <span style=color:#66d9ef>in</span> self.robots.iter().enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// It&#39;s impossible to build, we don&#39;t make the right resources
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> robot
</span></span><span style=display:flex><span>                    .inputs
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .enumerate()
</span></span><span style=display:flex><span>                    .any(<span style=color:#f92672>|</span>(input_id, input_qty)<span style=color:#f92672>|</span> <span style=color:#f92672>*</span>input_qty <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> population[input_id] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// When is the next time we&#39;ll have enough inputs to build it?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> ticks <span style=color:#f92672>=</span> robot
</span></span><span style=display:flex><span>                    .inputs
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .enumerate()
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>(input_id, input_qty)<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> inventory[input_id] <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>*</span>input_qty {
</span></span><span style=display:flex><span>                            <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                            ((<span style=color:#f92672>*</span>input_qty <span style=color:#f92672>-</span> inventory[input_id]) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>                                <span style=color:#f92672>/</span> population[input_id] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f32</span>)
</span></span><span style=display:flex><span>                                .ceil() <span style=color:#66d9ef>as</span> Qty
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                    .max()
</span></span><span style=display:flex><span>                    .unwrap()
</span></span><span style=display:flex><span>                    <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If it won&#39;t be done in time, don&#39;t try to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> ticks <span style=color:#f92672>&gt;</span> time {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update inventory for those ticks - this build
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_inventory <span style=color:#f92672>=</span> inventory.clone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                population
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .enumerate()
</span></span><span style=display:flex><span>                    .for_each(<span style=color:#f92672>|</span>(id, qty)<span style=color:#f92672>|</span> new_inventory[id] <span style=color:#f92672>+=</span> <span style=color:#f92672>*</span>qty <span style=color:#f92672>*</span> ticks);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                self.robots[id]
</span></span><span style=display:flex><span>                    .inputs
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .enumerate()
</span></span><span style=display:flex><span>                    .for_each(<span style=color:#f92672>|</span>(id, qty)<span style=color:#f92672>|</span> new_inventory[id] <span style=color:#f92672>-=</span> <span style=color:#f92672>*</span>qty);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update the population with the new robot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_population <span style=color:#f92672>=</span> population.clone();
</span></span><span style=display:flex><span>                new_population[id] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Update the steps with the number of skips + the build
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_builds <span style=color:#f92672>=</span> builds.clone();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>(ticks <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    new_builds.push(None);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                new_builds.push(Some(id <span style=color:#66d9ef>as</span> ID));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Add to queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                queue.push(State {
</span></span><span style=display:flex><span>                    time: <span style=color:#a6e22e>time</span> <span style=color:#f92672>-</span> ticks,
</span></span><span style=display:flex><span>                    inventory: <span style=color:#a6e22e>new_inventory</span>,
</span></span><span style=display:flex><span>                    population: <span style=color:#a6e22e>new_population</span>,
</span></span><span style=display:flex><span>                    builds: <span style=color:#a6e22e>new_builds</span>,
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        best
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s pretty much the same code as what I ended up with for day 16 and I hope well enough commented. The interesting bits are:</p><ul><li>The initial state starts with no inventory and 1 of the lowest level (ore-collecting) robot</li><li>The best case is how many geodes we built</li><li>This time I wrapped everything up in an internal <code>State</code> structure; it&rsquo;s neat being able to define these within a function</li><li>The best case assumes you can build a <code>geode</code> robot each frame for the rest of the game (without checking input), each of which produces a <code>geode</code> until the end of the simulation. This uses the <a href=https://en.wikipedia.org/wiki/1%20+%202%20+%203%20+%204%20+%20%e2%8b%af>1 + 2 + 3 + 4 + ⋯</a> formula to calculate quickly. It only removes the worst cases, but that&rsquo;s really all we need</li><li>The recursive case tries to build one of each robot:<ul><li>If we don&rsquo;t even produce the right resources, don&rsquo;t try to calculate it</li><li>Otherwise, figure out how many ticks it will take to build it, schedule the build for then. This is perhaps the most interesting bit: rather than recurring once every time increment, we skip forward long enough to build the next bot. This helps cut down the search time significantly.</li><li>Update the inventory to: produce whatever we do * time + use the resources to build the new bot</li><li>Update the population with the new bot</li></ul></li></ul><p>And that&rsquo;s basically it. To solve the problem, load each <code>Blueprint</code> and find the total quality as requested:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> blueprints <span style=color:#f92672>=</span> iter_lines(filename)
</span></span><span style=display:flex><span>        .map(Blueprint::from)
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> total_quality <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> blueprint <span style=color:#66d9ef>in</span> blueprints.into_iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (geode_count, steps) <span style=color:#f92672>=</span> blueprint.solve(<span style=color:#ae81ff>24</span>);
</span></span><span style=display:flex><span>        total_quality <span style=color:#f92672>+=</span> blueprint.id <span style=color:#f92672>*</span> geode_count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    total_quality.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Cool.</p><h2 id=part-2>Part 2</h2><blockquote><p>Do the same thing with a time limit of <code>32 minutes</code>, but only for the first 3 blueprints. Calculate the product of their <code>geode</code> production numbers.</p></blockquote><p>This is quite literally the same thing. If you code isn&rsquo;t as good, it would certainly take a very very long time if you were doing this less efficiently.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> blueprints <span style=color:#f92672>=</span> iter_lines(filename)
</span></span><span style=display:flex><span>        .map(Blueprint::from)
</span></span><span style=display:flex><span>        .take(<span style=color:#ae81ff>3</span>) <span style=color:#75715e>// Only keep the first 3 blueprints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> quality_product <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> blueprint <span style=color:#66d9ef>in</span> blueprints.into_iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (geode_count, steps) <span style=color:#f92672>=</span> blueprint.solve(<span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>        quality_product <span style=color:#f92672>*=</span> geode_count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    quality_product.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The iterator functions (<code>take</code> in this example) being core to the language is so nice.</p><h2 id=performance>Performance</h2><p>So&mldr; it&rsquo;s not fast. But I was really working more towards getting things working at this point.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/19-blueprintinator <span style=color:#ae81ff>1</span> data/19.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1092</span>
</span></span><span style=display:flex><span>took 8.854342166s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/19-blueprintinator <span style=color:#ae81ff>2</span> data/19.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3542</span>
</span></span><span style=display:flex><span>took 155.567067083s
</span></span></code></pre></div><p>I really would much rather get that under a minute, but for the moment&mldr; I&rsquo;m moving on!</p><h2 id=edit-dec-25-optimizing-max-builds>Edit Dec 25, Optimizing Max Builds</h2><p>So On digging back into this problem (my longest by far), I did come up with one (pretty major) improvement:</p><p>We can only build one robot per turn. So the most resources we&rsquo;ll ever need per turn is the maximum of that resource to build any robot. Once we&rsquo;ve built that many, stop building that kind of robot. This will mostly stop looking down branches where we build the smallest robots.</p><p>Implementation wise, there are only two small changes:</p><ol><li><p>At the top of the loop before processing the <code>queue</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Figure out the most of each resource we need to build any given robot
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We don&#39;t need more than that many production robots, since you can only build one per frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_needed <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>Material::COUNT)
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> self.robots.iter().map(<span style=color:#f92672>|</span>r<span style=color:#f92672>|</span> r.inputs[i]).max().unwrap())
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>max_needed[Material::Geode <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>] <span style=color:#f92672>=</span> Qty::MAX;
</span></span></code></pre></div></li><li><p>In the loop before even checking if it&rsquo;s possible to build one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// We don&#39;t need any more of this one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> id <span style=color:#f92672>!=</span> (Material::Geode <span style=color:#66d9ef>as</span> Qty) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We are creating enough resources each tick to build any robot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> population[id] <span style=color:#f92672>&gt;=</span> max_needed[id] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><p>And that&rsquo;s really it. The results are &mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/19-blueprintinator <span style=color:#ae81ff>1</span> data/19.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1092</span>
</span></span><span style=display:flex><span>took 262.607583ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/19-blueprintinator <span style=color:#ae81ff>2</span> data/19.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3542</span>
</span></span><span style=display:flex><span>took 1.928983666s
</span></span></code></pre></div><p>That&rsquo;s really impressive. Roughly ~80x faster. That actually brings this down to 4th slowest, faster than Day <a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/>16</a>, <a href=https://blog.jverkamp.com/2022/12/23/aoc-2022-day-23-elf-scattinator/.md>23</a>, and <a href=https://blog.jverkamp.com/2022/12/24/aoc-2022-day-24-blizzinator/>24</a>. It&rsquo;s amazing what you can do with just a few lines of code&mldr;</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>