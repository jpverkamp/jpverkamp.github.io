<!doctype html><html><head><title>AoC 2022 Day 17: Tetrisinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script defer src=/jquery_6894410585563545744.min.cc1cade18c999752b7befe111634889dca8d89b24923775954ecebc68c54fcd3.js></script>
<script defer src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js></script>
<script defer src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js></script>
<script defer src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js></script>
<script defer src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js></script>
<script defer src=/custom.js></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css></script><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css></script><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css></script><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css></script><link rel=stylesheet href=/custom.css><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2022 Day 17: Tetrisinator</h1><div class=entry-meta><span class=entry-date>2022-12-17</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/rust>Rust</a><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/games>Games</a></li><li><a href=https://blog.jverkamp.com/2022/12/11/aoc-2022-day-11-monkeyinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/modular-arithmetic>Modular Arithmetic</a><a href=https://blog.jverkamp.com/2022/12/20/aoc-2022-day-20-deencryptinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a><a href=https://blog.jverkamp.com/2022/12/19/aoc-2022-day-19-blueprintinator/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/tetris>Tetris</a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2022>Advent of Code 2022</a><a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2022/12/16/aoc-2022-day-16-pressurinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2022/12/17/the-wicked--the-divine-vol.-1-the-faust-act/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2022/12/18/aoc-2022-day-18-lavinator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h2 id=source-pyroclastic-flowhttpsadventofcodecom2022day17>Source: <a href=https://adventofcode.com/2022/day/17>Pyroclastic Flow</a></h2><h2 id=part-1>Part 1</h2><blockquote><p>Simulate <a href=https://en.wikipedia.org/wiki/Tetris>Tetris</a> on a 7 wide board with a given (infinitely repeated) series of left and right inputs to be applied on each frame before dropping the block and a given (infinitely repeated) set of blocks. Once 2022 blocks have been dropped, what is the total height of the placed blocks?</p></blockquote><p>Sweet!</p><p>Let&rsquo;s just directly simulate it, what could go wrong?</p><p>First, the blocks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Rock</span> {
</span></span><span style=display:flex><span>    points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rock {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>nth</span>(n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Rock</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> Rock {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>2</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>3</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                ],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> Rock {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>2</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>2</span> },
</span></span><span style=display:flex><span>                ],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> Rock {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>2</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>2</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>2</span>, y: <span style=color:#ae81ff>2</span> },
</span></span><span style=display:flex><span>                ],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>3</span> <span style=color:#f92672>=&gt;</span> Rock {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>2</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>3</span> },
</span></span><span style=display:flex><span>                ],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span> <span style=color:#f92672>=&gt;</span> Rock {
</span></span><span style=display:flex><span>                points: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                    Point { x: <span style=color:#ae81ff>1</span>, y: <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>                ],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;n % 5 somehow not 0..=4&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We always have the same 5 blocks, so <code>nth</code> will use <a href=https://en.wikipedia.org/wiki/modular%20arithmetic>modular arithmetic</a> to figure out which block we need. One gotcha is that we need the same anchor point on each block so that we can correctly spawn them on the map. In this case, that is the bottom left.</p><p>After that, the map:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>    width: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    tower_height: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    walls: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rock_count: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    next_rock: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    rock: <span style=color:#a6e22e>Rock</span>,
</span></span><span style=display:flex><span>    rock_at: <span style=color:#a6e22e>Point</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(width: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> walls <span style=color:#f92672>=</span> HashSet::new();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>(width <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>            walls.insert(Point {
</span></span><span style=display:flex><span>                x: <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>            walls.insert(Point {
</span></span><span style=display:flex><span>                x: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            walls.insert(Point {
</span></span><span style=display:flex><span>                x: <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map {
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            tower_height: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            walls,
</span></span><span style=display:flex><span>            rock_count: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>            rock: <span style=color:#a6e22e>Rock</span>::nth(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            rock_at: <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>                x: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#ae81ff>4</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We are going to keep the <code>walls</code> as a <code>HashSet</code> of <code>Point</code>. This should be fast enough for collision detection, we just have to make sure we keep extending it upwards.</p><p>Other than that:</p><ul><li><code>width</code> is the constant width</li><li><code>tower_height</code> is the current highest <code>y</code> value of any wall (to save iterating through <code>walls</code>)</li><li><code>rock_count</code> is how many rocks we&rsquo;ve spawned so far so we know when to stop</li><li><code>rock</code> is the current rock being dropped</li><li><code>rock_at</code> is the offset where that rock is</li></ul><p>After that, we want a function that can simulate one step, given the input (we&rsquo;ll come back to how we parse that in a bit):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, xd: <span style=color:#66d9ef>isize</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to move left/right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we can&#39;t, just don&#39;t move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> sidestep <span style=color:#f92672>=</span> Point { x: <span style=color:#a6e22e>xd</span>, y: <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self
</span></span><span style=display:flex><span>            .rock
</span></span><span style=display:flex><span>            .points
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> self.walls.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> self.rock_at <span style=color:#f92672>+</span> sidestep)))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            self.rock_at <span style=color:#f92672>=</span> self.rock_at <span style=color:#f92672>+</span> sidestep;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to move down
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// If we can&#39;t, lock in place
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> downstep <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self
</span></span><span style=display:flex><span>            .rock
</span></span><span style=display:flex><span>            .points
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .any(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> self.walls.contains(<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> self.rock_at <span style=color:#f92672>+</span> downstep)))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            self.lock_and_spawn();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            self.rock_at <span style=color:#f92672>=</span> self.rock_at <span style=color:#f92672>+</span> downstep;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I do love the functional style code. In this case, we&rsquo;ll first <code>sidestep</code> left or right. If any of the rock points (offset by <code>rock_at</code> and then <code>sidestep</code>) touch any of the walls, just don&rsquo;t do this move. Then, do the same with a <code>downstep</code>, but if we have any collisions this time, <code>lock_and_spawn</code> the current and a new rock:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>lock_and_spawn</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p <span style=color:#66d9ef>in</span> self.rock.points.iter() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>+</span> self.rock_at;
</span></span><span style=display:flex><span>            self.tower_height <span style=color:#f92672>=</span> self.tower_height.max(p.y <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>);
</span></span><span style=display:flex><span>            self.walls.insert(p);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Inefficient, but ðŸ¤·
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> y <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span>(self.tower_height <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            self.walls.insert(Point {
</span></span><span style=display:flex><span>                x: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            self.walls.insert(Point {
</span></span><span style=display:flex><span>                x: <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> self.width <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>                y: <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Don&#39;t forget the extra offset for the left wall and floor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        self.rock <span style=color:#f92672>=</span> Rock::nth(self.current_rock);
</span></span><span style=display:flex><span>        self.rock_at <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>            x: <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>            y: <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> self.tower_height <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.rock_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This one is interesting. It a nutshell:</p><ul><li>turn the rock into walls, updating the <code>tower_height</code></li><li>expand the walls well beyond that height, just in case (we&rsquo;re reinserting all previous walls, but ðŸ¤·, it works for this part)</li><li>spawning the next new rock at 2 from the left wall and 3 from the tallest block</li><li>increment which rock we&rsquo;re on</li></ul><p>And&mldr; that&rsquo;s it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part1</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> lines <span style=color:#f92672>=</span> read_lines(filename);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> winds <span style=color:#f92672>=</span> lines[<span style=color:#ae81ff>0</span>].as_bytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a custom infinite iterator for the wind
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> first <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> wind_iter <span style=color:#f92672>=</span> std::iter::from_fn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> first {
</span></span><span style=display:flex><span>            first <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Some(winds[index <span style=color:#f92672>%</span> winds.len()] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>char</span>)
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Build a new map and iterate until we hit the target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> map <span style=color:#f92672>=</span> Map::new(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> wind_iter.next() {
</span></span><span style=display:flex><span>            Some(<span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                map.step(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Some(<span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                map.step(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;unexpected char in wind_iter&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> map.rock_count <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2022</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    map.tower_height.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, not quite. We still need a way to make an infinite iterator of the wind / moves left and right. That&rsquo;s where <a href=https://doc.rust-lang.org/std/iter/fn.from_fn.html><code>std::iter::from_fn</code></a> comes in. Basically, it turns a function into an <code>Iterator</code>. Keep the state (<code>index</code>) and we have it. This would be easier with <code>generators</code> (not in stable yet) or making my own struct that implements <code>Iterator</code>, but this works well enough.</p><p>Onward!</p><h2 id=part-2>Part 2</h2><blockquote><p>Do the same thing for 1 trillion blocks.</p></blockquote><p>I enjoy problems like this. Yes, you could just simulate the first bit. But&mldr; that&rsquo;s going to take days at best (given my <code>122 ms</code> for part 1, the estimate is just under 700 days and that&rsquo;s assuming constant performance and memory consumption).</p><p>So&mldr; we have to do better.</p><p>Idea: the same 6 blocks repeat over and over again, as does the same inputs. So at some point&mldr; have to get a cycle, right? Where the blocks are placed in the same way with a relative offset?</p><p>Let&rsquo;s assume that&rsquo;s true:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>part2</span>(filename: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> lines <span style=color:#f92672>=</span> read_lines(filename);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> winds <span style=color:#f92672>=</span> lines[<span style=color:#ae81ff>0</span>].as_bytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> target: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000000000000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> first <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> wind_iter <span style=color:#f92672>=</span> std::iter::from_fn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> first {
</span></span><span style=display:flex><span>            first <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Some(winds[index <span style=color:#f92672>%</span> winds.len()] <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>char</span>)
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> map <span style=color:#f92672>=</span> Map::new(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> last_rock_count <span style=color:#f92672>=</span> <span style=color:#66d9ef>usize</span>::MAX;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> last_height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> deltas <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Attempt to detect cycles in the delta between heights
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cycle</span> {
</span></span><span style=display:flex><span>        length: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        value: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cycle <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Loop until we find a cycle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Then loop until the current height and the target are at the same point in the cycle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Then add enough cycles to jump ahead to the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#39;</span><span style=color:#a6e22e>cycle</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> wind_iter.next() {
</span></span><span style=display:flex><span>            Some(<span style=color:#e6db74>&#39;&lt;&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                map.step(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Some(<span style=color:#e6db74>&#39;&gt;&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                map.step(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;unexpected char in wind_iter&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update the count and height as before, but also calculate delta (change in height)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> map.rock_count <span style=color:#f92672>!=</span> last_rock_count {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> count <span style=color:#f92672>=</span> map.rock_count;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> map.tower_height;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> delta <span style=color:#f92672>=</span> height <span style=color:#f92672>-</span> last_height;
</span></span><span style=display:flex><span>            deltas.push(delta);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cfg!(debug_assertions) {
</span></span><span style=display:flex><span>                println!(<span style=color:#e6db74>&#34;{count}\t{delta}\t{height}&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            last_rock_count <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>            last_height <span style=color:#f92672>=</span> height;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Try to detect cycles in delta by:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// - for each length from a small value up to the full list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// - test if [prefix][data of length][data of length] repeats the data sections
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Once we&#39;ve detected a cycle, stop looking for one (but keep iterating)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// The offsets are completely random at this point, I&#39;m not sure what to base it off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> cycle.is_none() <span style=color:#f92672>&amp;&amp;</span> deltas.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2000</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> length <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1000</span><span style=color:#f92672>..</span>(deltas.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> seq1 <span style=color:#f92672>=</span> deltas.iter().rev().take(length).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> seq2 <span style=color:#f92672>=</span> deltas
</span></span><span style=display:flex><span>                        .iter()
</span></span><span style=display:flex><span>                        .rev()
</span></span><span style=display:flex><span>                        .skip(length)
</span></span><span style=display:flex><span>                        .take(length)
</span></span><span style=display:flex><span>                        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> seq1 <span style=color:#f92672>==</span> seq2 {
</span></span><span style=display:flex><span>                        cycle <span style=color:#f92672>=</span> Some(Cycle {
</span></span><span style=display:flex><span>                            length: <span style=color:#a6e22e>length</span>,
</span></span><span style=display:flex><span>                            value: <span style=color:#a6e22e>seq1</span>.into_iter().sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> cfg!(debug_assertions) {
</span></span><span style=display:flex><span>                            println!(<span style=color:#e6db74>&#34;cycle detected: {cycle:?}&#34;</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we have a cycle, we need the current rock and the target to be at the same offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Otherwise we&#39;d have to add partial cycles; we can do it, this is just easier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>match</span> cycle {
</span></span><span style=display:flex><span>                Some(Cycle { length, value, <span style=color:#f92672>..</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> map.rock_count <span style=color:#f92672>%</span> length <span style=color:#f92672>==</span> target <span style=color:#f92672>%</span> length {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Hacky, but technically correct? Doesn&#39;t update walls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// We certainly could, but no point for this problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#66d9ef>let</span> jumps <span style=color:#f92672>=</span> (target <span style=color:#f92672>-</span> map.rock_count) <span style=color:#f92672>/</span> length;
</span></span><span style=display:flex><span>                        map.rock_count <span style=color:#f92672>+=</span> jumps <span style=color:#f92672>*</span> length;
</span></span><span style=display:flex><span>                        map.tower_height <span style=color:#f92672>+=</span> jumps <span style=color:#f92672>*</span> value;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span> &#39;cycle;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Edge case: If we never found a cycle but hit the target anyways, be done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> map.rock_count <span style=color:#f92672>&gt;=</span> target {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> &#39;cycle;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    map.tower_height.to_string()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To detect the cycle, I&rsquo;m not looking at the heights, but rather the <code>deltas</code> between the heights. The height is always increasing, but the <code>deltas</code> should fall into a pattern eventually.</p><p>The main interesting part is the cycle detection:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Try to detect cycles in delta by:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - for each length from a small value up to the full list
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - test if [prefix][data of length][data of length] repeats the data sections
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Once we&#39;ve detected a cycle, stop looking for one (but keep iterating)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The offsets are completely random at this point, I&#39;m not sure what to base it off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> cycle.is_none() <span style=color:#f92672>&amp;&amp;</span> deltas.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2000</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> length <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1000</span><span style=color:#f92672>..</span>(deltas.len() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> seq1 <span style=color:#f92672>=</span> deltas.iter().rev().take(length).collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> seq2 <span style=color:#f92672>=</span> deltas
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .rev()
</span></span><span style=display:flex><span>            .skip(length)
</span></span><span style=display:flex><span>            .take(length)
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> seq1 <span style=color:#f92672>==</span> seq2 {
</span></span><span style=display:flex><span>            cycle <span style=color:#f92672>=</span> Some(Cycle {
</span></span><span style=display:flex><span>                length: <span style=color:#a6e22e>length</span>,
</span></span><span style=display:flex><span>                value: <span style=color:#a6e22e>seq1</span>.into_iter().sum::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cfg!(debug_assertions) {
</span></span><span style=display:flex><span>                println!(<span style=color:#e6db74>&#34;cycle detected: {cycle:?}&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I expect there are smarter algorithms for this (at the very least ones that don&rsquo;t need to create two <code>iter()</code> and <code>skip()</code> over the elements for the second one. But this does at least make sense. So far as the lower bound <code>1000</code> on length&mldr; it&rsquo;s totally a made up number that at least for this works. It can&rsquo;t be too short or you risk false positives.</p><p>Plus, generated all of the <code>delta</code> values up to 10,000 or so, copied a random section and replaced it with <code>$section\n</code>. That actually showed me the cycle I was looking for, which happened to be 1740 characters long. So I knew this would catch it.</p><p>Another gotcha was originally the possibility of something that repeated twice but not thrice. So I had at times a <code>seq3</code> generated the same way albeit with <code>.skip(2 * length)</code>, but it turned out not to be necessary.</p><p>The other interesting bit is that once we&rsquo;ve found a cycle, we can&rsquo;t jump immediately. Instead, we have to wait until the current place in that cycle &rsquo;lines up&rsquo; with the target we&rsquo;re aiming for. As I mention in the comment, we could have instead added a slice of <code>deltas</code>, but I found this easier. Just use <code>%</code> (modulo) again until <code>map.rock_count</code> and <code>target</code> are an even multiple of <code>cycle.length</code> apart and bam. Jump to the end. One trillion blocks dropped stretching 1.54 trillion blocks high in a second and change. Not bad at all.</p><h3 id=a-cleanup-side-note>A cleanup side note</h3><p>One final aside, I did momentarily go down a variant where I only kept part of the board in memory at any given time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Map {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A currently unneeded function used to remove all walls lower than a certain threshold
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We&#39;ll never collide with them anyways
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Unfortunately, the drain_filter function that would have made this more performant isn&#39;t in stable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cleanup</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, threshold: <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>        self.walls <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .walls
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> p.y <span style=color:#f92672>&gt;=</span> (self.tower_height <span style=color:#f92672>-</span> threshold) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>isize</span> {
</span></span><span style=display:flex><span>                    Some(<span style=color:#f92672>*</span>p)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>HashSet<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This had the advantage of making the initial part (before we find a cycle) potentially faster since we have to compare again fewer <code>walls</code>. But it turns out that <code>HashSet::contains</code> is super faster and we didn&rsquo;t run out of RAM&mldr; so I ended up not using it. It&rsquo;s more expensive to remove the elements than just to keep them all along. I did tree a <code>BTreeSet</code> as well, which should have better <code>.pop()</code> performance, but that requires correctly ordering the points. Which I could do&mldr; but this is fast enough.</p><h2 id=performance>Performance</h2><p>Speaking of which:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./target/release/17-tetrisnator <span style=color:#ae81ff>1</span> data/17.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3114</span>
</span></span><span style=display:flex><span>took 122.644416ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./target/release/17-tetrisnator <span style=color:#ae81ff>2</span> data/17.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1540804597682</span>
</span></span><span style=display:flex><span>took 1.472870625s
</span></span></code></pre></div><p>We&rsquo;re over a second now, mostly because I didn&rsquo;t</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>