<!doctype html><html><head><title>Three ways to write expressions – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Three ways to write expressions</h1><div class=entry-meta><span class=entry-date>2012-10-07</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/10/two-word-games/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2012/10/08/evaluating-prefix/infix/postfix-expressions/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/06/generated-html-index/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/08/evaluating-prefix/infix/postfix-expressions/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/06/generated-html-index/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/08/evaluating-prefix/infix/postfix-expressions/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><pre tabindex=0><code>(- (- (+ 4 (* 2 7)) (* (- 1 6) 5)) 1)
</code></pre><p>is the same as</p><pre tabindex=0><code>4 + 2 * 7 - (1 - 6) * 5 - 1
</code></pre><p>is the same as</p><pre tabindex=0><code>4 2 7 * + 1 6 - 5 * - 1 -
</code></pre><p>Madness right?</p><p>Not really. More like prefix, infix, and <a href=https://en.wikipedia.org/wiki/Reverse%20Polish%20notation>reverse polish</a> / postfix notation. Basically, they&rsquo;re all just ways of writing down mathematical concepts.</p><p>You can really see it if you start with the general structure that all three share:</p><figure><img src=/embeds/2012/example.png></figure><p>That&rsquo;s what&rsquo;s called an <a href=https://en.wikipedia.org/wiki/expression%20tree>expression tree</a>. Each node is either a number (the boxes) or a function of two numbers (the circles). To calculate the final value of the tree, you can either think of it by starting at the top or the bottom and working recursively. If you start at the top, whenever you have an operator, branch and work out the value of the two child trees. When you have those, apply the function. If you start at the bottom, repeatedly find branches that have just a leaf on each side and simplify them. Either way, you&rsquo;ll get the same answer.</p><p>From the expression tree, you can easily get the three expressions that we were dealing with earlier. Just take the preorder, inorder, or postorder <a href=https://en.wikipedia.org/wiki/Tree%20traversal>traversal</a> of the tree (I&rsquo;ll cover those algorithms at some point as well).</p><p>Then to evaluate the tree, you&rsquo;ll get something like this (using the prefix notation as it&rsquo;s textual representation is most similar to the tree structure):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(- (- (+ <span style=color:#ae81ff>4</span> (* <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>7</span>)) (* (- <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span>) <span style=color:#ae81ff>5</span>)) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>= (- (- (+ <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>14</span>) (* <span style=color:#ae81ff>-5</span> <span style=color:#ae81ff>5</span>)) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>= (- (- <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>-25</span>) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>= (- <span style=color:#ae81ff>43</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>43</span>
</span></span></code></pre></div><p>Basically, you end up repeated end up rewriting expressions from the inside out until you&rsquo;re left with the final answer. The same sort of thing happens with the infix notation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>2</span> * <span style=color:#ae81ff>7</span> - (<span style=color:#ae81ff>1</span> - <span style=color:#ae81ff>6</span>) * <span style=color:#ae81ff>5</span> - <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>14</span> - <span style=color:#ae81ff>-5</span> * <span style=color:#ae81ff>5</span> - <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>14</span> - <span style=color:#ae81ff>-25</span> - <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>18</span> - <span style=color:#ae81ff>-25</span> - <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>43</span> - <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>This time it&rsquo;s a little more complicated to figure out which expressions are on the &ldquo;inside&rdquo;, but on the flip side it&rsquo;s easier to understand since we&rsquo;re all used to working with infix expressions, we&rsquo;ve been doing them since grade school after all.</p><p>What about the Reverse Polish Notation?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>7</span> * + <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span> - <span style=color:#ae81ff>5</span> * - <span style=color:#ae81ff>1</span> -
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>14</span> + <span style=color:#ae81ff>-5</span> <span style=color:#ae81ff>5</span> * - <span style=color:#ae81ff>1</span> -
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>28</span> <span style=color:#ae81ff>25</span> - <span style=color:#ae81ff>1</span> -
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>43</span> <span style=color:#ae81ff>1</span> -
</span></span><span style=display:flex><span>= <span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>Same thing. Just this time, you&rsquo;re looking for two numbers followed by an operator which you can then reduce.</p><p>So what if a computer wanted to do any of these operations?</p><p>Note: In order to make this a fair comparison, the input to each will be a list of either numbers or functions that take two numbers and return one. This means that the prefix code at least will be a little more complicated than just calling <code>eval</code>.</p><p>Let&rsquo;s start with the prefix / Scheme version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>car+cdr</span> ls)
</span></span><span style=display:flex><span>  (values (car ls) (cdr ls)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>prefix-calc</span> main-expr)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step</span> expr)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(number? (car expr))
</span></span><span style=display:flex><span>       (values (car expr) (cdr expr))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>let*-values</span> ([(<span style=color:#a6e22e>op</span> rest) (<span style=color:#a6e22e>car+cdr</span> expr)]
</span></span><span style=display:flex><span>                     [(<span style=color:#a6e22e>lv</span> rest) (<span style=color:#a6e22e>step</span> rest)]
</span></span><span style=display:flex><span>                     [(<span style=color:#a6e22e>rv</span> rest) (<span style=color:#a6e22e>step</span> rest)])
</span></span><span style=display:flex><span>         (values ((eval op) lv rv) rest))]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>let-values</span> ([(<span style=color:#a6e22e>val</span> rest) (<span style=color:#a6e22e>step</span> main-expr)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(null? rest)
</span></span><span style=display:flex><span>        val
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#39;prefix-calc</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;malformed expression ~s: ~s left over&#34;</span> main-expr rest)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>~ (<span style=color:#a6e22e>prefix-calc</span> <span style=color:#f92672>&#39;</span>(+ * <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>8</span> + <span style=color:#ae81ff>5</span> - <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>There are a few interesting bits here, so let&rsquo;s go through them one by one. The first thing is the helper function, <code>step</code>. Essentially, <code>step</code>&rsquo;s job is to take one &ldquo;step&rdquo; in the given expression. If the first thing is a number, just return it. If it&rsquo;s an operator we need to find the value of the two sub-expressions and then apply it. To do that, I&rsquo;ve defined <code>step</code> to take in an expression and return a pair of values: the numeric result of the step and any part of the expression that we did not consume.</p><p>That&rsquo;s where the <code>let*-values</code> comes in. Basically, it threads the three states that the code can be in together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>let*-values</span> ([(<span style=color:#a6e22e>op</span> rest) (<span style=color:#a6e22e>car+cdr</span> expr)]
</span></span><span style=display:flex><span>              [(<span style=color:#a6e22e>lv</span> rest) (<span style=color:#a6e22e>step</span> rest)]
</span></span><span style=display:flex><span>              [(<span style=color:#a6e22e>rv</span> rest) (<span style=color:#a6e22e>step</span> rest)])
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>The first line pulls apart the operator and the rest. The second line applies step again, starting at the <code>cdr</code> of the original list. If <code>step</code> does everything that it&rsquo;s supposed to (the promise of recursion), then we should get back a value from the front of the list (as <code>lv</code>) and any part of the list we didn&rsquo;t process (as the first value of <code>rest</code>). We can then feed that <code>rest</code> right back into <code>step</code>, resulting in another value (the right side) and anything that didn&rsquo;t get processed to give us that. We now have an operator and it&rsquo;s two arguments <code>lv</code> and <code>rv</code> and anything we didn&rsquo;t use to calculate any of those (the final value of <code>rest</code>), so return those two values.</p><p>Easy enough right? Well, it turns out that combining that with a base case that deals with single numbers is all that you need. Recursion takes care of the rest. But all of that power doesn&rsquo;t come for free. The drawback of doing this is that you need to allocate a stack frame each time you make the recursive call. Worse yet, it&rsquo;s not tail recursive so you can&rsquo;t even make that optimization. Still, it&rsquo;s a neat bit of code.</p><p>The next one gets even more interesting. Here, we have to deal with infix notation. It may be the one that we&rsquo;ve all grown up with, but it&rsquo;s actually generally considered the hardest of the three to deal with from a computer&rsquo;s perspective. Mostly because we have to deal with precedence and associativity to really do it correctly.</p><p>The way that I&rsquo;m going to do it is to repeatedly go through the given expression and evaluate things based on their precedence. So I&rsquo;ll find the leftmost multiplication or division and combine it, repeating until there are none left. If we didn&rsquo;t find any, try the leftmost addition or subtraction. After that, go back and try multiplication and division again. It&rsquo;s definitely not an efficient way to do it, but it does work.</p><p>First, the code that will find and reduce one expression of a given type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step</span> ls which)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(number? ls) ls]
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>or </span>(null? ls) (null? (cdr ls)) (null? (cddr ls))) ls]
</span></span><span style=display:flex><span>    [(member (cadr ls) which)
</span></span><span style=display:flex><span>     (cons ((eval (cadr ls)) (car ls) (caddr ls)) (cdddr ls))]
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     (cons (car ls) (<span style=color:#a6e22e>step</span> (cdr ls) which))]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>~ (<span style=color:#a6e22e>step</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>2</span> * <span style=color:#ae81ff>3</span> - <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&#39;</span>(* /))
</span></span><span style=display:flex><span> (<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>6</span> - <span style=color:#ae81ff>4</span>)
</span></span></code></pre></div><p>Then, a function that will repeatedly step, taking precedence into account. This is the slow part. 😄</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step-all</span> ls)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([step1 (<span style=color:#a6e22e>step</span> ls <span style=color:#f92672>&#39;</span>(* /))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(equal? ls step1)
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>let </span>([step2 (<span style=color:#a6e22e>step</span> step1 <span style=color:#f92672>&#39;</span>(+ -))])
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>if </span>(equal? step1 step2)
</span></span><span style=display:flex><span>              (car step2)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>step-all</span> step2)))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>step-all</span> step1))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>~ (<span style=color:#a6e22e>step-all</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>2</span> * <span style=color:#ae81ff>3</span> - <span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>And finally, the glue that holds the parts together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>infix-calc</span> expr)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step</span> ls which) <span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step-all</span> ls) <span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>step-all</span> expr))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>~ (<span style=color:#a6e22e>infix-calc</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>2</span> * <span style=color:#ae81ff>7</span> - <span style=color:#ae81ff>1</span> * <span style=color:#ae81ff>5</span> + <span style=color:#ae81ff>6</span> * <span style=color:#ae81ff>5</span> - <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>(Yes, I had to distribute the 5 at one point. Without doing so, there&rsquo;s no way to force the subtraction to go first and the expression doesn&rsquo;t have the same meaning.)</p><p>Whew. That was a fun one. Luckily, I&rsquo;ve saved the easiest one for last. Here, we have the Reverse Polish Notation. As a side note, you have may have guessed that since the other two were prefix and infix notation, another name for RPN is postfix notation.</p><p>The algorithm for this one is neat because all you need to keep track of the operation is a stack of values. Whenever you see a number, you push it onto the stack. When you see a function, you pop two values, apply the function, and push the result back onto the stack. Easy as pie. And as an added benefit, you can easily write it in an iterative / tail-recursive manner that avoids allocated stack frames so all the extra memory you need is in the value stack.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>postfix-calc</span> expr)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>step</span> expr stack)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(null? expr) (car stack)]
</span></span><span style=display:flex><span>      [(number? (car expr))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>step</span> (cdr expr)
</span></span><span style=display:flex><span>             (cons (car expr) stack))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>step</span> (cdr expr)
</span></span><span style=display:flex><span>             (cons ((eval (car expr))
</span></span><span style=display:flex><span>                    (cadr stack)
</span></span><span style=display:flex><span>                    (car stack))
</span></span><span style=display:flex><span>                   (cddr stack)))]))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>step</span> expr <span style=color:#f92672>&#39;</span>()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>~ (<span style=color:#a6e22e>postfix-calc</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>7</span> * + <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span> - <span style=color:#ae81ff>5</span> * - <span style=color:#ae81ff>1</span> -))
</span></span><span style=display:flex><span><span style=color:#ae81ff>42</span>
</span></span></code></pre></div><p>Pretty much the only thing you have to watch out for in this code is the actual evaluation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>((eval (car expr)) (cadr stack) (car stack))
</span></span></code></pre></div><p>Because you pushed the first argument onto the stack first, you have to reverse them after popping them (thus <code>cadr</code> before <code>car</code>). This doesn&rsquo;t matter for + or *, so it&rsquo;s easy to miss, but it will really mess up your day when you&rsquo;re working with - or /.</p><p>So there you have it. Three ways to write expressions and at least one way a computer could deal with each of them.</p><p>Before I go, I bet you were wondering why postfix notation is more commonly called Reverse Polish Notation. It&rsquo;s mostly because of J<a href=https://en.wikipedia.org/wiki/Jan%20%c5%81ukasiewicz>an Łukasiewicz</a>, a Polish logician and philosopher from first half of the 1900s. Essentially, he described (prefix) Polish notation in the 1920s but for whatever reason it stuck on the postfix notation, ergo reverse. And now you know.</p><p>The goal tomorrow is to create a web-based simulation of each of these three algorithms that shows the internal works, step by step. We&rsquo;ll see how that goes.</p><p>If you&rsquo;d like to download today&rsquo;s source, you can do so here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/evaluating-prefix-infix-postfix.rkt title="Evaluating prefix/infix/postfix expressions in Racket">source code</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>