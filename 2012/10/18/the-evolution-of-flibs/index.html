<!doctype html><html><head><title>The Evolution Of Flibs â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.a8e11addf4349ee2ca5045f7f3cbf1febbf2c3a2840be2143ea69539c10f8c7f.js integrity="sha256-qOEa3fQ0nuLKUEX388vx/rvyw6KEC+IUPqaVOcEPjH8=" defer></script><script src=/katex_17296078054267651618.min.4a06464d8d6f8358d8896de62b53b5a89205d335dfd8c5b6b27edd7c039ae9d8.js integrity="sha256-SgZGTY1vg1jYiW3mK1O1qJIF0zXf2MW2sn7dfAOa6dg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.a17078917a4403310cd19178939257b706fb5e1da76167c9f4a6d2123c9d59c4.js integrity="sha256-oXB4kXpEAzEM0ZF4k5JXtwb7Xh2nYWfJ9KbSEjydWcQ=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.7420a1602c62a85d4b50881c1d8ce42f72c049dc2b097d440696425d6e54bb1e.css integrity="sha256-dCChYCxiqF1LUIgcHYzkL3LASdwrCX1EBpZCXW5Uux4="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.5ff4b87c40715a96119d8b5f34d971604fc65ab18f4870fd8da6ede9fd1e6188.css integrity="sha256-X/S4fEBxWpYRnYtfNNlxYE/GWrGPSHD9jabt6f0eYYg="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>The Evolution Of Flibs</h1><div class=entry-meta><span class=entry-date>2012-10-18</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/10/20/memoization-in-racket/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/20/memoization-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/10/20/memoization-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/genetic-algorithms>Genetic Algorithms</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/19/small-projects-source-code-on-github/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/19/a-sea-of-stars-ch.-16-collision/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>In the past, I absolutely loved messing around with <a href=https://en.wikipedia.org/wiki/Genetic%20algorithm>genetic algorithms</a>. The idea of bringing the power of natural selection to bear to solve all manner of problems just appeals to me for some reason. So when I came across a puzzle on on Programming Praxis called <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/flibs.rkt target=_blank rel=noopener>flibs source code</a></p><p>The eventual goal will be&ndash;given a binary sequence&ndash;to evolve a finite state machine that will recognize the sequence and output the same, offset by one. So if we&rsquo;re given the sequence <code>010011010011</code>, the solution will output something like this: <code>001001101001</code>.</p><p>So what do we need to do this? First, we need a way to represent the finite automaton. We&rsquo;re just going to directly go with what they suggested in the post and build machines with three states. So for example, this would be a valid machine:</p><table><thead><tr><th></th><th>Input 0</th><th></th><th>Input 1</th><th></th></tr></thead><tbody><tr><td>A</td><td>1</td><td>B</td><td>1</td><td>C</td></tr><tr><td>B</td><td>0</td><td>C</td><td>0</td><td>B</td></tr><tr><td>C</td><td>1</td><td>A</td><td>0</td><td>A</td></tr></tbody></table><p>Which is equivalent to this diagram:</p><figure><img src=/embeds/2012/FSA-diagram.png></figure><p>So how can we represent this in code? I went with a vector just writing straight across the rows and then down the columns. So the chart represented above then becomes this vector:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A)
</span></span></code></pre></div><p>Given a flib and an input (also represented as a vector), how do we generate the output?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; run a flib on a given input</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>run-flib</span> flib input)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; turn a state into a number</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>f</span> s) (<span style=color:#66d9ef>case </span>s [(<span style=color:#a6e22e>A</span>) <span style=color:#ae81ff>0</span>] [(<span style=color:#a6e22e>B</span>) <span style=color:#ae81ff>1</span>] [(<span style=color:#a6e22e>C</span>) <span style=color:#ae81ff>2</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; initial state</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>state <span style=color:#e6db74>&#39;A</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; loop over the flip, update state and report output</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/vector</span> ([this input])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>([next (vector-ref flib (+ (* (<span style=color:#a6e22e>f</span> state) <span style=color:#ae81ff>4</span>) (* this <span style=color:#ae81ff>2</span>) <span style=color:#ae81ff>1</span>))]
</span></span><span style=display:flex><span>          [output (vector-ref flib (+ (* (<span style=color:#a6e22e>f</span> state) <span style=color:#ae81ff>4</span>) (* this <span style=color:#ae81ff>2</span>)))])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>set! </span>state next)
</span></span><span style=display:flex><span>      output)))
</span></span></code></pre></div><p>Basically, keep a mutable state starting at <code>A</code>. At each tick, pull apart the rows in the vector structure from above to get the output for the current state and input, along with the next input. Each enough, but still nothing like a genetic algorithm.</p><p>The general idea of the algorithm is to generate a random initial population then repeatedly mutate and breed those individuals until the population improves enough to find an optimal solution. So the first thing we need is a way to generate random flibs. Easy enough with <code>for/vector</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; generate a random flib</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; a flib is a state machine of the form</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   0  1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; A 1B 1C</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; B 0C 0B</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; C 1A 0A =&gt; 1B1C0C0B1A0A</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>random-flib</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/vector</span> ([i <span style=color:#ae81ff>12</span>])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(even? i)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        (vector-ref <span style=color:#f92672>&#39;#</span>(A B C) (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>3</span>)))))
</span></span></code></pre></div><p>After that, we need to calculate the fitness of each individual in the population. The strongest individuals will survive, the weaker ones will die off. So here&rsquo;s a function that will take an flib and an input vector, run the flib using the function above, and then measure the difference (offset by 1 as noted above).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; score a flib by calculating it&#39;s output, shifting one right</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; and counting differences</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>score-flib</span> flib input)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>output (<span style=color:#a6e22e>run-flib</span> flib input))
</span></span><span style=display:flex><span>  (- <span style=color:#ae81ff>1.0</span> (/ (<span style=color:#a6e22e>for/sum</span> ([i (- (vector-length input) <span style=color:#ae81ff>1</span>)])
</span></span><span style=display:flex><span>              (abs (- (vector-ref input (+ i <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                      (vector-ref output i))))
</span></span><span style=display:flex><span>            (- (vector-length input) <span style=color:#ae81ff>1</span>))))
</span></span></code></pre></div><p>That&rsquo;s enough to tell us which the stronger individuals are, but how do we use that to improve the population? Two different ways. First, we want to be able to take two individuals together and &ldquo;breed&rdquo; them. In the example given, they suggested breeding the strongest and weakest individual and using that to replace the weakest, but there are many possible strategies. The one I went for was to remove the lowest (given) number from a population and then breeding surviving members at random to get back to the original population size. We&rsquo;ll see that later in the <code>run</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; breed two flibs by selecting a crossover point and merging input</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>breed</span> flib1 flib2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>@ (<span style=color:#a6e22e>random</span> (vector-length flib1)))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/vector</span> ([i (vector-length flib1)]
</span></span><span style=display:flex><span>               [c1 flib1]
</span></span><span style=display:flex><span>               [c2 flib2])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(&lt; i @) c1 c2)))
</span></span></code></pre></div><p>The other option for advancement will mostly be used to break out of local optimums. With just crossovers, eventually a population is likely to stagnate as the individuals become too similar. So here we&rsquo;ll occasionally mutate an flib by randomly tweaking one of the genes therein.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; mutate a flib by random altering one character</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>mutate</span> flib)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>@ (<span style=color:#a6e22e>random</span> (vector-length flib)))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/vector</span> ([i (vector-length flib)]
</span></span><span style=display:flex><span>               [c flib])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(= @ i)
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>if </span>(symbol? c)
</span></span><span style=display:flex><span>            (vector-ref <span style=color:#f92672>&#39;#</span>(A B C) (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>random</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>        c)))
</span></span></code></pre></div><p>And with that, we&rsquo;re as good as done. I added a few more functions to help, for example to turn a string into a vector like the ones we want, which you can here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/flibs.rkt target=_blank rel=noopener>flibs source code</a>. And without further ado, here&rsquo;s the main function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; use a genetic algorithm to find a perfect flib</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>run</span> input
</span></span><span style=display:flex><span>             [pool-size <span style=color:#ae81ff>12</span>]  <span style=color:#75715e>; number of flibs to breed</span>
</span></span><span style=display:flex><span>             [kill-off <span style=color:#ae81ff>2</span>]    <span style=color:#75715e>; remove the lowest this many flibs each generation</span>
</span></span><span style=display:flex><span>                             <span style=color:#75715e>;   refill by breeding two random surviving flibs</span>
</span></span><span style=display:flex><span>             [mutate-% <span style=color:#ae81ff>0.1</span>]) <span style=color:#75715e>; mutate this percentage of flibs each generation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; sort a pool by a given criteria</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>sort-pool</span> pool)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>sort</span> 
</span></span><span style=display:flex><span>     pool
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>p1</span> p2) (&gt; (car p1) (car p2)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; iterate until we have a winner</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([pool (<span style=color:#a6e22e>sort-pool</span>
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>for/list</span> ([i pool-size]) 
</span></span><span style=display:flex><span>                      (<span style=color:#66d9ef>let </span>([flib (<span style=color:#a6e22e>random-flib</span>)])
</span></span><span style=display:flex><span>                        (list (<span style=color:#a6e22e>score-flib</span> flib input) flib))))]
</span></span><span style=display:flex><span>             [high-score <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; find a new maximum</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>new-max (&gt; (caar pool) high-score))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>next-high-score (<span style=color:#66d9ef>if </span>new-max (caar pool) high-score))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>high-flib (cadar pool))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; display progress</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>when</span> new-max
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;new best flib: ~s scoring ~s\n&#34;</span> high-flib next-high-score))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; loop (or not)</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(&lt; next-high-score <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span>       
</span></span><span style=display:flex><span>         <span style=color:#75715e>; kill off and replace the lowest performing flibs for the new pool</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>sort-pool</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>append</span>
</span></span><span style=display:flex><span>           <span style=color:#75715e>; add new flibs by breeding the old ones</span>
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>for/list</span> ([i kill-off]) 
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>let </span>([flib1 (cadr (list-ref pool (- pool-size kill-off)))]
</span></span><span style=display:flex><span>                   [flib2 (cadr (list-ref pool (- pool-size kill-off)))])
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>let </span>([flib3 (<span style=color:#a6e22e>breed</span> flib1 flib2)])
</span></span><span style=display:flex><span>                 (list (<span style=color:#a6e22e>score-flib</span> flib3 input) flib3))))
</span></span><span style=display:flex><span>           <span style=color:#75715e>; randomly mutate surviving flibs the given percent of the time</span>
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>for/list</span> ([sflib (<span style=color:#a6e22e>drop</span> (reverse pool) kill-off)])
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>if </span>(&lt; (<span style=color:#a6e22e>random</span>) mutate-%)
</span></span><span style=display:flex><span>                 (<span style=color:#66d9ef>let </span>([f (<span style=color:#a6e22e>mutate</span> (cadr sflib))])
</span></span><span style=display:flex><span>                   (list (<span style=color:#a6e22e>score-flib</span> f input) f))
</span></span><span style=display:flex><span>                 sflib))))
</span></span><span style=display:flex><span>         next-high-score)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        high-flib)))
</span></span></code></pre></div><p>Hopefully it should be pretty self explanatory, particularly with the comments I&rsquo;ve included, but there are definitely some more interesting bits. For example, the <code>pool</code> is going to be maintained as a list of pairs. Each pair has the score of an flib and then the flib in question to make sorting easier (without recalculating the score whenever we want to sort).</p><p>The next interesting part is the loop. Each iteration, we&rsquo;ll have a sorted list, so we&rsquo;ll check for the highest scoring flib currently in the pool. If it&rsquo;s better than what we&rsquo;ve seen, print that out and remember it. Otherwise, just keep going.</p><p>The bulk of work of updating the generation takes place in the recursive call to <code>loop</code>. We&rsquo;ll use <code>drop</code> to remove the weakest parts of the population (after a <code>reverse</code> so that they&rsquo;re at the front of the list) and then append on the newly bred members with their randomly selected parents.</p><p>And that&rsquo;s actually all there is to it. Here&rsquo;s an example of running it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>run</span> (<span style=color:#a6e22e>string-&gt;input</span> (<span style=color:#a6e22e>repeat-string</span> <span style=color:#e6db74>&#34;010011&#34;</span> <span style=color:#ae81ff>5</span>)))
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A) scoring <span style=color:#ae81ff>0.8275862068965517</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A) scoring <span style=color:#ae81ff>0.8620689655172413</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> B) scoring <span style=color:#ae81ff>0.9655172413793104</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> B) scoring <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> B)
</span></span></code></pre></div><p>Not the same machine we had above, but they both represent the string. If we run the same thing again, we&rsquo;re likely to get another equivalent result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>run</span> (<span style=color:#a6e22e>string-&gt;input</span> (<span style=color:#a6e22e>repeat-string</span> <span style=color:#e6db74>&#34;010011&#34;</span> <span style=color:#ae81ff>5</span>)))
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> C) scoring <span style=color:#ae81ff>0.6551724137931034</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A) scoring <span style=color:#ae81ff>0.6896551724137932</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> B) scoring <span style=color:#ae81ff>0.8275862068965517</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> B) scoring <span style=color:#ae81ff>0.8620689655172413</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> B) scoring <span style=color:#ae81ff>0.9655172413793104</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>0</span> A) scoring <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>0</span> A)
</span></span></code></pre></div><p>Alternatively, we can tweak the other parameters. Say we wanted a larger population with a 1/5 killoff rate and twice the mutation rate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>run</span> (<span style=color:#a6e22e>string-&gt;input</span> (<span style=color:#a6e22e>repeat-string</span> <span style=color:#e6db74>&#34;010011&#34;</span> <span style=color:#ae81ff>5</span>)) <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> A) scoring <span style=color:#ae81ff>0.6896551724137932</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A) scoring <span style=color:#ae81ff>0.8275862068965517</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> B) scoring <span style=color:#ae81ff>0.8620689655172413</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> B <span style=color:#ae81ff>0</span> C) scoring <span style=color:#ae81ff>0.9655172413793104</span>
</span></span><span style=display:flex><span>new best flib: <span style=color:#f92672>#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> B) scoring <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> A <span style=color:#ae81ff>0</span> B <span style=color:#ae81ff>0</span> C <span style=color:#ae81ff>0</span> A <span style=color:#ae81ff>1</span> C <span style=color:#ae81ff>1</span> B)
</span></span></code></pre></div><p>That&rsquo;s one of the fun parts about genetic algorithms is tuning the parameters. Any given problem can have vastly different sets of optimal parameters.</p><p>In any case, that&rsquo;s all I have for now. I&rsquo;ve started working on a version that will generalize to any string (with only three states, this can only recognize strings with a limited length), but progress is proving rocky. We&rsquo;ll see how it goes.</p><p>If you would like the source code, you can get it here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/flibs.rkt target=_blank rel=noopener>flibs source code</a></p><p>If you have any questions or comments, drop me a line below.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>