<!DOCTYPE html>
<html>
<head>
        
        

        <title>Dodgson’s Doublets | jverkamp.com | John-Paul Verkamp</title>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css" />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.css" />
        <script src="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.js"></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.9/jquery.transit.min.js"></script>

        <!-- Highlight.js for syntax highlighting -->
        <link rel="stylesheet" href="/highlight/styles/tomorrow-night.css" />
        <script src="/highlight/highlight.pack.js"></script>

        <!-- MathJax for LaTeX support -->
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- nanoGallery for Flickr Galleries -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/css/themes/light/nanogallery_light.css" />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/jquery.nanogallery.min.js"></script>

        <!-- Any custom CSS or JS that I've written; this should be kept minimal -->
        <link rel="stylesheet" href="/custom.css" />
        <script src="/custom.js"></script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
        <header class="container">
        <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://blog.jverkamp.com"><span style="color: green;">jv</span>erkamp.com</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav"><li class="dropdown"><a href="http://blog.jverkamp.com/category/archives" class="dropdown-toggle">Archives<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/archives/2004">2004</a></li><li><a href="http://blog.jverkamp.com/category/archives/2005">2005</a></li><li><a href="http://blog.jverkamp.com/category/archives/2006">2006</a></li><li><a href="http://blog.jverkamp.com/category/archives/2007">2007</a></li><li><a href="http://blog.jverkamp.com/category/archives/2008">2008</a></li><li><a href="http://blog.jverkamp.com/category/archives/2009">2009</a></li><li><a href="http://blog.jverkamp.com/category/archives/2010">2010</a></li><li><a href="http://blog.jverkamp.com/category/archives/2011">2011</a></li><li><a href="http://blog.jverkamp.com/category/archives/2012">2012</a></li><li><a href="http://blog.jverkamp.com/category/archives/2013">2013</a></li><li><a href="http://blog.jverkamp.com/category/archives/2014">2014</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/other" class="dropdown-toggle">Other<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/other/board-game-reviews">Board Game Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/cooking">Cooking</a></li><li><a href="http://blog.jverkamp.com/category/other/movie-reviews">Movie Reviews</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/photography" class="dropdown-toggle">Photography<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/photography/dp-challenge">DP Challenge</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosets">Photosets</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosynth">Photosynth</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/programming" class="dropdown-toggle">Programming<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/programming/by-language">By Language</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-project">By Project</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source">By Source</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/programming/libraries">Libraries</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/research" class="dropdown-toggle">Research<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/research/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/research/publications">Publications</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/writing" class="dropdown-toggle">Writing<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/writing/by-genre">By Genre</a></li><li><a href="http://blog.jverkamp.com/category/writing/nanowrimo">NaNoWriMo</a></li><li><a href="http://blog.jverkamp.com/category/writing/novels">Novels</a></li><li><a href="http://blog.jverkamp.com/category/writing/other">Other</a></li><li><a href="http://blog.jverkamp.com/category/writing/short-stories">Short Stories</a></li></ul></li></ul>

      <!--
      <form class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
        </header>

        <article class="container">
                <header>
                        <h1 class="entry-title">Dodgson’s Doublets</h1>

                        <div class="entry-meta">
                                <span class="posted-on"><time class="entry-date" datetime="2012-10-14"><span class="year">2012</span> <span class="month">Oct</span> <span class="day">14</span></time></span>
                                <span class="tags"><ul class="tag-list list-inline"><li><a href="http://blog.jverkamp.com/category/programming/by-source/programming-praxis">Programming Praxis</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/word-games">Word Games</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/scheme">Scheme</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a></li></ul></span>
                        </div>

                        <hr />
                </header>
                <div class="entry-content">
                        <p>Today we have <a href="http://programmingpraxis.com/2009/03/20/dodgsons-doublets/" title="Programming Praxis: Dodgson's Doublets">another post</a> from Programming Praxis' <a href="http://programmingpraxis.com/contents/themes/#Word Games" title="Programming Praxis: Word Games">Word Games</a>. This time, it's a puzzle inspired by <a href="https://en.wikipedia.org/wiki/Lewis_Carroll">Lewis Carroll</a> (author of <a href="https://en.wikipedia.org/wiki/Alice_in Wonderland">Alice in Wonderland</a>). The goal is, given a pair or words of the same length, find a path between the words, changing one letter at a time. Something like this:</p>
<pre>H E A D
h e a l
t e a l
t e l l
t a l l
T A I L</pre>
<!--more-->
<p>If you'd like to follow along, the full source code is available here: <a href='https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt'>doublets source code</a>, <a href='https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt'>dictionary source code</a>, <a href='https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt'>queue source code</a>.</p>
<p>Using the same source code as the previous two posts (<a href="http://blog.jverkamp.com/2012/10/11/squaring-the-bishop">here</a> and <a href="http://blog.jverkamp.com/2012/10/13/word-cubes">here</a>, described originally <a href="http://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket">here</a>) for the dictionary, the code is a pretty straight forward case of using <a href="https://en.wikipedia.org/wiki/recursion">recursion</a> to do <a href="https://en.wikipedia.org/wiki/backtracking">backtracking</a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:</p>
<pre class="scheme"><code>; find the path between two words, changing one letters at a time
; use call/cc to bail out when we find an answer
(define (direct-doublet dict src dst)
  (call/cc
   (λ (exit)
     (let ([src (string-upcase src)]
           [dst (string-upcase dst)])
       ; loop down possible solutions
       (let loop ([current src] [words (list src)])
         ; when we find one, bail out entirely
         (if (equal? current dst)
             (exit (reverse words))
             ; try all possible values
             (for*/list ([i (string-length src)]
                         [c "ABCDEFGHIJKLMNOPQRSTUVWXYZ"])
               (let ([next (string-set current i c)])
                 (when (and (not (member next words))
                            (contains? dict next))
                   (loop next (cons next words))))))))
     (exit #f))))</code></pre>
<p>Basically, I'm using a neat trick I last used on the post about <a href="http://blog.jverkamp.com/2012/08/27/4sum">4SUM</a> where <code>call/cc</code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it's a simple matter of using <code>for*</code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we've seen before in this path), keep going. Eventually, we'll find a solution and can bail out. On the off chance that we don't, return <code>#f</code>.</p>
<p>(Side note: <code>string-set</code> is a functional version of <code>string-set!</code> that returns a new string rather than mutating the previous one in place. It's easy enough to implement or can see a version of it in the <a href='https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt'>full source</a>.)</p>
<p>It works well enough, but there is one bit of an issue. This one performs a depth first search, following one path all of the way until it finds a solution or a dead end. Unfortunately, there are a *lot* of paths that we can take without getting close to a solution. Let's see if we can't do better.</p>
<p>This time, I'm going to use a simple greedy heuristic to control the solution. It's still depth first, but this time, we're going to try the words that are closest to the target first (with a small bit of random wiggle to break up equally likely solutions). Here's the differencing function:</p>
<pre class="scheme"><code>; calculate the difference between two strings
(define (string-diff s1 s2)
  (+ (random)
     (for/sum ([c1 s1] [c2 s2])
       (abs (- (char-&gt;integer c1) (char-&gt;integer c2))))))</code></pre>
<p>With that, we can work out the solution:</p>
<pre class="scheme"><code>; find the path between two words, changing one letters at a time
; use call/cc to bail out when we find an answer
(define (doublet dict src dst)
  (call/cc
   (λ (exit)
     (let ([src (string-upcase src)]
           [dst (string-upcase dst)])
       ; loop recursively
       (let loop ([current src] [words (list src)])
         ; bail when we find any solution
         (if (equal? current dst)
             (exit (reverse words))
             ; find all of the next steps
             (let ([nexts
                    (for*/list ([i (string-length src)]
                                [c "ABCDEFGHIJKLMNOPQRSTUVWXYZ"]
                                #:when
                                (let ([next (string-set current i c)])
                                  (and (not (member next words))
                                       (contains? dict next))))
                      (string-set current i c))])
               ; sort by distance to the final solution, recur in that order
               (for ([next (sort nexts (λ (w1 w2) (&lt; (string-diff w1 dst)
                                                     (string-diff w2 dst))))])
                 (loop next (cons next words)))))))
     (exit #f))))</code></pre>
<p>This time we use <code>for*/list</code> instead of <code>for*</code> as we actually want to return the possible next words. We then sort them by their distance from the target and use that for the branching. It's quite a bit faster, actually solving the suggested one on Programming Praxis where they want a path from <code>BLACK</code> to <code>WHITE</code> (actually rather fast, solving it in only 16ms).</p>
<p>Faster, but it's still not quite optimal. The paths returned are nowhere near the shortest they could be. So let's take a totally different track. What we need is a breadth first search. We're going to keep a queue of solutions, at each loop adding any new branches to the end and taking the next try from the beginning. This will guarantee that the found solution is as short as possible.</p>
<p>Unfortunately, the code isn't nearly as functional as the previous solutions. To share a queue between the various branches, we need a mutable queue. Here's something that I wrote up quicklike to make it happen:</p>
<pre class="scheme"><code>; opaque structure for the queue
(define-struct :queue: (values head tail) #:mutable)

; create a new queue
(define (make-queue) (make-:queue: (make-hasheq) 0 0))

; test if the queue is empty
(define (queue-empty? q)
  (= (:queue:-head q) (:queue:-tail q)))

; push an item onto the queue
(define (queue-push! q v)
  (hash-set! (:queue:-values q) (:queue:-tail q) v)
  (set-:queue:-tail! q (+ 1 (:queue:-tail q))))

; pop an item from the queue and return
(define (queue-pop! q)
  (let ([v (hash-ref (:queue:-values q) (:queue:-head q))])
    (hash-remove! (:queue:-values q) (:queue:-head q))
    (set-:queue:-head! q (+ 1 (:queue:-head q)))
    v))</code></pre>
<p>Perhaps it's not the most efficient, but it does work well enough. You can get the full source code: <a href='https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt'>queue source code</a>. Here's a solution to doublet that uses it:</p>
<pre class="scheme"><code>; find the path between two words, using a queue
; values in the queue are (current, path)
(define (breadth-doublet dict src dst)
  (call/cc
   (λ (exit)
     (let ([src (string-upcase src)]
           [dst (string-upcase dst)]
           [q (make-queue)])
       ; start with just the initial solution
       (queue-push! q (list src (list src)))
       ; loop as long as the queue isn't empty, popping the first each time
       (let loop ()
         (when (not (queue-empty? q))
           (let* ([next (queue-pop! q)]
                  [curr (car next)]
                  [wrds (cadr next)])
             ; if we find a solution, it's optimal
             (if (equal? curr dst)
                 (exit (reverse wrds))
                 (begin
                   ; find all next steps, push them onto the queue
                   (for* ([i (string-length src)]
                          [c "ABCDEFGHIJKLMNOPQRSTUVWXYZ"])
                     (let ([next (string-set curr i c)])
                       (when (and (not (member next wrds))
                                  (contains? dict next))
                         (queue-push! q (list next (cons next wrds))))))
                   (loop)))))))
     (exit #f))))</code></pre>
<p>Most of the structure looks about the same with the same internal loop generating next words. The difference this time is that the new solutions are added to the queue and the next solution is popped from the queue.</p>
<p>Let's see what sort of answers we get:</p>
<pre class="scheme"><code>&gt; (time (doublet dict "head" "tail"))
cpu time: 15 real time: 17 gc time: 0
'("HEAD" "READ" "REAL" "REEL" "REEK" "SEEK"
  "SEEM" "TEEM" "TEEN" "SEEN" "WEEN" "WEEK"
  "PEEK" "PEEL" "PEEN" "PEEP" "SEEP" "VEEP"
  "WEEP" "WEED" "TEED" "TEES" "TEDS" "TADS"
  "TAGS" "SAGS" "SAGO" "SAGE" "SAKE" "TAKE"
  "TALE" "TALL" "TAIL")

&gt; (time (breadth-doublet dict "head" "tail"))
cpu time: 5070 real time: 5344 gc time: 1170
'("HEAD" "HEAL" "HEIL" "HAIL" "TAIL")

&gt; (time (doublet dict "black" "white"))
cpu time: 15 real time: 9 gc time: 0
'("BLACK" "SLACK" "SLICK" "SLINK" "SLING" "STING"
  "SUING" "RUING" "RUINS" "REINS" "VEINS" "ZEINS"
  "PEINS" "PAINS" "PAINE" "MAINE" "MAINS" "WAINS"
  "WAITS" "WHITS" "WHITE")

&gt; (time (breadth-doublet dict "black" "white"))
cpu time: 58890 real time: 62141 gc time: 16380
'("BLACK" "CLACK" "CLICK" "CHICK" "CHINK" "CHINE" "WHINE" "WHITE")
</code></pre>
<p>As one might expect, the depth first solution is much faster when it finds a solution but the solutions aren't optimal. The breadth first solution finds the shortest solution (or at least one tied for it, it actually found a better solution than the one given in the original description of the problem), but takes much longer.</p>
<p>The breadth first solution also eats up quite a lot more memory, possibly owning to my implementation of the queue. I had to up the memory allocated to Racket to get it to run, although only to 256 MB and only for the <code>BLACK</code>/<code>WHITE</code> case. Still, none too shabby.</p>
<p>If you'd like to see the full source code, click here: <a href='https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt'>doublets source code</a>, <a href='https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt'>dictionary source code</a>, <a href='https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt'>queue source code</a>. It runs in <a href="http://racket-lang.org" title="(((λ Racket)))">Racket 5.3+</a>.</p>
                </div>
                <div class="entry-footnotes">
                        <div id="footnotes"><ol></ol></div>
                </div>

                <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "jverkamp";
var disqus_title = "Dodgson’s Doublets";
var disqus_url = "http://blog.jverkamp.com/2012/10/14/dodgsons-doublets/";
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </article>

        <footer class="container" role="contentinfo">
                <nav class="navbar navbar-default" role="navigation"><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2012/10/13/word-cubes">← Word cubes</a></li><li><a href="http://blog.jverkamp.com/category/archives">Archives</a></li><li><a href="http://blog.jverkamp.com/2012/10/15/chopping-words">Chopping words →</a></li></ul><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2012/10/13/word-cubes">← Word cubes</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/2012/10/15/chopping-words">Chopping words →</a></li></ul></nav>

                <div class="legal">
                        All posts unless otherwise mentioned are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
                        Any source code unless otherwise mentioned is licensed under the <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
                </div>
        </footer>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53688146-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>