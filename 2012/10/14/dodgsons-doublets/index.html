<!doctype html><html><head><title>Dodgson’s Doublets – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Dodgson’s Doublets</h1><div class=entry-meta><span class=entry-date>2012-10-14</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/word-games>Word Games</a><a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/13/word-cubes/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/15/chopping-words/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Today we have <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt target=_blank rel=noopener>doublets source code</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt target=_blank rel=noopener>dictionary source code</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt target=_blank rel=noopener>queue source code</a>.</p><p>Using the same source code as the previous two posts (<a href=https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/>here</a> and <a href=https://blog.jverkamp.com/2012/10/13/word-cubes/>here</a>, described originally <a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/>here</a>) for the dictionary, the code is a pretty straight forward case of using <a href=https://en.wikipedia.org/wiki/recursion>recursion</a> to do <a href=https://en.wikipedia.org/wiki/backtracking>backtracking</a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; find the path between two words, changing one letters at a time</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; use call/cc to bail out when we find an answer</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>direct-doublet</span> dict src dst)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>call/cc</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>exit</span>)
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>([src (<span style=color:#a6e22e>string-upcase</span> src)]
</span></span><span style=display:flex><span>           [dst (<span style=color:#a6e22e>string-upcase</span> dst)])
</span></span><span style=display:flex><span>       <span style=color:#75715e>; loop down possible solutions</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>let </span>loop ([current src] [words (list src)])
</span></span><span style=display:flex><span>         <span style=color:#75715e>; when we find one, bail out entirely</span>
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>if </span>(equal? current dst)
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>exit</span> (reverse words))
</span></span><span style=display:flex><span>             <span style=color:#75715e>; try all possible values</span>
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>for*/list</span> ([i (string-length src)]
</span></span><span style=display:flex><span>                         [c <span style=color:#e6db74>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>])
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>let </span>([next (<span style=color:#a6e22e>string-set</span> current i c)])
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(not (member next words))
</span></span><span style=display:flex><span>                            (<span style=color:#a6e22e>contains?</span> dict next))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>loop</span> next (cons next words))))))))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>exit</span> <span style=color:#66d9ef>#f</span>))))
</span></span></code></pre></div><p>Basically, I&rsquo;m using a neat trick I last used on the post about <a href=https://blog.jverkamp.com/2012/08/27/4sum/>4SUM</a> where <code>call/cc</code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it&rsquo;s a simple matter of using <code>for*</code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we&rsquo;ve seen before in this path), keep going. Eventually, we&rsquo;ll find a solution and can bail out. On the off chance that we don&rsquo;t, return <code>#f</code>.</p><p>(Side note: <code>string-set</code> is a functional version of <code>string-set!</code> that returns a new string rather than mutating the previous one in place. It&rsquo;s easy enough to implement or can see a version of it in the <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt target=_blank rel=noopener>full source</a>.)</p><p>It works well enough, but there is one bit of an issue. This one performs a depth first search, following one path all of the way until it finds a solution or a dead end. Unfortunately, there are a <em>lot</em> of paths that we can take without getting close to a solution. Let&rsquo;s see if we can&rsquo;t do better.</p><p>This time, I&rsquo;m going to use a simple greedy heuristic to control the solution. It&rsquo;s still depth first, but this time, we&rsquo;re going to try the words that are closest to the target first (with a small bit of random wiggle to break up equally likely solutions). Here&rsquo;s the differencing function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; calculate the difference between two strings</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>string-diff</span> s1 s2)
</span></span><span style=display:flex><span>  (+ (<span style=color:#a6e22e>random</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>for/sum</span> ([c1 s1] [c2 s2])
</span></span><span style=display:flex><span>       (abs (- (char-&gt;integer c1) (char-&gt;integer c2))))))
</span></span></code></pre></div><p>With that, we can work out the solution:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; find the path between two words, changing one letters at a time</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; use call/cc to bail out when we find an answer</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>doublet</span> dict src dst)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>call/cc</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>exit</span>)
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>([src (<span style=color:#a6e22e>string-upcase</span> src)]
</span></span><span style=display:flex><span>           [dst (<span style=color:#a6e22e>string-upcase</span> dst)])
</span></span><span style=display:flex><span>       <span style=color:#75715e>; loop recursively</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>let </span>loop ([current src] [words (list src)])
</span></span><span style=display:flex><span>         <span style=color:#75715e>; bail when we find any solution</span>
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>if </span>(equal? current dst)
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>exit</span> (reverse words))
</span></span><span style=display:flex><span>             <span style=color:#75715e>; find all of the next steps</span>
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>let </span>([nexts
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>for*/list</span> ([i (string-length src)]
</span></span><span style=display:flex><span>                                [c <span style=color:#e6db74>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>]
</span></span><span style=display:flex><span>                                <span style=color:#f92672>#</span>:when
</span></span><span style=display:flex><span>                                (<span style=color:#66d9ef>let </span>([next (<span style=color:#a6e22e>string-set</span> current i c)])
</span></span><span style=display:flex><span>                                  (<span style=color:#66d9ef>and </span>(not (member next words))
</span></span><span style=display:flex><span>                                       (<span style=color:#a6e22e>contains?</span> dict next))))
</span></span><span style=display:flex><span>                      (<span style=color:#a6e22e>string-set</span> current i c))])
</span></span><span style=display:flex><span>               <span style=color:#75715e>; sort by distance to the final solution, recur in that order</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>for</span> ([next (<span style=color:#a6e22e>sort</span> nexts (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>w1</span> w2) (&lt; (<span style=color:#a6e22e>string-diff</span> w1 dst)
</span></span><span style=display:flex><span>                                                     (<span style=color:#a6e22e>string-diff</span> w2 dst))))])
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>loop</span> next (cons next words)))))))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>exit</span> <span style=color:#66d9ef>#f</span>))))
</span></span></code></pre></div><p>This time we use <code>for*/list</code> instead of <code>for*</code> as we actually want to return the possible next words. We then sort them by their distance from the target and use that for the branching. It&rsquo;s quite a bit faster, actually solving the suggested one on Programming Praxis where they want a path from <code>BLACK</code> to <code>WHITE</code> (actually rather fast, solving it in only 16ms).</p><p>Faster, but it&rsquo;s still not quite optimal. The paths returned are nowhere near the shortest they could be. So let&rsquo;s take a totally different track. What we need is a breadth first search. We&rsquo;re going to keep a queue of solutions, at each loop adding any new branches to the end and taking the next try from the beginning. This will guarantee that the found solution is as short as possible.</p><p>Unfortunately, the code isn&rsquo;t nearly as functional as the previous solutions. To share a queue between the various branches, we need a mutable queue. Here&rsquo;s something that I wrote up quicklike to make it happen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; opaque structure for the queue</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>define-struct</span> :queue: (values head tail) <span style=color:#f92672>#</span>:mutable)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; create a new queue</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-queue</span>) (<span style=color:#a6e22e>make-:queue:</span> (<span style=color:#a6e22e>make-hasheq</span>) <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; test if the queue is empty</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>queue-empty?</span> q)
</span></span><span style=display:flex><span>  (= (<span style=color:#a6e22e>:queue:-head</span> q) (<span style=color:#a6e22e>:queue:-tail</span> q)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; push an item onto the queue</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>queue-push!</span> q v)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-set!</span> (<span style=color:#a6e22e>:queue:-values</span> q) (<span style=color:#a6e22e>:queue:-tail</span> q) v)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>set-:queue:-tail!</span> q (+ <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>:queue:-tail</span> q))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; pop an item from the queue and return</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>queue-pop!</span> q)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([v (<span style=color:#a6e22e>hash-ref</span> (<span style=color:#a6e22e>:queue:-values</span> q) (<span style=color:#a6e22e>:queue:-head</span> q))])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>hash-remove!</span> (<span style=color:#a6e22e>:queue:-values</span> q) (<span style=color:#a6e22e>:queue:-head</span> q))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>set-:queue:-head!</span> q (+ <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>:queue:-head</span> q)))
</span></span><span style=display:flex><span>    v))
</span></span></code></pre></div><p>Perhaps it&rsquo;s not the most efficient, but it does work well enough. You can get the full source code: <a href=https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt target=_blank rel=noopener>queue source code</a>. Here&rsquo;s a solution to doublet that uses it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; find the path between two words, using a queue</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; values in the queue are (current, path)</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>breadth-doublet</span> dict src dst)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>call/cc</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>exit</span>)
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>([src (<span style=color:#a6e22e>string-upcase</span> src)]
</span></span><span style=display:flex><span>           [dst (<span style=color:#a6e22e>string-upcase</span> dst)]
</span></span><span style=display:flex><span>           [q (<span style=color:#a6e22e>make-queue</span>)])
</span></span><span style=display:flex><span>       <span style=color:#75715e>; start with just the initial solution</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>queue-push!</span> q (list src (list src)))
</span></span><span style=display:flex><span>       <span style=color:#75715e>; loop as long as the queue isn&#39;t empty, popping the first each time</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>let </span>loop ()
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>when</span> (not (<span style=color:#a6e22e>queue-empty?</span> q))
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>let* </span>([next (<span style=color:#a6e22e>queue-pop!</span> q)]
</span></span><span style=display:flex><span>                  [curr (car next)]
</span></span><span style=display:flex><span>                  [wrds (cadr next)])
</span></span><span style=display:flex><span>             <span style=color:#75715e>; if we find a solution, it&#39;s optimal</span>
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>if </span>(equal? curr dst)
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>exit</span> (reverse wrds))
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>begin</span>
</span></span><span style=display:flex><span>                   <span style=color:#75715e>; find all next steps, push them onto the queue</span>
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>for*</span> ([i (string-length src)]
</span></span><span style=display:flex><span>                          [c <span style=color:#e6db74>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>])
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>let </span>([next (<span style=color:#a6e22e>string-set</span> curr i c)])
</span></span><span style=display:flex><span>                       (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(not (member next wrds))
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>contains?</span> dict next))
</span></span><span style=display:flex><span>                         (<span style=color:#a6e22e>queue-push!</span> q (list next (cons next wrds))))))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>loop</span>)))))))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>exit</span> <span style=color:#66d9ef>#f</span>))))
</span></span></code></pre></div><p>Most of the structure looks about the same with the same internal loop generating next words. The difference this time is that the new solutions are added to the queue and the next solution is popped from the queue.</p><p>Let&rsquo;s see what sort of answers we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>doublet</span> dict <span style=color:#e6db74>&#34;head&#34;</span> <span style=color:#e6db74>&#34;tail&#34;</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>15</span> real time: <span style=color:#ae81ff>17</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;HEAD&#34;</span> <span style=color:#e6db74>&#34;READ&#34;</span> <span style=color:#e6db74>&#34;REAL&#34;</span> <span style=color:#e6db74>&#34;REEL&#34;</span> <span style=color:#e6db74>&#34;REEK&#34;</span> <span style=color:#e6db74>&#34;SEEK&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;SEEM&#34;</span> <span style=color:#e6db74>&#34;TEEM&#34;</span> <span style=color:#e6db74>&#34;TEEN&#34;</span> <span style=color:#e6db74>&#34;SEEN&#34;</span> <span style=color:#e6db74>&#34;WEEN&#34;</span> <span style=color:#e6db74>&#34;WEEK&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;PEEK&#34;</span> <span style=color:#e6db74>&#34;PEEL&#34;</span> <span style=color:#e6db74>&#34;PEEN&#34;</span> <span style=color:#e6db74>&#34;PEEP&#34;</span> <span style=color:#e6db74>&#34;SEEP&#34;</span> <span style=color:#e6db74>&#34;VEEP&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;WEEP&#34;</span> <span style=color:#e6db74>&#34;WEED&#34;</span> <span style=color:#e6db74>&#34;TEED&#34;</span> <span style=color:#e6db74>&#34;TEES&#34;</span> <span style=color:#e6db74>&#34;TEDS&#34;</span> <span style=color:#e6db74>&#34;TADS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;TAGS&#34;</span> <span style=color:#e6db74>&#34;SAGS&#34;</span> <span style=color:#e6db74>&#34;SAGO&#34;</span> <span style=color:#e6db74>&#34;SAGE&#34;</span> <span style=color:#e6db74>&#34;SAKE&#34;</span> <span style=color:#e6db74>&#34;TAKE&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;TALE&#34;</span> <span style=color:#e6db74>&#34;TALL&#34;</span> <span style=color:#e6db74>&#34;TAIL&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>breadth-doublet</span> dict <span style=color:#e6db74>&#34;head&#34;</span> <span style=color:#e6db74>&#34;tail&#34;</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>5070</span> real time: <span style=color:#ae81ff>5344</span> gc time: <span style=color:#ae81ff>1170</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;HEAD&#34;</span> <span style=color:#e6db74>&#34;HEAL&#34;</span> <span style=color:#e6db74>&#34;HEIL&#34;</span> <span style=color:#e6db74>&#34;HAIL&#34;</span> <span style=color:#e6db74>&#34;TAIL&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>doublet</span> dict <span style=color:#e6db74>&#34;black&#34;</span> <span style=color:#e6db74>&#34;white&#34;</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>15</span> real time: <span style=color:#ae81ff>9</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;BLACK&#34;</span> <span style=color:#e6db74>&#34;SLACK&#34;</span> <span style=color:#e6db74>&#34;SLICK&#34;</span> <span style=color:#e6db74>&#34;SLINK&#34;</span> <span style=color:#e6db74>&#34;SLING&#34;</span> <span style=color:#e6db74>&#34;STING&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;SUING&#34;</span> <span style=color:#e6db74>&#34;RUING&#34;</span> <span style=color:#e6db74>&#34;RUINS&#34;</span> <span style=color:#e6db74>&#34;REINS&#34;</span> <span style=color:#e6db74>&#34;VEINS&#34;</span> <span style=color:#e6db74>&#34;ZEINS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;PEINS&#34;</span> <span style=color:#e6db74>&#34;PAINS&#34;</span> <span style=color:#e6db74>&#34;PAINE&#34;</span> <span style=color:#e6db74>&#34;MAINE&#34;</span> <span style=color:#e6db74>&#34;MAINS&#34;</span> <span style=color:#e6db74>&#34;WAINS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;WAITS&#34;</span> <span style=color:#e6db74>&#34;WHITS&#34;</span> <span style=color:#e6db74>&#34;WHITE&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>breadth-doublet</span> dict <span style=color:#e6db74>&#34;black&#34;</span> <span style=color:#e6db74>&#34;white&#34;</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>58890</span> real time: <span style=color:#ae81ff>62141</span> gc time: <span style=color:#ae81ff>16380</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;BLACK&#34;</span> <span style=color:#e6db74>&#34;CLACK&#34;</span> <span style=color:#e6db74>&#34;CLICK&#34;</span> <span style=color:#e6db74>&#34;CHICK&#34;</span> <span style=color:#e6db74>&#34;CHINK&#34;</span> <span style=color:#e6db74>&#34;CHINE&#34;</span> <span style=color:#e6db74>&#34;WHINE&#34;</span> <span style=color:#e6db74>&#34;WHITE&#34;</span>)
</span></span></code></pre></div><p>As one might expect, the depth first solution is much faster when it finds a solution but the solutions aren&rsquo;t optimal. The breadth first solution finds the shortest solution (or at least one tied for it, it actually found a better solution than the one given in the original description of the problem), but takes much longer.</p><p>The breadth first solution also eats up quite a lot more memory, possibly owning to my implementation of the queue. I had to up the memory allocated to Racket to get it to run, although only to 256 MB and only for the <code>BLACK</code>/<code>WHITE</code> case. Still, none too shabby.</p><p>If you&rsquo;d like to see the full source code, click here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt target=_blank rel=noopener>doublets source code</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt target=_blank rel=noopener>dictionary source code</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt target=_blank rel=noopener>queue source code</a>. It runs in <a href=http://racket-lang.org title="(((λ Racket)))">Racket 5.3+</a>.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>