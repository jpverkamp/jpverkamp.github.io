<!DOCTYPE html>
<html onclick >
<head>
    <title>Dodgson’s Doublets – jverkamp.com</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8"><link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="//blog.jverkamp.com/feed/">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css" integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" />

<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel="stylesheet">

<link rel="stylesheet" href="/custom.css" defer />

    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
</head>
<body>
    <div id="wrapper"><header id="page-header" role="banner">
    <h1><a href="/">JP's Blog</a></h1>

    <ul id="page-header-links">
        <li>
            <a href="https://github.com/jpverkamp">GitHub</a> *
            <a href="https://www.flickr.com/photos/jpverkamp">Flickr</a> *
            <a href="/resume">Resume</a>
        </li>
        <li>
            <form action="//www.google.com/search" method="get" onsubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search" _lpchecked="1">
                <div class="form-group">
                    <input name="q" type="hidden">
                    <input name="qfront" type="text" class="form-control" placeholder="Search">
                    <button type="submit" class="btn btn-default" value="Search">Search</button>
                </div>
            </form>
        </li>
    </ul>

    <nav id="header-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation"><li><a href="https://blog.jverkamp.com/reviews/">Reviews</a></li><li><a href="https://blog.jverkamp.com/programming/">Programming</a></li><li><a href="https://blog.jverkamp.com/photography/">Photography</a></li><li><a href="https://blog.jverkamp.com/maker/">Maker</a></li><li><a href="https://blog.jverkamp.com/writing/">Writing</a></li><li><a href="https://blog.jverkamp.com/research/">Research</a></li><li class="subscription" data-subscription="rss"><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
        </ul>
    </nav>
</header>
<div id="page-content-wrapper">
            <div id="page-content"><article>
	<header>
		<h1 class="entry-title">Dodgson’s Doublets</h1>

        <div class="entry-meta"><span class="entry-date">2012-10-14</span>
            </div>

        <div class="entry-taxonomies"><div class="entry-tags"><ul class="taxonomy-keys"><li>
            <a class="taxonomy-key" href="/programming/languages/">Languages</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/racket">Racket</a><a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link"></a></li><li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/scheme">Scheme</a><a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/sources/">Sources</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link"></a><a class="taxonomy-value" href="/programming/sources/programming-praxis">Programming Praxis</a><a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/topics/">Topics</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/09/24/n-queens-in-18-lines-of-code/" class="previous-link"></a><a class="taxonomy-value" href="/programming/topics/backtracking">Backtracking</a><a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link"></a></li><li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link"></a><a class="taxonomy-value" href="/programming/topics/word-games">Word Games</a><a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link"></a></li></ul>
        </li><li><a class="taxonomy-key" href="/programming">programming</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link">Next</a></ul>
        </li><li><a class="taxonomy-key" href="/">All Posts</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2012/10/13/word-cubes/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2012/10/15/chopping-words/" class="next-link">Next</a></ul>
        </li></ul>
</div>
</div>
    </header>

	<div class="entry-content"><p>Today we have <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt">doublets source code</a>, <a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt">dictionary source code</a>, <a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt">queue source code</a>.</p>

<p>Using the same source code as the previous two posts (<a href="https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/">here</a> and <a href="https://blog.jverkamp.com/2012/10/13/word-cubes/">here</a>, described originally <a href="https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/">here</a>) for the dictionary, the code is a pretty straight forward case of using <a href="https://en.wikipedia.org/wiki/recursion">recursion</a> to do <a href="https://en.wikipedia.org/wiki/backtracking">backtracking</a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; find the path between two words, changing one letters at a time</span>
<span style="color:#75715e">; use call/cc to bail out when we find an answer</span>
(<span style="color:#66d9ef">define </span>(direct-doublet dict src dst)
  (call/cc
   (λ (exit)
     (<span style="color:#66d9ef">let </span>([src (string-upcase src)]
           [dst (string-upcase dst)])
       <span style="color:#75715e">; loop down possible solutions</span>
       (<span style="color:#66d9ef">let </span>loop ([current src] [words (list src)])
         <span style="color:#75715e">; when we find one, bail out entirely</span>
         (<span style="color:#66d9ef">if </span>(equal? current dst)
             (exit (reverse words))
             <span style="color:#75715e">; try all possible values</span>
             (for*/list ([i (string-length src)]
                         [c <span style="color:#e6db74">&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>])
               (<span style="color:#66d9ef">let </span>([next (string-set current i c)])
                 (when (<span style="color:#66d9ef">and </span>(not (member next words))
                            (contains? dict next))
                   (loop next (cons next words))))))))
     (exit <span style="color:#66d9ef">#f</span>))))</code></pre></div>
<p>Basically, I&rsquo;m using a neat trick I last used on the post about <a href="https://blog.jverkamp.com/2012/08/27/4sum/">4SUM</a> where <code>call/cc</code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it&rsquo;s a simple matter of using <code>for*</code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we&rsquo;ve seen before in this path), keep going. Eventually, we&rsquo;ll find a solution and can bail out. On the off chance that we don&rsquo;t, return <code>#f</code>.</p>

<p>(Side note: <code>string-set</code> is a functional version of <code>string-set!</code> that returns a new string rather than mutating the previous one in place. It&rsquo;s easy enough to implement or can see a version of it in the <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt">full source</a>.)</p>

<p>It works well enough, but there is one bit of an issue. This one performs a depth first search, following one path all of the way until it finds a solution or a dead end. Unfortunately, there are a <em>lot</em> of paths that we can take without getting close to a solution. Let&rsquo;s see if we can&rsquo;t do better.</p>

<p>This time, I&rsquo;m going to use a simple greedy heuristic to control the solution. It&rsquo;s still depth first, but this time, we&rsquo;re going to try the words that are closest to the target first (with a small bit of random wiggle to break up equally likely solutions). Here&rsquo;s the differencing function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; calculate the difference between two strings</span>
(<span style="color:#66d9ef">define </span>(string-diff s1 s2)
  (+ (random)
     (for/sum ([c1 s1] [c2 s2])
       (abs (- (char-&gt;integer c1) (char-&gt;integer c2))))))</code></pre></div>
<p>With that, we can work out the solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; find the path between two words, changing one letters at a time</span>
<span style="color:#75715e">; use call/cc to bail out when we find an answer</span>
(<span style="color:#66d9ef">define </span>(doublet dict src dst)
  (call/cc
   (λ (exit)
     (<span style="color:#66d9ef">let </span>([src (string-upcase src)]
           [dst (string-upcase dst)])
       <span style="color:#75715e">; loop recursively</span>
       (<span style="color:#66d9ef">let </span>loop ([current src] [words (list src)])
         <span style="color:#75715e">; bail when we find any solution</span>
         (<span style="color:#66d9ef">if </span>(equal? current dst)
             (exit (reverse words))
             <span style="color:#75715e">; find all of the next steps</span>
             (<span style="color:#66d9ef">let </span>([nexts
                    (for*/list ([i (string-length src)]
                                [c <span style="color:#e6db74">&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>]
                                <span style="color:#f92672">#</span>:when
                                (<span style="color:#66d9ef">let </span>([next (string-set current i c)])
                                  (<span style="color:#66d9ef">and </span>(not (member next words))
                                       (contains? dict next))))
                      (string-set current i c))])
               <span style="color:#75715e">; sort by distance to the final solution, recur in that order</span>
               (for ([next (sort nexts (λ (w1 w2) (&lt; (string-diff w1 dst)
                                                     (string-diff w2 dst))))])
                 (loop next (cons next words)))))))
     (exit <span style="color:#66d9ef">#f</span>))))</code></pre></div>
<p>This time we use <code>for*/list</code> instead of <code>for*</code> as we actually want to return the possible next words. We then sort them by their distance from the target and use that for the branching. It&rsquo;s quite a bit faster, actually solving the suggested one on Programming Praxis where they want a path from <code>BLACK</code> to <code>WHITE</code> (actually rather fast, solving it in only 16ms).</p>

<p>Faster, but it&rsquo;s still not quite optimal. The paths returned are nowhere near the shortest they could be. So let&rsquo;s take a totally different track. What we need is a breadth first search. We&rsquo;re going to keep a queue of solutions, at each loop adding any new branches to the end and taking the next try from the beginning. This will guarantee that the found solution is as short as possible.</p>

<p>Unfortunately, the code isn&rsquo;t nearly as functional as the previous solutions. To share a queue between the various branches, we need a mutable queue. Here&rsquo;s something that I wrote up quicklike to make it happen:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; opaque structure for the queue</span>
(define-struct :queue: (values head tail) <span style="color:#f92672">#</span>:mutable)

<span style="color:#75715e">; create a new queue</span>
(<span style="color:#66d9ef">define </span>(make-queue) (make-:queue: (make-hasheq) <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>))

<span style="color:#75715e">; test if the queue is empty</span>
(<span style="color:#66d9ef">define </span>(queue-empty? q)
  (= (:queue:-head q) (:queue:-tail q)))

<span style="color:#75715e">; push an item onto the queue</span>
(<span style="color:#66d9ef">define </span>(queue-push! q v)
  (hash-set! (:queue:-values q) (:queue:-tail q) v)
  (set-:queue:-tail! q (+ <span style="color:#ae81ff">1</span> (:queue:-tail q))))

<span style="color:#75715e">; pop an item from the queue and return</span>
(<span style="color:#66d9ef">define </span>(queue-pop! q)
  (<span style="color:#66d9ef">let </span>([v (hash-ref (:queue:-values q) (:queue:-head q))])
    (hash-remove! (:queue:-values q) (:queue:-head q))
    (set-:queue:-head! q (+ <span style="color:#ae81ff">1</span> (:queue:-head q)))
    v))</code></pre></div>
<p>Perhaps it&rsquo;s not the most efficient, but it does work well enough. You can get the full source code: <a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt">queue source code</a>. Here&rsquo;s a solution to doublet that uses it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; find the path between two words, using a queue</span>
<span style="color:#75715e">; values in the queue are (current, path)</span>
(<span style="color:#66d9ef">define </span>(breadth-doublet dict src dst)
  (call/cc
   (λ (exit)
     (<span style="color:#66d9ef">let </span>([src (string-upcase src)]
           [dst (string-upcase dst)]
           [q (make-queue)])
       <span style="color:#75715e">; start with just the initial solution</span>
       (queue-push! q (list src (list src)))
       <span style="color:#75715e">; loop as long as the queue isn&#39;t empty, popping the first each time</span>
       (<span style="color:#66d9ef">let </span>loop ()
         (when (not (queue-empty? q))
           (<span style="color:#66d9ef">let* </span>([next (queue-pop! q)]
                  [curr (car next)]
                  [wrds (cadr next)])
             <span style="color:#75715e">; if we find a solution, it&#39;s optimal</span>
             (<span style="color:#66d9ef">if </span>(equal? curr dst)
                 (exit (reverse wrds))
                 (begin
                   <span style="color:#75715e">; find all next steps, push them onto the queue</span>
                   (for* ([i (string-length src)]
                          [c <span style="color:#e6db74">&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>])
                     (<span style="color:#66d9ef">let </span>([next (string-set curr i c)])
                       (when (<span style="color:#66d9ef">and </span>(not (member next wrds))
                                  (contains? dict next))
                         (queue-push! q (list next (cons next wrds))))))
                   (loop)))))))
     (exit <span style="color:#66d9ef">#f</span>))))</code></pre></div>
<p>Most of the structure looks about the same with the same internal loop generating next words. The difference this time is that the new solutions are added to the queue and the next solution is popped from the queue.</p>

<p>Let&rsquo;s see what sort of answers we get:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (time (doublet dict <span style="color:#e6db74">&#34;head&#34;</span> <span style="color:#e6db74">&#34;tail&#34;</span>))
cpu time: <span style="color:#ae81ff">15</span> real time: <span style="color:#ae81ff">17</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;HEAD&#34;</span> <span style="color:#e6db74">&#34;READ&#34;</span> <span style="color:#e6db74">&#34;REAL&#34;</span> <span style="color:#e6db74">&#34;REEL&#34;</span> <span style="color:#e6db74">&#34;REEK&#34;</span> <span style="color:#e6db74">&#34;SEEK&#34;</span>
  <span style="color:#e6db74">&#34;SEEM&#34;</span> <span style="color:#e6db74">&#34;TEEM&#34;</span> <span style="color:#e6db74">&#34;TEEN&#34;</span> <span style="color:#e6db74">&#34;SEEN&#34;</span> <span style="color:#e6db74">&#34;WEEN&#34;</span> <span style="color:#e6db74">&#34;WEEK&#34;</span>
  <span style="color:#e6db74">&#34;PEEK&#34;</span> <span style="color:#e6db74">&#34;PEEL&#34;</span> <span style="color:#e6db74">&#34;PEEN&#34;</span> <span style="color:#e6db74">&#34;PEEP&#34;</span> <span style="color:#e6db74">&#34;SEEP&#34;</span> <span style="color:#e6db74">&#34;VEEP&#34;</span>
  <span style="color:#e6db74">&#34;WEEP&#34;</span> <span style="color:#e6db74">&#34;WEED&#34;</span> <span style="color:#e6db74">&#34;TEED&#34;</span> <span style="color:#e6db74">&#34;TEES&#34;</span> <span style="color:#e6db74">&#34;TEDS&#34;</span> <span style="color:#e6db74">&#34;TADS&#34;</span>
  <span style="color:#e6db74">&#34;TAGS&#34;</span> <span style="color:#e6db74">&#34;SAGS&#34;</span> <span style="color:#e6db74">&#34;SAGO&#34;</span> <span style="color:#e6db74">&#34;SAGE&#34;</span> <span style="color:#e6db74">&#34;SAKE&#34;</span> <span style="color:#e6db74">&#34;TAKE&#34;</span>
  <span style="color:#e6db74">&#34;TALE&#34;</span> <span style="color:#e6db74">&#34;TALL&#34;</span> <span style="color:#e6db74">&#34;TAIL&#34;</span>)

&gt; (time (breadth-doublet dict <span style="color:#e6db74">&#34;head&#34;</span> <span style="color:#e6db74">&#34;tail&#34;</span>))
cpu time: <span style="color:#ae81ff">5070</span> real time: <span style="color:#ae81ff">5344</span> gc time: <span style="color:#ae81ff">1170</span>
<span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;HEAD&#34;</span> <span style="color:#e6db74">&#34;HEAL&#34;</span> <span style="color:#e6db74">&#34;HEIL&#34;</span> <span style="color:#e6db74">&#34;HAIL&#34;</span> <span style="color:#e6db74">&#34;TAIL&#34;</span>)

&gt; (time (doublet dict <span style="color:#e6db74">&#34;black&#34;</span> <span style="color:#e6db74">&#34;white&#34;</span>))
cpu time: <span style="color:#ae81ff">15</span> real time: <span style="color:#ae81ff">9</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;BLACK&#34;</span> <span style="color:#e6db74">&#34;SLACK&#34;</span> <span style="color:#e6db74">&#34;SLICK&#34;</span> <span style="color:#e6db74">&#34;SLINK&#34;</span> <span style="color:#e6db74">&#34;SLING&#34;</span> <span style="color:#e6db74">&#34;STING&#34;</span>
  <span style="color:#e6db74">&#34;SUING&#34;</span> <span style="color:#e6db74">&#34;RUING&#34;</span> <span style="color:#e6db74">&#34;RUINS&#34;</span> <span style="color:#e6db74">&#34;REINS&#34;</span> <span style="color:#e6db74">&#34;VEINS&#34;</span> <span style="color:#e6db74">&#34;ZEINS&#34;</span>
  <span style="color:#e6db74">&#34;PEINS&#34;</span> <span style="color:#e6db74">&#34;PAINS&#34;</span> <span style="color:#e6db74">&#34;PAINE&#34;</span> <span style="color:#e6db74">&#34;MAINE&#34;</span> <span style="color:#e6db74">&#34;MAINS&#34;</span> <span style="color:#e6db74">&#34;WAINS&#34;</span>
  <span style="color:#e6db74">&#34;WAITS&#34;</span> <span style="color:#e6db74">&#34;WHITS&#34;</span> <span style="color:#e6db74">&#34;WHITE&#34;</span>)

&gt; (time (breadth-doublet dict <span style="color:#e6db74">&#34;black&#34;</span> <span style="color:#e6db74">&#34;white&#34;</span>))
cpu time: <span style="color:#ae81ff">58890</span> real time: <span style="color:#ae81ff">62141</span> gc time: <span style="color:#ae81ff">16380</span>
<span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;BLACK&#34;</span> <span style="color:#e6db74">&#34;CLACK&#34;</span> <span style="color:#e6db74">&#34;CLICK&#34;</span> <span style="color:#e6db74">&#34;CHICK&#34;</span> <span style="color:#e6db74">&#34;CHINK&#34;</span> <span style="color:#e6db74">&#34;CHINE&#34;</span> <span style="color:#e6db74">&#34;WHINE&#34;</span> <span style="color:#e6db74">&#34;WHITE&#34;</span>)</code></pre></div>
<p>As one might expect, the depth first solution is much faster when it finds a solution but the solutions aren&rsquo;t optimal. The breadth first solution finds the shortest solution (or at least one tied for it, it actually found a better solution than the one given in the original description of the problem), but takes much longer.</p>

<p>The breadth first solution also eats up quite a lot more memory, possibly owning to my implementation of the queue. I had to up the memory allocated to Racket to get it to run, although only to 256 MB and only for the <code>BLACK</code>/<code>WHITE</code> case. Still, none too shabby.</p>

<p>If you&rsquo;d like to see the full source code, click here: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt">doublets source code</a>, <a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt">dictionary source code</a>, <a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt">queue source code</a>. It runs in <a href="http://racket-lang.org" title="(((λ Racket)))">Racket 5.3+</a>.</p>
</div>
</article></div>
        </div><footer id="page-footer" role="contentinfo">
    <nav id="footer-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation">
            <li><a href="/archive-by-date/">All posts: By Date</a></li>
            <li><a href="/archive-by-tag/">All posts: By Tag</a></li>

            <li>
                <a href="/atom.xml">
                    RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li><li>
                <a href="/programming/atom.xml">
                    RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li></ul>
    </nav>

    <div id="page-footer-content">
        <div class="legal">
            <p>
                All posts unless otherwise mentioned are licensed under
                <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">
                    <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png">
                </a>
            </p>

            <p>
                Any source code unless otherwise mentioned is licensed under the <a href="//directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
            </p>
        </div>
    </div>
</footer>
</div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js" integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js" integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin="anonymous"></script>

<script src="/custom.js"></script>
</body>
</html>
