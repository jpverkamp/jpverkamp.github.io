<!doctype html><html><head><title>Chopping words – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js integrity="sha256-MESIkqofkenEy1SU5cXlq8E7d3jed4blJWzcfSQkgTo=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.1a5fbab1ecff843d4ee6e936243fb06066197cd8c9357883d791333ce6001f3b.css integrity="sha256-Gl+6sez/hD1O5uk2JD+wYGYZfNjJNXiD15EzPOYAHzs="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Chopping words</h1><div class=entry-meta><span class=entry-date>2012-10-15</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2013/03/28/path-to-philosophy/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/word-games>Word Games</a><a href=https://blog.jverkamp.com/2013/02/06/numbers-as-words-in-arbitrary-bases/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/17/rule-30-rng/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/16/a-sea-of-stars-ch.-15-artifact/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p><a title="Programming Praxis: Chopping Words" href=http://programmingpraxis.com/2012/07/03/chopping-words/>One more challenge</a> from Programming Praxis&rsquo; <a title="Programming Praxis: Themes: Word Games" href="http://programmingpraxis.com/contents/themes/#Word Games">Word Games</a> today (there are only a few left!). This time we have the challenge of cutting off bits of words, one letter at a time, such that each step is still a word.</p><p>The example given in their post is <code>planet → plane → plan → pan → an → a</code>, although surely many such examples exist.</p><p>This one looks really simple on the surface&ndash;use the same backtracking algorithms that we&rsquo;ve been using all along with the <a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/>dictionary code</a> previously described to verify words at each step. Let&rsquo;s see if it really is that simple.</p><p>First, we want to be able to cut a single character out of a string, leaving the rest untouched. Basically, choose a random character in the string. Then make a new string, copying letters from before the random character directly and those after offset by one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; chop a given character from a string</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>chop</span> s i)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>list-&gt;string</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/list</span> ([n (string-length r)])
</span></span><span style=display:flex><span>     (string-ref s (<span style=color:#66d9ef>if </span>(&lt; n i) n (+ n <span style=color:#ae81ff>1</span>))))))
</span></span></code></pre></div><p>Now we can solve the problem. I&rsquo;m going for a slightly more in depth problem; rather than just finding one such chain of words, I want to find all of them. The idea is to start at each level by finding the strings with one letter chopped that are still words. For each of those recur. By the power of recursion, you should either get a tree of chopped words from that point or an empty list. If you get the former, add our word to it; the latter, pass the empty list along.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; repeatedly chop so long as all chops are words</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>chopping-words</span> dict word)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>(= <span style=color:#ae81ff>1</span> (string-length word))
</span></span><span style=display:flex><span>      (list word)
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>let </span>([recur (<span style=color:#a6e22e>for/fold</span> ([ans <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>                             ([i (string-length word)]
</span></span><span style=display:flex><span>                              <span style=color:#f92672>#</span>:when (<span style=color:#a6e22e>contains?</span> dict (<span style=color:#a6e22e>chop</span> word i)))
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>let </span>([each (<span style=color:#a6e22e>chopping-words</span> dict (<span style=color:#a6e22e>chop</span> word i))])
</span></span><span style=display:flex><span>                       (<span style=color:#66d9ef>if </span>(null? each)
</span></span><span style=display:flex><span>                           ans
</span></span><span style=display:flex><span>                           (cons each ans))))])
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>if </span>(null? recur)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>            (cons word recur)))))
</span></span></code></pre></div><p>Seems sensible enough. The <code>for/fold</code> is an interesting construct that I hadn&rsquo;t used before, but it&rsquo;s not too bad. Basically, instead of just the looping variables of a normal <code>for</code>, you have a first block storing the accumulators&ndash;in this case <code>ans</code>. Each iteration of the loop should return the next value (or <code>values</code>) for the accumulators(s). Add in the case at the end for either building the tree or passing the empty list up the chain and you&rsquo;re good to go.</p><p>Let&rsquo;s try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>chopping-words</span> dict <span style=color:#e6db74>&#34;PLANET&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;PLANET&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>&#34;PLANE&#34;</span>
</span></span><span style=display:flex><span>   (<span style=color:#e6db74>&#34;PLAN&#34;</span> (<span style=color:#e6db74>&#34;PAN&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AN&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>))))
</span></span><span style=display:flex><span>   (<span style=color:#e6db74>&#34;PANE&#34;</span> (<span style=color:#e6db74>&#34;PAN&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AN&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)))))
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>&#34;PLANT&#34;</span>
</span></span><span style=display:flex><span>   (<span style=color:#e6db74>&#34;PLAN&#34;</span> (<span style=color:#e6db74>&#34;PAN&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AN&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>))))
</span></span><span style=display:flex><span>   (<span style=color:#e6db74>&#34;PLAT&#34;</span> (<span style=color:#e6db74>&#34;PAT&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AT&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>))))
</span></span><span style=display:flex><span>   (<span style=color:#e6db74>&#34;PANT&#34;</span>
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#34;PAN&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AN&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#34;PAT&#34;</span> (<span style=color:#e6db74>&#34;PA&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AT&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#34;ANT&#34;</span> (<span style=color:#e6db74>&#34;AN&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>)) (<span style=color:#e6db74>&#34;AT&#34;</span> (<span style=color:#e6db74>&#34;A&#34;</span>))))))
</span></span></code></pre></div><p>Looks pretty good. 😄 As you may have guessed, you&rsquo;re going to need a word containing either <code>A</code> or <code>I</code> for there to be a valid tree at all. Still, pretty neat though. An even more interesting trick would be to generate a graph rather than a tree, branching out from the initial word and eventually collapsing back into the one or two final states. In this case, there would be a single final state and only three states before that: <code>PA</code>, <code>AN</code>, and <code>AT</code>. Perhaps we&rsquo;ll leave that for another day.</p><p>The code is short enough today that I don&rsquo;t have a full source code download. You can just copy/paste the code into Racket to try it out for yourself. Don&rsquo;t forget the <code>(require "[dictionary.rkt](https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/)")</code> line though, otherwise <code>contains?</code> isn&rsquo;t likely to work so well. 😄</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>