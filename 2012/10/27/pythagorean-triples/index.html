<!doctype html><html><head><title>Pythagorean Triples â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.7a29c6e86e28b6da48d6e8a526f4fa597dfba1464ca3f975ea9e0fb8c00052b7.css integrity="sha256-einG6G4ottpI1uilJvT6WX37oUZMo/l16p4PuMAAUrc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Pythagorean Triples</h1><div class=entry-meta><span class=entry-date>2012-10-27</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/10/29/bitvectors-in-racket/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/29/bitvectors-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/10/31/pandigital-sums/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a><a href=https://blog.jverkamp.com/2012/10/31/pandigital-sums/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/25/determining-country-by-latitude/longitude/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/29/bitvectors-in-racket/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/26/a-sea-of-stars-ch.-18-daedalus/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/28/starfall/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>When Programming Praxis mentioned that the <a href=http://programmingpraxis.com/2012/10/26/pythagorean-triples/ title="Programming Praxis: Pythagorean Triples">newest challenge</a> sounded like a <a href=http://projecteuler.net/ title="Project Euler">Project Euler</a> problem, they were&rsquo;t wrong. Basically, the idea is to count the number of <a href=https://en.wikipedia.org/wiki/Pythagorean%20Triples>Pythagorean Triples</a> with perimeters (sum of the three numbers) under a given value. The necessary code to brute force the problem is really straight forward, but then they asked for the count up to one million. With the brute force <span class=latex-inline>O(n^2)</span>
algorithm (and a relatively high constant), that&rsquo;s not really feasible. So that&rsquo;s when we have to get a bit more creative.</p><p>First, how about that brute force solution I promised:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>brute-count-triples-under</span> sum)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>count <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for*</span> ([a (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> sum)]
</span></span><span style=display:flex><span>         [b (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> a)]
</span></span><span style=display:flex><span>         <span style=color:#f92672>#</span>:when (<span style=color:#66d9ef>let </span>([c (sqrt (+ (* a a) (* b b)))])
</span></span><span style=display:flex><span>                  (<span style=color:#66d9ef>and </span>(&lt;= (+ a b c) sum)
</span></span><span style=display:flex><span>                       (integer? c))))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>set! </span>count (+ count <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>  count)
</span></span></code></pre></div><p>The basic idea is calculate every a and b such that a &lt; b and such that <span class=latex-inline>c = \sqrt{a^2 + b^2}</span>
for some integer c and the sum a+b+c is less than the target. Simple enough, how does that work out?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>brute-count-triples-under</span> <span style=color:#ae81ff>100</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>8</span> real time: <span style=color:#ae81ff>5</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>17</span>
</span></span></code></pre></div><p>And pretty fast too. But if we try to run longer examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>brute-count-triples-under</span> <span style=color:#ae81ff>1000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>584</span> real time: <span style=color:#ae81ff>585</span> gc time: <span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>325</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>brute-count-triples-under</span> <span style=color:#ae81ff>10000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>54687</span> real time: <span style=color:#ae81ff>54840</span> gc time: <span style=color:#ae81ff>1348</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4858</span>
</span></span></code></pre></div><p>Yeah, I don&rsquo;t really want to try that on one million. So we need a faster algorithm. Luckily, you don&rsquo;t have to try all of the possible ways that could generate a triple&ndash;it turns out there are algorithms to <a href=https://en.wikipedia.org/wiki/Formulas%20for%20generating%20Pythagorean%20triples>do it for you</a>. One in particularly came from a British math professor A. Hall in the paper <em><a href="http://www.jstor.org/discover/10.2307/3613860?uid=2&uid=4&sid=21101204896923" title="Genealogy of Pythagorean Triads">Genealogy of Pythagorean Triads</a></em> which showed that given any primitive Pythagorean triple (one that is not a multiple of another, smaller triple), you can produce three more primitive triples with the formulas:</p><blockquote><p>a â€“ 2b + 2c, 2a â€“ b + 2c, 2a â€“ 2b + 3c
a + 2b + 2c, 2a + b + 2c, 2a + 2b + 3c
-a + 2b + 2c, -2a + b + 2c, -2a + 2b + 3c</p></blockquote><p>You can generate even more primitive triples from those in turn, as long as you choose to do so. In our case, we can stop each branch once the perimeter of the triple is larger than our target as they don&rsquo;t ever get smaller. So how do we turn that into code? We use Racket&rsquo;s <code><a href="http://docs.racket-lang.org/search/index.html?q=generators">generators</a></code>
:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>primitive-triples</span> [max-sum <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>generator</span> ()
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([a <span style=color:#ae81ff>3</span>] [b <span style=color:#ae81ff>4</span>] [c <span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>or </span>(not max-sum) (&lt;= (+ a b c) max-sum))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>yield</span> (list (min a b) (max a b) c))
</span></span><span style=display:flex><span>        <span style=color:#75715e>; a â€“ 2b + 2c, 2a â€“ b + 2c, 2a â€“ 2b + 3c</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> (+ a (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>2</span> a) (- b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>        <span style=color:#75715e>; a + 2b + 2c, 2a + b + 2c, 2a + 2b + 3c</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> (+ a (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>        <span style=color:#75715e>; -a + 2b + 2c, -2a + b + 2c, -2a + 2b + 3c</span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> (+ (- a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>-2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>              (+ (* <span style=color:#ae81ff>-2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>yield</span> <span style=color:#66d9ef>#f</span>)))
</span></span></code></pre></div><p>Similar to Python&rsquo;s <code>yield</code>, this generator will create a sequence of primitive triples, scanning in a depth first manner down each branch of the aforementioned tree. From there, we just have to calculate each multiple to get a list of all Pythagorean triples with perimeters less than a given value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>triples-under</span> sum)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for*/list</span> ([trip (<span style=color:#a6e22e>in-producer</span> (<span style=color:#a6e22e>primitive-triples</span> sum) <span style=color:#66d9ef>#f</span>)]
</span></span><span style=display:flex><span>              [k (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> (quotient sum (apply + trip))))])
</span></span><span style=display:flex><span>    (map (<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>n</span>) (* n k)) trip)))
</span></span></code></pre></div><p>So if we wanted to test this with all 17 triples with perimeters under 100, we could:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>triples-under</span> <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>((<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)    (<span style=color:#ae81ff>6</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>10</span>)   (<span style=color:#ae81ff>9</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>15</span>)  (<span style=color:#ae81ff>12</span> <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>20</span>) (<span style=color:#ae81ff>15</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>25</span>) (<span style=color:#ae81ff>18</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>30</span>) (<span style=color:#ae81ff>21</span> <span style=color:#ae81ff>28</span> <span style=color:#ae81ff>35</span>)
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>24</span> <span style=color:#ae81ff>32</span> <span style=color:#ae81ff>40</span>) (<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>13</span>)  (<span style=color:#ae81ff>10</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>26</span>) (<span style=color:#ae81ff>15</span> <span style=color:#ae81ff>36</span> <span style=color:#ae81ff>39</span>) (<span style=color:#ae81ff>7</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>25</span>)  (<span style=color:#ae81ff>9</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>41</span>)  (<span style=color:#ae81ff>20</span> <span style=color:#ae81ff>21</span> <span style=color:#ae81ff>29</span>)
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>8</span> <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>17</span>)  (<span style=color:#ae81ff>16</span> <span style=color:#ae81ff>30</span> <span style=color:#ae81ff>34</span>) (<span style=color:#ae81ff>12</span> <span style=color:#ae81ff>35</span> <span style=color:#ae81ff>37</span>))
</span></span></code></pre></div><p>On the other hand though, we don&rsquo;t necessarily care what the actual triples are, we just want to know how many there are. So a slight modification to just count them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>count-triples-under</span> sum)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>count <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for*</span> ([trip (<span style=color:#a6e22e>in-producer</span> (<span style=color:#a6e22e>primitive-triples</span> sum) <span style=color:#66d9ef>#f</span>)]
</span></span><span style=display:flex><span>         [k (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> (quotient sum (apply + trip))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>set! </span>count (+ count <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>  count)
</span></span></code></pre></div><p>And that&rsquo;s it. We can finally answer the question originally asked of us:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>count-triples-under</span> <span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>6116</span> real time: <span style=color:#ae81ff>6121</span> gc time: <span style=color:#ae81ff>1792</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>808950</span>
</span></span></code></pre></div><p>It&rsquo;s still not as fast as I&rsquo;d like, but it&rsquo;s certainly faster than it would have been without the fancier algorithm.</p><p>And that&rsquo;s all there is to it. If you&rsquo;d like to download the entire source code for today, you can do so here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/pythagorean-triples.rkt>pythagorean-triples source</a></p><p>Like I said before, it definitely did have the feel of a Project Euler problem, where the straight forward solution is not generally the best one and if you work at it, you can find something that will run in a fraction of the time.</p><p>Perhaps I&rsquo;ll start publishing my Project Euler solutions here. I&rsquo;ve worked through a good chunk of the problems on two separate occasions, both in Python and in Scheme and it might be interesting to compare and contrast the different languages. Although since it&rsquo;s sort of a contest, that might be frowned upon. We&rsquo;ll see.</p><p><strong>Edit:</strong></p><p>Eesh. When programmingpraxis mentioned that generators were slow down in the comments, I remembered some chatter on the Racket mailing list (the thread from this message) talking about generator performance. But I hadn&rsquo;t realized it would be quite <em>this</em> extensive. It&rsquo;s easy enough to reimplement the code to make <code>primitive-triples</code> just return a list of all of the triples directly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>primitive-triples-nogen</span> max-sum)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([a <span style=color:#ae81ff>3</span>] [b <span style=color:#ae81ff>4</span>] [c <span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>(&gt; (+ a b c) max-sum)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>append</span>
</span></span><span style=display:flex><span>         (list (list (min a b) (max a b) c))
</span></span><span style=display:flex><span>         <span style=color:#75715e>; a â€“ 2b + 2c, 2a â€“ b + 2c, 2a â€“ 2b + 3c</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (+ a (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>2</span> a) (- b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>         <span style=color:#75715e>; a + 2b + 2c, 2a + b + 2c, 2a + 2b + 3c</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (+ a (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>         <span style=color:#75715e>; -a + 2b + 2c, -2a + b + 2c, -2a + 2b + 3c</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (+ (- a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>-2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>               (+ (* <span style=color:#ae81ff>-2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>count-triples-under-nogen</span> sum)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>count <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for*</span> ([trip (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>primitive-triples-nogen</span> sum))]
</span></span><span style=display:flex><span>         [k (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> (quotient sum (apply + trip))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>set! </span>count (+ count <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>  count)
</span></span></code></pre></div><p>Then look at the performance we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>count-triples-under</span> <span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>7109</span> real time: <span style=color:#ae81ff>7129</span> gc time: <span style=color:#ae81ff>2292</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>808950</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>count-triples-under-nogen</span> <span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>352</span> real time: <span style=color:#ae81ff>348</span> gc time: <span style=color:#ae81ff>112</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>808950</span>
</span></span></code></pre></div><p>Yeah&mldr; So there is a bit of a performance penalty for generators after all (most likely due to the use of continuations to implement them according to the aforementioned thread). I&rsquo;ll have to keep that in mind.</p><p><strong>Edit 2:</strong></p><p>So I decided to go for the best of both worlds and essentially make a generator while maintaining the state myself. Essentially, I&rsquo;ll use <code>set!</code> to update the list of triples we haven&rsquo;t yet tried, stored in the function&rsquo;s state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>primitive-triples-state</span> [max-sum <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>triples <span style=color:#f92672>&#39;</span>((<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>lambda </span>()
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ()
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        [(null? triples) <span style=color:#66d9ef>#f</span>]
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>define </span>a (caar triples))
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>define </span>b (cadar triples))
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>define </span>c (caddar triples))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>           [(<span style=color:#66d9ef>and </span>max-sum (&gt; (+ a b c) max-sum))
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>set! </span>triples (cdr triples))
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>loop</span>)]
</span></span><span style=display:flex><span>           [else
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>define </span>r (car triples))
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>set! </span>triples
</span></span><span style=display:flex><span>                  (<span style=color:#a6e22e>list*</span>
</span></span><span style=display:flex><span>                   <span style=color:#75715e>; a â€“ 2b + 2c, 2a â€“ b + 2c, 2a â€“ 2b + 3c</span>
</span></span><span style=display:flex><span>                   (list (+ a (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>2</span> a) (- b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>-2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>                   <span style=color:#75715e>; a + 2b + 2c, 2a + b + 2c, 2a + 2b + 3c</span>
</span></span><span style=display:flex><span>                   (list (+ a (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>                   <span style=color:#75715e>; -a + 2b + 2c, -2a + b + 2c, -2a + 2b + 3c</span>
</span></span><span style=display:flex><span>                   (list (+ (- a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>-2</span> a) b (* <span style=color:#ae81ff>2</span> c))
</span></span><span style=display:flex><span>                         (+ (* <span style=color:#ae81ff>-2</span> a) (* <span style=color:#ae81ff>2</span> b) (* <span style=color:#ae81ff>3</span> c)))
</span></span><span style=display:flex><span>                   <span style=color:#75715e>; all of the rest</span>
</span></span><span style=display:flex><span>                   (cdr triples)))
</span></span><span style=display:flex><span>            r])]))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>count-triples-under-state</span> sum)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>count <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for*</span> ([trip (<span style=color:#a6e22e>in-producer</span> (<span style=color:#a6e22e>primitive-triples-state</span> sum) <span style=color:#66d9ef>#f</span>)]
</span></span><span style=display:flex><span>         [k (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> (quotient sum (apply + trip))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>set! </span>count (+ count <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>  count)
</span></span></code></pre></div><p>It&rsquo;s fractionally slower than the version that just directly returns the list (the overhead of the function calls, I&rsquo;m guessing), but not enough to be statistically significant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>count-triples-under-nogen</span> <span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>352</span> real time: <span style=color:#ae81ff>348</span> gc time: <span style=color:#ae81ff>112</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>808950</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>count-triples-under-state</span> <span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>388</span> real time: <span style=color:#ae81ff>388</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>808950</span>
</span></span></code></pre></div><p>Now I&rsquo;m wondering how hard it would be a write a version of the <code>generator</code> macro that bundles this all up for you. It wouldn&rsquo;t be as general purpose, but I&rsquo;m will to bet it could be done.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>