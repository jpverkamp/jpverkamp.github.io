<!doctype html><html><head><title>Two Word Games – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script defer src=/jquery_6894410585563545744.min.cc1cade18c999752b7befe111634889dca8d89b24923775954ecebc68c54fcd3.js integrity="sha256-zByt4YyZl1K3vv4RFjSIncqNibJJI3dZVOzrxoxU/NM="></script>
<script defer src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg="></script>
<script defer src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM="></script>
<script defer src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY="></script>
<script defer src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90="></script>
<script defer src=/custom.js></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="></script><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="></script><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="></script><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="></script><link rel=stylesheet href=/custom.css><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Two Word Games</h1><div class=entry-meta><span class=entry-date>2012-10-10</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/09/19/a-piece-of-the-abc-conjecture/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/10/07/three-ways-to-write-expressions/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/09/19/a-piece-of-the-abc-conjecture/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/topics/word-games>Word Games</a><a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/10/08/evaluating-prefix/infix/postfix-expressions/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/10/09/a-sea-of-stars-ch.-13-missing/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another day, <a title="Programming Praxis: Two Word Games" href=http://programmingpraxis.com/2012/10/09/two-word-games/>another post</a> from Programming Praxis. Today they posted a word game that seems simple enough: first find all words in a given dictionary that contain all five vowels (a, e, i, o, u) in ascending order and then find any words (at least six letters long) where the letters are all in ascending alphabetical order.</p><p>First, we need some sort of framework for loading a file and looping through the lines. Luckily for us, we have the nice functions <code>with-input-from-file</code>, <code>with-output-to-file</code>, and <code>read-line</code> that will do most of the heavy lifting for us. All together, we have this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>filter-file</span> f? fin fout)
</span></span><span style=display:flex><span>  (with-output-to-file fout
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>lambda </span>()
</span></span><span style=display:flex><span>      (with-input-from-file fin
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>lambda </span>()
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>let </span>loop ([word (<span style=color:#a6e22e>read-line</span>)])
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>unless</span> (eof-object? word)
</span></span><span style=display:flex><span>              (<span style=color:#66d9ef>let </span>([word (<span style=color:#a6e22e>string-trim</span> word)])
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>when</span> (<span style=color:#a6e22e>f?</span> word)
</span></span><span style=display:flex><span>                  (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;~a\n&#34;</span> word)))
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>read-line</span>)))))))
</span></span><span style=display:flex><span>    <span style=color:#f92672>#</span>:exists <span style=color:#e6db74>&#39;truncate</span>))
</span></span></code></pre></div><p>This will take the input and output filenames <code>fin</code> and <code>fout</code> and a filtering function <code>f?</code>. Each line in turn will be passed to <code>f?</code>, those that return <code>#t</code> will be written to <code>fout</code>.</p><p>As a side note, the keyword argument <code>#:exists</code> tells <code>with-output-to-file</code> to overwrite the output file if it already exists. This is almost surely a Racket specific thing, but something similar probably exists in other Schemes.</p><p>Now we just need some functions to pass as <code>f?</code>.</p><p>First, a function to test if all five vowels are present and in ascending order. Basically, just filter for only the vowels, make sure that there are 5 of those and that they&rsquo;re all unique, and finally that they&rsquo;re sorted. Of course for this we need the ability to return only the unique elements in a list and test if a list is sorted, both things that I&rsquo;ve written a dozen times before:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>sorted?</span> c? ls)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>or </span>(null? ls)
</span></span><span style=display:flex><span>      (null? (cdr ls))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>c?</span> (car ls) (cadr ls))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>sorted?</span> c? (cdr ls)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>unique</span> ls)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>foldl</span> (<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>x</span> l) (<span style=color:#66d9ef>if </span>(member x l) l (cons x l))) <span style=color:#f92672>&#39;</span>() ls))
</span></span></code></pre></div><p>Finally, here&rsquo;s the function for ascending vowels:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>ascending-vowels?</span> word)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([vowels (<span style=color:#a6e22e>filter</span>
</span></span><span style=display:flex><span>                 (<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>c</span>) (member c <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>#\a</span> <span style=color:#e6db74>#\e</span> <span style=color:#e6db74>#\i</span> <span style=color:#e6db74>#\o</span> <span style=color:#e6db74>#\u</span>)))
</span></span><span style=display:flex><span>                 (string-&gt;list word))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>and </span>(= (length vowels) <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>         (= (length (<span style=color:#a6e22e>unique</span> vowels)) <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>sorted?</span> char&lt;? vowels))))
</span></span></code></pre></div><p>Yes, <code>length</code> isn&rsquo;t particular efficient, but the lists really aren&rsquo;t going to be that long. After all, they won&rsquo;t be any longer than the most vowels any word has in your dictionary. After that, getting words of length at least 6 with letter in ascending order is even easier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>ascending-letters?</span> word)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([letters (string-&gt;list word)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>and </span>(&gt;= (length letters) <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>sorted?</span> char&lt;? letters))))
</span></span></code></pre></div><p>And that&rsquo;s all there is to it. I tested it on a the <a href=http://www.gnu.org/software/ispell/ispell.html title="GNU ispell">ispell</a> dictionary and it ran in under a second, so that&rsquo;s good enough for me. 😄</p><p>Looking through some of the previous Programming Praxis <a href="http://programmingpraxis.com/contents/themes/#Word Games" title="Programming Praxis: Themes: Word Games">Word Games</a>, I think I know what I&rsquo;ll be doing for the next few days.</p><p>You can download the entire source for this project here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/two-word-games.rkt title="two-word-games source">two-word-games source</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>