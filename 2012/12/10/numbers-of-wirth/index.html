<!doctype html><html><head><title>Numbers of Wirth â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Numbers of Wirth</h1><div class=entry-meta><span class=entry-date>2012-12-10</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/12/10/confession-day-39/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/12/11/life-of-pi/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Niklaus Wirth gave the following problem back in 1973:</p><blockquote><p>Develop a program that generates in ascending order the least 100 numbers of the set M, where M is defined as follows:</p></blockquote><blockquote><p>a) The number 1 is in M.</p></blockquote><blockquote><p>b) If x is in M, then y = 2 * x + 1 and z = 3 * x + 1 are also in M.</p></blockquote><blockquote><p>c) No other numbers are in M.</p></blockquote><p>(via <a href=http://programmingpraxis.com/2012/12/07/wirth-problem-15-12/ title="Programming Praxis: Wirth Problem 15.12">Programming Praxis</a>)</p><p>It&rsquo;s an interesting enough problem, so let&rsquo;s work out a few different ways of doing it.</p><p>First, there&rsquo;s the simple, brute force method. Start by writing a recursive definition to check if a number is a &lsquo;Wirth number&rsquo; by reversing the two equations given in part b of the definition:</p><p>In Scheme:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; recursively determine if a number is a wirth number</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>wirth?</span> n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(positive? n)
</span></span><span style=display:flex><span>       (integer? n)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>or </span>(= n <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>wirth?</span> (/ (- n <span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>wirth?</span> (/ (- n <span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>3</span>)))))
</span></span></code></pre></div><p>And Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_wirth</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Recursively determine if a number is a wirth number&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> n <span style=color:#f92672>!=</span> int(n):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>elif</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> is_wirth((n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>) <span style=color:#f92672>or</span> is_wirth((n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3.0</span>)
</span></span></code></pre></div><p>With something like that, it would be easy enough to write a loop in either language that just starts at 1 and checks every number:</p><p>Scheme:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; list the first n wirth numbers</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>n-wirth</span> n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([i <span style=color:#ae81ff>1</span>] [cnt <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(= cnt n) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>wirth?</span> i) (cons i (<span style=color:#a6e22e>loop</span> (+ i <span style=color:#ae81ff>1</span>) (+ cnt <span style=color:#ae81ff>1</span>)))]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else </span>(<span style=color:#a6e22e>loop</span> (+ i <span style=color:#ae81ff>1</span>) cnt)])))
</span></span></code></pre></div><p>Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>n_wirth</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;List the first n wirth numbers&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ls <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> len(ls) <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> is_wirth(i):
</span></span><span style=display:flex><span>			ls<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>		i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ls
</span></span></code></pre></div><p>Easy enough, and for the case of <code>n=100</code>, it runs pretty much instantly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>n-wirth</span> <span style=color:#ae81ff>100</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>0</span> real time: <span style=color:#ae81ff>1</span> gc time: <span style=color:#ae81ff>0</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span>    <span style=color:#ae81ff>3</span>    <span style=color:#ae81ff>4</span>    <span style=color:#ae81ff>7</span>    <span style=color:#ae81ff>9</span>    <span style=color:#ae81ff>10</span>   <span style=color:#ae81ff>13</span>   <span style=color:#ae81ff>15</span>   <span style=color:#ae81ff>19</span>   <span style=color:#ae81ff>21</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>22</span>   <span style=color:#ae81ff>27</span>   <span style=color:#ae81ff>28</span>   <span style=color:#ae81ff>31</span>   <span style=color:#ae81ff>39</span>   <span style=color:#ae81ff>40</span>   <span style=color:#ae81ff>43</span>   <span style=color:#ae81ff>45</span>   <span style=color:#ae81ff>46</span>   <span style=color:#ae81ff>55</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>57</span>   <span style=color:#ae81ff>58</span>   <span style=color:#ae81ff>63</span>   <span style=color:#ae81ff>64</span>   <span style=color:#ae81ff>67</span>   <span style=color:#ae81ff>79</span>   <span style=color:#ae81ff>81</span>   <span style=color:#ae81ff>82</span>   <span style=color:#ae81ff>85</span>   <span style=color:#ae81ff>87</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>91</span>   <span style=color:#ae81ff>93</span>   <span style=color:#ae81ff>94</span>   <span style=color:#ae81ff>111</span>  <span style=color:#ae81ff>115</span>  <span style=color:#ae81ff>117</span>  <span style=color:#ae81ff>118</span>  <span style=color:#ae81ff>121</span>  <span style=color:#ae81ff>127</span>  <span style=color:#ae81ff>129</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>130</span>  <span style=color:#ae81ff>135</span>  <span style=color:#ae81ff>136</span>  <span style=color:#ae81ff>139</span>  <span style=color:#ae81ff>159</span>  <span style=color:#ae81ff>163</span>  <span style=color:#ae81ff>165</span>  <span style=color:#ae81ff>166</span>  <span style=color:#ae81ff>171</span>  <span style=color:#ae81ff>172</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>175</span>  <span style=color:#ae81ff>183</span>  <span style=color:#ae81ff>187</span>  <span style=color:#ae81ff>189</span>  <span style=color:#ae81ff>190</span>  <span style=color:#ae81ff>193</span>  <span style=color:#ae81ff>202</span>  <span style=color:#ae81ff>223</span>  <span style=color:#ae81ff>231</span>  <span style=color:#ae81ff>235</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>237</span>  <span style=color:#ae81ff>238</span>  <span style=color:#ae81ff>243</span>  <span style=color:#ae81ff>244</span>  <span style=color:#ae81ff>247</span>  <span style=color:#ae81ff>255</span>  <span style=color:#ae81ff>256</span>  <span style=color:#ae81ff>259</span>  <span style=color:#ae81ff>261</span>  <span style=color:#ae81ff>262</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>271</span>  <span style=color:#ae81ff>273</span>  <span style=color:#ae81ff>274</span>  <span style=color:#ae81ff>279</span>  <span style=color:#ae81ff>280</span>  <span style=color:#ae81ff>283</span>  <span style=color:#ae81ff>319</span>  <span style=color:#ae81ff>327</span>  <span style=color:#ae81ff>331</span>  <span style=color:#ae81ff>333</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>334</span>  <span style=color:#ae81ff>343</span>  <span style=color:#ae81ff>345</span>  <span style=color:#ae81ff>346</span>  <span style=color:#ae81ff>351</span>  <span style=color:#ae81ff>352</span>  <span style=color:#ae81ff>355</span>  <span style=color:#ae81ff>364</span>  <span style=color:#ae81ff>367</span>  <span style=color:#ae81ff>375</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>379</span>  <span style=color:#ae81ff>381</span>  <span style=color:#ae81ff>382</span>  <span style=color:#ae81ff>387</span>  <span style=color:#ae81ff>388</span>  <span style=color:#ae81ff>391</span>  <span style=color:#ae81ff>405</span>  <span style=color:#ae81ff>406</span>  <span style=color:#ae81ff>409</span>  <span style=color:#ae81ff>418</span>)
</span></span></code></pre></div><p>In fact, even until the first 10,000 such numbers it&rsquo;s still pretty fast:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>n-wirth</span> <span style=color:#ae81ff>10000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>670</span> real time: <span style=color:#ae81ff>700</span> gc time: <span style=color:#ae81ff>63</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>So why even bother doing better? Because we can!</p><p>The next step would be to realize that we&rsquo;re redoing a lot of the work in <code>is_wirth</code> / <code>wirth?</code>. This should look like the perfect opportunity to use memorization, which I just so happen to have posted about both in <a href=https://blog.jverkamp.com/2012/09/29/pickles-and-memoization/>Python</a> and <a href=https://blog.jverkamp.com/2012/10/20/memoization-in-racket/>Racket</a>.</p><p>Make those changes and run it again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>n-wirth</span> <span style=color:#ae81ff>10000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>218</span> real time: <span style=color:#ae81ff>213</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>Three times faster. None too shabby, particularly for such a relatively small runtime as it is. But there&rsquo;s still at least two (fairly obvious) ways to do it!</p><p>The next would be to use generators. This solution got a bit strange, so I only have a Python version. The basic idea is that for any number, we want to be able to generate the two branches of Wirth numbers from that number, merging them as we go. So first, let&rsquo;s start with a function that can merge two generators into a new generator (removing duplicates):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_generators</span>(g1, g2):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Merge two numeric generators in increasing order.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	n1 <span style=color:#f92672>=</span> g1<span style=color:#f92672>.</span>next()
</span></span><span style=display:flex><span>	n2 <span style=color:#f92672>=</span> g2<span style=color:#f92672>.</span>next()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> n1 <span style=color:#f92672>&lt;</span> n2:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>yield</span> n1
</span></span><span style=display:flex><span>			n1 <span style=color:#f92672>=</span> g1<span style=color:#f92672>.</span>next()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>elif</span> n1 <span style=color:#f92672>&gt;</span> n2:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>yield</span> n2
</span></span><span style=display:flex><span>			n2 <span style=color:#f92672>=</span> g2<span style=color:#f92672>.</span>next()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>yield</span> n1
</span></span><span style=display:flex><span>			n1 <span style=color:#f92672>=</span> g1<span style=color:#f92672>.</span>next()
</span></span><span style=display:flex><span>			n2 <span style=color:#f92672>=</span> g2<span style=color:#f92672>.</span>next()
</span></span></code></pre></div><p>So for example, if we have generators for multiples of two and three:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>take</span>(gen, n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Take the first n items from a generator.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>	ls <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> len(ls) <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>		ls<span style=color:#f92672>.</span>append(gen<span style=color:#f92672>.</span>next())
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multiples_of</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Return multiples of n, starting at n.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> n
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span> i
</span></span><span style=display:flex><span>		i <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> take(merge_generators(multiples_of(<span style=color:#ae81ff>2</span>), multiples_of(<span style=color:#ae81ff>3</span>)), <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>18</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>22</span>, <span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>26</span>, <span style=color:#ae81ff>27</span>, <span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>30</span>]
</span></span></code></pre></div><p>So how do we put that all together?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wirth_gen</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;A generator for wirth numbers.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>yield</span> n
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> merge_generators(wirth_gen(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), wirth_gen(<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span> i
</span></span></code></pre></div><p>So you yield the number that you&rsquo;re at, then you merge the two generators. Straight forward enough. And we can use the <code>take</code> function from above to generate the first <code>n</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gen_n_wirth</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;List the first n wirth numbers using generators&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> take(wirth_gen(<span style=color:#ae81ff>1</span>), n)
</span></span></code></pre></div><p>I have to admit, I think that&rsquo;s the most nested generator I&rsquo;ve ever written. In practice though, it&rsquo;s faster than either of the previous Racket versions, taking only 160ms to generate the first 10,000 numbers in the sequence.</p><p>Two more options and I think I&rsquo;ll call it a day. The first is based pretty much directly on the sieves that I used in my original <a href=https://blog.jverkamp.com/2012/11/01/the-sum-of-the-first-billion-primes/>billion primes post</a>. Basically, create a list of natural numbers. Starting at the bottom, we&rsquo;ll check off the Wirth numbers, returning them as we go. The only problem is that we don&rsquo;t have a solid upper bound (as we did with the primes). So we&rsquo;ll just ask the user to supply one. Here&rsquo;s the code:</p><p>Racket:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; list the first n wirth numbers with a sieve</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>sieve-n-wirth</span> n sieve-size)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>sieve (make-vector sieve-size <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>  (vector-set! sieve <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>take</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> sieve-size)]
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:when (vector-ref sieve i))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>when</span> (&lt; (+ (* <span style=color:#ae81ff>2</span> i) <span style=color:#ae81ff>1</span>) sieve-size)
</span></span><span style=display:flex><span>       (vector-set! sieve (+ (* <span style=color:#ae81ff>2</span> i) <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>#t</span>))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>when</span> (&lt; (+ (* <span style=color:#ae81ff>3</span> i) <span style=color:#ae81ff>1</span>) sieve-size)
</span></span><span style=display:flex><span>       (vector-set! sieve (+ (* <span style=color:#ae81ff>3</span> i) <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>#t</span>))
</span></span><span style=display:flex><span>     i)
</span></span><span style=display:flex><span>   n))
</span></span></code></pre></div><p>Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sieve_n_wirth</span>(n, size):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Generate the first n wirth numbers using a sieve.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sieve <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span> <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(size)]
</span></span><span style=display:flex><span>	sieve[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>	ls <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(size):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> sieve[i]:
</span></span><span style=display:flex><span>			ls<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> size: sieve[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> size: sieve[<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> len(ls) <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ls
</span></span></code></pre></div><p>And timing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>sieve-n-wirth</span> <span style=color:#ae81ff>10000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>15</span> real time: <span style=color:#ae81ff>11</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>I don&rsquo;t think we&rsquo;re going to beat that time.</p><p>Last but not least, priority queues / heaps. The general idea is to let the data structure do the work. Since a heap is designed to let you insert items in any order but only pull them back out in order, it&rsquo;s perfect for the task. You can get heaps in Python from <code>heapq</code> and in Racket from <code>data/heap</code>. Here&rsquo;s how you use it (there&rsquo;s a bit of ugliness to remove duplicates):</p><p>Racket:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>require</span> data/heap)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; list the first n wirth numbers with a heap</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>heap-n-wirth</span> n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>heap (<span style=color:#a6e22e>make-heap</span> &lt;))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>heap-add!</span> heap <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([n n])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(zero? n) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>i (<span style=color:#a6e22e>heap-min</span> heap))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>heap-add!</span> heap (+ (* <span style=color:#ae81ff>2</span> i) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>heap-add!</span> heap (+ (* <span style=color:#ae81ff>3</span> i) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>let </span>loop () <span style=color:#75715e>; remove duplicates</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>when</span> (= i (<span style=color:#a6e22e>heap-min</span> heap))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>heap-remove-min!</span> heap)
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>loop</span>)))
</span></span><span style=display:flex><span>       (cons i (<span style=color:#a6e22e>loop</span> (- n <span style=color:#ae81ff>1</span>)))])))
</span></span></code></pre></div><p>Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> heapq <span style=color:#f92672>import</span> heappop, heappush 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>heap_n_wirth</span>(n):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Generate the first n wirth numbers using a heap.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ls <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	heap <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>	heappush(heap, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> len(ls) <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>		i <span style=color:#f92672>=</span> heappop(heap)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> i <span style=color:#f92672>in</span> ls:
</span></span><span style=display:flex><span>			ls<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>			heappush(heap, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			heappush(heap, <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ls
</span></span></code></pre></div><p>And timing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>heap-n-wirth</span> <span style=color:#ae81ff>10000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>562</span> real time: <span style=color:#ae81ff>557</span> gc time: <span style=color:#ae81ff>157</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>And we&rsquo;re back to the original runtime. So the sieved version still wins out.</p><p>If you have any particularly different algorithms (or any improvements to my versions above), be sure to let me know in the comments.</p><p>As always, you can download the full code for today&rsquo;s post from GitHub:</p><ul><li><a href=https://github.com/jpverkamp/small-projects/blob/master/blog/numbers-of-wirth.py title="Numbers of wirth source (python)">Python source</a></li><li><a href=https://github.com/jpverkamp/small-projects/blob/master/blog/numbers-of-wirth.rkt title="Numbers of wirth source (Racket)">Racket source</a></li></ul></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>