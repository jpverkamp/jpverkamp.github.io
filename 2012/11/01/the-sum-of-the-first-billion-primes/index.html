<!DOCTYPE html>
<html onclick >
<head>
    <title>The Sum Of The First Billion Primes â€“ jverkamp.com</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8"><link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="//blog.jverkamp.com/feed/">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css" integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" />

<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel="stylesheet">

<link rel="stylesheet" href="/custom.css" defer />

    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
</head>
<body>
    <div id="wrapper"><header id="page-header" role="banner">
    <h1><a href="/">JP's Blog</a></h1>

    <ul id="page-header-links">
        <li>
            <a href="https://github.com/jpverkamp">GitHub</a> *
            <a href="https://www.flickr.com/photos/jpverkamp">Flickr</a> *
            <a href="/resume">Resume</a>
        </li>
        <li>
            <form action="//www.google.com/search" method="get" onsubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search" _lpchecked="1">
                <div class="form-group">
                    <input name="q" type="hidden">
                    <input name="qfront" type="text" class="form-control" placeholder="Search">
                    <button type="submit" class="btn btn-default" value="Search">Search</button>
                </div>
            </form>
        </li>
    </ul>

    <nav id="header-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation"><li><a href="https://blog.jverkamp.com/reviews/">Reviews</a></li><li><a href="https://blog.jverkamp.com/programming/">Programming</a></li><li><a href="https://blog.jverkamp.com/photography/">Photography</a></li><li><a href="https://blog.jverkamp.com/maker/">Maker</a></li><li><a href="https://blog.jverkamp.com/writing/">Writing</a></li><li><a href="https://blog.jverkamp.com/research/">Research</a></li><li class="subscription" data-subscription="rss"><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
        </ul>
    </nav>
</header>
<div id="page-content-wrapper">
            <div id="page-content"><article>
	<header>
		<h1 class="entry-title">The Sum Of The First Billion Primes</h1>

        <div class="entry-meta"><span class="entry-date">2012-11-01</span>
            </div>

        <div class="entry-taxonomies"><div class="entry-tags"><ul class="taxonomy-keys"><li>
            <a class="taxonomy-key" href="/programming/languages/">Languages</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/10/31/pandigital-sums/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/racket">Racket</a><a href="https://blog.jverkamp.com/2012/11/03/project-euler-1/" class="next-link"></a></li><li><a href="https://blog.jverkamp.com/2012/10/31/pandigital-sums/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/scheme">Scheme</a><a href="https://blog.jverkamp.com/2012/11/03/project-euler-1/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/sources/">Sources</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/10/31/pandigital-sums/" class="previous-link"></a><a class="taxonomy-value" href="/programming/sources/programming-praxis">Programming Praxis</a><a href="https://blog.jverkamp.com/2012/11/10/taxicab-numbers/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/topics/">Topics</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2012/10/31/pandigital-sums/" class="previous-link"></a><a class="taxonomy-value" href="/programming/topics/mathematics">Mathematics</a><a href="https://blog.jverkamp.com/2012/11/03/project-euler-1/" class="next-link"></a></li><li><a href="https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/" class="previous-link"></a><a class="taxonomy-value" href="/programming/topics/prime-numbers">Prime Numbers</a><a href="https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/" class="next-link"></a></li></ul>
        </li><li><a class="taxonomy-key" href="/programming">programming</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2012/10/31/pandigital-sums/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2012/11/03/project-euler/" class="next-link">Next</a></ul>
        </li><li><a class="taxonomy-key" href="/">All Posts</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2012/11/01/nanowrimo-2012/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2012/11/01/confession-day-1/" class="next-link">Next</a></ul>
        </li></ul>
</div>
</div>
    </header>

	<div class="entry-content"><p><a title="Programming Praxis: The Sum of the First Billion Primes" href="http://programmingpraxis.com/2012/09/11/the-sum-of-the-first-billion-primes/">This problem</a> from Programming Praxis came about in the comments to my last post and intrigued me. So today, we are trying to sum the first one billion primes. Summing the first hundred, thousand, even million primes isn&rsquo;t actually that bad. But it takes a bit more effort when you scale it up to a billion. And why&rsquo;s that?</p>
<p>Before I get started, if you&rsquo;d like to download today&rsquo;s source code and follow along, you can do so here: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/billion-primes.rkt" title="billion primes source">billion primes source</a></p>
<p>Now that that&rsquo;s out of the way, the first problem is time. A naive approach would be to go through all of the numbers from 2 to a billion and test if each is prime. To do that, test each number up to your current number and see if the latter divides the former. Simple enough:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; test if n divides m</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">divides?</span> m n)
  (= <span style="color:#ae81ff">0</span> (remainder m n)))

<span style="color:#75715e">; test if n is prime by trial division</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">prime?</span> n)
  (<span style="color:#66d9ef">and </span>(not (<span style="color:#a6e22e">divides?</span> n <span style="color:#ae81ff">2</span>))
       (<span style="color:#a6e22e">for/and</span> ([i (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">3</span> (+ <span style="color:#ae81ff">1</span> (ceiling (sqrt n))) <span style="color:#ae81ff">2</span>)])
         (not (<span style="color:#a6e22e">divides?</span> n i)))))

<span style="color:#75715e">; sum the first n primes directly</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-direct</span> n)
  (<span style="color:#66d9ef">let </span>loop ([i <span style="color:#ae81ff">3</span>] [count <span style="color:#ae81ff">1</span>] [sum <span style="color:#ae81ff">2</span>])
    (<span style="color:#a6e22e">cond</span>
      [(= count n) sum]
      [(<span style="color:#a6e22e">prime?</span> i)
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) (+ count <span style="color:#ae81ff">1</span>) (+ sum i))]
      [else
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) count sum)])))
</code></pre></div><p>Not too bad, we can sum the first hundred thousand primes pretty easily:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-direct</span> <span style="color:#ae81ff">100000</span>))
cpu time: <span style="color:#ae81ff">3068</span> real time: <span style="color:#ae81ff">3063</span> gc time: <span style="color:#ae81ff">79</span>
<span style="color:#ae81ff">62260698721</span>
</code></pre></div><p>If we waited a bit longer, we could even get the first billion that way. Still, that&rsquo;s 3 seconds for just only 1/10,000th of the problem. I think that we can do better. What&rsquo;s the next idea? Perhaps if rather than dividing by all numbers from 2 up to the number we&rsquo;re dealing with, why don&rsquo;t we just divide by the previous primes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; sum the first n primes by keeping a list of primes to divide by</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-list</span> n)
  (<span style="color:#66d9ef">let </span>loop ([i <span style="color:#ae81ff">3</span>] [count <span style="color:#ae81ff">1</span>] [sum <span style="color:#ae81ff">2</span>] [primes <span style="color:#f92672">&#39;</span>()])
    (<span style="color:#a6e22e">cond</span>
      [(= count n)
       sum]
      [(<span style="color:#a6e22e">andmap</span> (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">prime</span>) (not (<span style="color:#a6e22e">divides?</span> i prime))) primes)
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) (+ count <span style="color:#ae81ff">1</span>) (+ sum i) (cons i primes))]
      [else
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) count sum primes)])))
</code></pre></div><p>Simple enough. And theoretically it should be faster, yes? After all, we&rsquo;re doing far fewer divisions for each number. But no. It turns out that it&rsquo;s not actually faster at all. If you cut it down to the first 10,000 primes, the direct solution only takes 91 ms but this solution takes a whopping 9 seconds. That&rsquo;s two whole orders of magnitude. Ouch!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-direct</span> <span style="color:#ae81ff">10000</span>))
cpu time: <span style="color:#ae81ff">91</span> real time: <span style="color:#ae81ff">90</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">496165411</span>

&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-list</span> <span style="color:#ae81ff">10000</span>))
cpu time: <span style="color:#ae81ff">8995</span> real time: <span style="color:#ae81ff">8987</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">496165411</span>
</code></pre></div><p>At first, you might think that that doesn&rsquo;t make the least bit of sense. After all, we&rsquo;re doing essentially the same thing, we&rsquo;re just performing fewer divisions. So why isn&rsquo;t it faster?</p>
<p>Basically, it all comes down to memory access. In the first direct case, we basically aren&rsquo;t using the system&rsquo;s RAM. Everything (or just about) can be done in registers directly on the CPU. In the second case though, there&rsquo;s constant swapping as the list grows too large to hold in registers alone. And memory access is orders of magnitude slower than any single instruction on the CPU. Really, this is a perfect example of both this phenomenon and the cost of premature optimization. Just because something should be faster according to runtime alone, that&rsquo;s not the entire story.</p>
<p>Still, we&rsquo;re not quite done. I know we can do better than the direct method. So this time, let&rsquo;s use a more intricate method, specifically the <a href="https://en.wikipedia.org/wiki/Sieve%20of%20Eratosthenes">Sieve of Eratosthenes</a>. The basic idea is to start with a list of all of the numbers you are interested in. Then repeatedly take the first number as prime and cross out all of it&rsquo;s multiples. There&rsquo;s a pretty nice graphic on the aforelinked Wikipedia page.</p>
<p>And if we just go with a loop, the code is rather straight forward:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; sum the first n primes using the Sieve of Eratosthenes</span>
<span style="color:#75715e">; algorithm source: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-list</span> n)
  (<span style="color:#a6e22e">define-values</span> (<span style="color:#a6e22e">lo</span> hi) (<span style="color:#a6e22e">guess-nth-prime</span> n))
  (<span style="color:#66d9ef">let </span>loop ([ls (<span style="color:#a6e22e">range</span> <span style="color:#ae81ff">2</span> hi)]
             [count <span style="color:#ae81ff">0</span>]
             [sum <span style="color:#ae81ff">0</span>])
    (<span style="color:#a6e22e">cond</span>
      [(= count n) sum]
      [else
       (<span style="color:#a6e22e">loop</span> 
        (<span style="color:#a6e22e">filter</span>
         (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">i</span>) (not (<span style="color:#a6e22e">divides?</span> i (car ls))))
         (cdr ls))
        (+ count <span style="color:#ae81ff">1</span>)
        (+ (car ls) sum))])))
</code></pre></div><p>There&rsquo;s one interesting bit&ndash;the <code>guess-nth-prime</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; estimate the nth prime, return lower and upper bounds</span>
<span style="color:#75715e">; source: http://en.wikipedia.org/wiki/Prime_number_theorem</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">guess-nth-prime</span> n)
  (values (inexact-&gt;exact 
           (floor (* n (log n))))
          (inexact-&gt;exact 
           (<span style="color:#a6e22e">ceiling</span>
            (<span style="color:#66d9ef">if </span>(&lt;= n <span style="color:#ae81ff">1</span>) 
                <span style="color:#ae81ff">3</span> 
                (+ (* n (log n)) (* n (log (log n)))))))))
</code></pre></div><p>By default, the Sieve of Eratosthenes generates all of the primes from 1 to some number n. But that&rsquo;s not what we want. Instead, we want the first n primes. After a bit of searching though, I found the Wikipedia page on the <a href="https://en.wikipedia.org/wiki/Prime%20number%20theorem">Prime number theorem</a>. That defines the function <code>pi(n)</code> which approximates the number of primes less than or equal to n. Invert that function and you find that the value of the nth prime p<sub>n</sub> falls in the range:</p>
<div class="latex-block">n * ln(n) < p_n < n * ln(ln(n))</div>

<p>That upper bound is the one that lets us generate enough primes with the <a href="https://en.wikipedia.org/wiki/Sieve%20of%20Eratosthenes">Sieve of Eratosthenes</a> so that we can sum the first n.</p>
<p>The best part is that it turns out that it&rsquo;s at least faster than the list based method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-list</span> <span style="color:#ae81ff">10000</span>))
cpu time: <span style="color:#ae81ff">4347</span> real time: <span style="color:#ae81ff">4344</span> gc time: <span style="color:#ae81ff">776</span>
<span style="color:#ae81ff">496165411</span>
</code></pre></div><p>Still. That&rsquo;s not good enough. The problem here is much the same as the list based method. We&rsquo;re passingly along and constantly building a list that would eventually have a billion elements in it. Not something that&rsquo;s particularly easy to deal with. So instead of a list, why don&rsquo;t we use a vector of <code>#t</code>/<code>#f</code>?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; sum the first n primes using the Sieve of Eratosthenes with a vector</span>
<span style="color:#75715e">; algorithm source: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-vector</span> n)
  (<span style="color:#a6e22e">define-values</span> (<span style="color:#a6e22e">lo</span> hi) (<span style="color:#a6e22e">guess-nth-prime</span> n))
  (<span style="color:#66d9ef">define </span>v (make-vector hi <span style="color:#66d9ef">#t</span>))
  (vector-set! v <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">#f</span>)
  (vector-set! v <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">#f</span>)
  (<span style="color:#a6e22e">for*</span> ([i (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">2</span> hi)]
         <span style="color:#f92672">#</span>:when (vector-ref v i)
         [j (<span style="color:#a6e22e">in-range</span> (* i i) hi i)])
    (vector-set! v j <span style="color:#66d9ef">#f</span>))
  (<span style="color:#66d9ef">let </span>loop ([i <span style="color:#ae81ff">3</span>] [count <span style="color:#ae81ff">1</span>] [sum <span style="color:#ae81ff">2</span>])
    (<span style="color:#a6e22e">cond</span>
      [(= count n) sum]
      [(vector-ref v i)
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) (+ count <span style="color:#ae81ff">1</span>) (+ sum i))]
      [else
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) count sum)])))
</code></pre></div><p>So how does it perform?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-vector</span> <span style="color:#ae81ff">10000</span>))
cpu time: <span style="color:#ae81ff">6</span> real time: <span style="color:#ae81ff">6</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">496165411</span>
</code></pre></div><p>Dang that&rsquo;s nice. ðŸ˜„ Let&rsquo;s scale to a million:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-vector</span> <span style="color:#ae81ff">1000000</span>))
cpu time: <span style="color:#ae81ff">892</span> real time: <span style="color:#ae81ff">889</span> gc time: <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">7472966967499</span>
</code></pre></div><p>Less than a second isn&rsquo;t too shabby. It&rsquo;s slower than I&rsquo;d like, but I could wait a thousand seconds (a bit over 16 minutes) if I had to.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-vector</span> <span style="color:#ae81ff">1000000000</span>))
out of memory
</code></pre></div><p>Oops. It turns out that calling <code>make-vector</code> to make a billion element vector doesn&rsquo;t actually work so well on my machine&hellip; We&rsquo;re going to have to get a get a little sneakier.</p>
<p>Perhaps if we used the bitvectors from <a href="https://blog.jverkamp.com/2012/10/29/bitvectors-in-racket/">Monday&rsquo;s post</a>? (And now you know why I made that library ðŸ˜„). All we have to do is swap out each instance of <code>make-vector</code>, <code>vector-ref</code>, or <code>vector-set!</code> for <code>make-bitvector</code>, <code>bitvector-ref</code>, or <code>bitvector-set!</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-bitvector</span> <span style="color:#ae81ff">1000000</span>))
cpu time: <span style="color:#ae81ff">5174</span> real time: <span style="color:#ae81ff">5170</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">7472966967499</span>
</code></pre></div><p>So it run about five times slower than the simple vector based method (which makes sense if you think about it; twiddling bits doesn&rsquo;t come for free). Still, we&rsquo;re using a fair bit less memory. Let&rsquo;s see if it can handle a billion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-bitvector</span> <span style="color:#ae81ff">1000000000</span>))
cpu time: <span style="color:#ae81ff">9724165</span> real time: <span style="color:#ae81ff">9713671</span> gc time: <span style="color:#ae81ff">5119</span>
<span style="color:#ae81ff">11138479445180240497</span>
</code></pre></div><p>Dang. Nice. 2 hrs 41 minutes may be more than twice as long as I was expecting based on the 16 minute estimate for the one million run <code>vector</code> version and the 5x slowdown between the <code>vector</code> and <code>bitvector</code> versions. Still, it worked. And that&rsquo;s a pretty good base all by itself. Still, I think we can do better.</p>
<p>Upon some searching, it turns out that you can actually create vectors containing one billion entries. You just can&rsquo;t have them all in the same vector. So instead, I created another datatype: the <code>multivector</code>. Essentially, the idea is to create several smaller vectors and abstract the <code>ref</code> and <code>set!</code> methods to minimize the changes to the Sieve of Eratosthenes code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-struct</span> multivector (<span style="color:#a6e22e">size</span> chunks default data)
  <span style="color:#f92672">#</span>:mutable
  <span style="color:#f92672">#</span>:constructor-name make-multivector-struct)

(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">make-multivector</span> size [chunks <span style="color:#ae81ff">1</span>] [default <span style="color:#66d9ef">#f</span>])
  (<span style="color:#66d9ef">define </span>per-chunk (inexact-&gt;exact (ceiling (/ size chunks))))
  (<span style="color:#a6e22e">make-multivector-struct</span>
   size chunks default
   (<span style="color:#a6e22e">for/vector</span> ([i (<span style="color:#a6e22e">in-range</span> chunks)])
     (<span style="color:#66d9ef">if </span>(= i (- chunks <span style="color:#ae81ff">1</span>))
         (make-vector (- size (* (- chunks <span style="color:#ae81ff">1</span>) per-chunk)) default)
         (make-vector per-chunk default)))))

(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">multivector-ref</span> mv i)
  (vector-ref (vector-ref (<span style="color:#a6e22e">multivector-data</span> mv)
                          (quotient i (<span style="color:#a6e22e">multivector-chunks</span> mv)))
              (remainder i (<span style="color:#a6e22e">multivector-chunks</span> mv))))

(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">multivector-set!</span> mv i v)
  (vector-set! (vector-ref (<span style="color:#a6e22e">multivector-data</span> mv)
                           (quotient i (<span style="color:#a6e22e">multivector-chunks</span> mv)))
               (remainder i (<span style="color:#a6e22e">multivector-chunks</span> mv))
               v))
</code></pre></div><p>You can test it if you&rsquo;d like, but it does work. So let&rsquo;s try it in the Sieve of Eratosthenes. The same as before, just swap out <code>make-vector</code>, <code>vector-ref</code>, or <code>vector-set!</code> for <code>make-multivector</code>, <code>multivector-ref</code>, or <code>multivector-set!</code>.</p>
<p>So how does the performance compare?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-eratosthenes-multivector</span> <span style="color:#ae81ff">1000000</span>))
cpu time: <span style="color:#ae81ff">6635</span> real time: <span style="color:#ae81ff">6625</span> gc time: <span style="color:#ae81ff">435</span>
<span style="color:#ae81ff">7472966967499</span>
</code></pre></div><p>Hmm. Well, it doesn&rsquo;t actually run any faster than the <code>bitvector</code>, but it also doesn&rsquo;t run out of memory.</p>
<p>I think we may have a winner, but before we wind down, there are two other sieves linked to from the Sieve of Eratosthenes page: the <a href="https://en.wikipedia.org/wiki/Sieve%20of%20Atkin">Sieve of Atkin</a> and the <a href="https://en.wikipedia.org/wiki/Sieve%20of%20Sundaram">Sieve of Sundaram</a>. The algorithms are a bit more complicated than the Sieve of Eratosthenes, but still entirely doable. It is interesting just how they work though. The Sieve of Eratosthenes is intuitive. These two? A bit less so.</p>
<p>First, we have the <a href="https://en.wikipedia.org/wiki/Sieve%20of%20Atkin">Sieve of Atkin</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; sum the first n primes using the Sieve of Atkin</span>
<span style="color:#75715e">; algorithm source: http://en.wikipedia.org/wiki/Sieve_of_Atkin</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-sieve-atkin</span> n)
  (<span style="color:#a6e22e">define-values</span> (<span style="color:#a6e22e">lo</span> hi) (<span style="color:#a6e22e">guess-nth-prime</span> n))
  (<span style="color:#66d9ef">define </span>v (make-vector hi <span style="color:#66d9ef">#f</span>))
  <span style="color:#75715e">; add candidate primes</span>
  (<span style="color:#a6e22e">for*</span> ([x (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">1</span> (+ <span style="color:#ae81ff">1</span> (sqrt hi)))]
         [y (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">1</span> (+ <span style="color:#ae81ff">1</span> (sqrt hi)))])
    (<span style="color:#66d9ef">define </span>x2 (* x x))
    (<span style="color:#66d9ef">define </span>y2 (* y y))
    (<span style="color:#66d9ef">let </span>([i (+ (* <span style="color:#ae81ff">4</span> x2) y2)])
      (<span style="color:#a6e22e">when</span> (<span style="color:#66d9ef">and </span>(&lt; i hi) (<span style="color:#66d9ef">or </span>(= <span style="color:#ae81ff">1</span> (remainder i <span style="color:#ae81ff">12</span>))
                               (= <span style="color:#ae81ff">5</span> (remainder i <span style="color:#ae81ff">12</span>))))
        (vector-set! v i (not (vector-ref v i)))))
    (<span style="color:#66d9ef">let </span>([i (+ (* <span style="color:#ae81ff">3</span> x2) y2)])
      (<span style="color:#a6e22e">when</span> (<span style="color:#66d9ef">and </span>(&lt; i hi) (= <span style="color:#ae81ff">7</span> (remainder i <span style="color:#ae81ff">12</span>)))
        (vector-set! v i (not (vector-ref v i)))))
    (<span style="color:#66d9ef">let </span>([i (- (* <span style="color:#ae81ff">3</span> x2) y2)])
      (<span style="color:#a6e22e">when</span> (<span style="color:#66d9ef">and </span>(&gt; x y) (&lt; i hi) (= <span style="color:#ae81ff">11</span> (remainder i <span style="color:#ae81ff">12</span>)))
        (vector-set! v i (not (vector-ref v i))))))
  <span style="color:#75715e">; remove composites</span>
  (<span style="color:#a6e22e">for</span> ([i (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">5</span> (+ <span style="color:#ae81ff">1</span> (sqrt hi)))])
    (<span style="color:#a6e22e">when</span> (vector-ref v i)
      (<span style="color:#a6e22e">for</span> ([k (<span style="color:#a6e22e">in-range</span> (* i i) hi (* i i))])
        (vector-set! v k <span style="color:#66d9ef">#f</span>))))
  <span style="color:#75715e">; report</span>
  (<span style="color:#66d9ef">let </span>loop ([i <span style="color:#ae81ff">5</span>] [count <span style="color:#ae81ff">2</span>] [sum <span style="color:#ae81ff">5</span>])
    (<span style="color:#a6e22e">cond</span>
      [(= count n) sum]
      [(vector-ref v i)
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) (+ count <span style="color:#ae81ff">1</span>) (+ sum i))]
      [else
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">2</span>) count sum)])))
</code></pre></div><p>It&rsquo;s pretty much a direct translation of the code on the Wikipedia page. Since it uses <code>vector</code>, it won&rsquo;t be able to calculate the sum of the first billion, but you could pretty easily replace swap out for a <code>bitvector</code> or <code>multivector</code>. Still, I&rsquo;m mostly interested in the implementation and performance to start with. Speaking of which:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-atkin</span> <span style="color:#ae81ff">1000000</span>))
cpu time: <span style="color:#ae81ff">2421</span> real time: <span style="color:#ae81ff">2421</span> gc time: <span style="color:#ae81ff">415</span>
<span style="color:#ae81ff">7472966967499</span>
</code></pre></div><p>So this particular version is about three times slower than the vector version of the Sieve of Eratosthenes. The Wikipedia page mentions that there are a number of optimizations that you could do to speed this up which I may try some day, but not today. What&rsquo;s interesting though is that if you do swap out a <code>bitvector</code> for a vector, it&rsquo;s actually faster:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-atkin-bitvector</span> <span style="color:#ae81ff">1000000</span>))
cpu time: <span style="color:#ae81ff">3059</span> real time: <span style="color:#ae81ff">3058</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">7472966967499</span>
</code></pre></div><p>If that proportion follows through to the billion element run, we should be able to finish in just an hour and a half. Let&rsquo;s try it out.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-atkin-bitvector</span> <span style="color:#ae81ff">1000000000</span>))
cpu time: <span style="color:#ae81ff">5304855</span> real time: <span style="color:#ae81ff">5300800</span> gc time: <span style="color:#ae81ff">1237</span>
<span style="color:#ae81ff">11138479445180240497</span>
</code></pre></div><p>An hour and a half, spot on. None too shabby if I do say so myself. (Although I bet we could get even faster. I&rsquo;ll leave that as an exercise for another day though.)</p>
<p>Finally, the Sieve of Sundaram. This one is even more different than the previous ones, not removing multiples of primes but rather removing all composites less than <em>n</em> by noting that they all have the form <em>i + j + 2ij â‰¤ n</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; sum the first n primes using the Sieve of Sundaram</span>
<span style="color:#75715e">; algorithm source: http://en.wikipedia.org/wiki/Sieve_of_Sundaram</span>
(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-primes-sieve-sundaram</span> n)
  (<span style="color:#a6e22e">define-values</span> (<span style="color:#a6e22e">lo</span> hi) (<span style="color:#a6e22e">guess-nth-prime</span> n))
  (<span style="color:#66d9ef">define </span>dn (quotient hi <span style="color:#ae81ff">2</span>))
  (<span style="color:#66d9ef">define </span>v (make-vector dn <span style="color:#66d9ef">#t</span>))
  (<span style="color:#a6e22e">for*</span> ([j (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">1</span> dn)]
         [i (<span style="color:#a6e22e">in-range</span> <span style="color:#ae81ff">1</span> (+ j <span style="color:#ae81ff">1</span>))]
         <span style="color:#f92672">#</span>:when (&lt; (+ i j (* <span style="color:#ae81ff">2</span> i j)) dn))
    (vector-set! v (+ i j (* <span style="color:#ae81ff">2</span> i j)) <span style="color:#66d9ef">#f</span>))
  (<span style="color:#66d9ef">let </span>loop ([i <span style="color:#ae81ff">1</span>] [count <span style="color:#ae81ff">1</span>] [sum <span style="color:#ae81ff">2</span>])
    (<span style="color:#a6e22e">cond</span>
      [(= count n) sum]
      [(vector-ref v i)
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">1</span>) (+ count <span style="color:#ae81ff">1</span>) (+ sum (+ <span style="color:#ae81ff">1</span> (* <span style="color:#ae81ff">2</span> i))))]
      [else
       (<span style="color:#a6e22e">loop</span> (+ i <span style="color:#ae81ff">1</span>) count sum)])))
</code></pre></div><p>Very straight forward code, how does it perform?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#a6e22e">time</span> (<span style="color:#a6e22e">sum-primes-sieve-sundaram</span> <span style="color:#ae81ff">10000</span>))
cpu time: <span style="color:#ae81ff">32066</span> real time: <span style="color:#ae81ff">32055</span> gc time: <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">496165411</span>
</code></pre></div><p>Eesh. Note that that&rsquo;s only on 10,000 and it still took 30 seconds. I think I&rsquo;ll skip running this one even out to a million.</p>
<p>Well, that&rsquo;s enough for today I think. Here&rsquo;s a nice timing summary for the methods:</p>
<table>
<thead>
<tr>
<th><strong>Algorithm</strong></th>
<th><strong>Ten thousand</strong></th>
<th><strong>One million</strong></th>
<th><strong>One billion</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct</td>
<td>91 ms</td>
<td>86.0 s</td>
<td>â€”</td>
</tr>
<tr>
<td>Previous primes</td>
<td>9.0 s</td>
<td>â€”</td>
<td>â€”</td>
</tr>
<tr>
<td>Eratosthenes (list)</td>
<td>4.3 s</td>
<td>â€”</td>
<td>â€”</td>
</tr>
<tr>
<td>Eratosthenes (vector)</td>
<td>6 ms</td>
<td>0.9 s</td>
<td>â€”</td>
</tr>
<tr>
<td>Eratosthenes (bitvector)</td>
<td>31 ms</td>
<td>5.2 s</td>
<td>2 hr 42 min</td>
</tr>
<tr>
<td>Eratosthenes (multivector)</td>
<td>34 ms</td>
<td>6.6 s</td>
<td>â€”</td>
</tr>
<tr>
<td>Atkin (vector)</td>
<td>12 ms</td>
<td>2.4 s</td>
<td>â€”</td>
</tr>
<tr>
<td>Atkin (bitvector)</td>
<td>20 ms</td>
<td>3.1 s</td>
<td>1 hr 28 min</td>
</tr>
<tr>
<td>Atkin (multivector)</td>
<td>23 ms</td>
<td>4.4 s</td>
<td>â€”</td>
</tr>
<tr>
<td>Sundaram</td>
<td>32.1 s</td>
<td>â€”</td>
<td>â€”</td>
</tr>
<tr>
<td><a href="https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/">Segmented Sieve</a></td>
<td>7 ms</td>
<td>0.9 s</td>
<td>25 min 12 sec</td>
</tr>
</tbody>
</table>
<p>And the actual values:</p>
<table>
<thead>
<tr>
<th><strong>Ten thousand</strong></th>
<th>496165411</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>One million</strong></td>
<td>7472966967499</td>
</tr>
<tr>
<td><strong>One billion</strong></td>
<td>11138479445180240497</td>
</tr>
</tbody>
</table>
<p>If you&rsquo;d like to download the source code for today&rsquo;s post, you can do so here:</p>
<ul>
<li><a href="https://github.com/jpverkamp/small-projects/blob/master/blog/billion-primes.rkt" title="billion primes source">billion primes source</a></li>
<li><a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/bitvector.rkt" title="bitvector source">bitvector source</a></li>
<li><a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/multivector.rkt" title="multivector source">multivector source</a></li>
</ul>
<p><strong>Edit</strong>: After Will&rsquo;s comments, I actually got around to writing a segmented version. It&rsquo;s pretty amazing the different it made too. It runs about 3x faster than even the Sieve of Atkin. Sometimes optimization is awesome. You can find that post <a href="https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/">here</a> and the source code <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/billion-primes-segmented.rkt" title="GitHub: Segmented billion primes source">here</a>.</p></div>
</article></div>
        </div><footer id="page-footer" role="contentinfo">
    <nav id="footer-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation">
            <li><a href="/archive-by-date/">All posts: By Date</a></li>
            <li><a href="/archive-by-tag/">All posts: By Tag</a></li>

            <li>
                <a href="/atom.xml">
                    RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li><li>
                <a href="/programming/atom.xml">
                    RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li></ul>
    </nav>

    <div id="page-footer-content">
        <div class="legal">
            <p>
                All posts unless otherwise mentioned are licensed under
                <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">
                    <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png">
                </a>
            </p>

            <p>
                Any source code unless otherwise mentioned is licensed under the <a href="//directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
            </p>
        </div>
    </div>
</footer>
</div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js" integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js" integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin="anonymous"></script>

<script src="/custom.js"></script>
</body>
</html>
