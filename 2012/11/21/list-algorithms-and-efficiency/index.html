<!doctype html><html><head><title>List algorithms and efficiency â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.e0e68b86dea32185ab89b0b9cc01649107cc6b0be3290c8c7b13c716bc0dabfa.css integrity="sha256-4OaLht6jIYWribC5zAFkkQfMawvjKQyMexPHFrwNq/o="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>List algorithms and efficiency</h1><div class=entry-meta><span class=entry-date>2012-11-21</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/10/25/determining-country-by-latitude/longitude/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2012/12/10/numbers-of-wirth/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/11/15/project-euler-9/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/11/15/project-euler-9/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/10/taxicab-numbers/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/programming-praxis>Programming Praxis</a><a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/11/15/project-euler-9/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/11/21/confession-day-20/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/11/22/confession-day-21/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Programming Praxis&rsquo; new challenge(s) are to write three different list algorithms three times, each with a different runtime complexity. From their <a title="Programming Praxis: List Intersection and Union" href=http://programmingpraxis.com/2012/11/16/list-intersection-and-union/>first post</a> last week we have list intersection and union and from a <a title="Programming Praxis: List Difference" href=http://programmingpraxis.com/2012/11/20/list-difference/>newer post</a> yesterday we have the difference of two lists. For each of those, we want to be able to write an algorithm that runs in O(n<sup>2</sup>) time, one that runs in O(n log n), and finally one that runs in O(n). It turns out that it&rsquo;s more of an exercise in data structures than anything (although they&rsquo;re all still technically &rsquo;list&rsquo; algorithms), but it&rsquo;s still interesting to see how you can achieve the same goal in different ways that may be far more efficient.</p><p>Since all three of the basic algorithms (intersection, union, and difference) are actually rather similar, I&rsquo;m going to start with the three different runtimes first. Like my recent <a href=https://blog.jverkamp.com/2012/11/15/project-euler-9/>Project Euler</a> posts, I&rsquo;ll be writing the code in both Racket and Python to help those that read one language but not the other (although I would highly recommend that you learn both actually, they each have definite strengths). If you&rsquo;d like to see the full code for each algorithm, you can see it here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.py title="List algorithms source (Python)">python</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.rkt title="List algorithms source (Racket)">racket</a></p><p>First, let&rsquo;s start with the slowest but most likely easiest to understand algorithm. Since we&rsquo;re doing list intersection, we want to only return the elements in both lists. To do that, we want to start by looping over one list. For each element in that last, scan through the second list. If the element is in both, return it, otherwise, skip it. This ends up being O(n<sup>2</sup>) because for each element in one list (O(n)), you have to loop over the other list (also O(n)). Since the loops are nested, you multiply the runtimes, resulting in O(n<sup>2</sup>).</p><p>Starting with the Python version (note that Python&rsquo;s <code>in</code> operator on lists loops over the list to check for inclusion):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>intersection_loops</span>(ls1, ls2):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Calculate the intersection of two lists using nested loops.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> ls1:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> e <span style=color:#f92672>in</span> ls2:
</span></span><span style=display:flex><span>			result<span style=color:#f92672>.</span>append(e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p>(Yes, this could be written in a single line using Python&rsquo;s list comprehension as <code>return [e for e in ls1 if e in ls2]</code>. In this case, I&rsquo;m going for clean code over the shortest version.)</p><p>Next, we have the Racket version (in much the same way, <code>member</code> is linear):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Calculate the intersection of two lists using nested loops.</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>intersection-loops</span> ls1 ls2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([ls1 ls1])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(null? ls1) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [(member (car ls1) ls2) 
</span></span><span style=display:flex><span>       (cons (car ls1) (<span style=color:#a6e22e>loop</span> (cdr ls1)))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (cdr ls1))])))
</span></span></code></pre></div><p>This could be shortened significantly using Racket&rsquo;s <code>for/list</code> macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>intersection-loops</span> ls1 ls2)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/list</span> ([e (<span style=color:#a6e22e>in-list</span> ls1)]
</span></span><span style=display:flex><span>             <span style=color:#f92672>#</span>:when (member e ls2))
</span></span><span style=display:flex><span>    e))
</span></span></code></pre></div><p>This will work here and on the third case, but we&rsquo;ll need to write the loops explicitly in the next (pre-sorted) case.</p><p>When you run it on some randomly generated lists, the result is quite obviously quadratic (the blue line is the runtime, the red line is a quadratic fit):</p><figure><img src=/embeds/2012/intersection-loops.png></figure><p>Next, we want to improve the time to O(n log n). Any time that you see a runtime like that, you should immediately think &lsquo;sort&rsquo; (or trees, but not in this case) as the best sorting algorithms all have that runtime. In this case, we have to change the algorithm somewhat, but the basic idea is to first sort the lists. Then, you only have to compare the first elements against each other, basically zipping them together.</p><p>That basic idea in Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>intersection_sort</span>(ls1, ls2):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Calculate the intersection of two lists by sorting them first.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ls1 <span style=color:#f92672>=</span> sorted(ls1)
</span></span><span style=display:flex><span>	ls2 <span style=color:#f92672>=</span> sorted(ls2)
</span></span><span style=display:flex><span>	result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;=</span> len(ls1):
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>elif</span> j <span style=color:#f92672>&gt;=</span> len(ls2):
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>elif</span> ls1[i] <span style=color:#f92672>&lt;</span> ls2[j]:
</span></span><span style=display:flex><span>			i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>elif</span> ls1[i] <span style=color:#f92672>&gt;</span> ls2[j]:
</span></span><span style=display:flex><span>			j <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>: <span style=color:#75715e># ==</span>
</span></span><span style=display:flex><span>			result<span style=color:#f92672>.</span>append(ls1[i])
</span></span><span style=display:flex><span>			i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			j <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p>For intersection, if either list runs out, we&rsquo;re done. There will be no more matched elements. If either first element is smaller than the other, skip past that one. As soon as they&rsquo;re both equal, we have a match. Return it and keep going. The other two (union and difference) are much the same, see the full code (<a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.py title="List algorithms source (Python)">python</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.rkt title="List algorithms source (Racket)">racket</a>) for more details.</p><p>And here&rsquo;s the Racket version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>intersection-sort</span> ls1 ls2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([ls1 (<span style=color:#a6e22e>sort</span> ls1 &lt;)]
</span></span><span style=display:flex><span>             [ls2 (<span style=color:#a6e22e>sort</span> ls2 &lt;)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(null? ls1) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [(null? ls2) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [(&lt; (car ls1) (car ls2))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (cdr ls1) ls2)]
</span></span><span style=display:flex><span>      [(&gt; (car ls1) (car ls2))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> ls1 (cdr ls2))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (cons (car ls1) (<span style=color:#a6e22e>loop</span> (cdr ls1) (cdr ls2)))])))
</span></span></code></pre></div><p>If we graph this one against O(n log n), we find that the graph isn&rsquo;t nearly as nice. Mostly, that&rsquo;s due to the relatively small times we&rsquo;re using. I also tried using larger lists, but garbage collection became a significant problem. Again, the blue is runtime and the red is the expected value.</p><figure><img src=/embeds/2012/insertion-sort.png></figure><p>Finally, the fastest version. The goal here is O(n). Since we have to loop over the lists at least once, that&rsquo;s going to be the fastest we can get. Since we don&rsquo;t have any more room to breathe as it were, we need an O(1) sort of algorithm. The first thing that comes to mind then is a hash. Hashes will gives us both O(1) insertion and selection, so it sounds like exactly what we need. Actually, the change from the first set (with nested loops) is only a line or two of code in each. In the Python version, we&rsquo;ll still be using <code>in</code>, but we want to build a <code>set</code> first (which is stored using hashing):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>intersection_hash</span>(ls1, ls2):
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;&#39;&#39;Calculate the intersection of two lists using a hash.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ls2_set <span style=color:#f92672>=</span> set(ls2)
</span></span><span style=display:flex><span>	result <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> ls1:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> e <span style=color:#f92672>in</span> ls2_set:
</span></span><span style=display:flex><span>			result<span style=color:#f92672>.</span>append(e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p>And similarly for Racket, we will be using a hash built using <code>for/list</code>. For that, we want to return two <code>value</code>s, the key and the value. We don&rsquo;t care what the values are, so we&rsquo;ll just insert <code>#t</code>. Then we can use <code>hash-has-key?</code> to do the lookup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Calculate the intersection of two lists using a hash.</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>intersection-hash</span> ls1 ls2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>ls2-hash (<span style=color:#a6e22e>for/hash</span> ([e2 (<span style=color:#a6e22e>in-list</span> ls2)]) (values e2 <span style=color:#66d9ef>#t</span>)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([ls1 ls1])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(null? ls1) <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>hash-has-key?</span> ls2-hash (car ls1)) 
</span></span><span style=display:flex><span>       (cons (car ls1) (<span style=color:#a6e22e>loop</span> (cdr ls1)))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (cdr ls1))])))
</span></span></code></pre></div><p>Similiarly to the sorted case, the timing (blue line) isn&rsquo;t perfect, but it&rsquo;s quite clearly linear (the red line):</p><figure><img src=/embeds/2012/insertion-hash.png></figure><p>ANd that&rsquo;s it. I&rsquo;m not actually going to include the code for union or difference as it&rsquo;s basically the same with a few minor tweaks. You can see it in its fully comment entirety here: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.py title="List algorithms source (Python)">python</a>, <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/list-algorithms.rkt title="List algorithms source (Racket)">racket</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>