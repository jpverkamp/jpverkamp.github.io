<!doctype html><html><head><title>Project Euler 9 – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Project Euler 9</h1><div class=entry-meta><span class=entry-date>2012-11-15</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/14/project-euler-8/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2012/11/14/project-euler-8/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2012/11/14/project-euler-8/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/project-euler>Project Euler</a><a href=https://blog.jverkamp.com/2023/08/05/stacklang-part-vii-new-cli-and-datatypes/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2012/11/14/project-euler-8/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2012/11/15/confession-day-14/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2012/11/15/confession-day-15/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><blockquote><p>A Pythagorean triplet is a set of three natural numbers, a b c, for which,</p></blockquote><blockquote><p>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></p></blockquote><blockquote><p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.</p></blockquote><blockquote><p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.</p></blockquote><blockquote><p>Find the product abc.
&ndash; <cite><a href="http://projecteuler.net/problem=9">PROJECT EULER #9</a></cite></p></blockquote><p>I like it. &#x1f604;</p><p>I&rsquo;ve already done a <a href=https://blog.jverkamp.com/2012/10/27/pythagorean-triples/>much larger problem</a> on <a href=https://en.wikipedia.org/wiki/Pythagorean%20Triples>Pythagorean Triples</a>, so this one should be pretty straight forward. Essentially, since we know that an answer exists, we need to just go through all of the triples in some sensible order until we find the one that we want.</p><p>Starting with Python this, time, we can represent that idea pretty directly with a generator (a function that when called multiple times returns a (potentially) different answer for each call):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pythagorean_triplets</span>():
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Generate all pythagorean triples with a &lt; b, ordered by b.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> xrange(<span style=color:#ae81ff>1</span>, b <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>sqrt(a <span style=color:#f92672>*</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>*</span> b) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> int(c):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> a, b, int(c)
</span></span></code></pre></div><p>The idea here is to loop through all natural numbers for <code>b</code>. For each of those, loop through all values for <code>a</code> up to (and including) <code>b</code>. For each, calculate <code>c</code> and check if it&rsquo;s an actual integer solution. If it is, <code>return</code> it (in this case, we use <code>yield</code> rather than <code>return</code> to signify that this is a generator and to &lsquo;<code>return</code>&rsquo; multiple results).</p><p>From here, we want to write a general function that, given any number n, will find a Pythagorean triple such that <code>a+b+c = n</code>. The power of Python&rsquo;s generators is that we can directly use them in a loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pythagorean_sum_equals</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Find all pythagorean triples where a+b+c = n.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a, b, c <span style=color:#f92672>in</span> pythagorean_triplets():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> c <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a, b, c
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> b <span style=color:#f92672>&gt;</span> n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#75715e>#f</span>
</span></span></code></pre></div><p>The last bit there says that if we&rsquo;ve already advanced be past n, we know that there&rsquo;s no chance for finding a valid sum as all future sums are greater than n. We could probably stop a bit sooner than that, but since we&rsquo;re looking at the moment for a sum that we know exists, we don&rsquo;t have to.</p><p>Let&rsquo;s try it out with the smallest Pythagorean Triple. We should just get the triple right back out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> pythagorean_sum_equals(<span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><p>Good to go. So, let&rsquo;s use this to actually solve the problem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>problem_0009</span>():
</span></span><span style=display:flex><span>    a, b, c <span style=color:#f92672>=</span> pythagorean_sum_equals(<span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> b <span style=color:#f92672>*</span> c
</span></span></code></pre></div><p>And try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> problem_0009()
</span></span><span style=display:flex><span><span style=color:#ae81ff>31875000</span>
</span></span></code></pre></div><p>Exactly what we were looking for. And it only took 36 milliseconds to calculate. That&rsquo;s pretty good. Judging from a comment on the previous Pythagorean Triples post, generators are expensive, so let&rsquo;s try it without:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pythagorean_sum_equals_nogen</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Find all pythagorean triples where a+b+c = n.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> xrange(<span style=color:#ae81ff>1</span>, b <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>sqrt(a <span style=color:#f92672>*</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>*</span> b) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> int(c) <span style=color:#f92672>and</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> c <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a, b, c
</span></span></code></pre></div><p>It turns out though, that while this code is faster, it&rsquo;s only 3 milliseconds (about 10% faster), well within the threshold for noise for this sort of problem. We&rsquo;ll keep trying on future problems though, on some of them that take longer to run, it may become necessary.</p><p>Now that we&rsquo;ve gotten the solution worked out in Python, let&rsquo;s work it out in Racket. I&rsquo;m just going to go straight for the non-generator version here, since I do know that generators in Racket are more expensive.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>pythagorean-sum-equals</span> n)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>call/cc</span>
</span></span><span style=display:flex><span>   (<span style=color:#66d9ef>lambda </span>(<span style=color:#a6e22e>return</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>for*</span> ([b (<span style=color:#a6e22e>in-naturals</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>            [a (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ b <span style=color:#ae81ff>1</span>))])
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>c (sqrt (+ (* a a) (* b b))))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(integer? c)
</span></span><span style=display:flex><span>                  (= n (+ a b c)))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>return</span> (* a b c)))))))
</span></span></code></pre></div><p>There are two interesting points here. The first is the use of <code>call/cc</code> to bail out of the function whenever I find a solution, much as I did back in the solution to <a href=https://blog.jverkamp.com/2012/08/27/4sum/>4sum</a>. <code>call/cc</code> is a fascinating beast all it&rsquo;s own, but all you need to know at this point is that it will take whatever would be done &rsquo;next&rsquo; where it&rsquo;s called (in this case, returning from the function) and pass it along as an argument. So in this case, <code>return</code> has the same meaning that it would in Python or the like, although I could have chosen anything for that name.</p><p>The second intersting thing is the <code>for*</code> macro. Rather than zipping the two variables as a normal <code>for</code> would, <code>for*</code> automatically nests them, so that you get the exact same nested looping structure that we had in the Python version, only in two lines rather than 4.</p><p>After that, the core of the loop is the same, so we should theoretically get the same answer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>time</span> (<span style=color:#a6e22e>pythagorean-sum-equals</span> <span style=color:#ae81ff>1000</span>))
</span></span><span style=display:flex><span>cpu time: <span style=color:#ae81ff>24</span> real time: <span style=color:#ae81ff>24</span> gc time: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>31875000</span>
</span></span></code></pre></div><p>So we do. And it&rsquo;s marginally faster, which I would say is probably the general case between Python and Racket. We&rsquo;ll see though, particularly as the problems get even more interesting.</p><p>As always, you can download my code for this or any Project Euler problem I’ve uploaded <a href=https://github.com/jpverkamp/small-projects/tree/master/project-euler title="GitHub: jpverkamp: Project Euler">here</a>.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>