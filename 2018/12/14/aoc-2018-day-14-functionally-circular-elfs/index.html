<!doctype html><html><head><title>AoC 2018 Day 14: Functionally Circular Elfs â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js integrity="sha256-MESIkqofkenEy1SU5cXlq8E7d3jed4blJWzcfSQkgTo=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.1a5fbab1ecff843d4ee6e936243fb06066197cd8c9357883d791333ce6001f3b.css integrity="sha256-Gl+6sez/hD1O5uk2JD+wYGYZfNjJNXiD15EzPOYAHzs="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>AoC 2018 Day 14: Functionally Circular Elfs</h1><div class=entry-meta><span class=entry-date>2018-12-14</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/13/aoc-2018-day-13-mine-cart-madness/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2020/01/29/wrapping-xattr-as-a-racket-module/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/13/aoc-2018-day-13-mine-cart-madness/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2021/12/01/advent-of-code-2021/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/13/aoc-2018-day-13-mine-cart-madness/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2018>Advent of Code 2018</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2018/12/13/aoc-2018-day-13-mine-cart-madness/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2019/01/04/listing-and-downloading-s3-versions/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2018/12/13/aoc-2018-day-13-mine-cart-madness/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/29/furies-of-calderon/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-chocolate-chartshttpsadventofcodecom2018day14>Source: <a href=https://adventofcode.com/2018/day/14>Chocolate Charts</a></h3><blockquote><p><strong>Part 1:</strong> Create an infinite stream of numbers, by starting with [3, 7] with two pointers: 0 and 1. To add values to the list:</p></blockquote><blockquote><ul><li>Add the current values of the two pointers<ul><li>If the value is less than ten, add that value to the end of the list</li><li>If the value is greater or equal to ten, add 1 and then the ones digits to the end of the list</li></ul></li><li>Update each pointer by adding the value it is pointing at to its current index plus one</li></ul></blockquote><blockquote><p>With that algorithm, find the ten digits after a given index.</p></blockquote><p>Fascinating.</p><p>My first inclination is that I want circular lists. But the code I have from <a href=https://blog.jverkamp.com/2018/12/09/aoc-2018-day-9-marble-madness/>Marble Madness</a> won&rsquo;t quite work, since I also need to keep track of the two pointers.</p><p>My second inclination is that I want an array of values where I can cheaply add values to the end and index arbitrary elements. What I really want is something like an <code><a href>ArrayList</a></code>
from Java. But this is Racket. Let&rsquo;s just fake it with a <code><a href="http://docs.racket-lang.org/search/index.html?q=hash">hash</a></code>
keyed on integers and a length. Not quite as memory efficient, but it will work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>struct</span> state (data length elf1 elf2) <span style=color:#66d9ef>#:transparent</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (initial-state)
</span></span><span style=display:flex><span>  (state (hash <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p>Now, we can start building up increasingly complicated functions. First, we want a function that can add a single value to the end of the list. Second, add either one or two values based on the current pointers (if the sum is greater than 10 or not). Third, move the pointers based on their current values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Add a single value to the end of the current state</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (add-recipe s v)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (state data length elf1 elf2) s)
</span></span><span style=display:flex><span>  (state (hash-set data length v)
</span></span><span style=display:flex><span>         (add1 length)
</span></span><span style=display:flex><span>         elf1
</span></span><span style=display:flex><span>         elf2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Add one or two recipes to the state</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (add-recipes s)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (state data length elf1 elf2) s)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> sum (+ (hash-ref data elf1) (hash-ref data elf2)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>    [(&gt;= sum <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>     (add-recipe (add-recipe s (quotient sum <span style=color:#ae81ff>10</span>)) (remainder sum <span style=color:#ae81ff>10</span>))]
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>     (add-recipe s sum)]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Update each elf&#39;s current recipe</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Wrap values that run off the end of the current list back to the beginning</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (move-elfs s)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (state data length elf1 elf2) s)
</span></span><span style=display:flex><span>  (state data
</span></span><span style=display:flex><span>         length
</span></span><span style=display:flex><span>         (remainder (+ elf1 (hash-ref data elf1) <span style=color:#ae81ff>1</span>) length)
</span></span><span style=display:flex><span>         (remainder (+ elf2 (hash-ref data elf2) <span style=color:#ae81ff>1</span>) length)))
</span></span></code></pre></div><p>And with that, we can expand the current list:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Do a full update</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (tick s)
</span></span><span style=display:flex><span>  (move-elfs (add-recipes s)))
</span></span></code></pre></div><p>I always love when the final version of a function is next to nothing because of the work you&rsquo;ve already put in.</p><p>So, how do we find the 10 values after a given point? Well, first we have to make the list long enough, then just pull them out of <code>state-data</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Calculate the score after a coordinate</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (score i)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> state
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let</span> loop ([s (initial-state)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>        [(&lt; (state-length s) (+ i <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>         (loop (tick s))]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>else</span> s])))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for/list</span> ([i (in-range i (+ i <span style=color:#ae81ff>10</span>))])
</span></span><span style=display:flex><span>    (hash-ref (state-data state) i)))
</span></span></code></pre></div><p>With a quick helper to turn that into a single number:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (digits-&gt;int ls)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([n <span style=color:#ae81ff>0</span>] [digits ls])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      [(null? digits) n]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop (+ (* n <span style=color:#ae81ff>10</span>) (first digits))
</span></span><span style=display:flex><span>             (rest digits))])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> argv (current-command-line-arguments))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>for</span> ([arg (in-vector argv)])
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;input: ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> arg)
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;[part1] ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> (digits-&gt;int (score (string-&gt;number arg)))))
</span></span></code></pre></div><p>And for my input:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ racket functionally-circular-elfs.rkt <span style=color:#ae81ff>157901</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>input: <span style=color:#ae81ff>157901</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part1<span style=color:#f92672>]</span> <span style=color:#ae81ff>9411137133</span>
</span></span></code></pre></div><p>Nice.</p><blockquote><p><strong>Part 2:</strong> Given a sequence of digits, what is the index of the first occurance of those digits?</p></blockquote><p>This is computationally a bit more interesting. It actually reminds me of <a href=https://blog.jverkamp.com/2012/09/16/a-needle-in-a-pi-stack/>a post I wrote all the way back in 2012</a>&mldr;</p><p>The goal here will be to keep a list of digits we have left to find and scan through the current list of numbers, expanding it whenever we need more. If we get a partial match but then an error, just reset to the original list of digits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Find a specific pattern in the input stream</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (search ls)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([state (initial-state)]
</span></span><span style=display:flex><span>             [index <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>             [to-find ls])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>when</span> (zero? (remainder index <span style=color:#ae81ff>1000</span>)) (displayln index))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Found our target, return the index it started at</span>
</span></span><span style=display:flex><span>      [(null? to-find) (- index (length ls))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Don&#39;t have enough data, generate some more</span>
</span></span><span style=display:flex><span>      [(&gt;= index (state-length state))
</span></span><span style=display:flex><span>       (loop (tick state) index to-find)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The current match continues</span>
</span></span><span style=display:flex><span>      [(equal? (first to-find) (hash-ref (state-data state) index))
</span></span><span style=display:flex><span>       (loop state (add1 index) (rest to-find))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; The current match does not continue, reset to where we started + 1</span>
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop state (+ (- index (length ls)) (length to-find) <span style=color:#ae81ff>1</span>) ls)])))
</span></span></code></pre></div><p>For full output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (int-&gt;digits n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([n n] [digits <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      [(&lt; n <span style=color:#ae81ff>10</span>) (list* n digits)]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span> (loop (quotient n <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>                  (list* (remainder n <span style=color:#ae81ff>10</span>) digits))])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Find score/search for any given values</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> argv (current-command-line-arguments))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>for</span> ([arg (in-vector argv)])
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;input: ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> arg)
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;[part1] ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> (digits-&gt;int (score (string-&gt;number arg))))
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;[part2] ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> (search (int-&gt;digits (string-&gt;number arg)))))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ racket functionally-circular-elfs.rkt <span style=color:#ae81ff>157901</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>input: <span style=color:#ae81ff>157901</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part1<span style=color:#f92672>]</span> <span style=color:#ae81ff>9411137133</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part2<span style=color:#f92672>]</span> <span style=color:#ae81ff>20317612</span>
</span></span></code></pre></div><p>This is actually a really neat problem since my original approach was not at all functional, using mutation in order to create a proper doubly-linked list with pointers to the two elf nodes. But not only was it not as &lsquo;pure&rsquo; it was actually a lot more complicated and ugly code. This is just so much nicer to work with. ðŸ˜„</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>