<!doctype html><html><head><title>AoC 2018 Day 13: Mine Cart Madness – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2018 Day 13: Mine Cart Madness</h1><div class=entry-meta><span class=entry-date>2018-12-13</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/12/aoc-2018-day-12-fat-cellular-automaton/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2018/12/14/aoc-2018-day-14-functionally-circular-elfs/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/12/aoc-2018-day-12-fat-cellular-automaton/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2018/12/14/aoc-2018-day-14-functionally-circular-elfs/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/12/aoc-2018-day-12-fat-cellular-automaton/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2018>Advent of Code 2018</a><a href=https://blog.jverkamp.com/2018/12/14/aoc-2018-day-14-functionally-circular-elfs/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2018/12/12/aoc-2018-day-12-fat-cellular-automaton/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/14/aoc-2018-day-14-functionally-circular-elfs/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2018/12/12/aoc-2018-day-12-fat-cellular-automaton/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/14/aoc-2018-day-14-functionally-circular-elfs/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-mine-cart-madness>Source: <a href=https://adventofcode.com/2018/day/13 target=_blank rel=noopener>Mine Cart Madness</a></h3><blockquote><p><strong>Part 1:</strong> Load a minecart track that looks like this:</p></blockquote><blockquote><pre tabindex=0><code></code></pre></blockquote><p>/->-\<br>| | /&mdash;-<br>| /-+&ndash;+-\ |
| | | | v |
-+-/ -+&ndash;/
-&mdash;&ndash;/</p><pre tabindex=0><code>
&gt; Assuming minecarts follow the tracks and alternate turning left, going straight, and turning right on each intersection (`+`), where does the first collision occur?

&gt; NOTE: Update carts top to bottom, left to right. Carts can collide mid update.




Okay. It&#39;s an interesting data format problem mostly. And we have to deal a bit with not being imperative, in particular when we&#39;re doing the updates, since having collisions happen halfway through an update is not so great. Let&#39;s load it:

```racket
(struct point (x y) #:transparent)
(struct cart (location velocity next-turn) #:transparent)
(struct track (data carts top-left bottom-right) #:transparent)
</code></pre><p>The goal will be to load the tracks into a hash of <code>point</code> to character (so I know how the track turns / intersects) and separately store the carts. I&rsquo;ll want to process the track after the initial load to replace carts with their underlying track and get the initial velocity as well. Finally, <code>next-turn</code> will always start as <code>'left</code>, but we&rsquo;ll deal with that later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Read a track from the current-input</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (read-track [in (current-input-port)])
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Read the raw data</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> raw-data
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for/fold</span> ([track (hash)])
</span></span><span style=display:flex><span>              ([line (in-lines in)]
</span></span><span style=display:flex><span>               [y (in-naturals)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>for/fold</span> ([track track])
</span></span><span style=display:flex><span>                ([c (in-string line)]
</span></span><span style=display:flex><span>                 [x (in-naturals)]
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>#:unless</span> (equal? c <span style=color:#e6db74>#\space</span>))
</span></span><span style=display:flex><span>        (hash-set track (point x y) c))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; For each cart character, track to underlying track and current velocity</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> cart-track-data
</span></span><span style=display:flex><span>    (hash <span style=color:#e6db74>#\&gt;</span> (list <span style=color:#e6db74>#\-</span>  <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>          <span style=color:#e6db74>#\&lt;</span> (list <span style=color:#e6db74>#\-</span> <span style=color:#ae81ff>-1</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>          <span style=color:#e6db74>#\^</span> (list <span style=color:#e6db74>#\|</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>-1</span>)
</span></span><span style=display:flex><span>          <span style=color:#e6db74>#\v</span> (list <span style=color:#e6db74>#\|</span> <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Determine where the carts are</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define-values</span> (data carts)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for*/fold</span> ([data raw-data]
</span></span><span style=display:flex><span>                [carts (list)])
</span></span><span style=display:flex><span>               ([(p c) (in-hash raw-data)]
</span></span><span style=display:flex><span>                [ctd (in-value (hash-ref cart-track-data c <span style=color:#66d9ef>#f</span>))]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>#:when</span> ctd)
</span></span><span style=display:flex><span>      (values
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Overwrite the track point with the underlying track</span>
</span></span><span style=display:flex><span>       (hash-set data p (first ctd))
</span></span><span style=display:flex><span>       <span style=color:#75715e>; Store the cart position and velocity</span>
</span></span><span style=display:flex><span>       (list* (cart p (point (second ctd) (third ctd)) <span style=color:#f92672>&#39;</span><span style=color:#e6db74>left</span>) carts))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Determine the bounds for the track</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define-values</span> (min-x max-x min-y max-y)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for/fold</span> ([min-x <span style=color:#66d9ef>#f</span>] [max-x <span style=color:#66d9ef>#f</span>] [min-y <span style=color:#66d9ef>#f</span>] [max-y <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>              ([(p c) (in-hash data)])
</span></span><span style=display:flex><span>      (values (min (<span style=color:#66d9ef>or</span> min-x (point-x p)) (point-x p))
</span></span><span style=display:flex><span>              (max (<span style=color:#66d9ef>or</span> max-x (point-x p)) (point-x p))
</span></span><span style=display:flex><span>              (min (<span style=color:#66d9ef>or</span> min-y (point-y p)) (point-y p))
</span></span><span style=display:flex><span>              (max (<span style=color:#66d9ef>or</span> max-y (point-y p)) (point-y p)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Finally create the track structure</span>
</span></span><span style=display:flex><span>  (track data
</span></span><span style=display:flex><span>         carts
</span></span><span style=display:flex><span>         (point min-x min-y)
</span></span><span style=display:flex><span>         (point max-x max-y)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>It&rsquo;s a bit complicated and it turns out that the only reason that I need the bounds is to display the tracks for debug reasons, which amuses me somewhat. But we have it, so let&rsquo;s use it. Speaking of display, here&rsquo;s a function to take those bounds and write out what the current track looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Helper function to display a track</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (display-track m)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for</span> ([y (in-range (point-y (track-top-left m)) (add1 (point-y (track-bottom-right m))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for</span> ([x (in-range (point-x (track-top-left m)) (add1 (point-x (track-bottom-right m))))])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>        [(<span style=color:#66d9ef>for/first</span> ([c (in-list (track-carts m))]
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>#:when</span> (equal? (cart-location c) (point x y)))
</span></span><span style=display:flex><span>           c)
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>=&gt;</span> (<span style=color:#66d9ef>λ</span> (c)
</span></span><span style=display:flex><span>              (display
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>match</span> (cart-velocity c)
</span></span><span style=display:flex><span>                 [(point <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>1</span>) <span style=color:#e6db74>#\v</span>]
</span></span><span style=display:flex><span>                 [(point <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>-1</span>) <span style=color:#e6db74>#\^</span>]
</span></span><span style=display:flex><span>                 [(point  <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>) <span style=color:#e6db74>#\&gt;</span>]
</span></span><span style=display:flex><span>                 [(point <span style=color:#ae81ff>-1</span> <span style=color:#ae81ff>0</span>) <span style=color:#e6db74>#\&lt;</span>])))]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>         (display (hash-ref (track-data m) (point x y) <span style=color:#e6db74>#\.</span>))]))
</span></span><span style=display:flex><span>    (newline)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Helpful for debugging. <code><a href="http://docs.racket-lang.org/search/index.html?q=match">match</a></code>
is lovely.</p><p>Okay, next we want a function to update a single <code>cart</code>. We&rsquo;ll use this next to update each cart in turn. This got tricky. Initially, I was checking the carts against the <code>track</code> data (to check for collisions), but that doesn&rsquo;t work, since we can have a cart collide against another one after both have already moved. The only way I&rsquo;ve seen to track that is to specify the current cart locations to the <code>update-cart</code> function. There really should be a more elegant way to do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Update a cart by one tick</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Return the new cart; but if it collided raise the cart as an exception insteadcurrent-frame</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; c* Is a running updated list of carts, since collisions can happen with already moved carts</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (update-cart m c c*)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (cart (point x y) (point vx vy) rotation) c)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> new-location (point (+ x vx) (+ y vy)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define-values</span> (new-velocity new-rotation)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>case</span> (hash-ref (track-data m) new-location)
</span></span><span style=display:flex><span>      [(<span style=color:#e6db74>#\/</span>) (values (point (- vy) (- vx)) rotation)]
</span></span><span style=display:flex><span>      [(<span style=color:#e6db74>#\\</span>) (values (point vy vx) rotation)]
</span></span><span style=display:flex><span>      [(<span style=color:#e6db74>#\+</span>)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>case</span> rotation
</span></span><span style=display:flex><span>         [(left)     (values (point vy (- vx)) <span style=color:#f92672>&#39;</span><span style=color:#e6db74>straight</span>)]
</span></span><span style=display:flex><span>         [(straight) (values (point vx vy)     <span style=color:#f92672>&#39;</span><span style=color:#e6db74>right</span>)]
</span></span><span style=display:flex><span>         [(right)    (values (point (- vy) vx) <span style=color:#f92672>&#39;</span><span style=color:#e6db74>left</span>)])]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>  (values (point vx vy) rotation)]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> updated-cart (cart new-location new-velocity new-rotation))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Check for collisions</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for</span> ([c (in-list c*)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>#:when</span> (equal? new-location (cart-location c)))
</span></span><span style=display:flex><span>    (raise updated-cart))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  updated-cart)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>One thing that I actually enjoy here is that I&rsquo;m using <code><a href="http://docs.racket-lang.org/search/index.html?q=exception">exception</a></code>
handling to deal with the collisions. The function itself only deals with returning the updated cart. If there&rsquo;s a collision, we&rsquo;ll <code><a href="http://docs.racket-lang.org/search/index.html?q=raise">raise</a></code>
the cart that caused the problem in order to catch it via <code><a href="http://docs.racket-lang.org/search/index.html?q=with-handlers">with-handlers</a></code>
later.</p><p>I&rsquo;m also pretty proud of the rotation code. There are a few other ways you can do this, for example with matrix multiplication or hard coding each case. But I worked it out on paper and it turns out that you flip x and y and negate one or the other. (It&rsquo;s a symptom of the aforementioned matrix multiplication.)</p><p>In any case, we can now update the entire track:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Update a track by one tick</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; If two carts collide, an exception will be raised, catch it and return the cart</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (update-track m)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Update carts, has to be done oddly since they can collide half way through an update</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Otherwise, remove the third argument from update-cart and use:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;   (map (curry update-cart m) (sort (track-carts m) cart-location-&lt;?))</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> updated-carts
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let</span> loop ([done <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>               [todo (sort (track-carts m) cart-location-&lt;?)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>        [(null? todo) done]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>; TODO: Make this more efficient than using append</span>
</span></span><span style=display:flex><span>         (loop (list* (update-cart m (first todo) (append done todo)) done)
</span></span><span style=display:flex><span>               (rest todo))])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (track (track-data m)
</span></span><span style=display:flex><span>         updated-carts
</span></span><span style=display:flex><span>         (track-top-left m)
</span></span><span style=display:flex><span>         (track-bottom-right m)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>As the comment notes, I wish we could have done all the carts at a time. But that would lead to carts skipping past each other in cases like this: <code>->--&lt;-</code>. So it goes.</p><p>Now we can take it one step more and run the simulation until we get a collision. Because we&rsquo;re using exceptions and we haven&rsquo;t caught them yet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Run a track until collision, return the cart that collided</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (update-track-until-collision m)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>with-handlers</span> ([cart? identity])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let</span> loop ([m m])
</span></span><span style=display:flex><span>      (loop (update-track m)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Run the main program</span>
</span></span><span style=display:flex><span>(printf <span style=color:#e6db74>&#34;[part1]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> input (read-track))
</span></span><span style=display:flex><span>(update-track-until-collision input)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>That&rsquo;s fun.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat input.txt | racket mine-cart-madness.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>cart <span style=color:#f92672>(</span>point <span style=color:#ae81ff>118</span> 66<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>point <span style=color:#ae81ff>1</span> 0<span style=color:#f92672>)</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>straight<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Whee!</p><blockquote><p><strong>Part 2:</strong> Instead of ending the simulation, removing carts that crash into one another. What is the location of the final remaining cart?</p></blockquote><p>This time around, the <code>updated-carts</code> function will be caught immediately in this function, triggering the removal of the cart that was removed (with the <code>(rest todo</code>) and all other carts at the same location (<code>remove-by-location</code>). Voila:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Update a track by one tick</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; If two carts collide, remove those two carts and contiue updating</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (update-track/remove-collisions m)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Helper to remove carts at a given location from a list</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (remove-by-location carts location)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for/list</span> ([c (in-list carts)]
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>#:unless</span> (equal? (cart-location c) location))
</span></span><span style=display:flex><span>      c))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Calculate the new list of carts, some might collide</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> updated-carts
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let</span> loop ([done <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>               [todo (sort (track-carts m) cart-location-&lt;?)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>        [(null? todo) done]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>with-handlers</span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Case where carts collided</span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Remove that cart + all other carts with that coordinate from both lists</span>
</span></span><span style=display:flex><span>             ([cart? (<span style=color:#66d9ef>λ</span> (c)
</span></span><span style=display:flex><span>                       (loop (remove-by-location done (cart-location c))
</span></span><span style=display:flex><span>                             (remove-by-location (rest todo) (cart-location c))))])
</span></span><span style=display:flex><span>           <span style=color:#75715e>; Otherwise</span>
</span></span><span style=display:flex><span>           (loop (list* (update-cart m (first todo) (append done todo)) done)
</span></span><span style=display:flex><span>                 (rest todo)))])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (track (track-data m)
</span></span><span style=display:flex><span>         updated-carts
</span></span><span style=display:flex><span>         (track-top-left m)
</span></span><span style=display:flex><span>         (track-bottom-right m)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The wrapper function to run until there is only one cart is only slightly longer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Run a track until there is only one cart left, removing carts that collide</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (update-track-until-singleton m)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([m m])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      [(&lt;= (length (track-carts m)) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>       (first (track-carts m))]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop (update-track/remove-collisions m))])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Run the main program again</span>
</span></span><span style=display:flex><span>(printf <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>[part2]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>(current-frame <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>(update-track-until-singleton input)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Shiny:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>$ cat input.txt <span style=color:#960050;background-color:#1e0010>|</span> racket mine-cart-madness.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[part1]
</span></span><span style=display:flex><span>(cart (point <span style=color:#ae81ff>118</span> <span style=color:#ae81ff>66</span>) (point <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&#39;</span><span style=color:#e6db74>straight</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[part2]
</span></span><span style=display:flex><span>(cart (point <span style=color:#ae81ff>70</span> <span style=color:#ae81ff>129</span>) (point <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&#39;</span><span style=color:#e6db74>right</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>As a bonus, I made a function that can render the simulation to a picture!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Helper function to render a map as a frame to an image with ASCII graphics</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (render-frame m <span style=color:#66d9ef>prefix</span>)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (track data carts (point left top) (point right bottom)) m)
</span></span><span style=display:flex><span>  (printf <span style=color:#e6db74>&#34;rendering frame ~a:~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>prefix</span> (current-frame))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>send</span>
</span></span><span style=display:flex><span>   (flomap-&gt;bitmap
</span></span><span style=display:flex><span>    (build-flomap*
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>3</span> (add1 (- right left)) (add1 (- bottom top))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>λ</span> (x y)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Carts are red</span>
</span></span><span style=display:flex><span>         [(<span style=color:#66d9ef>for/first</span> ([c (in-list carts)]
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>#:when</span> (equal? (point x y) (cart-location c)))
</span></span><span style=display:flex><span>            c)
</span></span><span style=display:flex><span>          (vector <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>)]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Tracks are white</span>
</span></span><span style=display:flex><span>         [(hash-ref data (point x y) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>          (vector <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Background is black</span>
</span></span><span style=display:flex><span>         [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          (vector <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>)]))))
</span></span><span style=display:flex><span>   save-file
</span></span><span style=display:flex><span>   (~a <span style=color:#e6db74>&#34;frame-&#34;</span> <span style=color:#66d9ef>prefix</span> <span style=color:#e6db74>&#34;-&#34;</span> (~a (current-frame) <span style=color:#66d9ef>#:min-width</span> <span style=color:#ae81ff>4</span> <span style=color:#66d9ef>#:left-pad-string</span> <span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#66d9ef>#:align</span> <span style=color:#f92672>&#39;</span><span style=color:#e6db74>right</span>) <span style=color:#e6db74>&#34;.png&#34;</span>)
</span></span><span style=display:flex><span>   <span style=color:#f92672>&#39;</span><span style=color:#e6db74>png</span>)
</span></span><span style=display:flex><span>  (current-frame (add1 (current-frame))))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Pretty pictures!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat input.txt | racket mine-cart-madness.rkt --debug-frames
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ convert frame-collision-*.png -interpolate Nearest -filter point -resize 200% aoc-13-minecart.gif
</span></span></code></pre></div><figure><img src=/embeds/2018/aoc-13-minecart.gif></figure><p>Not super helpful at this scale, but pretty.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>