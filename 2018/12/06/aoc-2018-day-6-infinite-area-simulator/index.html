<!doctype html><html><head><title>AoC 2018 Day 6: Infinite Area Simulator – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.a8e11addf4349ee2ca5045f7f3cbf1febbf2c3a2840be2143ea69539c10f8c7f.js integrity="sha256-qOEa3fQ0nuLKUEX388vx/rvyw6KEC+IUPqaVOcEPjH8=" defer></script><script src=/katex_17296078054267651618.min.4a06464d8d6f8358d8896de62b53b5a89205d335dfd8c5b6b27edd7c039ae9d8.js integrity="sha256-SgZGTY1vg1jYiW3mK1O1qJIF0zXf2MW2sn7dfAOa6dg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.a17078917a4403310cd19178939257b706fb5e1da76167c9f4a6d2123c9d59c4.js integrity="sha256-oXB4kXpEAzEM0ZF4k5JXtwb7Xh2nYWfJ9KbSEjydWcQ=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.7420a1602c62a85d4b50881c1d8ce42f72c049dc2b097d440696425d6e54bb1e.css integrity="sha256-dCChYCxiqF1LUIgcHYzkL3LASdwrCX1EBpZCXW5Uux4="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.61064b3964637440ee1c28e577377fcf238ddc5939020ef8b3c3cae543898111.css integrity="sha256-YQZLOWRjdEDuHCjldzd/zyON3Fk5Ag74s8PK5UOJgRE="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2018 Day 6: Infinite Area Simulator</h1><div class=entry-meta><span class=entry-date>2018-12-06</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/05/aoc-2018-day-5-alchemical-reduction/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2018/12/07/aoc-2018-day-7-job-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/05/aoc-2018-day-5-alchemical-reduction/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2018/12/07/aoc-2018-day-7-job-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/05/aoc-2018-day-5-alchemical-reduction/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2018>Advent of Code 2018</a><a href=https://blog.jverkamp.com/2018/12/07/aoc-2018-day-7-job-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2018/12/05/aoc-2018-day-5-alchemical-reduction/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/07/aoc-2018-day-7-job-simulator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2018/12/05/aoc-2018-day-5-alchemical-reduction/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/07/aoc-2018-day-7-job-simulator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-chronal-coordinates>Source: <a href=https://adventofcode.com/2018/day/6 target=_blank rel=noopener>Chronal Coordinates</a></h3><blockquote><p><strong>Part 1:</strong> Given a list of points, calculate the region of points closest to each point (using <a href=https://en.wikipedia.org/wiki/Manhattan%20distance>Manhattan distance</a>). Return the size of the largest non-infinite region.</p></blockquote><p>First, some boilerplate. We want a function to load in the points and then find the bounds of the entire region (we&rsquo;ll need it later):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Read constant POINTS for the current input</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (read-points [in (current-input-port)])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for/list</span> ([line (in-lines in)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>match-define</span> (regexp <span style=color:#e6db74>#px&#34;(\\d+), (\\d+)&#34;</span> (list <span style=color:#66d9ef>_</span> raw-x raw-y)) line)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> x (string-&gt;number raw-x))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> y (string-&gt;number raw-y))
</span></span><span style=display:flex><span>    (point x y)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> POINTS (read-points))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Determine the bounds for the given points</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define-values</span> (MIN-X MAX-X MIN-Y MAX-Y)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for/fold</span> ([min-x <span style=color:#ae81ff>+inf.0</span>] [max-x <span style=color:#ae81ff>-inf.0</span>] [min-y <span style=color:#ae81ff>+inf.0</span>] [max-y <span style=color:#ae81ff>-inf.0</span>])
</span></span><span style=display:flex><span>            ([pt (in-list POINTS)])
</span></span><span style=display:flex><span>    (values (min min-x (point-x pt))
</span></span><span style=display:flex><span>            (max max-y (point-x pt))
</span></span><span style=display:flex><span>            (min min-x (point-y pt))
</span></span><span style=display:flex><span>            (max max-y (point-y pt)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; If a region has more points than are contained in the bounds, it&#39;s infinite</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> VOLUME (* (- MAX-X MIN-X) (- MAX-Y MIN-Y)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Next, define our distance function, a function to find the closet point from our list of given points, and a helper that will give the four neighbors to a given point (we&rsquo;ll use this to <a href=https://en.wikipedia.org/wiki/flood%20fill>flood fill</a>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Manhattan distance</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (distance p1 p2)
</span></span><span style=display:flex><span>  (+ (abs (- (point-x p1) (point-x p2)))
</span></span><span style=display:flex><span>     (abs (- (point-y p1) (point-y p2)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Return the point in pts closest to the given point pt</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (closest target)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define-values</span> (min-point min-distance)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for*/fold</span> ([min-point <span style=color:#66d9ef>#f</span>] [min-distance <span style=color:#ae81ff>+inf.0</span>])
</span></span><span style=display:flex><span>               ([pt (in-list POINTS)]
</span></span><span style=display:flex><span>                [d (in-value (distance target pt))]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>#:when</span> (&lt;= d min-distance))
</span></span><span style=display:flex><span>      (values (<span style=color:#66d9ef>if</span> (= d min-distance) <span style=color:#66d9ef>#f</span> pt) d)))
</span></span><span style=display:flex><span>  min-point)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; The four neighbors of a given point</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (neighbors target)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (point x y) target)
</span></span><span style=display:flex><span>  (list (point x (- y <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        (point (+ x <span style=color:#ae81ff>1</span>) y)
</span></span><span style=display:flex><span>        (point x (+ y <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        (point (- x <span style=color:#ae81ff>1</span>) y)))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>And that&rsquo;s the bulk of what&rsquo;s needed. With that, we can start on a point and flood fill outwards until we either know we have an infinite area or until we find the boundary of all points that are now as close or closer to a different point:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Calculate the number of points closest to this point than any other via floodfill</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (area target)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([area <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>             [to-check (list target)]
</span></span><span style=display:flex><span>             [checked (set)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      [(null? to-check) area]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>match-define</span> (list-rest current-to-check next-to-check) to-check)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define</span> next-checked (set-add checked current-to-check))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Already checked this point, ignore</span>
</span></span><span style=display:flex><span>         [(set-member? checked current-to-check)
</span></span><span style=display:flex><span>          (loop area next-to-check checked)]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; More than the maximum area, has gone infinite</span>
</span></span><span style=display:flex><span>         [(&gt; area VOLUME)
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>+inf.0</span>]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Closest to target, add and expand</span>
</span></span><span style=display:flex><span>         [(equal? target (closest current-to-check))
</span></span><span style=display:flex><span>          (loop (add1 area)
</span></span><span style=display:flex><span>                (append (neighbors current-to-check) next-to-check)
</span></span><span style=display:flex><span>                next-checked)]
</span></span><span style=display:flex><span>         <span style=color:#75715e>; Not closest, don&#39;t add or expand</span>
</span></span><span style=display:flex><span>         [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          (loop area next-to-check next-checked)])])))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The trick to this algorithm is knowing that no single region will end up bigger than the volume enclosing all of the points. So if the area we&rsquo;re looking at is that big, it will clearly become infinite. While this isn&rsquo;t the best algorithm (we could probably trim down the bounds somewhat), it&rsquo;s still fairly fast. And it lets us finish part 1:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Find the largest non-infinite area</span>
</span></span><span style=display:flex><span>(printf <span style=color:#e6db74>&#34;[part1]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>for/fold</span> ([max-point <span style=color:#66d9ef>#f</span>] [max-area <span style=color:#ae81ff>-inf.0</span>])
</span></span><span style=display:flex><span>          ([pt (in-list POINTS)])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> a (area pt))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and</span> (not (infinite? a))
</span></span><span style=display:flex><span>          (&gt; a max-area))
</span></span><span style=display:flex><span>     (values pt a)]
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>     (values max-point max-area)]))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><blockquote><p><strong>Part 2:</strong> Define a new region such that a point <span class=latex-inline>p_1</span>
is in the region if the sum of distances to all input points is less than a given number <span class=latex-inline>R</span>
.</p></blockquote><p>This one took a bit to wrap my head around what they were asking. In the end though, the code ends up being a fairly direct translation of the problem statement. We keep a set of points to check, then move them over as we check them, adding them to the <code>region</code> if they satisfy the given condition.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Find the center point and flood fill out to all points with X of all points</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (points-within-range range)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([to-check (set (point (exact-round (/ (+ MIN-X MAX-X) <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>                                   (exact-round (/ (+ MIN-X MAX-X) <span style=color:#ae81ff>2</span>))))]
</span></span><span style=display:flex><span>             [checked (set)]
</span></span><span style=display:flex><span>             [region (set)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Base case: checked all points, return region</span>
</span></span><span style=display:flex><span>      [(set-empty? to-check) region]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Already checked this point, ignore</span>
</span></span><span style=display:flex><span>      [(set-member? checked (set-first to-check))
</span></span><span style=display:flex><span>       (loop (set-rest to-check) checked region)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Sum of distances is less than range, include and expand search</span>
</span></span><span style=display:flex><span>      [(&lt; (<span style=color:#66d9ef>for/sum</span> ([pt (in-list POINTS)])
</span></span><span style=display:flex><span>            (distance (set-first to-check) pt))
</span></span><span style=display:flex><span>          range)
</span></span><span style=display:flex><span>       (loop (set-union (<span style=color:#66d9ef>for/set</span> ([neighbor (in-list (neighbors (set-first to-check)))]
</span></span><span style=display:flex><span>                                  <span style=color:#66d9ef>#:when</span> (not (set-member? checked neighbor)))
</span></span><span style=display:flex><span>                          neighbor)
</span></span><span style=display:flex><span>                        (set-rest to-check))
</span></span><span style=display:flex><span>             (set-add checked (set-first to-check))
</span></span><span style=display:flex><span>             (set-add region (set-first to-check)))]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Not in region, skip</span>
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop (set-rest to-check) (set-add checked (set-first to-check)) region)])))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The most interesting case is the third one, mostly because of a few optimizations to make the code a bit quicker. First, we sum up distances and use that to determine if the sum of distances is within range (have I mentioned how much I like the <code><a href="http://docs.racket-lang.org/search/index.html?q=for">for</a></code>
) family of macros)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>?</p><p>Print it out and you&rsquo;re done:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat input.txt | racket infinite-area-simulator.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>point <span style=color:#ae81ff>241</span> 157<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3882</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>43852</span> are within <span style=color:#ae81ff>10000</span>
</span></span></code></pre></div><figure><img src=/embeds/2018/joliver-cool.gif></figure><p>As an added bonus, while I was working out how to generate an image for the regions produced by part 1:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> color-for
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> ([colors (<span style=color:#66d9ef>for/list</span> ([pt (in-list POINTS)]) (vector (random) (random) (random)))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>λ</span> (pt)
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define</span> closest-pt (closest pt))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>or</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>for/first</span> ([color (in-list colors)]
</span></span><span style=display:flex><span>                   [pt^ (in-list POINTS)]
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>#:when</span> (equal? closest-pt pt^))
</span></span><span style=display:flex><span>         color)
</span></span><span style=display:flex><span>       (vector <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (write-image-debug filename)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>send</span>
</span></span><span style=display:flex><span>   (flomap-&gt;bitmap
</span></span><span style=display:flex><span>    (build-flomap*
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>3</span> (exact-round (- MAX-X MIN-X)) (exact-round (- MAX-Y MIN-Y))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>λ</span> (x y) (color-for (point (+ x MIN-X) (+ y MIN-Y))))))
</span></span><span style=display:flex><span>   save-file
</span></span><span style=display:flex><span>   filename
</span></span><span style=display:flex><span>   <span style=color:#f92672>&#39;</span><span style=color:#e6db74>png</span>))<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><figure><img src=/embeds/2018/aoc-6-regions.png></figure><p>The colors are random each time you run the program, but it&rsquo;s still pretty neat to do.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><figure><img src=/embeds/2018/tennant-oh-yes.gif></figure>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>