<!doctype html><html><head><title>AoC 2018 Day 5: Alchemical reduction – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/auto-render_2152414756166376840.min.45ae2f6b03d0c7b867df0a6cb7d43215ec78369998685a5748c5b12f502321f2.js integrity="sha256-Ra4vawPQx7hn3wpst9QyFex4NpmYaFpXSMWxL1AjIfI=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.d99288811f82c16d031e4f6c01e50e18aeccbb9968db7c625a21660aef059ef5.css integrity="sha256-2ZKIgR+CwW0DHk9sAeUOGK7Mu5lo23xiWiFmCu8FnvU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2018 Day 5: Alchemical reduction</h1><div class=entry-meta><span class=entry-date>2018-12-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/04/aoc-2018-day-4-sleeping-on-the-job/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2018/12/06/aoc-2018-day-6-infinite-area-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/04/aoc-2018-day-4-sleeping-on-the-job/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2018/12/06/aoc-2018-day-6-infinite-area-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2018/12/04/aoc-2018-day-4-sleeping-on-the-job/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2018>Advent of Code 2018</a><a href=https://blog.jverkamp.com/2018/12/06/aoc-2018-day-6-infinite-area-simulator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2018/12/04/aoc-2018-day-4-sleeping-on-the-job/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/06/aoc-2018-day-6-infinite-area-simulator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2018/12/05/into-the-drowning-deep/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2018/12/06/aoc-2018-day-6-infinite-area-simulator/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-alchemical-reductionhttpsadventofcodecom2018day5>Source: <a href=https://adventofcode.com/2018/day/5 target=_blank rel=noopener>Alchemical Reduction</a></h3><blockquote><p><strong>Part 1:</strong> Given a string, reduce it by removing pairs of letters that are the same letter but different cases. Repeat until you have a minimal string.</p></blockquote><p>This is the sort of problem Racket excels at: it&rsquo;s basically a list processing problem. First, we want to define a helper function to test for reactions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Two units react if they are the same type (letter) and opposite polarity (case)</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (react? a b)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and</span> (not (eq? a b))
</span></span><span style=display:flex><span>       (eq? (char-downcase a)
</span></span><span style=display:flex><span>            (char-downcase b))))
</span></span></code></pre></div><p>After that, the core recursive function that will take a a list of characters and react through it once. This isn&rsquo;t quite enough to solve the problem (since after removing characters you might expose a new pair), but will do most of it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Collapse all unit pairs that can one time</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (collapse-once ls)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match</span> ls
</span></span><span style=display:flex><span>    <span style=color:#75715e>; If The first two units react, remove them</span>
</span></span><span style=display:flex><span>    [(list-rest a b rest)
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>#:when</span> (react? a b)
</span></span><span style=display:flex><span>     (collapse-once rest)]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Otherwise, if we have at least one item, process the rest</span>
</span></span><span style=display:flex><span>    [(list-rest a rest)
</span></span><span style=display:flex><span>     (list* a (collapse-once rest))]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Base case: nothing left</span>
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>     ls]))
</span></span></code></pre></div><p>I really like <code><a href="http://docs.racket-lang.org/search/index.html?q=match">match</a></code>
. It&rsquo;s really powerful for things like this, especially with the addition of the <code>#:when</code> clause (which I actually just learned/re-learned about today). I&rsquo;ll be using more of that!</p><p>Now, we just need a function that will collapse until it cannot any more:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>Collapse until there<span style=color:#f92672>&#39;</span><span style=color:#e6db74>s</span> nothing more to <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (collapse ls)
</span></span><span style=display:flex><span> (<span style=color:#66d9ef>let</span> ([ls^ (collapse-once ls)])
</span></span><span style=display:flex><span>   (<span style=color:#66d9ef>if</span> (equal? ls ls^)
</span></span><span style=display:flex><span>       ls
</span></span><span style=display:flex><span>       (collapse ls^))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> input-polymer (string-&gt;list (read-line)))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> output-polymer (collapse input-polymer))
</span></span><span style=display:flex><span>(printf <span style=color:#e6db74>&#34;[part 1] output length: ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> (length output-polymer))
</span></span></code></pre></div><blockquote><p><strong>Part 2:</strong> If you&rsquo;re allowed to remove one letter (both cases), what is the letter you can remove to get the smallest collapsed output (and that output&rsquo;s length).</p></blockquote><p>Let&rsquo;s just brute force it. Write a helper that can remove both cases of a letter from the string and try every letter of the alphabet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Remove all instances of a unit (either polarity)</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (remove/ignore-case ls c)
</span></span><span style=display:flex><span>  (filter (<span style=color:#66d9ef>λ</span> (a) (not (eq? (char-downcase a) (char-downcase c)))) ls))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Try removing each letter in turn, recording each new best</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define-values</span> (best-to-remove best-length)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for*/fold</span> ([best-to-remove <span style=color:#66d9ef>#f</span>]
</span></span><span style=display:flex><span>              [best-length <span style=color:#ae81ff>+inf.0</span>])
</span></span><span style=display:flex><span>             ([to-remove (in-string <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span>)]
</span></span><span style=display:flex><span>              [length (in-value (length (collapse (remove/ignore-case input-polymer to-remove))))]
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>#:when</span> (&lt; length best-length))
</span></span><span style=display:flex><span>    (values to-remove length)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(printf <span style=color:#e6db74>&#34;[part 2] removing ~a gives a length of: ~a</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> best-to-remove best-length)
</span></span></code></pre></div><p>It&rsquo;s a bit slow (a couple seconds per collapse, but it has to do 27 of them for the two parts), but it&rsquo;s certainly workable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat input.txt | time racket alchemical-collapser.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 1<span style=color:#f92672>]</span> output length: <span style=color:#ae81ff>9078</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 2<span style=color:#f92672>]</span> removing u gives a length of: <span style=color:#ae81ff>5698</span>
</span></span><span style=display:flex><span>       36.88 real        32.77 user         1.07 sys
</span></span></code></pre></div><p>Well within a minute (my baseline for &rsquo;efficient enough&rsquo; for these sort of problems).</p><p>I do wonder though if there&rsquo;s a faster way to solve this part? I bet there is. Probably something to do with <a href=https://en.wikipedia.org/wiki/graph%20theory>graph theory</a>. It&rsquo;s always graph theory.</p><p>A problem for another day.</p><blockquote><p><strong>Update 2018-12-10:</strong> Got a command (below): Can you use a stack to solve this problem?</p></blockquote><p>Why yes. Yes you can! Let&rsquo;s do it.</p><p>All we actually have to change is the <code>collapse</code> function. What we&rsquo;re going to do is move elements from an <code>input</code> list to an <code>output</code> list. Whenever the top element of each list/stack reacts, remove them both. This will allow reactions to cascade natively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Collapse an alchemical polymer removing matching units of opposite polarity</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (collapse polymer)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([input polymer]
</span></span><span style=display:flex><span>             [output <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; End condition, output the stack</span>
</span></span><span style=display:flex><span>      [(null? input) (reverse output)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Initial state, nothing on the output stack to compare</span>
</span></span><span style=display:flex><span>      [(null? output)
</span></span><span style=display:flex><span>       (loop (rest input) (list (first input)))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Top of stack and next of input match, remove both</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; This will allow chain reactions since it exposes a new top of stack to react</span>
</span></span><span style=display:flex><span>      [(react? (first input) (first output))
</span></span><span style=display:flex><span>       (loop (rest input) (rest output))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Don&#39;t react, move to output</span>
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop (rest input) (list* (first input) output))])))
</span></span></code></pre></div><p>And that&rsquo;s it; the rest of the code remains the same. We don&rsquo;t even need a wrapper function to collapse multiple time, this just does it.</p><p>And the crazy thing is just how much faster it is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat input.txt | time racket alchemical-collapser.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 1<span style=color:#f92672>]</span> output length: <span style=color:#ae81ff>9078</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 2<span style=color:#f92672>]</span> removing u gives a length of: <span style=color:#ae81ff>5698</span>
</span></span><span style=display:flex><span>       33.44 real        32.64 user         0.68 sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat input.txt | time racket alchemical-stacker.rkt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 1<span style=color:#f92672>]</span> output length: <span style=color:#ae81ff>9078</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>part 2<span style=color:#f92672>]</span> removing u gives a length of: <span style=color:#ae81ff>5698</span>
</span></span><span style=display:flex><span>        0.54 real         0.45 user         0.08 sys
</span></span></code></pre></div><p>Now that&rsquo;s a speedup&mldr; Most of which comes from not having to process the entire list over and over again, instead just doing it all at once. It really does show just how much difference you can get by coming at a problem from an algorithmically different direction.</p><p>Thanks!</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>