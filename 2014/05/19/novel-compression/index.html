<!doctype html><html><head><title>Novel compression â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js integrity="sha256-MESIkqofkenEy1SU5cXlq8E7d3jed4blJWzcfSQkgTo=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="><link rel=stylesheet href=/main.min.9efa38cb8d96be1a2d31208e5279a2f48fd2a15f6bcc9173c7375c675225b767.css integrity="sha256-nvo4y42WvhotMSCOUnmi9I/SoV9rzJFzxzdcZ1Ilt2c="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Novel compression</h1><div class=entry-meta><span class=entry-date>2014-05-19</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/daily-programmer>Daily Programmer</a><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/05/10/the-amazing-spider-man-2/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Last week on /r/dailyprogrammer, there was a neat trio of posts all about a new compression algorithm:</p><ul><li><a href=http://www.reddit.com/r/dailyprogrammer/comments/25clki/5122014_challenge_162_easy_novel_compression_pt_1/>Novel Compression, pt. 1: Unpacking the Data</a></li><li><a href=http://www.reddit.com/r/dailyprogrammer/comments/25hlo9/5142014_challenge_162_intermediate_novel/>Novel Compression, pt. 2: Compressing the Data</a></li><li><a href=http://www.reddit.com/r/dailyprogrammer/comments/25o2bd/5162014_challenge_162_hard_novel_compression_pt_3/>Novel Compression, pt. 3: Putting it all together</a></li></ul><p>More specifically, we&rsquo;re going to represent compressed text with the following rules:</p><ul><li>If the chunk is just a number (eg. 37), word number 37 from the dictionary (zero-indexed, so 0 is the 1st word) is printed lower-case.</li><li>If the chunk is a number followed by a caret (eg. 37^), then word 37 from the dictionary will be printed lower-case, with the first letter capitalised.</li><li>If the chunk is a number followed by an exclamation point (eg. 37!), then word 37 from the dictionary will be printed upper-case.</li><li>If it&rsquo;s a hyphen (-), then instead of putting a space in-between the previous and next words, put a hyphen instead.</li><li>If it&rsquo;s any of the following symbols: . , ? ! ; : (<strong>edit:</strong> also &rsquo; and &ldquo;), then put that symbol at the end of the previous outputted word.</li><li>If it&rsquo;s a letter R (upper or lower), print a new line.</li><li>If it&rsquo;s a letter E (upper or lower), the end of input has been reached.</li><li><strong>edit:</strong> any other block of text, represent as a literal &lsquo;word&rsquo; in the dictionary</li></ul><p>Got it? Let&rsquo;s go!</p><p>(If you&rsquo;d like to follow along: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/novel-compression.rkt>full source</a>)</p><h2 id=decompression>Decompression</h2><p>Given the ordering above (and the relative difficulty of the tasks) we&rsquo;ll start with decoding first. Eventually, we&rsquo;re going to have a single <code>decompress</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Decompress input compressed by the previous function</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>decompress</span> [in (<span style=color:#a6e22e>current-input-port</span>)])
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>Each &lsquo;function&rsquo; will take an input port to read from as input and write to the <code>current-output-port</code>. So if you want to wrap it in a string, do something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Decompress in string mode</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>decompress/string</span> str)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>with-output-to-string</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>with-input-from-string</span> str decompress))))
</span></span></code></pre></div><p>All righty then. First, as we noted in the file format, the compressed file starts with the size of the dictionary than a series of words.</p><p>We can pull these right out with the right application of a loop and <code><a href="http://docs.racket-lang.org/search/index.html?q=read">read</a></code>
:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Read the dictionary; number of words followed by that many words</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>words 
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/vector</span> ([i (<span style=color:#a6e22e>in-range</span> (read in))])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>~a</span> (read in))))
</span></span></code></pre></div><p>Now we just have to <code><a href="http://docs.racket-lang.org/search/index.html?q=vector-ref">vector-ref</a></code>
into <code>words</code> to decode words.</p><p>Second things second, we need to break apart all of the tokens. Normally, I&rsquo;d use the <code><a href="http://docs.racket-lang.org/search/index.html?q=read">read</a></code>
function and let Racket do some processing for us, but one token in particular (<code>.</code>) will cause some trouble. So instead, we&rsquo;ll read via loading the content into a string and splitting on spaces<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Read the rest of the file into a list of chunks</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Split on any whitespace, space vs tab vs newline are all the same</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>chunks (<span style=color:#a6e22e>string-split</span> (<span style=color:#a6e22e>port-&gt;string</span> in)))
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>let/ec</span> return
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/fold</span> ([prefix <span style=color:#e6db74>&#34;&#34;</span>]) ([chunk (<span style=color:#a6e22e>in-list</span> chunks)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>match</span> chunk
</span></span><span style=display:flex><span>      <span style=color:#f92672>...</span>)))
</span></span></code></pre></div><p>It&rsquo;s a bit strange to be using <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code>
, but it seemed the cleanest way to be able to go &lsquo;back in time&rsquo; in the special case characters. Specifically, this will help a lot with &ldquo;-&rdquo; tokens, in that we know if we&rsquo;re going to use the normal space or not.</p><p>The first case within the fold will be words. This is straight forward enough if it&rsquo;s purely numeric, but we might also have a suffix of either <code>!</code> (for upper case) or <code>^</code> (for titlecase). Regular expressions to the rescue<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>match</span> chunk
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Numbers indicate words from the dictionary</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; ^ means upcase the first letter</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; ! means upcase the entire word</span>
</span></span><span style=display:flex><span>  [(<span style=color:#a6e22e>regexp</span> <span style=color:#f92672>#</span>px<span style=color:#e6db74>&#34;(\\d+)(\\^|!|)&#34;</span> (list _ index flag))
</span></span><span style=display:flex><span>   (<span style=color:#66d9ef>define </span>word (vector-ref words (string-&gt;number index)))
</span></span><span style=display:flex><span>   (display prefix)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>case </span>flag
</span></span><span style=display:flex><span>      [(<span style=color:#e6db74>&#34;^&#34;</span>) (<span style=color:#a6e22e>string-titlecase</span> word)]
</span></span><span style=display:flex><span>      [(<span style=color:#e6db74>&#34;!&#34;</span>) (<span style=color:#a6e22e>string-upcase</span> word)]
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else </span> word]))
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34; &#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>The extra string at the end there is part of the <code>for/fold</code>. Since that&rsquo;s what&rsquo;s returned from the <code>match</code>, that means for the next iteration it will be the value of <code>prefix</code>. So if we&rsquo;re not done with a sentence, write out a space before the word (as shown earlier in this block).</p><p>Next, the special cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>match</span> chunk
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Use a hyphen as a seperator rather than a space</span>
</span></span><span style=display:flex><span>  [<span style=color:#e6db74>&#34;-&#34;</span> <span style=color:#e6db74>&#34;-&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Punctuation literals</span>
</span></span><span style=display:flex><span>  [(<span style=color:#66d9ef>or </span><span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#e6db74>&#34;?&#34;</span> <span style=color:#e6db74>&#34;!&#34;</span> <span style=color:#e6db74>&#34;;&#34;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#e6db74>&#34;\&#34;&#34;</span> <span style=color:#e6db74>&#34;&#39;&#34;</span>) (display chunk) <span style=color:#e6db74>&#34; &#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Newlines</span>
</span></span><span style=display:flex><span>  [(<span style=color:#66d9ef>or </span><span style=color:#e6db74>&#34;R&#34;</span> <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#e6db74>&#34;\n&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Early end of output (should generally be the last chunk)</span>
</span></span><span style=display:flex><span>  [(<span style=color:#66d9ef>or </span><span style=color:#e6db74>&#34;E&#34;</span> <span style=color:#e6db74>&#34;e&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>return</span>)])
</span></span></code></pre></div><p>First, the hyphens. Those are a little strange, since we don&rsquo;t actually output anything. Instead, we let the <code>prefix</code> pass through to the next word. This does have the interesting effect of not being able to output something like &ldquo;-.&rdquo; (since punctuation doesn&rsquo;t output the prefix). I guess it&rsquo;s just something that we&rsquo;ll have to deal with. After that punctuation is literally sent to output (and a space is sent to the next prefix). Newlines are newlines.</p><p>Finally, we have an end of input signifier, although we already deal with that above. This could have an interesting effect where you could store information past the end of the file if you wanted&mldr;</p><p>And that&rsquo;s actually it. That&rsquo;s all we need to decompress the sample text given:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; compressed
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;20 i do not like them a green sam mouse eggs or anywhere and here am house there with in ham 0! 1 2 3 4 18 5 15 . R 0! 1 2 3 4 17 5 8 . R 0! 1 2 3 4 13 10 16 . R 0! 1 2 3 4 11 . R 0! 1 2 3 6 9 12 19 . R 0! 1 2 3 4 , 7^ - 0! - 14 . E\n&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>with-input-from-string</span> compressed decompress)
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them in a house<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them with a mouse<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them here <span style=color:#66d9ef>or </span>there<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them anywhere<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like green eggs <span style=color:#66d9ef>and </span>ham<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them, Sam-I-am<span style=color:#f92672>.</span>
</span></span></code></pre></div><p>Shiny. So how about compression?</p><h2 id=compression>Compression</h2><p>Same basic structure as before:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Compress a file into a word-list based format</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>compress</span> [in (<span style=color:#a6e22e>current-input-port</span>)])
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Compress in string mode</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>compress/string</span> str)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>with-output-to-string</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>with-input-from-string</span> str compress))))
</span></span></code></pre></div><p>I&rsquo;m going to actually do something a little more than I strictly speaking have to. Instead of just taking the words in order to build the dictionary, I&rsquo;m actually going to order them in descending order of frequency. That way, if we have a lot of words, the most common will have one byte aliases, while less common words will have longer aliases. It won&rsquo;t amount to <em>that</em> much in the way of savings (at least not as much as duplicate words themselves), but it&rsquo;s something.</p><p>That being said, we&rsquo;ll start with a struct for &lsquo;words&rsquo; and the dictionary itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; While processing, store words as a special struct</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; mode is one of downcase, titlecase, upcase, specialcase</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>struct</span> word (<span style=color:#a6e22e>text</span> mode) <span style=color:#f92672>#</span>:transparent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Store words we&#39;ve already seen along with a count</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Later we&#39;re going to sort these so the most common are first</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>words (<span style=color:#a6e22e>make-hash</span>))
</span></span></code></pre></div><p><code>specialcase</code> is another extension that I&rsquo;m adding. Basically, if we have a word like LaTeX, we wouldn&rsquo;t be able to encode it as stands. What I&rsquo;m going to do is encode the three cases as described, but then anything else will get its own entry in the dictionary. So something like this would be a valid compressed file<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><pre tabindex=0><code> plaintext: latex Latex LATEX LaTeX
compressed: 2 latex LaTeX 0 0^ 0! 1
</code></pre><p>The first step is going to be to parse words. Assuming that we can get just the alphabetic characters of a word (which we&rsquo;ll do in a bit), we need to figure out what sort of word it is. In addition, we want to add each new word to the dictionary, so we can write that out later. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Helper to add a word to the dictionary and return the struct form</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>decode-word</span> chunk)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>chunk/downcase (<span style=color:#a6e22e>string-downcase</span> chunk))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-update!</span> words chunk/downcase (<span style=color:#a6e22e>curry</span> + <span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>word</span> chunk/downcase
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>          [(equal? chunk chunk/downcase)                    <span style=color:#e6db74>&#39;downcase</span>]
</span></span><span style=display:flex><span>          [(equal? chunk (<span style=color:#a6e22e>string-upcase</span> chunk/downcase))    <span style=color:#e6db74>&#39;upcase</span>]
</span></span><span style=display:flex><span>          [(equal? chunk (<span style=color:#a6e22e>string-titlecase</span> chunk/downcase)) <span style=color:#e6db74>&#39;titlecase</span>]
</span></span><span style=display:flex><span>          [<span style=color:#66d9ef>else </span>                                            <span style=color:#e6db74>&#39;specialcase</span>])))
</span></span></code></pre></div><p>After that, the next second will be to use that function to parse &lsquo;chunks&rsquo;. Same as before, we&rsquo;ll break apart the input string by spaces. Unfortunately, that means that we might get chunks like this: &ldquo;Sam-I-am.&rdquo; Eventually, that will be 6 tokens: &ldquo;{sam}^ - {i}! - {am} .&rdquo; So the solution I went with is recursive. It will look for any special characters (including newlines, hyphens, and punctuation) and break them apart, perhaps multiple times.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Encode a &#39;chunk&#39; which might actually turn into one or more tokens</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>decode-chunk</span> chunk)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match</span> chunk
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Break apart hyphens / punctuation / newlines</span>
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>regexp</span> <span style=color:#f92672>#</span>px<span style=color:#e6db74>&#34;(.*)([.,?!;:\\-\n\&#34;&#39;])(.*)&#34;</span> (list _ subchunk1 break subchunk2))
</span></span><span style=display:flex><span>     (append (<span style=color:#a6e22e>decode-chunk</span> subchunk1)
</span></span><span style=display:flex><span>             (list (<span style=color:#66d9ef>if </span>(equal? break <span style=color:#e6db74>&#34;\n&#34;</span>) <span style=color:#e6db74>&#39;newline</span> (string-&gt;symbol break)))
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>decode-chunk</span> subchunk2))]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Process words</span>
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>regexp</span> <span style=color:#f92672>#</span>px<span style=color:#e6db74>&#34;([a-z]+|[A-Z][a-z]*|[A-Z]+)&#34;</span>)
</span></span><span style=display:flex><span>     (list (<span style=color:#a6e22e>decode-word</span> chunk))]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Empty strings are empty lists (base case for breaking apart chunks)</span>
</span></span><span style=display:flex><span>    [<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Anything else is a weird empty string, add it directly to the dictionary</span>
</span></span><span style=display:flex><span>    [any 
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>hash-update!</span> words any (<span style=color:#a6e22e>curry</span> + <span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>     (list (<span style=color:#a6e22e>word</span> any <span style=color:#e6db74>&#39;specialcase</span>))]))
</span></span></code></pre></div><p>Note that this function always returns a list, even if it contains zero or one items. This is a trick I&rsquo;ve done a number of times, in that we&rsquo;ll be appending this lists together shortly. Similarly, in the breaking apart recursive case, we append the sublists, so the base case of the empty string "&rdquo; deals nicely with &ldquo;am.&rdquo; -> &ldquo;am&rdquo; &ldquo;.&rdquo; "" -> ({am} .). Exactly what we need.</p><p>Now that we have all of the processing done, we can actually do the bulk of the work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Pull apart chunks, process them, put them back together</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>chunks
</span></span><span style=display:flex><span>  (apply append 
</span></span><span style=display:flex><span>         (map decode-chunk 
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>string-split</span> 
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>string-replace</span> (<span style=color:#a6e22e>port-&gt;string</span> in) <span style=color:#e6db74>&#34;\r&#34;</span> <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#34; &#34;</span>))))
</span></span></code></pre></div><p>That was easy. ðŸ˜„</p><p>Kind of amazing how much work can be done with such relatively little effort. We still have word structs though. We need to use our <code>words</code> hash to turn them into numbers. But to do that, we need to assign a number to each:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Replace word counts with an ascending count</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Write out the dictionary as we go</span>
</span></span><span style=display:flex><span>(display (<span style=color:#a6e22e>hash-count</span> words)) 
</span></span><span style=display:flex><span>(display <span style=color:#e6db74>&#34; &#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>for</span> ([i (<span style=color:#a6e22e>in-naturals</span>)]
</span></span><span style=display:flex><span>      [word (<span style=color:#a6e22e>in-list</span> (map car (<span style=color:#a6e22e>sort</span> (<span style=color:#a6e22e>hash-&gt;list</span> words)
</span></span><span style=display:flex><span>                                    (<span style=color:#960050;background-color:#1e0010>Î»</span> (<span style=color:#a6e22e>a</span> b) (&gt; (cdr a) (cdr b))))))])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-set!</span> words word i)
</span></span><span style=display:flex><span>  (display word)
</span></span><span style=display:flex><span>  (display <span style=color:#e6db74>&#34; &#34;</span>))
</span></span></code></pre></div><p>As a bonus, we&rsquo;re already writing the first part of the output: the dictionary.</p><p>After that, we have enough to write the rest of the file. Just loop through each chunk. If it&rsquo;s a word, write the number then possibly a control character. Newlines become &ldquo;R&rdquo;. Anything else (punctuation) is written as a literal. At the end, write an &ldquo;E&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Replace each word with the numeric form</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Print out chunks as we go</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>for</span> ([chunk (<span style=color:#a6e22e>in-list</span> chunks)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match</span> chunk
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>word</span> text mode)
</span></span><span style=display:flex><span>     (display (<span style=color:#a6e22e>hash-ref</span> words text))
</span></span><span style=display:flex><span>     (display 
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>case </span>mode
</span></span><span style=display:flex><span>        [(<span style=color:#a6e22e>upcase</span>)    <span style=color:#e6db74>&#34;!&#34;</span>]
</span></span><span style=display:flex><span>        [(<span style=color:#a6e22e>titlecase</span>) <span style=color:#e6db74>&#34;^&#34;</span>]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>else </span>       <span style=color:#e6db74>&#34;&#34;</span>]))]
</span></span><span style=display:flex><span>    [<span style=color:#e6db74>&#39;newline</span>
</span></span><span style=display:flex><span>     (display <span style=color:#e6db74>&#34;R&#34;</span>)]
</span></span><span style=display:flex><span>    [any
</span></span><span style=display:flex><span>     (display any)])
</span></span><span style=display:flex><span>  (display <span style=color:#e6db74>&#34; &#34;</span>))
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>displayln</span> <span style=color:#e6db74>&#34;E&#34;</span>)
</span></span></code></pre></div><p>Testing it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; input
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;I do not like them in a house.\nI do not like them with a mouse.\nI do not like them here or there.\nI do not like them anywhere.\nI do not like green eggs and ham.\nI do not like them, Sam-I-am.&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>with-input-from-string</span> input compress)
</span></span><span style=display:flex><span><span style=color:#ae81ff>20</span> i <span style=color:#66d9ef>do </span>not like them a green sam mouse eggs <span style=color:#66d9ef>or </span>anywhere <span style=color:#66d9ef>and </span>here am house there with in ham <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>15</span> <span style=color:#f92672>.</span> R <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>17</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>.</span> R <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>.</span> R <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>11</span> <span style=color:#f92672>.</span> R <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>19</span> <span style=color:#f92672>.</span> R <span style=color:#ae81ff>0</span>! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>,</span> <span style=color:#ae81ff>7</span>^ - <span style=color:#ae81ff>0</span>! - <span style=color:#ae81ff>14</span> <span style=color:#f92672>.</span> E
</span></span></code></pre></div><p>Is it invertible?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (display (<span style=color:#a6e22e>decompress/string</span> (<span style=color:#a6e22e>compress/string</span> input)))
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them in a house<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them with a mouse<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them here <span style=color:#66d9ef>or </span>there<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them anywhere<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like green eggs <span style=color:#66d9ef>and </span>ham<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do </span>not like them, Sam-I-am<span style=color:#f92672>.</span>
</span></span></code></pre></div><p>Nice!</p><p>One last thing though (from Friday). Let&rsquo;s make it a little easier to run from the command line.</p><h2 id=command-line>Command line</h2><p>From the <a href=http://www.reddit.com/r/dailyprogrammer/comments/25o2bd/5162014_challenge_162_hard_novel_compression_pt_3/>description page</a>:</p><blockquote><p>The program will take 3 arguments on the command line: the first one will be one of the following:</p></blockquote><blockquote><ul><li>-c Will compress the input.</li><li>-d Will decompress the input.</li></ul></blockquote><blockquote><p>The second argument will be a path to a file that the input data will be read from, and the third argument will be a path to a file that output data will be written to.</p></blockquote><p>We could make it a little more bullet proof (and compress or decompress many files at once) but instead we&rsquo;ll just go with the specification:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>module+</span> main
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match</span> (<span style=color:#a6e22e>current-command-line-arguments</span>)
</span></span><span style=display:flex><span>    [(vector <span style=color:#e6db74>&#34;-c&#34;</span> in-file out-file)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;Compress ~a -&gt; ~a\n&#34;</span> in-file out-file)
</span></span><span style=display:flex><span>     (with-output-to-file out-file <span style=color:#f92672>#</span>:exists <span style=color:#e6db74>&#39;replace</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>thunk</span> (with-input-from-file in-file compress)))]
</span></span><span style=display:flex><span>    [(vector <span style=color:#e6db74>&#34;-d&#34;</span> in-file out-file)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;Decompress ~a -&gt; ~a\n&#34;</span> in-file out-file)
</span></span><span style=display:flex><span>     (with-output-to-file out-file <span style=color:#f92672>#</span>:exists <span style=color:#e6db74>&#39;replace</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>thunk</span> (with-input-from-file in-file decompress)))]
</span></span><span style=display:flex><span>    [any
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>void</span>)]))
</span></span></code></pre></div><p><code><a href="http://docs.racket-lang.org/search/index.html?q=match">match</a></code>
is pretty awesome.</p><p>Right from Racket, we can compile it to an executable. From then, it acts just like any other program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./novel-compression -c eggs.txt eggs.txt.nc
</span></span><span style=display:flex><span>Compress eggs.txt -&gt; eggx.txt.nc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat eggs.txt.nc
</span></span><span style=display:flex><span><span style=color:#ae81ff>20</span> i <span style=color:#66d9ef>do</span> not like them a green sam mouse eggs or anywhere and here am house there with in ham 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>15</span> . R 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>17</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>8</span> . R 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>16</span> . R 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>11</span> . R 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>19</span> . R 0! <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> , 7^ - 0! - <span style=color:#ae81ff>14</span> . R E
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./novel-compress -d eggs.txt.nc eggs.d.txt
</span></span><span style=display:flex><span>Decompress eggs.txt.nc -&gt; eggs.d.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat eggs.d.txt
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like them in a house.
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like them with a mouse.
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like them here or there.
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like them anywhere.
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like green eggs and ham.
</span></span><span style=display:flex><span>I <span style=color:#66d9ef>do</span> not like them, Sam-I-am.
</span></span></code></pre></div><p>But does it actually do any good?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls -lah eggs*
</span></span><span style=display:flex><span>-rwx------+ <span style=color:#ae81ff>1</span> me None <span style=color:#ae81ff>190</span> May <span style=color:#ae81ff>18</span> 19:14 eggs.d.txt
</span></span><span style=display:flex><span>-rwx------+ <span style=color:#ae81ff>1</span> me None <span style=color:#ae81ff>197</span> May <span style=color:#ae81ff>18</span> 19:07 eggs.txt
</span></span><span style=display:flex><span>-rwx------+ <span style=color:#ae81ff>1</span> me None <span style=color:#ae81ff>235</span> May <span style=color:#ae81ff>18</span> 19:10 eggs.txt.nc
</span></span></code></pre></div><p>So&mldr; It actually made it bigger (and the output isn&rsquo;t <em>exactly</em> the same as the input, the newlines are different). Most of our compression is 1:2 (for I) or 2:2 (for do)<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. But if you have a larger text that still has a lot of duplicate text, say the first chapter of the Book of Genesis:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>$ <span style=color:#f92672>.</span>/novel-compression -c genesis<span style=color:#f92672>.</span>txt genesis<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc
</span></span><span style=display:flex><span>Compress genesis<span style=color:#f92672>.</span>txt -&gt; genesis<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ls -lah genesis*
</span></span><span style=display:flex><span>-rwx------+ <span style=color:#ae81ff>1</span> me None <span style=color:#ae81ff>4.1</span>K May <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>19</span>:15 Genesis<span style=color:#f92672>.</span>txt
</span></span><span style=display:flex><span>-rwx------+ <span style=color:#ae81ff>1</span> me None <span style=color:#ae81ff>3.6</span>K May <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>19</span>:16 Genesis<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc
</span></span></code></pre></div><p>Much better!</p><p>There is one more trick that we can pull:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>$ <span style=color:#f92672>.</span>/novel-compression -c eggs<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc eggs<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc<span style=color:#f92672>.</span>nc
</span></span><span style=display:flex><span>Compress eggs<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc -&gt; eggs<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc<span style=color:#f92672>.</span>nc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat eggs<span style=color:#f92672>.</span>txt<span style=color:#f92672>.</span>nc<span style=color:#f92672>.</span>nc
</span></span><span style=display:flex><span><span style=color:#ae81ff>43</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>2</span> r <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> green <span style=color:#ae81ff>8</span> mouse <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>19</span> am <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>10</span> eggs anywhere <span style=color:#ae81ff>13</span> here there them <span style=color:#ae81ff>11</span> with like ham <span style=color:#ae81ff>6</span> sam a <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>9</span> <span style=color:#66d9ef>or </span>e <span style=color:#66d9ef>and </span>not <span style=color:#ae81ff>18</span> house <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>17</span> <span style=color:#66d9ef>do </span><span style=color:#ae81ff>7</span>^ in i <span style=color:#ae81ff>37</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>39</span> <span style=color:#ae81ff>34</span> <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>27</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>26</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>31</span> <span style=color:#ae81ff>16</span> <span style=color:#ae81ff>33</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>36</span> <span style=color:#ae81ff>19</span> <span style=color:#ae81ff>22</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>35</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>38</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>17</span> <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>29</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>21</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>30</span> <span style=color:#ae81ff>28</span> <span style=color:#ae81ff>11</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>0</span> ! <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>,</span> <span style=color:#ae81ff>40</span> - <span style=color:#ae81ff>0</span> ! - <span style=color:#ae81ff>13</span> <span style=color:#f92672>.</span> <span style=color:#ae81ff>3</span>! <span style=color:#ae81ff>32</span>! R E
</span></span></code></pre></div><p>Certainly doesn&rsquo;t compress it any more, but it is amusing. ðŸ˜„ Especially when the numbers are getting encoded to other numbers (such as 1 is actually 3, which in turn is actually like). Love it!</p><p>And that&rsquo;s it. Compression, of a sort. If you&rsquo;d like to download the entire code for today&rsquo;s post, it&rsquo;s all on GitHub: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/novel-compression.rkt>novel-compression.rkt</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Which has unfortunate implications if we compress really large files, but if you&rsquo;re using this scheme on large files&mldr; You get what&rsquo;s coming to you.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Perhaps a bit overkill, but it certainly works.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Pure luck that they&rsquo;re the same length.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Don&rsquo;t forget the space&mldr;&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>