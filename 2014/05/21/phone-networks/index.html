<!doctype html><html><head><title>Phone networks – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.a8e11addf4349ee2ca5045f7f3cbf1febbf2c3a2840be2143ea69539c10f8c7f.js integrity="sha256-qOEa3fQ0nuLKUEX388vx/rvyw6KEC+IUPqaVOcEPjH8=" defer></script><script src=/katex_17296078054267651618.min.4a06464d8d6f8358d8896de62b53b5a89205d335dfd8c5b6b27edd7c039ae9d8.js integrity="sha256-SgZGTY1vg1jYiW3mK1O1qJIF0zXf2MW2sn7dfAOa6dg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.a17078917a4403310cd19178939257b706fb5e1da76167c9f4a6d2123c9d59c4.js integrity="sha256-oXB4kXpEAzEM0ZF4k5JXtwb7Xh2nYWfJ9KbSEjydWcQ=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.7420a1602c62a85d4b50881c1d8ce42f72c049dc2b097d440696425d6e54bb1e.css integrity="sha256-dCChYCxiqF1LUIgcHYzkL3LASdwrCX1EBpZCXW5Uux4="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.5ff4b87c40715a96119d8b5f34d971604fc65ab18f4870fd8da6ede9fd1e6188.css integrity="sha256-X/S4fEBxWpYRnYtfNNlxYE/GWrGPSHD9jabt6f0eYYg="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Automation</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Phone networks</h1><div class=entry-meta><span class=entry-date>2014-05-21</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/19/novel-compression/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/05/23/amicable-chains/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/05/19/novel-compression/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/05/23/amicable-chains/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/19/novel-compression/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/daily-programmer>Daily Programmer</a><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/01/15/graph-coloring/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphs>Graphs</a><a href=https://blog.jverkamp.com/2014/05/23/amicable-chains/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/05/19/novel-compression/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/23/amicable-chains/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/05/19/novel-compression/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/23/amicable-chains/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Another day, <a href=http://www.reddit.com/r/dailyprogrammer/comments/25576s/592014_challenge_161_hard_phone_network/>another challenge from /r/dailyprogrammer</a>. It&rsquo;s almost two weeks old now, but I&rsquo;ve just now had a chance to get around it.</p><blockquote><p>Your company has built its own telephone network. This allows all your remote locations to talk to each other. It is your job to implement the program to establish calls between locations.</p></blockquote><h2 id=problem-description>Problem description</h2><p>Basically, this is an exercise in graph theory. Given a weighted graph (in this case representing locations in our call network and the maximum bandwidth between locations), route a series of calls between the nodes. There&rsquo;s an aspect of optimization to it as well, although if you cannot see the future, there&rsquo;s only so much you can do to be able to guess what future calls you&rsquo;ll have to route.</p><p>As stated in the problem, our input will be given by a list of source, destination, weight triples. Something like this:</p><pre tabindex=0><code>A B 2
A C 2
B C 2
B D 2
C E 1
D E 2
D G 1
E F 2
F G 2
</code></pre><p>Unusually for an /r/dailyprogrammer challenge, there isn&rsquo;t an indication for how many records we have to read. Instead, there will be a blank line at the end of the section. Still, that&rsquo;s easy enough to deal with. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Read a phone network as a weighted undirect graph, form {from} {to} {weight}</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>read-network</span> [in (<span style=color:#a6e22e>current-input-port</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>g (<span style=color:#a6e22e>weighted-graph/directed</span> <span style=color:#f92672>&#39;</span>()))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for</span> ([line (<span style=color:#a6e22e>in-lines</span> in)]
</span></span><span style=display:flex><span>        <span style=color:#f92672>#</span>:break (equal? line <span style=color:#e6db74>&#34;&#34;</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>match-define</span> (list from to weight) (<span style=color:#a6e22e>string-split</span> line))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>add-edge!</span> g from to (string-&gt;number weight))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>add-edge!</span> g to from (string-&gt;number weight)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  g)
</span></span></code></pre></div><p>(We&rsquo;re using stchang&rsquo;s <a href=https://blog.jverkamp.com/2014/01/14/graph-radius/>[1]</a><a href=https://blog.jverkamp.com/2014/01/15/graph-coloring/>[2]</a>.)</p><p>After that, we&rsquo;ll have a series of calls to route:</p><pre tabindex=0><code>A G
A G
C E
G D
D E
A B
A D
</code></pre><p>In this case, each call will be a pair of nodes, the source and the destination (although routes are not directional). Since we&rsquo;re reading to the end of the file and only reading two parts, the code is much cleaner.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Read a sequential list of calls formatted as {from} {to}</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>read-calls</span> [in (<span style=color:#a6e22e>current-input-port</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/list</span> ([line (<span style=color:#a6e22e>in-lines</span> in)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>string-split</span> line)))
</span></span></code></pre></div><p>So we&rsquo;ve gotten the problem read in, now all that&rsquo;s left is solving it. &#x1f604;</p><h2 id=routing-calls>Routing calls</h2><p>First things first, what are we going to return? Eventually, I need to have a list of paths (one for each call) or a failure if we couldn&rsquo;t route a particular call. In addition, I want to keep the current network at each step, to help with debugging. So perhaps something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Each step of a solution will have</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; - the current graph (before routing)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; - the call being made</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; - the found route (or #f)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>struct</span> step (<span style=color:#a6e22e>graph</span> call route) <span style=color:#f92672>#</span>:transparent)
</span></span></code></pre></div><p>Other than that, the algorithm is straight forward. For each call, find a route. If we find a route, reduce the bandwidth on each node. If not, report failed and leave the network alone.</p><p>Technically, finding the paths is interesting in and of itself. There are a number of algorithms, depending on which route you&rsquo;re looking for. One of particular interest is <a href=https://en.wikipedia.org/wiki/Dijkstra%e2%80%99s%20algorithm>Dijkstra’s algorithm</a>, which already has an implementation of sorts in the library I&rsquo;m using. One thing that it doesn&rsquo;t do; however, is route from one node to another, it actually does far more, routing from one node to all others (a natural result of running Dijkstra&rsquo;s algorithm anyways). So we need a function that will extract a single path from that result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Specialization of the graph library to find a single path using dijkstra&#39;s</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>dijkstra-path</span> graph from to)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>_</span> preds)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>dijkstra</span> graph from))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([to to] [path <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(equal? from to) 
</span></span><span style=display:flex><span>       (cons to path)]
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>hash-ref</span> preds to <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>=&gt; </span>(<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>loop</span> next (cons to path)))]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>#f</span>])))
</span></span></code></pre></div><p>Using the <code>=></code> form of <code>cond</code>, we can return the path if there is one, or immediately short circuit with no path if we ever fail. Additionally, using an accumulator (<code>path</code>), means that the list is naturally in the order we want, where it would have been reversed in the more &rsquo;natural&rsquo; recursive form.</p><p>That&rsquo;s basically everything we need. Given functions to read in the data and a path finder for each step, we can solve the entire call set:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Given a phone network and sequence of calls, place as many as possible</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>solve</span> [in (<span style=color:#a6e22e>current-input-port</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>network (<span style=color:#a6e22e>read-network</span> in))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>calls (<span style=color:#a6e22e>read-calls</span> in))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Try to route each call in turn</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Take the shortest path possible using dijkstra&#39;s algorithm for routing</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/list</span> ([call (<span style=color:#a6e22e>in-list</span> calls)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>match-define</span> (list from to) call)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; We can find a path; write it and update the network</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>dijkstra-path</span> network from to)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>=&gt; </span>(<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>begin0</span>
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>step</span> (<span style=color:#a6e22e>graph-copy</span> network) call path)
</span></span><span style=display:flex><span>              (<span style=color:#66d9ef>let </span>loop ([path path])
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>match</span> path
</span></span><span style=display:flex><span>                  <span style=color:#75715e>; As long as there are at least two nodes:</span>
</span></span><span style=display:flex><span>                  <span style=color:#75715e>; - Calculate the new edge weight</span>
</span></span><span style=display:flex><span>                  <span style=color:#75715e>; - Remove the current edge (no way to directly update)</span>
</span></span><span style=display:flex><span>                  <span style=color:#75715e>; - If new weight is not zero, add the new edges</span>
</span></span><span style=display:flex><span>                  [(<span style=color:#a6e22e>list-rest</span> from to rest)
</span></span><span style=display:flex><span>                   (<span style=color:#66d9ef>define </span>weight (- (<span style=color:#a6e22e>edge-weight</span> network from to) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>remove-edge!</span> network from to)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>remove-edge!</span> network to from)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>when</span> (&gt; weight <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>add-edge!</span> network from to weight)
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>add-edge!</span> network to from weight))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>loop</span> rest)]
</span></span><span style=display:flex><span>                  [any (<span style=color:#a6e22e>void</span>)]))))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; No path; print failure and leave the network</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>step</span> (<span style=color:#a6e22e>graph-copy</span> network) call <span style=color:#66d9ef>#f</span>)])))
</span></span></code></pre></div><p>Honestly, adding and removing the nodes is the largest part of the code. Perhaps I should add in an <code>edit-weight!</code> function. Anyways, this gives us a simple enough way to solve the problems given:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>with-input-from-string</span> <span style=color:#e6db74>&#34;A B 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>B C 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>C D 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>D E 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>E F 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>F G 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>G A 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>E H 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>H D 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>A C
</span></span></span><span style=display:flex><span><span style=color:#e6db74>A D
</span></span></span><span style=display:flex><span><span style=color:#e6db74>A D
</span></span></span><span style=display:flex><span><span style=color:#e6db74>F D
</span></span></span><span style=display:flex><span><span style=color:#e6db74>B D
</span></span></span><span style=display:flex><span><span style=color:#e6db74>B D
</span></span></span><span style=display:flex><span><span style=color:#e6db74>B E
</span></span></span><span style=display:flex><span><span style=color:#e6db74>C F&#34;</span> solve)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>list</span>
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;C&#34;</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;C&#34;</span>))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;G&#34;</span> <span style=color:#e6db74>&#34;F&#34;</span> <span style=color:#e6db74>&#34;E&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#e6db74>&#34;G&#34;</span> <span style=color:#e6db74>&#34;F&#34;</span> <span style=color:#e6db74>&#34;E&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;F&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>) <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#e6db74>&#34;D&#34;</span>))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#e6db74>&#34;E&#34;</span>) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>step</span> <span style=color:#f92672>#</span>&lt;weighted-graph&gt; <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#e6db74>&#34;F&#34;</span>) <span style=color:#66d9ef>#f</span>))
</span></span></code></pre></div><p>So for this case, we could only route 5 of the 8 calls. Oops. It turns out there&rsquo;s a solution that routes 6 of them, but only if you can see the future and purposely don&rsquo;t route one of the early further apart calls.</p><p>Well, that&rsquo;s all well and good, but how about some visualization?</p><h2 id=visualizing-output>Visualizing output</h2><p>My goal is going to be to write out a &lsquo;solution directory&rsquo;. First, we need a summary file (actually writing out the solution the problem asked for):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Write a solution to a directory</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>write-solution</span> steps output-directory)
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Make sure the output directory exists (files will be overwritten)</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>when</span> (not (<span style=color:#a6e22e>directory-exists?</span> output-directory))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>make-directory</span> output-directory))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; First generate a summary file</span>
</span></span><span style=display:flex><span>  (with-output-to-file (<span style=color:#a6e22e>build-path</span> output-directory <span style=color:#e6db74>&#34;summary.txt&#34;</span>)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for</span> ([i (<span style=color:#a6e22e>in-naturals</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>            [each (<span style=color:#a6e22e>in-list</span> steps)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>step</span> network call path) each)
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>match-define</span> (list from to) call)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>printf</span> <span style=color:#e6db74>&#34;~a -&gt; ~a ... ~a\n&#34;</span>
</span></span><span style=display:flex><span>                from
</span></span><span style=display:flex><span>                to
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>or </span>path <span style=color:#e6db74>&#34;failed&#34;</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>Straight foward enough. The only interesting piece is writing either the path <code>or</code> &ldquo;failed&rdquo;, which we can get away with because <code>or</code> short circuits. Easy enough.</p><p>Next, display the networks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Generate a graph for each step</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for</span> ([i (<span style=color:#a6e22e>in-naturals</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>        [each (<span style=color:#a6e22e>in-list</span> steps)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>step</span> network call path) each)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Generate a coloring with distinct colors for path</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>colors
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for/hash</span> ([node (<span style=color:#a6e22e>in-vertices</span> network)])
</span></span><span style=display:flex><span>        (values node (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>                       [(equal? node (<span style=color:#a6e22e>first</span> path)) <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                       [(equal? node (<span style=color:#a6e22e>last</span> path))  <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>                       [(member node path)         <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>                       [<span style=color:#66d9ef>else </span>                      <span style=color:#ae81ff>0</span>]))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Paramaterize each step filename so we can make dots and images</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>filename</span> ext)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;~a.~a&#34;</span> 
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>~a</span> i <span style=color:#f92672>#</span>:min-width <span style=color:#ae81ff>2</span> <span style=color:#f92672>#</span>:align <span style=color:#e6db74>&#39;right</span> <span style=color:#f92672>#</span>:pad-string <span style=color:#e6db74>&#34;0&#34;</span>)
</span></span><span style=display:flex><span>              ext))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Write the dot file</span>
</span></span><span style=display:flex><span>    (with-output-to-file (<span style=color:#a6e22e>build-path</span> output-directory (<span style=color:#a6e22e>filename</span> <span style=color:#e6db74>&#34;dot&#34;</span>))
</span></span><span style=display:flex><span>      <span style=color:#f92672>#</span>:exists <span style=color:#e6db74>&#39;replace</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>        (display (<span style=color:#a6e22e>graphviz</span> network <span style=color:#f92672>#</span>:colors colors))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Use the dot file to generate an image</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>system</span> (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;neato -Tpng ~a &gt; ~a&#34;</span> 
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>build-path</span> output-directory (<span style=color:#a6e22e>filename</span> <span style=color:#e6db74>&#34;dot&#34;</span>))
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>build-path</span> output-directory (<span style=color:#a6e22e>filename</span> <span style=color:#e6db74>&#34;png&#34;</span>))))))
</span></span></code></pre></div><p>It&rsquo;s a bit complicated looking, but really there are four parts. First, we generate a coloring. A <a href=https://blog.jverkamp.com/2014/01/15/graph-coloring/>little while ago</a> I made the function that would successfully display a coloring, so for that we need to create a hash of vertex labels to integers. In this case, we&rsquo;ll have distinct colors for the source (green), path (purple), destination (cyan), and unrelated nodes (red). Something like this:</p><figure><img src=/embeds/2014/01.png></figure><p>The next part generates a filename generating function (so we can parameterize over the extension). Straight forward, we just want to make sure we have two digits so they&rsquo;ll sort correctly, thus the use of <code>~a</code> (I wish there were a shorter way to do this).</p><p>After that, write out the file generated by the <code>graphviz</code> function, then call <code>neato</code> on my local system to generate the image. From that, we get a nice series of images:</p><pre tabindex=0><code>summary.txt:
A -&gt; G ... (A B D G)
A -&gt; G ... (A C E F G)
C -&gt; E ... (C E)
G -&gt; D ... (G F E D)
D -&gt; E ... (D E)
A -&gt; B ... (A B)
A -&gt; D ... (A C B D)
</code></pre><p>[gallery link=&ldquo;file&rdquo; columns=&ldquo;3&rdquo; orderby=&ldquo;title&rdquo;]</p><p>Yay graphs!</p><p>And that&rsquo;s it for today. If you want to see the entire code all in one place, you can do so on GitHub as always: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/phone-network.rkt>phone-network.rkt</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>