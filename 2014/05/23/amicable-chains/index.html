<!doctype html><html><head><title>Amicable chains â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.34a34d86b8aae11b989d80a1626629c053029d012419a1993cfb6c12ea175737.css integrity="sha256-NKNNhriq4RuYnYChYmYpwFMCnQEkGaGZPPtsEuoXVzc="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Amicable chains</h1><div class=entry-meta><span class=entry-date>2014-05-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/05/28/quadtree-image-compression/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/05/28/quadtree-image-compression/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphs>Graphs</a><a href=https://blog.jverkamp.com/2015/08/24/adjacency-matrix-generator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a><a href=https://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/01/27/factoring-factorials/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/number-theory>Number Theory</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/28/quadtree-image-compression/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/05/21/phone-networks/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/05/28/quadtree-image-compression/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Mathematicians are an odd bunch. Names for just about everyhing. There are <a href=https://en.wikipedia.org/wiki/Amicable%20number>amicable numbers</a> and <a href=https://en.wikipedia.org/wiki/perfect%20number>perfect number</a>, <a href=https://en.wikipedia.org/wiki/sociable%20number>sociable number</a> and <a href=https://en.wikipedia.org/wiki/Betrothed%20number>betrothed numbers</a>. There are <a href=https://en.wikipedia.org/wiki/sublime%20number>sublime number</a>, <a href=https://en.wikipedia.org/wiki/frugal%20number>frugal number</a>, and <a href=https://en.wikipedia.org/wiki/quasiperfect%20number>quasiperfect number</a>. Heck, there are <a href=https://en.wikipedia.org/wiki/powerful%20number>powerful number</a>, <a href=https://en.wikipedia.org/wiki/smooth%20number>smooth number</a>, and even <a href=https://en.wikipedia.org/wiki/Sphenic%20number>sphenic numbers</a>. Rather a lot to deal with all told&mldr; So let&rsquo;s just focus on two of them: <a href=https://en.wikipedia.org/wiki/Perfect%20number>perfect numbers</a> and <a href=https://en.wikipedia.org/wiki/Amicable%20number>amicable numbers</a>.</p><p>The two are rather related, in that they&rsquo;re both defined in terms of their sum of proper divisors. Start with divisors: the set of numbers that evenly divide a given number. So say the divisors of 25 are 1, 5, and 25. Proper adds the constraint that a number is not a divisor of itself (so only 1 and 5). Sum them and you have <span class=latex-inline>spd(25) = 6</span>
.</p><p>If <span class=latex-inline>spd(n) = n</span>
, a number is considered perfect. If <span class=latex-inline>spd(n) = m</span>
and <span class=latex-inline>spd(m) = n</span>
, the <span class=latex-inline>m</span>
and <span class=latex-inline>n</span>
are amicable. Simple<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> as that. The same context can be extended to a sequence:</p><div class=latex-block>\mathbb{X} = \left \{ x_n | spd(x_n) = x_{n+1} \right \}</div><p>So that&rsquo;s what we&rsquo;re dealing with today, given <a href=http://programmingpraxis.com/2014/05/20/amicable-chains/>Tuesday&rsquo;s post</a> on Programming Praxis. In a single sentence: find all perfect numbers, amicable pairs, and amicable chains less than one million.</p><p>Let&rsquo;s get started.</p><h2 id=perfect-numbers-and-amicable-pairs>Perfect numbers and amicable pairs</h2><p>First we need to write a function that can quickly calculate the <code>sum-of-divisors</code> of a number. We&rsquo;ll be using the <code><a href="http://docs.racket-lang.org/search/index.html?q=math/number-theory">math/number-theory</a></code>
module to calculate divisors and <a href=http://pkg.racket-lang.org/#[memoize]>jbclements&rsquo; <code>memoize</code> module</a> to save us a bit of time calculating a pile of these over and over again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>require</span> math/number-theory
</span></span><span style=display:flex><span>         memoize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Calculate sum of proper divisors (proper, thus subtracting i)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>define/memo</span> (<span style=color:#a6e22e>sum-of-divisors</span> n)
</span></span><span style=display:flex><span>  (- (apply + (<span style=color:#a6e22e>divisors</span> n)) n))
</span></span></code></pre></div><p>Testing it out with the value we already know:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>sum-of-divisors</span> <span style=color:#ae81ff>25</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>From here and with the definitions above, we can directly define perfect numbers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; A number is perfect if its divisors sum to itself</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>perfect?</span> n)
</span></span><span style=display:flex><span>  (= n (<span style=color:#a6e22e>sum-of-divisors</span> n)))
</span></span></code></pre></div><p>And amicable pairs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Two numbers are amicable if each numbers&#39;s sum of divisors is the other</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>amicable?</span> m n)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(= m (<span style=color:#a6e22e>sum-of-divisors</span> n))
</span></span><span style=display:flex><span>       (= n (<span style=color:#a6e22e>sum-of-divisors</span> m))))
</span></span></code></pre></div><p>As an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>perfect?</span> <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>perfect?</span> <span style=color:#ae81ff>25</span>) <span style=color:#75715e>; (spd 25) -&gt; 6</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>amicable?</span> <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>#f</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>amicable?</span> <span style=color:#ae81ff>220</span> <span style=color:#ae81ff>284</span>) <span style=color:#75715e>; (spd 220) -&gt; 284; (spd 284) -&gt; 220</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>#t</span>
</span></span></code></pre></div><p>Looks good. But how about we think a little bit bigger, eh?</p><h2 id=amicable-chains>Amicable chains</h2><p>For the next part of the problem, we want to calculate <em>amicable chains</em>. Sequences of numbers of any length such that the sum of proper divisors of each number is the next and the chain wraps around at the end. On the smaller end, all perfect numbers are amicable chains of length 1. All amicable pairs are chains of length 2. One example amicable chain of length 5 would be <code>(12496 14264 14536 15472 14288)</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Given all of that, we should be able to write a nice recursive function to determine if a number is in an amicable chain and, if so, return it. To do so, we&rsquo;re going to essentially need to recur down a chain of numbers until one of three/four conditions is met:</p><ul><li>We find the original number in the sequence; return the amicable chain</li><li>The chain terminates at 1 (any prime number will have 1 as the sum of divisors after which the chain will terminate)</li><li>We find a number other than the original for the second time; there is a chain, but the number in question is not part of it (example 25 -> 6 which then loops)</li><li><em>optional:</em> The current number is larger than some bound; it may be a chain, but for our purposes return <code>#f</code></li></ul><p>Translating this relatively directly into code, we have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; An amicable chain is a sequence of numbers where each&#39;s sum of divisors is the next</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Ignore chains that leave the given bounds</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>amicable-chain</span> n [bound +inf<span style=color:#f92672>.</span><span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>let/ec</span> return
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([x (<span style=color:#a6e22e>sum-of-divisors</span> n)] [prev <span style=color:#f92672>&#39;</span>()])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        [(= x n)
</span></span><span style=display:flex><span>         (cons x prev)]
</span></span><span style=display:flex><span>        [(<span style=color:#66d9ef>or </span>(&gt; x bound) (= x <span style=color:#ae81ff>1</span>) (member x prev))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>return</span> <span style=color:#66d9ef>#f</span>)]
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>sum-of-divisors</span> x)
</span></span><span style=display:flex><span>               (cons x prev))]))))
</span></span></code></pre></div><p>As given earlier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>amicable-chain</span> <span style=color:#ae81ff>12496</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>12496</span> <span style=color:#ae81ff>14264</span> <span style=color:#ae81ff>14536</span> <span style=color:#ae81ff>15472</span> <span style=color:#ae81ff>14288</span>)
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>amicable-chain</span> <span style=color:#ae81ff>15472</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>15472</span> <span style=color:#ae81ff>14288</span> <span style=color:#ae81ff>12496</span> <span style=color:#ae81ff>14264</span> <span style=color:#ae81ff>14536</span>)
</span></span></code></pre></div><p>That gives us most of our framework. All that&rsquo;s left is extended it to a bunch of numbers at a time (and as a bonus: making a pretty picture).</p><h2 id=generating-a-graph>Generating a graph</h2><p>Basic idea: Iterate through all numbers 2 through some bound. For each in turn, if it&rsquo;s an amicable chain, add the numbers in the chain to a graph. Skip any number added as we iterate upwards.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Create a graph of all amicable chains within the bounds</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>amicable-chains-graph</span> bound)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>graph (<span style=color:#a6e22e>unweighted-graph/directed</span> <span style=color:#f92672>&#39;</span>()))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>colors (<span style=color:#a6e22e>make-hash</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for</span> ([i (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>2</span> bound)] <span style=color:#f92672>#</span>:unless (<span style=color:#a6e22e>has-vertex?</span> graph i))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond </span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>amicable-chain</span> i bound) 
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>=&gt; </span>(<span style=color:#a6e22e>Î»</span> (<span style=color:#a6e22e>chain</span>)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>displayln</span> chain)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>for</span> ([from (<span style=color:#a6e22e>in-list</span> chain)] 
</span></span><span style=display:flex><span>                  [to (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>snoc</span> (car chain) (cdr chain)))])
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-set!</span> colors from
</span></span><span style=display:flex><span>                         (<span style=color:#66d9ef>case </span>(length chain)
</span></span><span style=display:flex><span>                           [(<span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>0</span>] [(<span style=color:#ae81ff>2</span>) <span style=color:#ae81ff>1</span>] [<span style=color:#66d9ef>else </span><span style=color:#ae81ff>2</span>]))
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>add-directed-edge!</span> graph from to)))]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (values graph colors))
</span></span></code></pre></div><p>That&rsquo;s actually all there is to it. One interesting trick is iterating over the list <code>chain</code> and <code>(snoc (car chain) (cdr chain))</code>. Basically, that&rsquo;s a sneaky way to iterate over all sequential numbers in the list. <code>snoc</code> is the reversed form of <code>cons</code>. Rather than adding to the head of a list, add to the end. It&rsquo;s terribly inefficient, but at the very least it serves our purposes.</p><p>With a helper wrapping the <code>graphviz</code> function to actually generate the files, and we can actually write out our results:</p><figure><img src=/embeds/2014/amicable-chains.png></figure><p>Looks like we have four perfect numbers (in red; 6, 28, 496, and 8128), a whole pile of amicable pairs, and two nice chains (the larger has almost 30 numbers). I&rsquo;m actually a little surprised that such a large chain already appears under a million. It sort of makes me wonder just how large of chains there might be out there if you look further&mldr;</p><p>And that&rsquo;s it for today. As always, the code is on GitHub: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/amicable-chains.rkt>amicable-chain.rkt</a>. Enjoy!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For some definitions of simple&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Verification left as exercise to the reader&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>