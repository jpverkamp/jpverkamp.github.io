<!DOCTYPE html>
<html>
<head>
        
        

        <title>Brownian trees | jverkamp.com | John-Paul Verkamp</title>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

        <script src="//code.jquery.com/ui/1.11.1/jquery-ui.min.js"></script>

        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css" />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.css" />
        <script src="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.js"></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.9/jquery.transit.min.js"></script>

        <!-- Highlight.js for syntax highlighting -->
        <link rel="stylesheet" href="/highlight/styles/obsidian.css" />
        <script src="/highlight/highlight.pack.js"></script>

        <!-- MathJax for LaTeX support -->
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- nanoGallery for Flickr Galleries -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/css/themes/light/nanogallery_light.css" />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/jquery.nanogallery.min.js"></script>

        <!-- Pretty pretty fonts -->
        <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Calligraffitti" />

        <!-- Emoji! (https://hassankhan.github.io/emojify.js/) -->
        <link rel="stylesheet" type="text/css" href="/emojify.js/emojify-emoticons.min.css" />
        <link rel="stylesheet" type="text/css" href="/emojify.js/emojify.min.css" />
        <script type="text/javascript" src="/emojify.js/emojify.min.js"></script>

        <!-- Any custom CSS or JS that I've written; this should be kept minimal -->
        <link rel="stylesheet" href="/custom.css" />
        <script src="/custom.js"></script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="http://blog.jverkamp.com/feed/" />
</head>
<body>
        <header class="container">
        <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://blog.jverkamp.com"><span style="color: green;">jv</span>erkamp.com</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav"><li class="dropdown"><a href="http://blog.jverkamp.com/category/archives" class="dropdown-toggle">Archives<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/archives/2004">2004</a></li><li><a href="http://blog.jverkamp.com/category/archives/2005">2005</a></li><li><a href="http://blog.jverkamp.com/category/archives/2006">2006</a></li><li><a href="http://blog.jverkamp.com/category/archives/2007">2007</a></li><li><a href="http://blog.jverkamp.com/category/archives/2008">2008</a></li><li><a href="http://blog.jverkamp.com/category/archives/2009">2009</a></li><li><a href="http://blog.jverkamp.com/category/archives/2010">2010</a></li><li><a href="http://blog.jverkamp.com/category/archives/2011">2011</a></li><li><a href="http://blog.jverkamp.com/category/archives/2012">2012</a></li><li><a href="http://blog.jverkamp.com/category/archives/2013">2013</a></li><li><a href="http://blog.jverkamp.com/category/archives/2014">2014</a></li><li><a href="http://blog.jverkamp.com/category/archives/2015">2015</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/other" class="dropdown-toggle">Other<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/other/board-game-reviews">Board Game Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/book-reviews">Book Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/cooking">Cooking</a></li><li><a href="http://blog.jverkamp.com/category/other/movie-reviews">Movie Reviews</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/photography" class="dropdown-toggle">Photography<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/photography/dp-challenge">DP Challenge</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosets">Photosets</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosynth">Photosynth</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/programming" class="dropdown-toggle">Programming<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/programming/by-language">By Language</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-project">By Project</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source">By Source</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/programming/libraries">Libraries</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/research" class="dropdown-toggle">Research<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/research/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/research/publications">Publications</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/writing" class="dropdown-toggle">Writing<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/writing/by-genre">By Genre</a></li><li><a href="http://blog.jverkamp.com/category/writing/ideas">Ideas</a></li><li><a href="http://blog.jverkamp.com/category/writing/nanowrimo">NaNoWriMo</a></li><li><a href="http://blog.jverkamp.com/category/writing/novels">Novels</a></li><li><a href="http://blog.jverkamp.com/category/writing/other">Other</a></li><li><a href="http://blog.jverkamp.com/category/writing/short-stories">Short Stories</a></li><li><a href="http://blog.jverkamp.com/category/writing/writing-excuses">Writing Excuses</a></li></ul></li></ul>

      <form action="http://www.google.com/search" method="get" onSubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input name="q" type="hidden" />
          <input name="qfront" type="text" class="form-control" placeholder="Search" />
          <button type="submit" class="btn btn-default" value="Search">Search</button>
        </p>
      </form>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
        </header>

        <article class="container">
                <header>
                        <h1 class="entry-title">Brownian trees</h1>

                        <div class="entry-meta">
                                <span class="posted-on"><time class="entry-date" datetime="2014-03-11"><span class="year">2014</span> <span class="month">Mar</span> <span class="day">11</span></time></span>
                                <span class="tags"><ul class="tag-list list-inline"><li><a href="http://blog.jverkamp.com/category/programming/by-topic/cellular-automata">Cellular Automata</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/graphics">Graphics</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/procedurally-generated-content">Procedurally Generated Content</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/scheme">Scheme</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/tree">Tree</a></li></ul></span>
                        </div>

                        <hr />
                </header>
                <div class="entry-content">
                        <p>Pretty pretty picture time<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<p><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-tree.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-tree.png" /></a></p>
<!--more-->
<p>The basic idea here is that of a <a href="https://en.wikipedia.org/wiki/Brownian_Tree">Brownian Tree</a>:</p>
<blockquote><p>A Brownian tree is built with these steps: first, a "seed" is placed somewhere on the screen. Then, a particle is placed in a random position of the screen, and moved randomly until it bumps against the seed. The particle is left there, and another particle is placed in a random position and moved until it bumps against the seed or any previous particle, and so on.</p>
-- Wikipedia</blockquote>
<p>In this case, we're going to put the seed point in the center and drop points in from the outside. There are a number of other parameters we can tweak, but we'll get to each of those in turn.</p>
<p>First, we need to come up with a basic structure for the code. Luckily, the <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> function will do exactly what we want. All we have to do it write something for the <code>on-tick</code> and <code>on-draw</code> clauses.</p>
<p>Okay, next step. What sort of data structure are we going to use?</p>
<p>Well, we need to know how big the world is. And we need to have a bunch of dots moving constantly inwards, so how about something like this:</p>
<pre class="scheme"><code>(struct point (x y) #:transparent)
(struct world (radius points drip) #:transparent)</code></pre>
<p>I went ahead and separated out the point that is currently falling inwards as the <code>drip</code>, although we could also have had that as the first of the list in <code>points</code>. Either works.</p>
<p>Okay, so next we want a function that takes in one of these world structures and returns the next step in the simulation. In this case, the drip should either move inwards or freeze in place if it meets another nearby point. Perhaps something like this:</p>
<pre class="scheme"><code>; Either randomly move the drip or create a new one
(define (update w)
  ; Always try to move the drip first
  (define new-drip
    (point (+ (point-x (world-drip w)) (random 3) -1)
           (+ (point-y (world-drip w)) (random 3) -1)))

  (cond
    ; If it's adjacent to any current point, freeze it and generate a new drip
    [(ormap (λ (pt) (&lt;= (δ new-drip pt) (current-spacing)))
            (world-points w))

     (world (world-radius w)
            (cons new-drip (world-points w))
            (random-point (world-radius w)))]
    ; Otherwise, just use the new drip
    [else
     (world (world-radius w)
            (world-points w)
            new-drip)]))</code></pre>
<p>As the comments say, we'll start by moving the point. Then, we can check if the <code>new-drip</code> is adjacent to any neighboring point by calculating the distance to each with <code>δ</code>:</p>
<pre class="scheme"><code>; Distance formula
(define (δ pt1 pt2)
  (sqrt (+ (sqr (- (point-x pt1) (point-x pt2)))
           (sqr (- (point-y pt1) (point-y pt2))))))</code></pre>
<p>Furthermore, because we're using <code>ormap</code>, as soon as we have any matching point, the check will short circuit. If we wanted to write it in a potentially more 'Rackety' style, we could instead have written the condition with <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>:</p>
<pre class="scheme"><code>(for/first ([pt (in-list (world-points w))]
            #:when (&lt;= (δ new-drip pt) (current-spacing)))
  #t)</code></pre>
<p>The last bit is the <code>random-point</code> function. Since we're dealing with a circle, it will be easiest to generate the points in <a href="https://en.wikipedia.org/wiki/polar_coordinates">polar coordinates</a> and then converting them to <a href="https://en.wikipedia.org/wiki/Cartesian_coordinates">Cartesian coordinates</a>:</p>
<pre class="scheme"><code>; Generate a new random point on the border of a given circle
(define (random-point r)
  (define θ (* 2 pi (random)))
  (point (inexact-&gt;exact (truncate (* r (cos θ))))
         (inexact-&gt;exact (truncate (* r (sin θ))))))</code></pre>
<p>If you wanted to generate points within the circle as well, rather than just on the edge, you could randomly generate <code>(define r^ (* (random) r))</code>. I think generating them on the borders works better though.</p>
<p>Well, that was straight forward enough> Hopefully the drawing function will be as quick?</p>
<p>For this, we're going to take advantage of the <code><a href="http://docs.racket-lang.org/search/index.html?q=circle">circle</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=overlay/offset">overlay/offset</a></code> functions, both from <code><a href="http://docs.racket-lang.org/search/index.html?q=2htdp/image">2htdp/image</a></code>. The former will create a circular image (either for the background or for the points themselves) and the latter will draw the latter on the former (nicely centering them for a convenient axis system).</p>
<p>Something like this:</p>
<pre class="scheme"><code>; Draw the current points in an image
(define (draw w)
  (for/fold ([img (circle (world-radius w) "outline" "black")])
            ([pt (in-list (cons (world-drip w)
                                (world-points w)))])
    (overlay/offset (outlined-circle 0.5 "black")
                    (point-x pt)
                    (point-y pt)
                    img)))</code></pre>
<p>I really like the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> macro. The first block starts with the loop state (the background circle). The second controls the loop (the drip and then each point in turn). The third/body draws the point with the next loop acting as the <code>img</code> the next time around.</p>
<p>Now, the beauty of this structure becomes apparent. With the <code><a href="http://docs.racket-lang.org/search/index.html?q=big-bang">big-bang</a></code> function from <code><a href="http://docs.racket-lang.org/search/index.html?q=2htpd/universe">2htpd/universe</a></code>, all we have to do is create an initial world and the <code>update</code>/<code>draw</code> functions:</p>
<pre class="scheme"><code>(define (brownian-tree radius)
  (big-bang (world radius '() (point 0 0))
    (on-tick update)
    (on-draw draw)))</code></pre>
<p>Let's give it a try:</p>
<pre class="scheme"><code>&gt; (brownian-tree 25)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-initial.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-initial.png" /></a></p>
<p>Yeah, that's tiny. Perhaps as the first tweak, we should introduce a scaling parameter to the world. The nice thing about the <code>update</code>/<code>draw</code> split is that we can keep the simulation unscaled and only scale in <code>draw</code>:</p>
<pre class="scheme"><code>(struct world (radius scale points drip) #:transparent)

; Draw the current points in an image
(define (draw w)
  (for/fold ([img (circle (* (world-scale w) (world-radius w)) "outline" "black")])
            ([pt (in-list (cons (world-drip w)
                                (world-points w)))])
    (overlay/offset (outlined-circle (/ (world-scale w) 2) "black")
                    (* (world-scale w) (point-x pt))
                    (* (world-scale w) (point-y pt))
                    img)))

(define (brownian-tree radius #:scale [scale 1.0])
  (big-bang (world radius scale '() (point 0 0))
    (on-tick update)
    (on-draw draw)))</code></pre>
<p>Optional keyword parameters, just because...</p>
<p>With that, we can make some much more reasonably sized images:</p>
<pre class="scheme"><code>&gt; (brownian-tree 25 #:scale 5.0)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-scaled.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-scaled.png" /></a></p>
<p>What's the next thing we could tweak? How about a bit more color?</p>
<pre class="scheme"><code>(struct point (x y c) #:transparent)

; Generate a new random point on the border of a given circle
(define (random-point r)
  (define θ (* 2 pi (random)))
  (point (inexact-&gt;exact (truncate (* r (cos θ))))
         (inexact-&gt;exact (truncate (* r (sin θ))))
         (vector-ref colors (random (vector-length colors)))))

; Draw the current points in an image
(define (draw w)
  (for/fold ([img (circle (* (world-scale w) (world-radius w)) "outline" "black")])
            ([pt (in-list (cons (world-drip w)
                                (world-points w)))])
    (overlay/offset (outlined-circle (/ (world-scale w) 2) (point-c pt))
                    (* (world-scale w) (point-x pt))
                    (* (world-scale w) (point-y pt))
                    img)))

(define (brownian-tree radius #:scale [scale 1.0])
  (define origin (point 0 0 "black"))
  (big-bang (world radius scale (list origin) (random-point radius))
    (on-tick update)
    (on-draw draw)))</code></pre>
<p>That's actually enough to generate the image from the header:</p>
<pre class="scheme"><code>&gt; (brownian-tree 25 #:scale 5.0)</code></pre>
<p><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-tree.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-tree.png" /></a></p>
<p>There are two things that you should have noticed though--although one isn't particularly obvious unless you're following along:</p>
<ul>
  <li>The grid structure tends to align on the vertical and horizontal axes</li>
  <li>It takes forever for the points to fall inwards and join the tree</li>
</ul>
<p>How can we deal with that?</p>
<p>Well for the first, think back to the update function we wrote. All we really used was a grid update that added ±1 to each point and a distance function <code>δ</code>. There's nothing in particular that would stop us from moving with real coordinates instead. To make the transition easier, let's factor out this '<code>wiggle</code>' function into two different options:</p>
<pre class="scheme"><code>(define current-wiggle-real? (make-parameter #f))
(define current-inward-bias (make-parameter 0.5))

; Wiggle a point closer to the origin, sticking to the unit grid
(define (wiggle:grid pt)
  (let ([max-d (δ origin pt)])
    (let loop ()
      (define xδ? (zero? (random 2)))
      (define new-pt
        (point (if xδ? (+ (point-x pt) (random 3) -1) (point-x pt))
               (if xδ? (point-y pt) (+ (point-y pt) (random 3) -1))
               (point-c pt)))
      (if (or (&lt;= (δ origin new-pt) max-d) (&lt; (current-inward-bias) (random)))
          new-pt
          (loop)))))

; Wiggle a point closer to the origin, returning any new point within the unit circle
(define (wiggle:real pt)
  (let ([max-d (δ origin pt)])
    (let loop ()
      (define θ (* 2 pi (random)))
      (define new-pt
        (point (+ (point-x pt) (cos θ))
               (+ (point-y pt) (sin θ))
               (point-c pt)))
      (if (or (&lt;= (δ origin new-pt) max-d) (&lt; (current-inward-bias) (random)))
          new-pt
          (loop)))))

; Either randomly move the drip or create a new one
(define (update w)
  ; Always try to move the drip first
  (define new-drip
    ((if (current-wiggle-real?) wiggle:real wiggle:grid)
     (world-drip w)))

  ...)

(define (brownian-tree radius
                       #:scale     [scale 1.0]
                       #:spacing   [spacing 1]
                       #:real-mode [real-mode? #f])
  (parameterize ([current-wiggle-real? real-mode?]
                 [current-spacing spacing])
    (define origin (point 0 0 "black"))
    (big-bang (world radius scale (list origin) (random-point radius))
      (on-tick update)
      (on-draw draw))))</code></pre>
<p>While we're at it, I made another tweak for the second issue above. Did you notice? <code>current-inward-bias</code>? Basically, a random percent of the number, we might move outwards, but otherwise we're guaranteed (via checking the <code>δ</code> to the <code>origin</code>) to move inwards. This should speed up the simulation--while at the same time adding enough parameters to get all sorts of interesting variants:</p>
<table class="table table-striped"><tr><td>bias</td><td>1.0</td><td>0.5</td><td>0.25</td></tr>
<tr><td>grid</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-full.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-full.png" /></a>
</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-half.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-half.png" /></a>
</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-quarter.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-grid-quarter.png" /></a>
</td></tr><tr><td>real</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-full.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-full.png" /></a>
</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-half.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-half.png" /></a>
</td><td>
<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-quarter.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-real-quarter.png" /></a>
</td></tr><table class="table table-striped">

It's interesting how different the two modes are. While grid mode aligns on the axes with higher inward bias, real mode makes more compact images as the points are more likely to skip past one another.

That's about all we have time for, although there are all sorts of additional tweaks that we could still make. For example, what about tweaking the distance at which we consider a collision?

<pre class="scheme"><code>&gt; (brownian-tree 25
                 #:scale 2.5
                 #:real-mode #t
                 #:spacing (* 2 (sqrt 2))
                 #:bias 0.5
                 #:fast-mode #t)</code></pre>

<a href="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-spaced-out.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/03/11/brownian-trees/brownian-spaced-out.png" /></a>

What's that you say? I haven't explained <code>#:fast-mode</code>?

<pre class="scheme"><code>; Faster version of update that loops until the new point freeze into place
(define (fast-update w)
  (let loop ([w^ w])
    (if (eq? (world-points w) (world-points w^))
        (loop (update w^))
        w^)))

; Run the full simulation, returning the resulting image
(define (brownian-tree radius
                       #:scale     [scale 1.0]
                       #:bias      [bias 0.5]
                       #:spacing   [spacing 1]
                       #:fast-mode [fast-mode? #f]
                       #:real-mode [real-mode? #f])
  (parameterize ([current-wiggle-real? real-mode?]
                 [current-spacing spacing]
                 [current-inward-bias bias])
    (define initial-world (world radius scale (list origin) (random-point radius)))
    (define draw (make-cached-draw initial-world))
    (draw
     (big-bang initial-world
       (on-tick (if fast-mode? fast-update update))
       (to-draw draw)))))</code></pre>

Basically, don't show every step. Run the simulation until a particle 'sticks' and <em>then</em> update<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>.

What? <code>make-cached-draw</code>?

Well, think about it. Every time we were calling <code>draw</code>, we were redrawing the entire image from scratch. But once a point freezes in place, we should never have to draw it again. We can take advantage of this to radically speed up our drawing function (particularly once we have hundreds or even thousands of points):

<pre class="scheme"><code>; Create a cached draw function for a particular world
(define (make-cached-draw initial-world)
  (let ([cache-key '()] [cache-val (circle (* (world-scale initial-world) (world-radius initial-world)) "outline" "black")])
    (λ (w)
      ; If we have at least one new point, add all new points to the cached image
      (when (not (eq? cache-key (world-points w)))
        (set! cache-val
          (for/fold ([img cache-val]) ([pt (in-list (world-points w))]
                                       #:break (member pt cache-key))
            (overlay/offset (outlined-circle (/ (world-scale w) 2) (point-c pt))
                            (* (world-scale w) (point-x pt))
                            (* (world-scale w) (point-y pt))
                            img)))
        (set! cache-key (world-points w)))
      ; Add the drip (never cached)
      (overlay/offset (outlined-circle (/ (world-scale w) 2) (point-c (world-drip w)))
                      (* (world-scale w) (point-x (world-drip w)))
                      (* (world-scale w) (point-y (world-drip w)))
                      cache-val))))</code></pre>

It's a little more complicated, but the basic idea should be pretty straight forward. If given an exact subset of the points we've already drawn, directly return that image. Since we're actually returning the same list (with potentially more points in front), <code>eq?</code> does exactly what we want here.

And there you have it. Brownian trees, in <a href="https://en.wikipedia.org/wiki/motion">Brownian motion</a>.

If you'd like to see all of the code in one place, you can do so here: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/brownian-tree.rkt">Brownian tree on GitHub</a>
                </div>
                <div class="entry-footnotes">
                        <div id="footnotes"><ol><li><a name="footnote-1"></a>For some definition of 'pretty'</li><li><a name="footnote-2"></a>Yes. I've been using that this entire post. It turns out that waiting for hundreds of particles to randomly drift takes too long...</li></ol></div>
                </div>

                <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "jverkamp";
var disqus_title = "Brownian trees";
var disqus_url = "http://blog.jverkamp.com/2014/03/11/brownian-trees/";
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </article>

        <footer class="container" role="contentinfo">
                <nav class="navbar navbar-default" role="navigation"><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/02/27/disre-emvowelification">← Dis/re-emvowelification</a></li><li><a href="http://blog.jverkamp.com/category/archives">Archives</a></li><li><a href="http://blog.jverkamp.com/2014/03/12/caesar-cipher">Caesar cipher →</a></li></ul><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/02/27/disre-emvowelification">← Dis/re-emvowelification</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/2014/03/12/caesar-cipher">Caesar cipher →</a></li></ul></nav>

                <div class="legal">
                        <a href="http://blog.jverkamp.com/feed/atom.xml">feed <img style="border: 0;" src="http://blog.jverkamp.com/rss.png" /></a><br />
                        All posts unless otherwise mentioned are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
                        Any source code unless otherwise mentioned is licensed under the <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
                </div>
        </footer>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53688146-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>