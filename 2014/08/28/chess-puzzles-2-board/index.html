<!DOCTYPE html>
<html onclick >
<head>
    <title>Chess Puzzles 2: Board? – jverkamp.com</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8"><link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="//blog.jverkamp.com/feed/">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css" integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" />

<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel="stylesheet">

<link rel="stylesheet" href="/custom.css" defer />

    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
</head>
<body>
    <div id="wrapper"><header id="page-header" role="banner">
    <h1><a href="/">JP's Blog</a></h1>

    <ul id="page-header-links">
        <li>
            <a href="https://github.com/jpverkamp">GitHub</a> *
            <a href="https://www.flickr.com/photos/jpverkamp">Flickr</a> *
            <a href="/resume">Resume</a>
        </li>
        <li>
            <form action="//www.google.com/search" method="get" onsubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search" _lpchecked="1">
                <div class="form-group">
                    <input name="q" type="hidden">
                    <input name="qfront" type="text" class="form-control" placeholder="Search">
                    <button type="submit" class="btn btn-default" value="Search">Search</button>
                </div>
            </form>
        </li>
    </ul>

    <nav id="header-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation"><li><a href="https://blog.jverkamp.com/programming/">Programming</a></li><li><a href="https://blog.jverkamp.com/photography/">Photography</a></li><li><a href="https://blog.jverkamp.com/reviews/">Reviews</a></li><li><a href="https://blog.jverkamp.com/writing/">Writing</a></li><li><a href="https://blog.jverkamp.com/research/">Research</a></li><li class="subscription" data-subscription="rss"><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
        </ul>
    </nav>
</header>
<div id="page-content-wrapper">
            <div id="page-content"><article>
	<header>
		<h1 class="entry-title">Chess Puzzles 2: Board?</h1>

        <div class="entry-meta"><span class="entry-date">2014-08-28</span>
            </div>

        <div class="entry-taxonomies"><div class="entry-tags"><ul class="taxonomy-keys"><li>
            <a class="taxonomy-key" href="/programming/languages/">Languages</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/racket">Racket</a><a href="https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/" class="next-link"></a></li><li><a href="https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/scheme">Scheme</a><a href="https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/topics/">Topics</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/" class="previous-link"></a><a class="taxonomy-value" href="/programming/topics/chess">Chess</a><a href="https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/" class="next-link"></a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/series/">Series</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/" class="previous-link"></a><a class="taxonomy-value" href="/series/chess-puzzles">Chess Puzzles</a><a href="https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/" class="next-link"></a></li></ul>
        </li><li><a class="taxonomy-key" href="/programming">programming</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2014/08/24/sandbox-battle/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2014/09/03/removing-large-files-from-git-history/" class="next-link">Next</a></ul>
        </li><li><a class="taxonomy-key" href="/">All Posts</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2014/08/24/sandbox-battle/" class="previous-link">Prev</a>
                <a href="https://blog.jverkamp.com/2014/09/03/removing-large-files-from-git-history/" class="next-link">Next</a></ul>
        </li></ul>
</div>
</div>
    </header>

	<div class="entry-content"><p>Now that we&rsquo;ve got <a href="https://blog.jverkamp.com/2013/05/21/ludum-dare-26-vtanks-results/">Ludum Dare</a> out of the way, back to chess! <a href="https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/">Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p>

<ul>
<li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li>
<li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup></li>
<li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href="https://en.wikipedia.org/wiki/fairy%20chess">fairy chess</a> pieces)</li>
</ul>

<p>I think that&rsquo;s about enough for the moment. Let&rsquo;s do it!</p>

<p>First things first, let&rsquo;s create a representation of the board. We&rsquo;ll start with only regular grids, although theoretically it should be possible to define arbitrary connections. That would mess somewhat with the move definitions we have, so let&rsquo;s not.</p>

<p>First, the board:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Stored as a vector of vectors where every element is either:</span>
<span style="color:#75715e">; (player, piece) if there is a piece there</span>
<span style="color:#75715e">; #f if empty</span>
(struct board (pieces data) <span style="color:#f92672">#</span>:transparent)</code></pre></div>
<p>So what we should have is something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(make-standard-board)
  (board (hash <span style="color:#e6db74">&#39;Rook</span>   Rook
               <span style="color:#e6db74">&#39;Knight</span> Knight
               <span style="color:#e6db74">&#39;Bishop</span> Bishop
               <span style="color:#e6db74">&#39;Queen</span>  Queen
               <span style="color:#e6db74">&#39;King</span>   King
               <span style="color:#e6db74">&#39;Pawn</span>   Pawn)
         <span style="color:#f92672">&#39;#</span>(<span style="color:#f92672">#</span>((Black Rook) (Black Knight) (Black Bishop) (Black Queen)
              (Black King) (Black Bishop) (Black Knight) (Black Rook))
            <span style="color:#f92672">#</span>((Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn)
              (Black Pawn) (Black Pawn) (Black Pawn) (Black Pawn))
            <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
            <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
            <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
            <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
            <span style="color:#f92672">#</span>((White Pawn) (White Pawn) (White Pawn) (White Pawn)
              (White Pawn) (White Pawn) (White Pawn) (White Pawn))
            <span style="color:#f92672">#</span>((White Rook) (White Knight) (White Bishop) (White Queen)
              (White King) (White Bishop) (White Knight) (White Rook)))))</code></pre></div>
<p>Vectors will allow both <code>O(1)</code> reading of elements, but also a nice way of doing mutation. I&rsquo;m just going to go right out now and say that I&rsquo;ll allow mutating the board, although I might make a non-mutable version that copies if I have a chance<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup>.</p>

<p>Next, a getter and a sanity check (which should make it cleaner to generate moves):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Test if a point is on the given board</span>
(<span style="color:#66d9ef">define </span>(on-board? b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (<span style="color:#66d9ef">and </span>(&lt;= <span style="color:#ae81ff">0</span> x (- (vector-length (vector-ref data <span style="color:#ae81ff">0</span>)) <span style="color:#ae81ff">1</span>))
       (&lt;= <span style="color:#ae81ff">0</span> y (- (vector-length data) <span style="color:#ae81ff">1</span>))))

<span style="color:#75715e">; Get the current player/piece at a square</span>
(<span style="color:#66d9ef">define </span>(board-ref b p)
  (match-define (board pieces data) b)
  (match-define (pt x y) p)
  (cond
    [(on-board? b p)
     (vector-ref (vector-ref data y) x)]
    [else
     <span style="color:#66d9ef">#f</span>]))</code></pre></div>
<p>And finally, a setter. In this case, it doesn&rsquo;t make sense to just set a single piece (except in set up I guess?)<sup class="footnote-ref" id="fnref:3"><a href="#fn:3">3</a></sup>. So instead, we will allow movement, overwriting whatever is at the target square:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Move a piece from one square to another, overwriting whatever is in the destination square</span>
(<span style="color:#66d9ef">define </span>(board-move! b src dst)
  (match-define (board pieces data) b)
  (match-define (pt src-x src-y) src)
  (match-define (pt dst-x dst-y) dst)
  (<span style="color:#66d9ef">define </span>piece (board-ref data src))
  (vector-set! (vector-ref data dst-y) dst-x piece)
  (vector-set! (vector-ref data src-y) src-x <span style="color:#66d9ef">#f</span>))</code></pre></div>
<p>And that&rsquo;s about all we need for the board representation. Let&rsquo;s check out rendering next, since it should (theoretically) make debugging the move list generation much better.</p>

<p>First, let&rsquo;s generalize the tile for a piece to a <code>glyph</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; The hash associating piece names with glyphs</span>
(<span style="color:#66d9ef">define </span>current-glyphs (make-parameter <span style="color:#66d9ef">#f</span>))

<span style="color:#75715e">; A single glyph containing a string and the rotation (default to upright)</span>
(struct glyph (character rotation) <span style="color:#f92672">#</span>:transparent)
(<span style="color:#66d9ef">define </span>(make-glyph character [rotation <span style="color:#ae81ff">0</span>])
  (glyph (~a character) rotation))

<span style="color:#75715e">; Render a single character with some sanity checking for different types</span>
(<span style="color:#66d9ef">define </span>(render-glyph/pict g tile-size)
  (cond
    [(glyph? g)
     (match-define (glyph character rotation) g)
     (rotate (text character <span style="color:#e6db74">&#39;default</span> (* <span style="color:#ae81ff">3</span>/4 tile-size)) rotation)]
    [else
     (render-glyph/pict (make-glyph g) tile-size)]))</code></pre></div>
<p>This way, we can specify characters in several different ways. We can pass just about anything directly and use the <code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code>
 function to &lsquo;string&rsquo; it. Or we can pass both the former and a rotation. That will let us do things like an inverted knight being the representation for the nightrider, etc.</p>

<p>One thing that amuses me entirely too much about this?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(set-standard-glyphs)
  (current-glyphs (hash <span style="color:#e6db74">&#39;Rook</span>   <span style="color:#e6db74">&#34;♜&#34;</span>
                        <span style="color:#e6db74">&#39;Knight</span> <span style="color:#e6db74">&#34;♞&#34;</span>
                        <span style="color:#e6db74">&#39;Bishop</span> <span style="color:#e6db74">&#34;♝&#34;</span>
                        <span style="color:#e6db74">&#39;Queen</span>  <span style="color:#e6db74">&#34;♛&#34;</span>
                        <span style="color:#e6db74">&#39;King</span>   <span style="color:#e6db74">&#34;♚&#34;</span>
                        <span style="color:#e6db74">&#39;Pawn</span>   <span style="color:#e6db74">&#34;♟&#34;</span>)))</code></pre></div>
<p>Those are unicode characters for the chess symbols. Nice. 😄</p>

<p>Okay, so we have a way to represent a single tile, what do we have to do to render all of them? Well, as often before, we can use the <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code>
 library:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Render a board to a pict with the given tile size</span>
(<span style="color:#66d9ef">define </span>(render/pict b <span style="color:#f92672">#</span>:tile-size [tile-size <span style="color:#ae81ff">20</span>])
  <span style="color:#75715e">; Sanity check and unpack, we don&#39;t care about the actual pieces at this point</span>
  (when (not (current-glyphs))
    (error <span style="color:#e6db74">&#39;render/pict</span> <span style="color:#e6db74">&#34;must specify (current-glyphs) as a hash of name -&gt; glyph&#34;</span>))
  (match-define (board _ board-data) b)

  <span style="color:#75715e">; Render each tile into a list of lists</span>
  (<span style="color:#66d9ef">define </span>tiles
    (for/list ([row-index (in-naturals)]
               [row       (in-vector board-data)])
      (for/list ([col-index (in-naturals)]
                 [col       (in-vector row)])
        <span style="color:#75715e">; Get the background tile</span>
        <span style="color:#75715e">; TODO: Parameterize the tile colors</span>
        <span style="color:#75715e">; TODO: Figure out how to do borders</span>
        (<span style="color:#66d9ef">define </span>tile-color
          (cond
            [(even? (+ row-index col-index))
             <span style="color:#e6db74">&#34;LightGray&#34;</span>]
            [else
             <span style="color:#e6db74">&#34;DarkGray&#34;</span>]))
        (<span style="color:#66d9ef">define </span>tile (colorize (filled-rectangle <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">20</span>) tile-color))

        (cond
          <span style="color:#75715e">; If there is a piece here, render the piece, colorize based on the player,</span>
          <span style="color:#75715e">; and overlay on the tile</span>
          [col
           (match-define (list player piece) col)
           (<span style="color:#66d9ef">define </span>glyph
             (render-glyph/pict (hash-ref (current-glyphs) piece) tile-size))
           (cc-superimpose tile (colorize glyph (~a player)))]
          <span style="color:#75715e">; If not, just return the empty tile</span>
          [else
           tile]))))

  <span style="color:#75715e">; Smash together all the lists of lists</span>
  (apply vc-append
         (for/list ([row (in-list tiles)])
           (apply hc-append row))))</code></pre></div>
<p>Okay, that looks like a lot, but most of it is comments. Basically, we loop over the board (the pair of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/list">for/list</a></code>
), building nested lists. Then, for each tile, we determine if we&rsquo;re on a white or black square (light and dark gray so that the white and black actually stand out). After that, we get the string from the <code>glyph</code> and render it as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code>
. There&rsquo;s one thing I haven&rsquo;t done yet: support strings of multiple characters. Essentially, I would scale horizontally to make it be the correct width. Good enough for now though.</p>

<p>So how does it work? Well combine <code>make-standard-board</code> and <code>render/pict</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (render/pict (make-standard-board))</code></pre></div>
<figure>
    <img src="/embeds/2014/initial-board.png"/> 
</figure>


<p>Fair enough. But to visualize, what we really want is an ability to show off certain squares. So let&rsquo;s add a <code>#:highlight</code> keyword parameter of a hash of points to colors to color them specially. Something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Render a board to a pict with the given tile size</span>
(<span style="color:#66d9ef">define </span>(render/pict b <span style="color:#f92672">#</span>:tile-size [tile-size <span style="color:#ae81ff">20</span>] <span style="color:#f92672">#</span>:highlights [special-tiles (hash)])
  <span style="color:#f92672">...</span>

  <span style="color:#75715e">; Get the background tile</span>
  <span style="color:#75715e">; TODO: Parameterize the tile colors</span>
  <span style="color:#75715e">; TODO: Figure out how to do borders</span>
  (<span style="color:#66d9ef">define </span>tile-color
    (cond
      [(hash-ref special-tiles (pt col-index row-index) <span style="color:#66d9ef">#f</span>)
       <span style="color:#66d9ef">=&gt; </span>identity]
      [(even? (+ row-index col-index))
       <span style="color:#e6db74">&#34;LightGray&#34;</span>]
      [else
       <span style="color:#e6db74">&#34;DarkGray&#34;</span>]))

  <span style="color:#f92672">...</span>)</code></pre></div>
<p>This way, we can highlight any square we want:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (render/pict (make-standard-board)
               <span style="color:#f92672">#</span>:highlights (hash (pt <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>) <span style="color:#e6db74">&#34;green&#34;</span>
                                  (pt <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>) <span style="color:#e6db74">&#34;green&#34;</span>
                                  (pt <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span>) <span style="color:#e6db74">&#34;red&#34;</span>
                                  (pt <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span>) <span style="color:#e6db74">&#34;red&#34;</span>
                                  (pt <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>) <span style="color:#e6db74">&#34;red&#34;</span>
                                  (pt <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">4</span>) <span style="color:#e6db74">&#34;red&#34;</span>))</code></pre></div>
<figure>
    <img src="/embeds/2014/highlights.png"/> 
</figure>


<p>(Remember that indices are 0-based)</p>

<p>Shiny!</p>

<p>Okay, that&rsquo;s enough to test. Let&rsquo;s work on a function to determine moves. We want something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Return a list of moves that a piece can make on the given board given it&#39;s origin point</span>
(<span style="color:#66d9ef">define </span>(moves-from b origin <span style="color:#f92672">#</span>:initial [initial <span style="color:#66d9ef">#f</span>])
  <span style="color:#f92672">...</span>)</code></pre></div>
<p>We&rsquo;ll have a flag if the piece is on the initial turn, otherwise we pull everything out (like which player we&rsquo;re dealing with) from the piece on the board:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#f92672">...</span>
  (cond
    [(board-ref b origin)
     <span style="color:#66d9ef">=&gt; </span>(λ (ls)
          (match-define (list player name) ls)
          (match-define (piece _ moves) (hash-ref pieces name))

          <span style="color:#75715e">; White has inverse moves since they&#39;re moving &#39;up&#39;</span>
          <span style="color:#75715e">; TODO: Generalize to more players</span>
          <span style="color:#75715e">; TODO: This moves the wrong way if you have &#39;left only&#39; pieces</span>
          (<span style="color:#66d9ef">define </span>player-multiplier
            (<span style="color:#66d9ef">case </span>player
              [(BLACK Black black)  <span style="color:#ae81ff">1</span>]
              [(WHITE White white) <span style="color:#ae81ff">-1</span>]
              [<span style="color:#66d9ef">else </span>    <span style="color:#ae81ff">1</span>]))

  <span style="color:#f92672">...</span></code></pre></div>
<p>This is the case when we have a piece (if not, the location is <code>#f</code>). If we have that, we unpack the piece and then determine which player we have. For the black player, we&rsquo;re moving down on the board / up in the y-coordinate, so the numbers are correct. Otherwise, we&rsquo;ll multiply moves my negative one. This has the effect of reflecting the moves. Unfortunately, it&rsquo;s on both axes, but at least with any piece I&rsquo;ve seen, that doesn&rsquo;t actually matter.</p>

<p>Next, we&rsquo;re going to take the move sequences we generated last time and filter each one so that we only include the moves from that sequence that are viable. For that, we first need to find the <code>first-target</code>&ndash;the first piece that we would hit if moving along this path.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#f92672">...</span>
          (<span style="color:#66d9ef">define </span>move-sublists
           (for*/list ([move-seq (in-list moves)])
             (match-define (move-sequence tags original-offset*) move-seq)
             (<span style="color:#66d9ef">define </span>offset* (map (λ (offset) (pt* player-multiplier offset)) original-offset*))

             <span style="color:#75715e">; Find the first target</span>
             (<span style="color:#66d9ef">define </span>first-target
               (for/first ([i (in-naturals)]
                           [offset (in-list offset*)]
                           <span style="color:#f92672">#</span>:when (board-ref b (pt+ origin offset)))
                 (list i (board-ref b (pt+ origin offset)))))

             <span style="color:#75715e">; If the first target belongs to the owner, remove it (no self captures)</span>
             <span style="color:#75715e">; TODO: Add an option for self-captures</span>
             (<span style="color:#66d9ef">define </span>self-capture
               (<span style="color:#66d9ef">and </span>first-target
                    (eq? (first (second first-target)) player)))
             <span style="color:#f92672">...</span></code></pre></div>
<p>Another amusing option that I&rsquo;m sure there are fairy chess pieces that use: self-captures.</p>

<p>Next, we want to unfold those lists based on how we found the <code>first-target</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#f92672">...</span>
             (map (λ (offset) (pt+ origin offset))
                  (cond
                    <span style="color:#75715e">; Bail out if we&#39;re initial only but not on the initial move</span>
                    [(<span style="color:#66d9ef">and </span>(set-member? tags <span style="color:#e6db74">&#39;initial-only</span>) (not initial))
                     (list)]
                    <span style="color:#75715e">; If we&#39;re capturing only, can only move if we have a target</span>
                    <span style="color:#75715e">; and to that square</span>
                    [(set-member? tags <span style="color:#e6db74">&#39;capture-only</span>)
                     (<span style="color:#66d9ef">if </span>(<span style="color:#66d9ef">and </span>first-target (not self-capture))
                         (list (list-ref offset* (first first-target)))
                         (list))]
                    <span style="color:#75715e">; If we&#39;re not capturing, get everything up until the target</span>
                    <span style="color:#75715e">; (or everything if no target)</span>
                    [(set-member? tags <span style="color:#e6db74">&#39;non-capture</span>)
                     (<span style="color:#66d9ef">if </span>(<span style="color:#66d9ef">and </span>first-target (&gt; (first first-target) <span style="color:#ae81ff">0</span>))
                         (take offset* (- (first first-target) <span style="color:#ae81ff">1</span>))
                         offset*)]
                    <span style="color:#75715e">; If we&#39;re a locust, we have to check the space after the self</span>
                    <span style="color:#75715e">; target is empty</span>
                    [(set-member? tags <span style="color:#e6db74">&#39;as-locust</span>)
                     (cond
                       [(<span style="color:#66d9ef">and </span>first-target
                             (not self-capture)
                             (&gt; (length offset*) (+ (first first-target) <span style="color:#ae81ff">1</span>)))
                        (<span style="color:#66d9ef">define </span>next-target
                          (board-ref b (list-ref offset* (+ (first first-target) <span style="color:#ae81ff">1</span>))))
                        (<span style="color:#66d9ef">if </span>(not next-target)
                            (list (list-ref offset* (+ <span style="color:#ae81ff">1</span> (first first-target))))
                            (list))]
                       [else
                        (list)])]
                    <span style="color:#75715e">; If the target is an enemy, capture it and stop</span>
                    <span style="color:#75715e">; Otherwise, if the target is a piece but we own, don&#39;t land there</span>
                    [first-target
                     (<span style="color:#66d9ef">if </span>self-capture
                         (<span style="color:#66d9ef">if </span>(&gt; (first first-target) <span style="color:#ae81ff">0</span>)
                             (take offset* (first first-target))
                             (list))
                         (take offset* (+ (first first-target) <span style="color:#ae81ff">1</span>)))]
                    <span style="color:#75715e">; Otherwise, include the entire range</span>
                    [else
                     offset*]))))

          <span style="color:#f92672">...</span></code></pre></div>
<p>Oof. That&rsquo;s a lot of code. But luckily, each case is fairly straight forward. We remove non-initial moves (like for pawns), set the capturing / non-capturing conditions, or move like a locust (that have to jump to capture). And then finally, if the first thing is our own, just cut that off (this is where a self-capture tag would come in).</p>

<p>And then to finish it off:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#f92672">...</span>
          <span style="color:#75715e">; Stick all the lists together since we no longer care how they got there</span>
          <span style="color:#75715e">; And remove all moves that jump off of the board somehow</span>
          (filter (λ (p) (on-board? b p)) (apply append move-sublists)))]
    [else
     <span style="color:#f92672">&#39;</span>()]))</code></pre></div>
<p>Bam. We have moves. Let&rsquo;s try it out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme"><span style="color:#75715e">; Black pawn</span>
&gt; (moves-from (make-standard-board) (pt <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">#</span>:initial <span style="color:#66d9ef">#t</span>)
(list (pt <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>) (pt <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>))

<span style="color:#75715e">; White knight</span>
&gt; (moves-from (make-standard-board) (pt <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span>))
(list (pt <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">5</span>) (pt <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">5</span>))</code></pre></div>
<p>And using our highlighting code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#66d9ef">let* </span>([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">#</span>:initial <span style="color:#66d9ef">#t</span>)])
                        (values pt <span style="color:#e6db74">&#34;green&#34;</span>))])
    (render/pict board <span style="color:#f92672">#</span>:highlights highlight))</code></pre></div>
<figure>
    <img src="/embeds/2014/moves-pawn.png"/> 
</figure>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (<span style="color:#66d9ef">let* </span>([board (make-standard-board)]
         [highlights (for/hash ([pt (moves-from board (pt <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span>))])
                        (values pt <span style="color:#e6db74">&#34;green&#34;</span>))])
    (render/pict board <span style="color:#f92672">#</span>:highlights highlight))</code></pre></div>
<figure>
    <img src="/embeds/2014/moves-knight.png"/> 
</figure>


<p>Shiny!</p>

<p>Looks like it&rsquo;s working great. Let&rsquo;s generate images for all of the pieces:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">&gt; (for/list ([piece (in-list <span style="color:#f92672">&#39;</span>(Pawn Rook Knight Bishop Queen King))])
    (<span style="color:#66d9ef">define </span>test-board
      (board (hash <span style="color:#e6db74">&#39;Rook</span>   Rook
                   <span style="color:#e6db74">&#39;Knight</span> Knight
                   <span style="color:#e6db74">&#39;Bishop</span> Bishop
                   <span style="color:#e6db74">&#39;Queen</span>  Queen
                   <span style="color:#e6db74">&#39;King</span>   King
                   <span style="color:#e6db74">&#39;Pawn</span>   Pawn)
             <span style="color:#f92672">`#</span>(<span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (White Pawn) <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (White Pawn) <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (White Pawn) <span style="color:#66d9ef">#f</span> (Black Pawn) <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (White <span style="color:#f92672">,</span>piece) <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (Black Pawn))
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (Black Pawn) <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> (Black Pawn) <span style="color:#66d9ef">#f</span>)
                <span style="color:#f92672">#</span>(<span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span> <span style="color:#66d9ef">#f</span>))))

    (<span style="color:#66d9ef">define </span>highlights
      (for/hash ([pt (in-list (moves-from test-board (pt <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">4</span>)))])
        (values pt <span style="color:#e6db74">&#34;green&#34;</span>)))

    (render/pict test-board <span style="color:#f92672">#</span>:highlights highlights))</code></pre></div>
<p><figure>
    <img src="/embeds/2014/demo-pawn.png"/> 
</figure>

<figure>
    <img src="/embeds/2014/demo-rook.png"/> 
</figure>

<figure>
    <img src="/embeds/2014/demo-knight.png"/> 
</figure>

<figure>
    <img src="/embeds/2014/demo-bishop.png"/> 
</figure>

<figure>
    <img src="/embeds/2014/demo-queen.png"/> 
</figure>

<figure>
    <img src="/embeds/2014/demo-king.png"/> 
</figure>
</p>

<p>That is cool. I love it when something works like that!</p>

<p>(Note: Yes, the king can currently move into check. That&rsquo;s on the list of things to fix yet, along with castling and en passant.)</p>

<p>Here&rsquo;s actually a lesson too, until I generated those images for this post, I actually had a bug where I wasn&rsquo;t stopping after hitting an enemy piece. Good thing I checked otherwise who knows what would have happened?</p>

<p>And that&rsquo;s about it for today. We now have move lists, a board, and some rendering. Should be enough so that next time we can <em>actually</em> write up a chess puzzle. Third time&rsquo;s a charm, eh?</p>

<p>If you&rsquo;d like to see the entire code, it&rsquo;s on GitHub: <a href="https://github.com/jpverkamp/chess-puzzles">jpverkamp/chess-puzzles</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">I need to add an option for that 😄
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">Hey, it&rsquo;s the schemey thing to do
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:3">And I bet there are fairy chess variations with &lsquo;spawners&rsquo; or the like&hellip;
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
</ol>
</div></div>
<div class="entry-comments">
    <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = "jverkamp";
            var disqus_title = "Chess Puzzles 2: Board?";
            var disqus_url = "https:\/\/blog.jverkamp.com\/2014\/08\/28\/chess-puzzles-2-board\/";

             
            (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div></article></div>
        </div><footer id="page-footer" role="contentinfo">
    <nav id="footer-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation">
            <li><a href="/archive-by-date/">All posts: By Date</a></li>
            <li><a href="/archive-by-tag/">All posts: By Tag</a></li>

            <li>
                <a href="/atom.xml">
                    RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li><li>
                <a href="/programming/atom.xml">
                    RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li></ul>
    </nav>

    <div id="page-footer-content">
        <div class="legal">
            <p>
                All posts unless otherwise mentioned are licensed under
                <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">
                    <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png">
                </a>
            </p>

            <p>
                Any source code unless otherwise mentioned is licensed under the <a href="//directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
            </p>
        </div>
    </div>
</footer>
</div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js" integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js" integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin="anonymous"></script>

<script type="text/javascript" src="/custom.js" defer></script>
</body>
</html>
