<!doctype html><html><head><title>Chess Puzzles 2: Board? – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js integrity="sha256-MESIkqofkenEy1SU5cXlq8E7d3jed4blJWzcfSQkgTo=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="><link rel=stylesheet href=/main.min.9efa38cb8d96be1a2d31208e5279a2f48fd2a15f6bcc9173c7375c675225b767.css integrity="sha256-nvo4y42WvhotMSCOUnmi9I/SoV9rzJFzxzdcZ1Ilt2c="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Chess Puzzles 2: Board?</h1><div class=entry-meta><span class=entry-date>2014-08-28</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/chess>Chess</a><a href=https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/ class=previous-link></a><a class=taxonomy-value href=/series/chess-puzzles>Chess Puzzles</a><a href=https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/08/24/sandbox-battle/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/09/03/removing-large-files-from-git-history/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/08/24/sandbox-battle/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/09/03/removing-large-files-from-git-history/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Now that we&rsquo;ve got <a href=https://blog.jverkamp.com/2013/05/21/ludum-dare-26-vtanks-results/>Ludum Dare</a> out of the way, back to chess! <a href=https://blog.jverkamp.com/2014/08/21/chess-puzzles-1-get-moving/>Last time</a>, we defined all of the pieces, which is all well and good, but what we really need is a board. More specifically, we want something that can:</p><ul><li>Represent an 8x8 chess board, storing the location of pieces (including the owner of each)</li><li>Add logic for collisions, so that when moving a piece, you cannot move through others or capture allies<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>Add rendering code to display the current chess board (must be flexible enough to handle arbitrary glyphs for <a href=https://en.wikipedia.org/wiki/fairy%20chess>fairy chess</a> pieces)</li></ul><p>I think that&rsquo;s about enough for the moment. Let&rsquo;s do it!</p><p>First things first, let&rsquo;s create a representation of the board. We&rsquo;ll start with only regular grids, although theoretically it should be possible to define arbitrary connections. That would mess somewhat with the move definitions we have, so let&rsquo;s not.</p><p>First, the board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Stored as a vector of vectors where every element is either:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; (player, piece) if there is a piece there</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; #f if empty</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>struct</span> board (<span style=color:#a6e22e>pieces</span> data) <span style=color:#f92672>#</span>:transparent)
</span></span></code></pre></div><p>So what we should have is something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-standard-board</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>board</span> (<span style=color:#a6e22e>hash</span> <span style=color:#e6db74>&#39;Rook</span>   Rook
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;Knight</span> Knight
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;Bishop</span> Bishop
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;Queen</span>  Queen
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;King</span>   King
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;Pawn</span>   Pawn)
</span></span><span style=display:flex><span>         <span style=color:#f92672>&#39;#</span>(<span style=color:#f92672>#</span>((<span style=color:#a6e22e>Black</span> Rook) (<span style=color:#a6e22e>Black</span> Knight) (<span style=color:#a6e22e>Black</span> Bishop) (<span style=color:#a6e22e>Black</span> Queen)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>Black</span> King) (<span style=color:#a6e22e>Black</span> Bishop) (<span style=color:#a6e22e>Black</span> Knight) (<span style=color:#a6e22e>Black</span> Rook))
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>((<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn) (<span style=color:#a6e22e>Black</span> Pawn))
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>((<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn) (<span style=color:#a6e22e>White</span> Pawn))
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>((<span style=color:#a6e22e>White</span> Rook) (<span style=color:#a6e22e>White</span> Knight) (<span style=color:#a6e22e>White</span> Bishop) (<span style=color:#a6e22e>White</span> Queen)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>White</span> King) (<span style=color:#a6e22e>White</span> Bishop) (<span style=color:#a6e22e>White</span> Knight) (<span style=color:#a6e22e>White</span> Rook)))))
</span></span></code></pre></div><p>Vectors will allow both <code>O(1)</code> reading of elements, but also a nice way of doing mutation. I&rsquo;m just going to go right out now and say that I&rsquo;ll allow mutating the board, although I might make a non-mutable version that copies if I have a chance<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Next, a getter and a sanity check (which should make it cleaner to generate moves):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Test if a point is on the given board</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>on-board?</span> b p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>board</span> pieces data) b)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>pt</span> x y) p)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>and </span>(&lt;= <span style=color:#ae81ff>0</span> x (- (vector-length (vector-ref data <span style=color:#ae81ff>0</span>)) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>       (&lt;= <span style=color:#ae81ff>0</span> y (- (vector-length data) <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Get the current player/piece at a square</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>board-ref</span> b p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>board</span> pieces data) b)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>pt</span> x y) p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>on-board?</span> b p)
</span></span><span style=display:flex><span>     (vector-ref (vector-ref data y) x)]
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>#f</span>]))
</span></span></code></pre></div><p>And finally, a setter. In this case, it doesn&rsquo;t make sense to just set a single piece (except in set up I guess?)<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. So instead, we will allow movement, overwriting whatever is at the target square:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Move a piece from one square to another, overwriting whatever is in the destination square</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>board-move!</span> b src dst)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>board</span> pieces data) b)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>pt</span> src-x src-y) src)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>pt</span> dst-x dst-y) dst)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>piece (<span style=color:#a6e22e>board-ref</span> data src))
</span></span><span style=display:flex><span>  (vector-set! (vector-ref data dst-y) dst-x piece)
</span></span><span style=display:flex><span>  (vector-set! (vector-ref data src-y) src-x <span style=color:#66d9ef>#f</span>))
</span></span></code></pre></div><p>And that&rsquo;s about all we need for the board representation. Let&rsquo;s check out rendering next, since it should (theoretically) make debugging the move list generation much better.</p><p>First, let&rsquo;s generalize the tile for a piece to a <code>glyph</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; The hash associating piece names with glyphs</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>current-glyphs (<span style=color:#a6e22e>make-parameter</span> <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; A single glyph containing a string and the rotation (default to upright)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>struct</span> glyph (<span style=color:#a6e22e>character</span> rotation) <span style=color:#f92672>#</span>:transparent)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-glyph</span> character [rotation <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>glyph</span> (<span style=color:#a6e22e>~a</span> character) rotation))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Render a single character with some sanity checking for different types</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>render-glyph/pict</span> g tile-size)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>glyph?</span> g)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>glyph</span> character rotation) g)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>rotate</span> (<span style=color:#a6e22e>text</span> character <span style=color:#e6db74>&#39;default</span> (* <span style=color:#ae81ff>3</span>/4 tile-size)) rotation)]
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>render-glyph/pict</span> (<span style=color:#a6e22e>make-glyph</span> g) tile-size)]))
</span></span></code></pre></div><p>This way, we can specify characters in several different ways. We can pass just about anything directly and use the <code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code>
function to &lsquo;string&rsquo; it. Or we can pass both the former and a rotation. That will let us do things like an inverted knight being the representation for the nightrider, etc.</p><p>One thing that amuses me entirely too much about this?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>set-standard-glyphs</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>current-glyphs</span> (<span style=color:#a6e22e>hash</span> <span style=color:#e6db74>&#39;Rook</span>   <span style=color:#e6db74>&#34;♜&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;Knight</span> <span style=color:#e6db74>&#34;♞&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;Bishop</span> <span style=color:#e6db74>&#34;♝&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;Queen</span>  <span style=color:#e6db74>&#34;♛&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;King</span>   <span style=color:#e6db74>&#34;♚&#34;</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;Pawn</span>   <span style=color:#e6db74>&#34;♟&#34;</span>)))
</span></span></code></pre></div><p>Those are unicode characters for the chess symbols. Nice. 😄</p><p>Okay, so we have a way to represent a single tile, what do we have to do to render all of them? Well, as often before, we can use the <code><a href="http://docs.racket-lang.org/search/index.html?q=pict">pict</a></code>
library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Render a board to a pict with the given tile size</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>render/pict</span> b <span style=color:#f92672>#</span>:tile-size [tile-size <span style=color:#ae81ff>20</span>])
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Sanity check and unpack, we don&#39;t care about the actual pieces at this point</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>when</span> (not (<span style=color:#a6e22e>current-glyphs</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#39;render/pict</span> <span style=color:#e6db74>&#34;must specify (current-glyphs) as a hash of name -&gt; glyph&#34;</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>board</span> _ board-data) b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Render each tile into a list of lists</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>tiles
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for/list</span> ([row-index (<span style=color:#a6e22e>in-naturals</span>)]
</span></span><span style=display:flex><span>               [row       (<span style=color:#a6e22e>in-vector</span> board-data)])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for/list</span> ([col-index (<span style=color:#a6e22e>in-naturals</span>)]
</span></span><span style=display:flex><span>                 [col       (<span style=color:#a6e22e>in-vector</span> row)])
</span></span><span style=display:flex><span>        <span style=color:#75715e>; Get the background tile</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>; TODO: Parameterize the tile colors</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>; TODO: Figure out how to do borders</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>define </span>tile-color
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>            [(even? (+ row-index col-index))
</span></span><span style=display:flex><span>             <span style=color:#e6db74>&#34;LightGray&#34;</span>]
</span></span><span style=display:flex><span>            [else
</span></span><span style=display:flex><span>             <span style=color:#e6db74>&#34;DarkGray&#34;</span>]))
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>define </span>tile (<span style=color:#a6e22e>colorize</span> (<span style=color:#a6e22e>filled-rectangle</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>20</span>) tile-color))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; If there is a piece here, render the piece, colorize based on the player,</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; and overlay on the tile</span>
</span></span><span style=display:flex><span>          [col
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>match-define</span> (list player piece) col)
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>define </span>glyph
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>render-glyph/pict</span> (<span style=color:#a6e22e>hash-ref</span> (<span style=color:#a6e22e>current-glyphs</span>) piece) tile-size))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>cc-superimpose</span> tile (<span style=color:#a6e22e>colorize</span> glyph (<span style=color:#a6e22e>~a</span> player)))]
</span></span><span style=display:flex><span>          <span style=color:#75715e>; If not, just return the empty tile</span>
</span></span><span style=display:flex><span>          [else
</span></span><span style=display:flex><span>           tile]))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Smash together all the lists of lists</span>
</span></span><span style=display:flex><span>  (apply vc-append
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>for/list</span> ([row (<span style=color:#a6e22e>in-list</span> tiles)])
</span></span><span style=display:flex><span>           (apply hc-append row))))
</span></span></code></pre></div><p>Okay, that looks like a lot, but most of it is comments. Basically, we loop over the board (the pair of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/list">for/list</a></code>
), building nested lists. Then, for each tile, we determine if we&rsquo;re on a white or black square (light and dark gray so that the white and black actually stand out). After that, we get the string from the <code>glyph</code> and render it as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code>
. There&rsquo;s one thing I haven&rsquo;t done yet: support strings of multiple characters. Essentially, I would scale horizontally to make it be the correct width. Good enough for now though.</p><p>So how does it work? Well combine <code>make-standard-board</code> and <code>render/pict</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>render/pict</span> (<span style=color:#a6e22e>make-standard-board</span>))
</span></span></code></pre></div><figure><img src=/embeds/2014/initial-board.png></figure><p>Fair enough. But to visualize, what we really want is an ability to show off certain squares. So let&rsquo;s add a <code>#:highlight</code> keyword parameter of a hash of points to colors to color them specially. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Render a board to a pict with the given tile size</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>render/pict</span> b <span style=color:#f92672>#</span>:tile-size [tile-size <span style=color:#ae81ff>20</span>] <span style=color:#f92672>#</span>:highlights [special-tiles (<span style=color:#a6e22e>hash</span>)])
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Get the background tile</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; TODO: Parameterize the tile colors</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; TODO: Figure out how to do borders</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>tile-color
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>hash-ref</span> special-tiles (<span style=color:#a6e22e>pt</span> col-index row-index) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>=&gt; </span>identity]
</span></span><span style=display:flex><span>      [(even? (+ row-index col-index))
</span></span><span style=display:flex><span>       <span style=color:#e6db74>&#34;LightGray&#34;</span>]
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       <span style=color:#e6db74>&#34;DarkGray&#34;</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>This way, we can highlight any square we want:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>render/pict</span> (<span style=color:#a6e22e>make-standard-board</span>)
</span></span><span style=display:flex><span>               <span style=color:#f92672>#</span>:highlights (<span style=color:#a6e22e>hash</span> (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>) <span style=color:#e6db74>&#34;green&#34;</span>
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>2</span>) <span style=color:#e6db74>&#34;green&#34;</span>
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>4</span>) <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>5</span>) <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span>) <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>                                  (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>4</span>) <span style=color:#e6db74>&#34;red&#34;</span>))
</span></span></code></pre></div><figure><img src=/embeds/2014/highlights.png></figure><p>(Remember that indices are 0-based)</p><p>Shiny!</p><p>Okay, that&rsquo;s enough to test. Let&rsquo;s work on a function to determine moves. We want something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Return a list of moves that a piece can make on the given board given it&#39;s origin point</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>moves-from</span> b origin <span style=color:#f92672>#</span>:initial [initial <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>We&rsquo;ll have a flag if the piece is on the initial turn, otherwise we pull everything out (like which player we&rsquo;re dealing with) from the piece on the board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#a6e22e>board-ref</span> b origin)
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>=&gt; </span>(<span style=color:#960050;background-color:#1e0010>λ</span> (<span style=color:#a6e22e>ls</span>)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>match-define</span> (list player name) ls)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>piece</span> _ moves) (<span style=color:#a6e22e>hash-ref</span> pieces name))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; White has inverse moves since they&#39;re moving &#39;up&#39;</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; TODO: Generalize to more players</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; TODO: This moves the wrong way if you have &#39;left only&#39; pieces</span>
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>player-multiplier
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>case </span>player
</span></span><span style=display:flex><span>              [(<span style=color:#a6e22e>BLACK</span> Black black)  <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>              [(<span style=color:#a6e22e>WHITE</span> White white) <span style=color:#ae81ff>-1</span>]
</span></span><span style=display:flex><span>              [<span style=color:#66d9ef>else </span>    <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>This is the case when we have a piece (if not, the location is <code>#f</code>). If we have that, we unpack the piece and then determine which player we have. For the black player, we&rsquo;re moving down on the board / up in the y-coordinate, so the numbers are correct. Otherwise, we&rsquo;ll multiply moves my negative one. This has the effect of reflecting the moves. Unfortunately, it&rsquo;s on both axes, but at least with any piece I&rsquo;ve seen, that doesn&rsquo;t actually matter.</p><p>Next, we&rsquo;re going to take the move sequences we generated last time and filter each one so that we only include the moves from that sequence that are viable. For that, we first need to find the <code>first-target</code>&ndash;the first piece that we would hit if moving along this path.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define </span>move-sublists
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>for*/list</span> ([move-seq (<span style=color:#a6e22e>in-list</span> moves)])
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>match-define</span> (<span style=color:#a6e22e>move-sequence</span> tags original-offset*) move-seq)
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>define </span>offset* (map (<span style=color:#960050;background-color:#1e0010>λ</span> (<span style=color:#a6e22e>offset</span>) (<span style=color:#a6e22e>pt*</span> player-multiplier offset)) original-offset*))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; Find the first target</span>
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>define </span>first-target
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>for/first</span> ([i (<span style=color:#a6e22e>in-naturals</span>)]
</span></span><span style=display:flex><span>                           [offset (<span style=color:#a6e22e>in-list</span> offset*)]
</span></span><span style=display:flex><span>                           <span style=color:#f92672>#</span>:when (<span style=color:#a6e22e>board-ref</span> b (<span style=color:#a6e22e>pt+</span> origin offset)))
</span></span><span style=display:flex><span>                 (list i (<span style=color:#a6e22e>board-ref</span> b (<span style=color:#a6e22e>pt+</span> origin offset)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; If the first target belongs to the owner, remove it (no self captures)</span>
</span></span><span style=display:flex><span>             <span style=color:#75715e>; TODO: Add an option for self-captures</span>
</span></span><span style=display:flex><span>             (<span style=color:#66d9ef>define </span>self-capture
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>and </span>first-target
</span></span><span style=display:flex><span>                    (eq? (<span style=color:#a6e22e>first</span> (<span style=color:#a6e22e>second</span> first-target)) player)))
</span></span><span style=display:flex><span>             <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Another amusing option that I&rsquo;m sure there are fairy chess pieces that use: self-captures.</p><p>Next, we want to unfold those lists based on how we found the <code>first-target</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>             (map (<span style=color:#960050;background-color:#1e0010>λ</span> (<span style=color:#a6e22e>offset</span>) (<span style=color:#a6e22e>pt+</span> origin offset))
</span></span><span style=display:flex><span>                  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; Bail out if we&#39;re initial only but not on the initial move</span>
</span></span><span style=display:flex><span>                    [(<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>set-member?</span> tags <span style=color:#e6db74>&#39;initial-only</span>) (not initial))
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>list</span>)]
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; If we&#39;re capturing only, can only move if we have a target</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; and to that square</span>
</span></span><span style=display:flex><span>                    [(<span style=color:#a6e22e>set-member?</span> tags <span style=color:#e6db74>&#39;capture-only</span>)
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>first-target (not self-capture))
</span></span><span style=display:flex><span>                         (list (list-ref offset* (<span style=color:#a6e22e>first</span> first-target)))
</span></span><span style=display:flex><span>                         (<span style=color:#a6e22e>list</span>))]
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; If we&#39;re not capturing, get everything up until the target</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; (or everything if no target)</span>
</span></span><span style=display:flex><span>                    [(<span style=color:#a6e22e>set-member?</span> tags <span style=color:#e6db74>&#39;non-capture</span>)
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>first-target (&gt; (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                         (<span style=color:#a6e22e>take</span> offset* (- (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                         offset*)]
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; If we&#39;re a locust, we have to check the space after the self</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; target is empty</span>
</span></span><span style=display:flex><span>                    [(<span style=color:#a6e22e>set-member?</span> tags <span style=color:#e6db74>&#39;as-locust</span>)
</span></span><span style=display:flex><span>                     (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>                       [(<span style=color:#66d9ef>and </span>first-target
</span></span><span style=display:flex><span>                             (not self-capture)
</span></span><span style=display:flex><span>                             (&gt; (length offset*) (+ (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>define </span>next-target
</span></span><span style=display:flex><span>                          (<span style=color:#a6e22e>board-ref</span> b (list-ref offset* (+ (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>                        (<span style=color:#66d9ef>if </span>(not next-target)
</span></span><span style=display:flex><span>                            (list (list-ref offset* (+ <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>first</span> first-target))))
</span></span><span style=display:flex><span>                            (<span style=color:#a6e22e>list</span>))]
</span></span><span style=display:flex><span>                       [else
</span></span><span style=display:flex><span>                        (<span style=color:#a6e22e>list</span>)])]
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; If the target is an enemy, capture it and stop</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; Otherwise, if the target is a piece but we own, don&#39;t land there</span>
</span></span><span style=display:flex><span>                    [first-target
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>if </span>self-capture
</span></span><span style=display:flex><span>                         (<span style=color:#66d9ef>if </span>(&gt; (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                             (<span style=color:#a6e22e>take</span> offset* (<span style=color:#a6e22e>first</span> first-target))
</span></span><span style=display:flex><span>                             (<span style=color:#a6e22e>list</span>))
</span></span><span style=display:flex><span>                         (<span style=color:#a6e22e>take</span> offset* (+ (<span style=color:#a6e22e>first</span> first-target) <span style=color:#ae81ff>1</span>)))]
</span></span><span style=display:flex><span>                    <span style=color:#75715e>; Otherwise, include the entire range</span>
</span></span><span style=display:flex><span>                    [else
</span></span><span style=display:flex><span>                     offset*]))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Oof. That&rsquo;s a lot of code. But luckily, each case is fairly straight forward. We remove non-initial moves (like for pawns), set the capturing / non-capturing conditions, or move like a locust (that have to jump to capture). And then finally, if the first thing is our own, just cut that off (this is where a self-capture tag would come in).</p><p>And then to finish it off:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; Stick all the lists together since we no longer care how they got there</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; And remove all moves that jump off of the board somehow</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>filter</span> (<span style=color:#960050;background-color:#1e0010>λ</span> (<span style=color:#a6e22e>p</span>) (<span style=color:#a6e22e>on-board?</span> b p)) (apply append move-sublists)))]
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     <span style=color:#f92672>&#39;</span>()]))
</span></span></code></pre></div><p>Bam. We have moves. Let&rsquo;s try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Black pawn</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>moves-from</span> (<span style=color:#a6e22e>make-standard-board</span>) (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>#</span>:initial <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>(list (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>) (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; White knight</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>moves-from</span> (<span style=color:#a6e22e>make-standard-board</span>) (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span>))
</span></span><span style=display:flex><span>(list (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>5</span>) (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>5</span>))
</span></span></code></pre></div><p>And using our highlighting code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#66d9ef>let* </span>([board (<span style=color:#a6e22e>make-standard-board</span>)]
</span></span><span style=display:flex><span>         [highlights (<span style=color:#a6e22e>for/hash</span> ([pt (<span style=color:#a6e22e>moves-from</span> board (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>#</span>:initial <span style=color:#66d9ef>#t</span>)])
</span></span><span style=display:flex><span>                        (values pt <span style=color:#e6db74>&#34;green&#34;</span>))])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>render/pict</span> board <span style=color:#f92672>#</span>:highlights highlight))
</span></span></code></pre></div><figure><img src=/embeds/2014/moves-pawn.png></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#66d9ef>let* </span>([board (<span style=color:#a6e22e>make-standard-board</span>)]
</span></span><span style=display:flex><span>         [highlights (<span style=color:#a6e22e>for/hash</span> ([pt (<span style=color:#a6e22e>moves-from</span> board (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span>))])
</span></span><span style=display:flex><span>                        (values pt <span style=color:#e6db74>&#34;green&#34;</span>))])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>render/pict</span> board <span style=color:#f92672>#</span>:highlights highlight))
</span></span></code></pre></div><figure><img src=/embeds/2014/moves-knight.png></figure><p>Shiny!</p><p>Looks like it&rsquo;s working great. Let&rsquo;s generate images for all of the pieces:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>for/list</span> ([piece (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(Pawn Rook Knight Bishop Queen King))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>test-board
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>board</span> (<span style=color:#a6e22e>hash</span> <span style=color:#e6db74>&#39;Rook</span>   Rook
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;Knight</span> Knight
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;Bishop</span> Bishop
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;Queen</span>  Queen
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;King</span>   King
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;Pawn</span>   Pawn)
</span></span><span style=display:flex><span>             <span style=color:#f92672>`#</span>(<span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>White</span> Pawn) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>White</span> Pawn) <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>White</span> Pawn) <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>Black</span> Pawn) <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>White</span> <span style=color:#f92672>,</span>piece) <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>Black</span> Pawn))
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>Black</span> Pawn) <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> (<span style=color:#a6e22e>Black</span> Pawn) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define </span>highlights
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for/hash</span> ([pt (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>moves-from</span> test-board (<span style=color:#a6e22e>pt</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>4</span>)))])
</span></span><span style=display:flex><span>        (values pt <span style=color:#e6db74>&#34;green&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>render/pict</span> test-board <span style=color:#f92672>#</span>:highlights highlights))
</span></span></code></pre></div><p><figure><img src=/embeds/2014/demo-pawn.png></figure><figure><img src=/embeds/2014/demo-rook.png></figure><figure><img src=/embeds/2014/demo-knight.png></figure><figure><img src=/embeds/2014/demo-bishop.png></figure><figure><img src=/embeds/2014/demo-queen.png></figure><figure><img src=/embeds/2014/demo-king.png></figure></p><p>That is cool. I love it when something works like that!</p><p>(Note: Yes, the king can currently move into check. That&rsquo;s on the list of things to fix yet, along with castling and en passant.)</p><p>Here&rsquo;s actually a lesson too, until I generated those images for this post, I actually had a bug where I wasn&rsquo;t stopping after hitting an enemy piece. Good thing I checked otherwise who knows what would have happened?</p><p>And that&rsquo;s about it for today. We now have move lists, a board, and some rendering. Should be enough so that next time we can <em>actually</em> write up a chess puzzle. Third time&rsquo;s a charm, eh?</p><p>If you&rsquo;d like to see the entire code, it&rsquo;s on GitHub: <a href=https://github.com/jpverkamp/chess-puzzles>jpverkamp/chess-puzzles</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I need to add an option for that 😄&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Hey, it&rsquo;s the schemey thing to do&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>And I bet there are fairy chess variations with &lsquo;spawners&rsquo; or the like&mldr;&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>