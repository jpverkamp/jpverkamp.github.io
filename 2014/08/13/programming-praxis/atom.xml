<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming Praxis on jverkamp.com</title><link>https://blog.jverkamp.com/2014/08/13/programming-praxis/</link><description>Recent content in Programming Praxis on jverkamp.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 13 Aug 2014 17:00:55 +0000</lastBuildDate><atom:link href="https://blog.jverkamp.com/2014/08/13/programming-praxis/atom.xml" rel="self" type="application/rss+xml"/><item><title>Minimal palindromic base</title><link>https://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/</link><pubDate>Wed, 13 Aug 2014 17:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2014/08/13/minimal-palindromic-base/</guid><description>&lt;p>What&amp;rsquo;s this? Two posts in one day? Well, &lt;a href="https://blog.jverkamp.com/2014/08/08/onwards-and-upwards/">writing a static blog generator&lt;/a> can do that. &amp;#x1f604;&lt;/p>
&lt;p>Another easily phrased challenge:&lt;/p>
&lt;blockquote>
&lt;p>We have a simple little problem today: Given an integer n &amp;gt; 2, find the minimum b &amp;gt; 1 for which n base b is a palindrome.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&amp;ndash; &lt;a href="http://programmingpraxis.com/2014/08/05/minimal-palindromic-base/">Minimal Palindromic Base&lt;/a> via Programming Praxis&lt;/p>&lt;/blockquote></description></item><item><title>Number words</title><link>https://blog.jverkamp.com/2014/08/13/number-words/</link><pubDate>Wed, 13 Aug 2014 14:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2014/08/13/number-words/</guid><description>&lt;p>Today&amp;rsquo;s five minute post brought to you via &lt;a href="http://programmingpraxis.com/2014/07/25/number-words/">Programming Praxis&lt;/a> / &lt;a href="http://www.careercup.com/question?id=5120347909128192">Career Cup&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Given a positive integer, return all the ways that the integer can be represented by letters using the mapping 1 -&amp;gt; A, 2 -&amp;gt; B, …, 26 -&amp;gt; Z. For instance, the number 1234 can be represented by the words ABCD, AWD and LCD.&lt;/p>&lt;/blockquote></description></item><item><title>Call stack bracket matcher</title><link>https://blog.jverkamp.com/2014/06/11/call-stack-bracket-matcher/</link><pubDate>Wed, 11 Jun 2014 14:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2014/06/11/call-stack-bracket-matcher/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2014/06/10/balanced-delimiters-2/">Five minute post&lt;/a> from Programming Praxis:&lt;/p>
&lt;blockquote>
&lt;p>Write a function to return true/false after looking at a string. Examples of strings that pass:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;code>{}, [], (), a(b)c, abc[d], a(b)c{d[e]}&lt;/code>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Examples of strings that don’t pass:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;code>{], (], a(b]c, abc[d}, a(b)c{d[e}]&lt;/code>&lt;/p>&lt;/blockquote></description></item><item><title>Caesar cipher</title><link>https://blog.jverkamp.com/2014/03/12/caesar-cipher/</link><pubDate>Wed, 12 Mar 2014 14:00:10 +0000</pubDate><guid>https://blog.jverkamp.com/2014/03/12/caesar-cipher/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2014/03/11/caesar-cipher/">Here&amp;rsquo;s&lt;/a> a 5 minute&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> coding challenge from Programming Praxis:&lt;/p>
&lt;blockquote>
&lt;p>A &lt;a href="https://en.wikipedia.org/wiki/Caesar%20cipher">caeser cipher&lt;/a>, named after Julius Caesar, who either invented the cipher or was an early user of it, is a simple substitution cipher in which letters are substituted at a fixed distance along the alphabet, which cycles; children’s magic decoder rings implement a caesar cipher. Non-alphabetic characters are passed unchanged. For instance, the plaintext PROGRAMMINGPRAXIS is rendered as the ciphertext SURJUDPPLQJSUDALV with a shift of 3 positions.&lt;/p>&lt;/blockquote>
&lt;p>&lt;figure>&lt;img src="https://blog.jverkamp.com/embeds/2014/caesar-shift.png">
&lt;/figure>

&amp;ndash; Source: &lt;a href="https://en.wikipedia.org/wiki/File:Caesar%20cipher%20left%20shift%20of%203.svg">Wikipedia&lt;/a>, public domain&lt;/p></description></item><item><title>Smallest consecutive four-factor composites</title><link>https://blog.jverkamp.com/2013/09/19/smallest-consecutive-four-factor-composites/</link><pubDate>Thu, 19 Sep 2013 14:00:23 +0000</pubDate><guid>https://blog.jverkamp.com/2013/09/19/smallest-consecutive-four-factor-composites/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2013/09/17/smallest-consecutive-four-factor-composites/">Another post&lt;/a> from Programming Praxis, from this past Tuesday:&lt;/p>
&lt;blockquote>
&lt;p>The smallest pair of consecutive natural numbers that each have two distinct prime factors are 14 = 2 * 7 and 15 = 3 * 5. The smallest triplet of consecutive natural numbers that each have three distinct prime factors are 644 = 2^2 * 7 * 23, 645 = 3 * 5 * 43 and 646 = 2 * 17 * 19. What is the smallest set of four consecutive natural numbers that each have four distinct prime factors?&lt;/p>&lt;/blockquote></description></item><item><title>Visualizing the Monkey Grid</title><link>https://blog.jverkamp.com/2013/08/30/visualizing-the-monkey-grid/</link><pubDate>Fri, 30 Aug 2013 14:00:37 +0000</pubDate><guid>https://blog.jverkamp.com/2013/08/30/visualizing-the-monkey-grid/</guid><description>&lt;p>I&amp;rsquo;m a bit behind the times, but &lt;a href="http://programmingpraxis.com/2013/08/16/monkey-grid-puzzle/">this post&lt;/a> from Programming Praxis intrigued me enough that I kept it in my todo list for rather a while. So let&amp;rsquo;s get around to it.&lt;/p>
&lt;p>I&amp;rsquo;ll just copy the description straight from the Programming Praxis website (although there are at least two previous version:&lt;a href="http://stackoverflow.com/questions/9762953/planar-grid-puzzle">[1]&lt;/a>&lt;a href="http://stackoverflow.com/questions/18133918/improve-the-solution-to-monkey-grid-puzzle">[2]&lt;/a>):&lt;/p>
&lt;blockquote>
&lt;p>There is a monkey which can walk around on a planar grid. The monkey can move one space at a time left, right, up or down. That is, from (x, y) the monkey can go to (x+1, y), (x-1, y), (x, y+1), and (x, y-1). Points where the sum of the digits of the absolute value of the x coordinate plus the sum of the digits of the absolute value of the y coordinate are lesser than or equal to 19 are accessible to the monkey. For example, the point (59, 79) is inaccessible because 5 + 9 + 7 + 9 = 30, which is greater than 19. Another example: the point (-5, -7) is accessible because abs(-5) + abs(-7) = 5 + 7 = 12, which is less than 19. How many points can the monkey access if it starts at (0, 0), including (0, 0) itself?&lt;/p>&lt;/blockquote></description></item><item><title>Swap list nodes</title><link>https://blog.jverkamp.com/2013/06/26/swap-list-nodes/</link><pubDate>Wed, 26 Jun 2013 14:00:42 +0000</pubDate><guid>https://blog.jverkamp.com/2013/06/26/swap-list-nodes/</guid><description>&lt;p>It&amp;rsquo;s been rather a while since I&amp;rsquo;ve worked out a &lt;a title="Programming Praxis" href="http://programmingpraxis.com/">Programming Praxis&lt;/a> problem, but they posted a &lt;a title="Swap list nodes" href="http://programmingpraxis.com/2013/06/25/swap-list-nodes/">new one yesterday&lt;/a>, so now seems as good a time as any. The problem is relatively simple:&lt;/p>
&lt;blockquote>
&lt;p>Given a linked list, swap the kth node from the head of the list with the kth node from the end of the list.&lt;/p>&lt;/blockquote>
&lt;p>Since all lists in Scheme are linked lists, that part seems easy enough. To make the problem a little more interesting however, I&amp;rsquo;m going to work it out in a purely functional manner: no mutation.&lt;/p></description></item><item><title>Cyclic equality</title><link>https://blog.jverkamp.com/2013/04/09/cyclic-equality/</link><pubDate>Tue, 09 Apr 2013 14:00:15 +0000</pubDate><guid>https://blog.jverkamp.com/2013/04/09/cyclic-equality/</guid><description>&lt;p>In &lt;a title="Cyclic equality on Programming Praxis" href="http://programmingpraxis.com/2013/04/09/cyclic-equality/">today&amp;rsquo;s post&lt;/a> from Programming Praxis, the goal is to check if two cyclic lists are equal. So if you have the cycles &lt;code>↻(1 2 3 4 5)&lt;/code> and &lt;code>↻(3 4 5 1 2)&lt;/code>, they&amp;rsquo;re equal. Likewise, &lt;code>↻(1 2 2 1)&lt;/code> and &lt;code>↻(2 1 1 2)&lt;/code> are equal. But &lt;code>↻(1 2 3 4)&lt;/code> and &lt;code>↻(1 2 3 5)&lt;/code> are not since they have different elements while &lt;code>↻(1 1 1)&lt;/code> and &lt;code>↻(1 1 1 1)&lt;/code> aren&amp;rsquo;t since they have different elements.&lt;/p></description></item><item><title>Approximating Pi with Buffon's Needle</title><link>https://blog.jverkamp.com/2013/03/18/approximating-pi-with-buffons-needle/</link><pubDate>Mon, 18 Mar 2013 14:00:14 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/18/approximating-pi-with-buffons-needle/</guid><description>&lt;p>I&amp;rsquo;m a bit late for Pi Day, but Programming Praxis had &lt;a href="http://programmingpraxis.com/2013/03/15/buffons-needle/" title="Buffon's Needle">a neat problem on Friday&lt;/a> that I wanted to check out:&lt;/p>
&lt;blockquote>
&lt;p>Suppose we have a floor made of parallel strips of wood, each the same width, and we drop a needle onto the floor. What is the probability that the needle will lie across a line between two strips?&lt;/p>&lt;/blockquote></description></item><item><title>Knight moves</title><link>https://blog.jverkamp.com/2013/03/11/knight-moves/</link><pubDate>Mon, 11 Mar 2013 22:00:20 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/11/knight-moves/</guid><description>&lt;p>How many ways are there for a knight in chess from the top left to the bottom right of a chess board in exactly &lt;em>n=6&lt;/em> moves?&lt;/p></description></item><item><title>Partitioning the Dutch national flag</title><link>https://blog.jverkamp.com/2013/03/06/partitioning-the-dutch-national-flag/</link><pubDate>Wed, 06 Mar 2013 14:00:08 +0000</pubDate><guid>https://blog.jverkamp.com/2013/03/06/partitioning-the-dutch-national-flag/</guid><description>&lt;p>&lt;a title="Dutch National Flag" href="http://programmingpraxis.com/2013/03/05/dutch-national-flag/">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis asks us to solve a problem known as the Dutch National Flag problem (attributed to &lt;a href="https://en.wikipedia.org/wiki/Edsgar%20Dijkstra">Edsgar Dijkstra&lt;/a>): &lt;em>sort an array of red, white and blue symbols so that all reds come together, followed by all whites, followed finally by all blues&lt;/em>.&lt;/p></description></item><item><title>Making Floupian Change</title><link>https://blog.jverkamp.com/2013/02/22/making-floupian-change/</link><pubDate>Fri, 22 Feb 2013 14:00:45 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/22/making-floupian-change/</guid><description>&lt;p>On the island of Floup in the South Pacific ((not a real place)), one might find coins worth 1, 3, 7, 31, or 153 floupia each. In addition, they have a most curious custom. Whenever one makes a payment of any sort, it is considered rude not to minimize the total number of coins involved in the exchange. For example, if someone were to purchase a nice refreshing beverage for 17 floupia ((the floupia is currently performing rather well against the dollar)), one might pay with three 7f coins and receive a 1f and a 3f coin in exchange for a total of 5 coins. But that would be terrible, as a more efficient solutions exists: pay a single 31f coin and receive two 7f coins as change.&lt;/p></description></item><item><title>NPR Sunday Puzzle</title><link>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</link><pubDate>Wed, 20 Feb 2013 14:00:26 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/20/npr-sunday-puzzle/</guid><description>&lt;p>&lt;a title="NPR Sunday Puzzle" href="https://programmingpraxis.com/2013/02/19/npr-sunday-puzzle/">Yesterday&amp;rsquo;s puzzle&lt;/a> from Programming Praxis asks us to solve a Sunday Puzzle from NPR:&lt;/p>
&lt;blockquote>
&lt;p>Think of two familiar, unhyphenated, eight-letter words that contain the letters A, B, C, D, E and F, plus two others, in any order. What words are these?&lt;/p>&lt;/blockquote>
&lt;p>It&amp;rsquo;s another in a &lt;a title="jverkamp.com: Word games" href="http://blog.jverkamp.com/tag/word-games/">long history of word games&lt;/a>, my favorite sort of puzzle.&lt;/p></description></item><item><title>Predecessor and successor in a binary search tree</title><link>https://blog.jverkamp.com/2013/02/13/predecessor-and-successor-in-a-binary-search-tree/</link><pubDate>Wed, 13 Feb 2013 14:00:53 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/13/predecessor-and-successor-in-a-binary-search-tree/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2013/02/12/binary-search-tree-in-order-predecessor-and-successor/" title="Binary Search Tree: In-Order Predecessor And Successor">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis has us trying to find the predecessor and successor to a given value in a binary search tree. There are actually two general algorithms for doing this, depending on if you have parent pointers or not&amp;ndash;but they&amp;rsquo;re asking for the algorithm without.&lt;/p></description></item><item><title>The 147 Puzzle</title><link>https://blog.jverkamp.com/2013/02/06/the-147-puzzle/</link><pubDate>Wed, 06 Feb 2013 14:00:51 +0000</pubDate><guid>https://blog.jverkamp.com/2013/02/06/the-147-puzzle/</guid><description>&lt;p>Yesterday saw another puzzle from Programming Praxis, this one entitled &lt;a href="http://programmingpraxis.com/2013/02/05/the-147-puzzle/" title="The 147 Puzzle">The 147 Puzzle&lt;/a>. The description is relatively straight forward. Find a set of &lt;em>k&lt;/em> fractions each with numerator 1 such that the sum is equal to one.&lt;/p>
&lt;p>For example, &lt;span class="latex-inline">1/5 &amp;#43; 1/5 &amp;#43; 1/5 &amp;#43; 1/5 &amp;#43; 1/5 = 1&lt;/span>
 is a trivial solution for &lt;em>k = 5&lt;/em>. It turns out that there are 147 solutions when &lt;em>k = 5&lt;/em>, thus the name of the puzzle.&lt;/p></description></item><item><title>Splay heaps redux-imperative model</title><link>https://blog.jverkamp.com/2013/01/24/splay-heaps-redux-imperative-model/</link><pubDate>Thu, 24 Jan 2013 14:00:32 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/24/splay-heaps-redux-imperative-model/</guid><description>&lt;p>I did say in &lt;a href="https://blog.jverkamp.com/2013/01/23/sorting-via-splay-heap/">yesterday&amp;rsquo;s comments&lt;/a> that I would try re-implementing splay heaps using an imperative model with an array (Scheme&amp;rsquo;s &lt;code>vector&lt;/code>) as the back end rather than a functional one with trees. Well, here is is.&lt;/p></description></item><item><title>Sorting via splay heap</title><link>https://blog.jverkamp.com/2013/01/23/sorting-via-splay-heap/</link><pubDate>Wed, 23 Jan 2013 14:00:32 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/23/sorting-via-splay-heap/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2013/01/22/splay-heaps/" title="Splay Heap">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis gives a new (or at least different) vantage point on one of the most common problems in Computer Science: sorting. Today, we&amp;rsquo;re going to implement a data structure known as a &lt;a href="https://en.wikipedia.org/wiki/splay%20heap">splay heap&lt;/a> and use that to perform a &lt;a href="https://en.wikipedia.org/wiki/heapsort">heapsort&lt;/a>.&lt;/p></description></item><item><title>Triangle Trilemma</title><link>https://blog.jverkamp.com/2013/01/20/triangle-trilemma/</link><pubDate>Sun, 20 Jan 2013 14:00:55 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/20/triangle-trilemma/</guid><description>&lt;p>&lt;a href="https://blog.jverkamp.com/2013/01/03/four-points-a-square/">Four points, a square?&lt;/a>) and comes originally from a &lt;a title="Google Code Jam: Triangle Trilemma" href="https://code.google.com/codejam/contest/32014/dashboard">Google Code Jam&lt;/a> problem. The problem is stated simply enough&lt;/p>
&lt;blockquote>
&lt;p>Accept three points as input, determine if they form a triangle, and, if they do, classify it at equilateral (all three sides the same), isoceles (two sides the same, the other different), or scalene (all three sides different), and also classify it as acute (all three angles less than 90 degrees), obtuse (one angle greater than 90 degrees) or right (one angle equal 90 degrees).&lt;/p>&lt;/blockquote>
&lt;p>But once you start implementing it, that&amp;rsquo;s when things get more interesting. &amp;#x1f604;&lt;/p></description></item><item><title>Translate CSV to HTML</title><link>https://blog.jverkamp.com/2013/01/16/translate-csv-to-html/</link><pubDate>Wed, 16 Jan 2013 04:55:10 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/16/translate-csv-to-html/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2013/01/15/translate-csv-to-html/" title="Translate CSV to HTML">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis asks us to write a function that will read content formatted as &lt;a href="https://en.wikipedia.org/wiki/comma-separated%20values">comma-separated values&lt;/a> and output the result as an HTML table. Their solution uses the &lt;a href="http://programmingpraxis.com/essays/#text-file-databases" title="Text file database">text file database library&lt;/a> that they posted about (which is a neat concept, you should check it out), but I think I&amp;rsquo;m going to work out the solution more directly.&lt;/p></description></item><item><title>Four points, a square?</title><link>https://blog.jverkamp.com/2013/01/03/four-points-a-square/</link><pubDate>Thu, 03 Jan 2013 14:00:45 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/03/four-points-a-square/</guid><description>&lt;p>&lt;a title="Four Points Determine a Square" href="http://programmingpraxis.com/2013/01/02/four-points-determine-a-square/">Another post&lt;/a> from Programming Praxis. This one was originally intended for Friday but they posted it early, so I figured I would go ahead and do the same. The problem is actually deceptively straight forward:&lt;/p>
&lt;p>Given four points, do they form a square?&lt;/p></description></item><item><title>Happy New Year</title><link>https://blog.jverkamp.com/2013/01/02/happy-new-year/</link><pubDate>Wed, 02 Jan 2013 14:00:40 +0000</pubDate><guid>https://blog.jverkamp.com/2013/01/02/happy-new-year/</guid><description>&lt;p>&lt;a title="Happy New Year!" href="http://programmingpraxis.com/2013/01/01/happy-new-year/">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis asks us to build a very special sort of expression. Using the numbers 10, 9, 8, 7, 6, 5, 4, 3, 2, and 1 in that order along with the operators of multiplication, division, addition, subtraction, and concatenation, find all of the ways that we can write an expression totaling 2013. Here&amp;rsquo;s one valid solution:&lt;/p>
&lt;div class="latex-block">109 - 8 * 7 + 654 * 3 - 2 / 1 = 2013&lt;/div></description></item><item><title>Nested Primes</title><link>https://blog.jverkamp.com/2012/12/22/nested-primes/</link><pubDate>Sat, 22 Dec 2012 14:00:17 +0000</pubDate><guid>https://blog.jverkamp.com/2012/12/22/nested-primes/</guid><description>&lt;p>&lt;a href="http://programmingpraxis.com/2012/12/21/building-primes/" title="Building Primes">Yesterday&amp;rsquo;s post&lt;/a> from Programming Praxis poses an interesting problem: find the largest prime &lt;em>n&lt;/em> such that the result of repeatedly removing each digit of &lt;em>n&lt;/em> from left to right is also always prime.&lt;/p>
&lt;p>For example, 6317 would be such a number, as not only is it prime, but so are 317, 17, and 7.&lt;/p></description></item><item><title>Narcissistic Numbers</title><link>https://blog.jverkamp.com/2012/12/14/narcissistic-numbers/</link><pubDate>Fri, 14 Dec 2012 11:00:16 +0000</pubDate><guid>https://blog.jverkamp.com/2012/12/14/narcissistic-numbers/</guid><description>&lt;p>&lt;a title="Programming Praxis: 115132219018763992565095597973971522401" href="http://programmingpraxis.com/2012/12/14/115132219018763992565095597973971522401/">Today&amp;rsquo;s post&lt;/a> from Programming Praxis posits an interesting problem: how can we (efficiently) find all of the &lt;a title="Wolfram Mathworld: Narcissistic numbers" href="http://mathworld.wolfram.com/NarcissisticNumber.html">narcissistic numbers&lt;/a> (in base 10)?&lt;/p></description></item><item><title>Generating non-repeating strings</title><link>https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/</link><pubDate>Wed, 12 Dec 2012 14:00:32 +0000</pubDate><guid>https://blog.jverkamp.com/2012/12/12/generating-non-repeating-strings/</guid><description>&lt;p>Based on &lt;a title="Programming Praxis: Stepwise Program Development: A Heuristic Algorithm" href="http://programmingpraxis.com/2012/12/11/stepwise-program-development-a-heuristic-algorithm/">this post&lt;/a> from Programming Praxis, today&amp;rsquo;s goal is to write an algorithm that, given a number &lt;em>N&lt;/em> and an alphabet &lt;em>A&lt;/em>, will generate all strings of length N made of letters from A with no adjacent substrings that repeat.&lt;/p>
&lt;p>So for example, given &lt;em>N = 5&lt;/em> and &lt;em>A = {a, b, c}&lt;/em> the string &lt;em>abcba&lt;/em> will be allowed, but none of &lt;em>abcbc&lt;/em>, &lt;em>ababc&lt;/em>, nor even &lt;em>aabcb&lt;/em> will be allowed (the &lt;em>bc&lt;/em>, &lt;em>ab&lt;/em>, and &lt;em>a&lt;/em> repeat).&lt;/p>
&lt;p>It&amp;rsquo;s a little more general even than the version Programming Praxis specifies (they limit the alphabet to exactly *A = {1, 2, 3} *and more more general still than their original source which requires only one possible string, but I think it&amp;rsquo;s worth the extra complications.&lt;/p></description></item><item><title>Numbers of Wirth</title><link>https://blog.jverkamp.com/2012/12/10/numbers-of-wirth/</link><pubDate>Mon, 10 Dec 2012 14:00:19 +0000</pubDate><guid>https://blog.jverkamp.com/2012/12/10/numbers-of-wirth/</guid><description>&lt;p>Niklaus Wirth gave the following problem back in 1973:&lt;/p>
&lt;blockquote>
&lt;p>Develop a program that generates in ascending order the least 100 numbers of the set M, where M is defined as follows:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>a) The number 1 is in M.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>b) If x is in M, then y = 2 * x + 1 and z = 3 * x + 1 are also in M.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>c) No other numbers are in M.&lt;/p>&lt;/blockquote>
&lt;p>(via &lt;a href="http://programmingpraxis.com/2012/12/07/wirth-problem-15-12/" title="Programming Praxis: Wirth Problem 15.12">Programming Praxis&lt;/a>)&lt;/p>
&lt;p>It&amp;rsquo;s an interesting enough problem, so let&amp;rsquo;s work out a few different ways of doing it.&lt;/p></description></item><item><title>One Billion Primes - Segmented Sieve</title><link>https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/</link><pubDate>Thu, 29 Nov 2012 22:00:31 +0000</pubDate><guid>https://blog.jverkamp.com/2012/11/29/one-billion-primes-segmented-sieve/</guid><description>&lt;p>After a &lt;a href="https://blog.jverkamp.com/2012/11/01/the-sum-of-the-first-billion-primes/">sum of the first billion primes&lt;/a> post (originally from &lt;a title="Programming Praxis: The Sum Of The First Billion Primes" href="http://programmingpraxis.com/2012/09/11/the-sum-of-the-first-billion-primes/">Programming Praxis&lt;/a>), I decided to finally write a segmented version of the &lt;a href="https://en.wikipedia.org/wiki/Sieve%20of%20Eratosthenes">Sieve of Eratosthenes&lt;/a>.&lt;/p></description></item><item><title>List algorithms and efficiency</title><link>https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/</link><pubDate>Wed, 21 Nov 2012 14:00:29 +0000</pubDate><guid>https://blog.jverkamp.com/2012/11/21/list-algorithms-and-efficiency/</guid><description>&lt;p>Programming Praxis&amp;rsquo; new challenge(s) are to write three different list algorithms three times, each with a different runtime complexity. From their &lt;a title="Programming Praxis: List Intersection and Union" href="http://programmingpraxis.com/2012/11/16/list-intersection-and-union/">first post&lt;/a> last week we have list intersection and union and from a &lt;a title="Programming Praxis: List Difference" href="http://programmingpraxis.com/2012/11/20/list-difference/">newer post&lt;/a> yesterday we have the difference of two lists. For each of those, we want to be able to write an algorithm that runs in O(n&lt;sup>2&lt;/sup>) time, one that runs in O(n log n), and finally one that runs in O(n). It turns out that it&amp;rsquo;s more of an exercise in data structures than anything (although they&amp;rsquo;re all still technically &amp;rsquo;list&amp;rsquo; algorithms), but it&amp;rsquo;s still interesting to see how you can achieve the same goal in different ways that may be far more efficient.&lt;/p></description></item><item><title>Taxicab numbers</title><link>https://blog.jverkamp.com/2012/11/10/taxicab-numbers/</link><pubDate>Sat, 10 Nov 2012 14:00:00 +0000</pubDate><guid>https://blog.jverkamp.com/2012/11/10/taxicab-numbers/</guid><description>&lt;p>Yesterday had another &lt;a title="Taxicab Numbers" href="http://programmingpraxis.com/2012/11/09/taxicab-numbers/">programming puzzle&lt;/a> by Programming Praxis. This time, we are looking for a very special sort of number, a &lt;a href="https://en.wikipedia.org/wiki/Taxicab%20number">Taxicab number&lt;/a>.  According to Wikipedia:&lt;/p>
&lt;blockquote>
&lt;p>In mathematics, the nth taxicab number, typically denoted Ta(n) or Taxicab(n), is defined as the smallest number that can be expressed as a sum of two positive algebraic cubes in n distinct ways.
&amp;ndash; &lt;cite>&lt;a href="https://en.wikipedia.org/wiki/Taxicab%20number">Wikipedia: Taxicab Number&lt;/a>&lt;/cite>&lt;/p>&lt;/blockquote></description></item><item><title>The Sum Of The First Billion Primes</title><link>https://blog.jverkamp.com/2012/11/01/the-sum-of-the-first-billion-primes/</link><pubDate>Thu, 01 Nov 2012 14:00:03 +0000</pubDate><guid>https://blog.jverkamp.com/2012/11/01/the-sum-of-the-first-billion-primes/</guid><description>&lt;p>&lt;a title="Programming Praxis: The Sum of the First Billion Primes" href="http://programmingpraxis.com/2012/09/11/the-sum-of-the-first-billion-primes/">This problem&lt;/a> from Programming Praxis came about in the comments to my last post and intrigued me. So today, we are trying to sum the first one billion primes. Summing the first hundred, thousand, even million primes isn&amp;rsquo;t actually that bad. But it takes a bit more effort when you scale it up to a billion. And why&amp;rsquo;s that?&lt;/p></description></item><item><title>Pandigital Sums</title><link>https://blog.jverkamp.com/2012/10/31/pandigital-sums/</link><pubDate>Wed, 31 Oct 2012 14:00:11 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/31/pandigital-sums/</guid><description>&lt;p>Yesterday&amp;rsquo;s &lt;a href="http://programmingpraxis.com/2012/10/30/pandigital-numbers/" title="Programming Praxis: Pandigital Numbers">new post&lt;/a> from Programming Praxis asked us to find all triples &lt;em>(a, b, a+b)&lt;/em> such that &lt;em>a&lt;/em> and &lt;em>b&lt;/em> are three digits and &lt;em>a+b&lt;/em> is four and concatenating the numbers results in a &lt;a href="https://en.wikipedia.org/wiki/pandigital%20number">pandigital number&lt;/a> (one with all 10 digits). After that, find the smallest individual number in any of these triples.&lt;/p></description></item><item><title>Pythagorean Triples</title><link>https://blog.jverkamp.com/2012/10/27/pythagorean-triples/</link><pubDate>Sat, 27 Oct 2012 14:00:44 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/27/pythagorean-triples/</guid><description>&lt;p>When Programming Praxis mentioned that the &lt;a href="http://programmingpraxis.com/2012/10/26/pythagorean-triples/" title="Programming Praxis: Pythagorean Triples">newest challenge&lt;/a> sounded like a &lt;a href="http://projecteuler.net/" title="Project Euler">Project Euler&lt;/a> problem, they were&amp;rsquo;t wrong. Basically, the idea is to count the number of &lt;a href="https://en.wikipedia.org/wiki/Pythagorean%20Triples">Pythagorean Triples&lt;/a> with perimeters (sum of the three numbers) under a given value. The necessary code to brute force the problem is really straight forward, but then they asked for the count up to one million. With the brute force &lt;span class="latex-inline">O(n^2)&lt;/span>
 algorithm (and a relatively high constant), that&amp;rsquo;s not really feasible. So that&amp;rsquo;s when we have to get a bit more creative.&lt;/p></description></item><item><title>Prime Partitions II: The Listing</title><link>https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/</link><pubDate>Mon, 22 Oct 2012 14:00:58 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/</guid><description>&lt;p>As the continuation of &lt;a href="https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/">Saturday&amp;rsquo;s post&lt;/a> on counting the number of prime partitions of a number without actually determining what those partitions are, today we&amp;rsquo;re going to work out the actual list of partitions.&lt;/p></description></item><item><title>Prime Partitions</title><link>https://blog.jverkamp.com/2012/10/20/prime-partitions/</link><pubDate>Sat, 20 Oct 2012 14:00:52 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/20/prime-partitions/</guid><description>&lt;p>Today we&amp;rsquo;re back into the mathy sort of problems from Programming Praxis, &lt;a href="http://programmingpraxis.com/2012/10/19/prime-partitions/" title="Programming Praxis: Prime Partitions">tasked with&lt;/a> calculating the number of &lt;a href="http://mathworld.wolfram.com/PrimePartition.html" title="WolframMathworld: Prime Partition">prime partitions&lt;/a> for a given number&amp;ndash;essentially, how many different lists of prime numbers are there that sum to the given number.&lt;/p>
&lt;p>For example, working with 11, there are six prime partitions (I&amp;rsquo;ll show the code for this later):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&amp;gt; (&lt;span style="color:#a6e22e">prime-partitions&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;#39;&lt;/span>((&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>) (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>) (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) (&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>) (&lt;span style="color:#ae81ff">11&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Unfortunately, the number of prime partitions quickly gets ridiculous. Once you get to 1000, there are 48 quadrillion prime partitions&amp;hellip; So generating all of them isn&amp;rsquo;t exactly feasible.&lt;/p></description></item><item><title>Memoization in Racket</title><link>https://blog.jverkamp.com/2012/10/20/memoization-in-racket/</link><pubDate>Sat, 20 Oct 2012 13:55:48 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/20/memoization-in-racket/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Memoization">Memoization&lt;/a> is awesome!&lt;/p>
&lt;p>I&amp;rsquo;ve already written &lt;a href="https://blog.jverkamp.com/2012/09/29/pickles-and-memoization/">one post&lt;/a> on the subject in Python, but this time we&amp;rsquo;ll do the same in Racket. It&amp;rsquo;s particularly timely as without it, &lt;a href="https://blog.jverkamp.com/2012/10/22/prime-partitions-ii-the-listing/">today&amp;rsquo;s post&lt;/a> on determining the number of prime partitions of a number would take longer to run than I care to wait.&lt;/p></description></item><item><title>The Evolution Of Flibs</title><link>https://blog.jverkamp.com/2012/10/18/the-evolution-of-flibs/</link><pubDate>Thu, 18 Oct 2012 14:00:14 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/18/the-evolution-of-flibs/</guid><description>&lt;p>In the past, I absolutely loved messing around with &lt;a href="https://en.wikipedia.org/wiki/Genetic%20algorithm">genetic algorithms&lt;/a>. The idea of bringing the power of natural selection to bear to solve all manner of problems just appeals to me for some reason. So when I came across a puzzle on on Programming Praxis called &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/flibs.rkt" target="_blank" rel="noopener">flibs source code&lt;/a>&lt;/p>
&lt;p>The eventual goal will be&amp;ndash;given a binary sequence&amp;ndash;to evolve a finite state machine that will recognize the sequence and output the same, offset by one. So if we&amp;rsquo;re given the sequence &lt;code>010011010011&lt;/code>, the solution will output something like this: &lt;code>001001101001&lt;/code>.&lt;/p></description></item><item><title>Rule 30 RNG</title><link>https://blog.jverkamp.com/2012/10/17/rule-30-rng/</link><pubDate>Wed, 17 Oct 2012 14:00:08 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/17/rule-30-rng/</guid><description>&lt;p>Today we get away from the word games for a little while and get back to talking about random number generators (previous posts &lt;a href="https://blog.jverkamp.com/2012/08/22/two-random-exercises/">here&lt;/a> and &lt;a href="https://blog.jverkamp.com/2012/08/23/two-more-random-exercises/">here&lt;/a>). Or rather one random number generator in specific: a &lt;a href="https://en.wikipedia.org/wiki/Rule%2030">Rule 30&lt;/a> &lt;a href="https://en.wikipedia.org/wiki/PRNG">psuedo-random number generator&lt;/a> (PRNG). (Here&amp;rsquo;s the &lt;a href="http://programmingpraxis.com/2011/04/29/rule-30-rng/" title="Programming Praxis: Rule 30 RNG">motivating post&lt;/a> from Programming Praxis.)&lt;/p>
&lt;p>Remember the previous post I made about &lt;a href="https://blog.jverkamp.com/2012/10/03/elementary-cellular-automaton/">cellular automaton&lt;/a>? The basic idea is to turn those into a random number generator. If you go back to the linked post in particular and give it Rule 30 with a random initial state, you can see how chaotic the rows seem to be. Perfect for a PRNG.&lt;/p></description></item><item><title>Chopping words</title><link>https://blog.jverkamp.com/2012/10/15/chopping-words/</link><pubDate>Mon, 15 Oct 2012 14:00:13 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/15/chopping-words/</guid><description>&lt;p>&lt;a title="Programming Praxis: Chopping Words" href="http://programmingpraxis.com/2012/07/03/chopping-words/">One more challenge&lt;/a> from Programming Praxis&amp;rsquo; &lt;a title="Programming Praxis: Themes: Word Games" href="http://programmingpraxis.com/contents/themes/#Word Games">Word Games&lt;/a> today (there are only a few left!). This time we have the challenge of cutting off bits of words, one letter at a time, such that each step is still a word.&lt;/p>
&lt;p>The example given in their post is &lt;code>planet → plane → plan → pan → an → a&lt;/code>, although surely many such examples exist.&lt;/p></description></item><item><title>Dodgson’s Doublets</title><link>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</link><pubDate>Sun, 14 Oct 2012 14:00:20 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/14/dodgsons-doublets/</guid><description>&lt;p>Today we have &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/doublets.rkt" target="_blank" rel="noopener">doublets source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/dictionary.rkt" target="_blank" rel="noopener">dictionary source code&lt;/a>, &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/racket-libraries/queue.rkt" target="_blank" rel="noopener">queue source code&lt;/a>.&lt;/p>
&lt;p>Using the same source code as the previous two posts (&lt;a href="https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/">here&lt;/a> and &lt;a href="https://blog.jverkamp.com/2012/10/13/word-cubes/">here&lt;/a>, described originally &lt;a href="https://blog.jverkamp.com/2012/10/11/dictionary-tries-in-racket/">here&lt;/a>) for the dictionary, the code is a pretty straight forward case of using &lt;a href="https://en.wikipedia.org/wiki/recursion">recursion&lt;/a> to do &lt;a href="https://en.wikipedia.org/wiki/backtracking">backtracking&lt;/a>. Basically, try all of the possible next words one letter different. Whenever you find a dead end, back up and try a different path. Something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; find the path between two words, changing one letters at a time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; use call/cc to bail out when we find an answer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">direct-doublet&lt;/span> dict src dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">call/cc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">λ&lt;/span> (&lt;span style="color:#a6e22e">exit&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([src (&lt;span style="color:#a6e22e">string-upcase&lt;/span> src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [dst (&lt;span style="color:#a6e22e">string-upcase&lt;/span> dst)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; loop down possible solutions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>loop ([current src] [words (list src)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; when we find one, bail out entirely&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(equal? current dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> (reverse words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">; try all possible values&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">for*/list&lt;/span> ([i (string-length src)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [c &lt;span style="color:#e6db74">&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([next (&lt;span style="color:#a6e22e">string-set&lt;/span> current i c)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">when&lt;/span> (&lt;span style="color:#66d9ef">and &lt;/span>(not (member next words))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">contains?&lt;/span> dict next))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">loop&lt;/span> next (cons next words))))))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> &lt;span style="color:#66d9ef">#f&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Basically, I&amp;rsquo;m using a neat trick I last used on the post about &lt;a href="https://blog.jverkamp.com/2012/08/27/4sum/">4SUM&lt;/a> where &lt;code>call/cc&lt;/code> lets us bail out of the depths of the code as soon as we find a solution. Other than that, it&amp;rsquo;s a simple matter of using &lt;code>for*&lt;/code> to loop over each position and each character, generating all possible words. Whenever a word is valid (and not one we&amp;rsquo;ve seen before in this path), keep going. Eventually, we&amp;rsquo;ll find a solution and can bail out. On the off chance that we don&amp;rsquo;t, return &lt;code>#f&lt;/code>.&lt;/p></description></item><item><title>Word cubes</title><link>https://blog.jverkamp.com/2012/10/13/word-cubes/</link><pubDate>Sat, 13 Oct 2012 14:00:38 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/13/word-cubes/</guid><description>&lt;p>Continuing in my recent set of &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/word-cube.rkt" target="_blank" rel="noopener">word-cube source code&lt;/a>. Like yesterday, it&amp;rsquo;s designed to work in &lt;a href="http://racket-lang.org" title="(((? Racket)))">Racket 5.3+&lt;/a>.&lt;/p></description></item><item><title>Squaring the Bishop</title><link>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</link><pubDate>Thu, 11 Oct 2012 14:00:40 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/11/squaring-the-bishop/</guid><description>&lt;p>Okay, this one was just neat. Based on &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/word-squares.rkt" target="_blank" rel="noopener">word-squares source&lt;/a>. I&amp;rsquo;ve only tested it in &lt;a href="http://racket-lang.org/" title="(((? Racket)))">Racket 5.3+&lt;/a>, but newer versions should work as well. Racket 5.2 won&amp;rsquo;t work without some tweaking as (at the very least) it&amp;rsquo;s missing a definition for &lt;code>string-trim&lt;/code>.&lt;/p></description></item><item><title>Two Word Games</title><link>https://blog.jverkamp.com/2012/10/10/two-word-games/</link><pubDate>Wed, 10 Oct 2012 14:00:09 +0000</pubDate><guid>https://blog.jverkamp.com/2012/10/10/two-word-games/</guid><description>&lt;p>Another day, &lt;a title="Programming Praxis: Two Word Games" href="http://programmingpraxis.com/2012/10/09/two-word-games/">another post&lt;/a> from Programming Praxis. Today they posted a word game that seems simple enough: first find all words in a given dictionary that contain all five vowels (a, e, i, o, u) in ascending order and then find any words (at least six letters long) where the letters are all in ascending alphabetical order.&lt;/p></description></item><item><title>A piece of the abc conjecture</title><link>https://blog.jverkamp.com/2012/09/19/a-piece-of-the-abc-conjecture/</link><pubDate>Wed, 19 Sep 2012 14:00:46 +0000</pubDate><guid>https://blog.jverkamp.com/2012/09/19/a-piece-of-the-abc-conjecture/</guid><description>&lt;p>There&amp;rsquo;s been a bit of hubbub in the in the math world the last few weeks with &lt;a href="https://en.wikipedia.org/wiki/Shinichi%20Mochizuki">Shinichi Mochizuki’s&lt;/a> 500 page proof that of the &lt;a href="https://en.wikipedia.org/wiki/ABC%20conjecture">ABC conjecture&lt;/a>. Basically, the conjecture states that given three positive coprime integers &lt;em>a&lt;/em>, &lt;em>b&lt;/em>, and &lt;em>c&lt;/em> such that &lt;em>a&lt;/em> + &lt;em>b&lt;/em> = &lt;em>c&lt;/em>, the product of the distinct prime factors of &lt;em>a&lt;/em>, &lt;em>b&lt;/em>, and &lt;em>c&lt;/em> is rarely much smaller than &lt;em>c&lt;/em>. While this may sound strange, there are a number of interesting consequences that you can read about &lt;a href="https://en.wikipedia.org/wiki/Abc%20conjecture#Some%20consequences">here&lt;/a>.&lt;/p>
&lt;p>To make a long story shorter, there was a challenge on &lt;a href="http://programmingpraxis.com/2012/09/18/abc-conjecture/" title="ABC Conjecture">Programming Praxis&lt;/a> that intrigued me, which was to write code that given a upper bound on &lt;em>c&lt;/em> would generate a list of all of the triples &lt;em>(a, b, c)&lt;/em> such that the product is larger.&lt;/p></description></item><item><title>The First Two Problems</title><link>https://blog.jverkamp.com/2012/09/08/the-first-two-problems/</link><pubDate>Sat, 08 Sep 2012 14:00:09 +0000</pubDate><guid>https://blog.jverkamp.com/2012/09/08/the-first-two-problems/</guid><description>&lt;p>Anything worth doing is worth over doing, right? This time we have another two problems from Programming Praxis, aptly title &amp;ldquo;&lt;a href="https://blog.jverkamp.com/2012/04/13/wombat-ide-turtle-graphics/">Turtle Graphics&lt;/a> instead of just printing the characters. &amp;#x1f604;&lt;/p></description></item><item><title>Random Access Lists</title><link>https://blog.jverkamp.com/2012/08/30/random-access-lists/</link><pubDate>Thu, 30 Aug 2012 14:00:28 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/30/random-access-lists/</guid><description>&lt;p>This time around, Programming Praxis &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/ralist.ss" target="_blank" rel="noopener">here&lt;/a> (make sure you download pmatch as well).&lt;/p>
&lt;p>First, we need to provide tree functions that are designed to work on complete &lt;a href="https://en.wikipedia.org/wiki/binary%20trees">binary trees&lt;/a>, taking the size as an additional parameters.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; lookup an item in a balanced binary tree&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">tree-lookup&lt;/span> size tr i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">pmatch&lt;/span> (list size tr i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Leaf&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x) &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Leaf&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x) &lt;span style="color:#f92672">,&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">error&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tree-lookup&lt;/span> &lt;span style="color:#e6db74">&amp;#34;subscript-error&amp;#34;&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>t2) &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>t2) &lt;span style="color:#f92672">,&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([size^ (&lt;span style="color:#a6e22e">div&lt;/span> size &lt;span style="color:#ae81ff">2&lt;/span>)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&amp;lt;= i size^)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">tree-lookup&lt;/span> size^ t1 (- i &lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">tree-lookup&lt;/span> size^ t2 (- i &lt;span style="color:#ae81ff">1&lt;/span> size^))))]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; update a balanced binary tree with a new element&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">tree-update&lt;/span> size tr i y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">pmatch&lt;/span> (list size tr i y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Leaf&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x) &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">,&lt;/span>y) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#a6e22e">Leaf&lt;/span> &lt;span style="color:#f92672">,&lt;/span>y)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Leaf&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x) &lt;span style="color:#f92672">,&lt;/span>i &lt;span style="color:#f92672">,&lt;/span>y) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">error&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tree-update&lt;/span> &lt;span style="color:#e6db74">&amp;#34;subscript error&amp;#34;&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>t2) &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">,&lt;/span>y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>y &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>t2)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [(&lt;span style="color:#f92672">,&lt;/span>size (&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>t2) &lt;span style="color:#f92672">,&lt;/span>i &lt;span style="color:#f92672">,&lt;/span>y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>([size^ (&lt;span style="color:#a6e22e">div&lt;/span> size &lt;span style="color:#ae81ff">2&lt;/span>)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&amp;lt;= i size^)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>(&lt;span style="color:#a6e22e">tree-update&lt;/span> size^ t1 (- i &lt;span style="color:#ae81ff">1&lt;/span>) y) &lt;span style="color:#f92672">,&lt;/span>t2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#a6e22e">Node&lt;/span> &lt;span style="color:#f92672">,&lt;/span>x &lt;span style="color:#f92672">,&lt;/span>t1 &lt;span style="color:#f92672">,&lt;/span>(&lt;span style="color:#a6e22e">tree-update&lt;/span> size^ t2 (- i &lt;span style="color:#ae81ff">1&lt;/span> size^) y))))]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With that, we have everything we need to represent the lists. A random access list will be defined as follows:&lt;/p></description></item><item><title>Hash Tables With Open Addressing</title><link>https://blog.jverkamp.com/2012/08/29/hash-tables-with-open-addressing/</link><pubDate>Wed, 29 Aug 2012 14:00:26 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/29/hash-tables-with-open-addressing/</guid><description>&lt;p>Another day, another post from &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/chez-libraries/hash.ss" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>Okay, first, some administrative detail. First, we have to set up the library (we&amp;rsquo;re important the standard Chez Scheme library) and the data structure that we&amp;rsquo;re going to use internally. The nice thing about &lt;code>define-record&lt;/code> is that it makes a bunch of functions for us, like the constructor &lt;code>make-:hash:&lt;/code> and the accessors &lt;code>:hash:-f&lt;/code>, &lt;code>:hash:-nul&lt;/code>, &lt;code>:hash:-vals&lt;/code>, etc.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#a6e22e">library&lt;/span> (&lt;span style="color:#a6e22e">hash&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">export&lt;/span> make-hash hash-ref hash-set! hash-unset! hash-&amp;gt;list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">import&lt;/span> (&lt;span style="color:#a6e22e">chezscheme&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">define-record&lt;/span> :hash: (&lt;span style="color:#a6e22e">f&lt;/span> nul del keys vals))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next up, we want a function that will set up a hash. I went with the abstraction that you pass the hashing function in here and it&amp;rsquo;s stored with the hash record rather than passing it around all over the place. The nul and del symbols are also created here, gensym&amp;rsquo;ed to be unique&lt;sup>1&lt;/sup>. The hash function is also wrapped here to force all generated keys to be in the proper range.&lt;/p></description></item><item><title>4sum</title><link>https://blog.jverkamp.com/2012/08/27/4sum/</link><pubDate>Mon, 27 Aug 2012 14:00:36 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/27/4sum/</guid><description>&lt;p>&lt;a title="4SUM" href="http://programmingpraxis.com/2012/08/14/4sum/">One more from Programming Praxis&lt;/a>, this time we&amp;rsquo;re dealing with summing combinations of a sequence. More formally, given a secquence S, either choose four elements &lt;span class="latex-inline">s_1&lt;/span>
 through &lt;span class="latex-inline">s_4&lt;/span>
 from S such that &lt;span class="latex-inline">s_1 &amp;#43; s_2 &amp;#43; s_3 &amp;#43; s_4 = 0&lt;/span>
 or verify that it isn&amp;rsquo;t possible. This immediately makes me about working through possible solutions until we find one and then bailing out, ergo &lt;a href="https://en.wikipedia.org/wiki/call/cc">call/cc&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>sum ls)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (call/cc (&lt;span style="color:#66d9ef">lambda &lt;/span>(&lt;span style="color:#a6e22e">exit&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (for-each (&lt;span style="color:#66d9ef">lambda &lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (for-each (&lt;span style="color:#66d9ef">lambda &lt;/span>(&lt;span style="color:#a6e22e">j&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (for-each (&lt;span style="color:#66d9ef">lambda &lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (for-each (&lt;span style="color:#66d9ef">lambda &lt;/span>(&lt;span style="color:#a6e22e">l&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">when&lt;/span> (= &lt;span style="color:#ae81ff">0&lt;/span> (+ i j l k))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> (list i j k l))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ls))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ls))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ls))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ls)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">exit&lt;/span> &lt;span style="color:#66d9ef">#f&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Minimum scalar product</title><link>https://blog.jverkamp.com/2012/08/24/minimum-scalar-product/</link><pubDate>Fri, 24 Aug 2012 14:00:59 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/24/minimum-scalar-product/</guid><description>&lt;p>&lt;a title="Minimum Scalar Product" href="http://programmingpraxis.com/2012/08/10/minimum-scalar-product/">Another post&lt;/a> from Programming Praxis, this time we&amp;rsquo;re to figure out what is the minimum &lt;a href="https://en.wikipedia.org/wiki/scalar%20product">scalar product&lt;/a> of two &lt;a href="https://en.wikipedia.org/wiki/Vector%20%28mathematics%20and%20physics%29">vectors&lt;/a>. Basically, you want to rearrange two given lists a&lt;sub>1&lt;/sub>, a&lt;sub>2&lt;/sub>, &amp;hellip;, a&lt;sub>n&lt;/sub> and b&lt;sub>1&lt;/sub>, b&lt;sub>2&lt;/sub>, &amp;hellip;, b&lt;sub>n&lt;/sub> such that a&lt;sub>1&lt;/sub>b&lt;sub>1&lt;/sub> + a&lt;sub>2&lt;/sub>b&lt;sub>2&lt;/sub> + &amp;hellip; + a&lt;sub>n&lt;/sub>b&lt;sub>n&lt;/sub> is minimized.&lt;/p></description></item><item><title>Two More Random Exercises</title><link>https://blog.jverkamp.com/2012/08/23/two-more-random-exercises/</link><pubDate>Thu, 23 Aug 2012 14:00:27 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/23/two-more-random-exercises/</guid><description>&lt;p>Programming Praxis put out &lt;a href="https://blog.jverkamp.com/2012/08/22/two-random-exercises/">the previous&lt;/a> had us composing already existing PRNGs).&lt;/p></description></item><item><title>Two Random Exercises</title><link>https://blog.jverkamp.com/2012/08/22/two-random-exercises/</link><pubDate>Wed, 22 Aug 2012 14:00:47 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/22/two-random-exercises/</guid><description>&lt;p>&lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/random.ss" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>First, let&amp;rsquo;s make a function that can turn any die into an unfair coin. Basically, return #t / true if and only if you roll the die twice and get the same result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; given any random die and a possible outcome&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">; turn it into an unfair coin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">define &lt;/span>(&lt;span style="color:#a6e22e">die-&amp;gt;coin&lt;/span> possible die)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">lambda &lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (eq? possible (&lt;span style="color:#a6e22e">die&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From here, use the same idea that I posted about earlier to turn that unfair coin into a fair 50/50 coin:&lt;/p></description></item><item><title>SEND + MORE = MONEY</title><link>https://blog.jverkamp.com/2012/08/21/send--more-money/</link><pubDate>Tue, 21 Aug 2012 14:00:25 +0000</pubDate><guid>https://blog.jverkamp.com/2012/08/21/send--more-money/</guid><description>&lt;p>There was &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/send-more-money.ss" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>There are a few ways that you could brute force the problem (discussed in &lt;a href="https://github.com/jpverkamp/small-projects/blob/master/blog/send-more-money.ss" target="_blank" rel="noopener">here&lt;/a>.&lt;/p></description></item></channel></rss>