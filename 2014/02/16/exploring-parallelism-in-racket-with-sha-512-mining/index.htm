<!DOCTYPE html>
<html>
<head>
        
        

        <title>Exploring parallelism in Racket with SHA-512 mining | jverkamp.com | John-Paul Verkamp</title>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css" />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.css" />
        <script src="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.js"></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.9/jquery.transit.min.js"></script>

        <!-- Highlight.js for syntax highlighting -->
        <link rel="stylesheet" href="/highlight/styles/tomorrow-night.css" />
        <script src="/highlight/highlight.pack.js"></script>

        <!-- MathJax for LaTeX support -->
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- nanoGallery for Flickr Galleries -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/css/themes/light/nanogallery_light.css" />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/jquery.nanogallery.min.js"></script>

        <!-- Any custom CSS or JS that I've written; this should be kept minimal -->
        <link rel="stylesheet" href="/custom.css" />
        <script src="/custom.js"></script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="http://blog.jverkamp.com/feed/" />
</head>
<body>
        <header class="container">
        <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://blog.jverkamp.com"><span style="color: green;">jv</span>erkamp.com</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav"><li class="dropdown"><a href="http://blog.jverkamp.com/category/archives" class="dropdown-toggle">Archives<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/archives/2004">2004</a></li><li><a href="http://blog.jverkamp.com/category/archives/2005">2005</a></li><li><a href="http://blog.jverkamp.com/category/archives/2006">2006</a></li><li><a href="http://blog.jverkamp.com/category/archives/2007">2007</a></li><li><a href="http://blog.jverkamp.com/category/archives/2008">2008</a></li><li><a href="http://blog.jverkamp.com/category/archives/2009">2009</a></li><li><a href="http://blog.jverkamp.com/category/archives/2010">2010</a></li><li><a href="http://blog.jverkamp.com/category/archives/2011">2011</a></li><li><a href="http://blog.jverkamp.com/category/archives/2012">2012</a></li><li><a href="http://blog.jverkamp.com/category/archives/2013">2013</a></li><li><a href="http://blog.jverkamp.com/category/archives/2014">2014</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/other" class="dropdown-toggle">Other<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/other/board-game-reviews">Board Game Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/cooking">Cooking</a></li><li><a href="http://blog.jverkamp.com/category/other/movie-reviews">Movie Reviews</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/photography" class="dropdown-toggle">Photography<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/photography/dp-challenge">DP Challenge</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosets">Photosets</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosynth">Photosynth</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/programming" class="dropdown-toggle">Programming<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/programming/by-language">By Language</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-project">By Project</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source">By Source</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/programming/libraries">Libraries</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/research" class="dropdown-toggle">Research<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/research/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/research/publications">Publications</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/writing" class="dropdown-toggle">Writing<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/writing/by-genre">By Genre</a></li><li><a href="http://blog.jverkamp.com/category/writing/nanowrimo">NaNoWriMo</a></li><li><a href="http://blog.jverkamp.com/category/writing/novels">Novels</a></li><li><a href="http://blog.jverkamp.com/category/writing/other">Other</a></li><li><a href="http://blog.jverkamp.com/category/writing/short-stories">Short Stories</a></li></ul></li></ul>

      <form action="http://www.google.com/search" method="get" onSubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input name="q" type="hidden" />
          <input name="qfront" type="text" class="form-control" placeholder="Search" />
          <button type="submit" class="btn btn-default" value="Search">Search</button>
        </p>
      </form>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
        </header>

        <article class="container">
                <header>
                        <h1 class="entry-title">Exploring parallelism in Racket with SHA-512 mining</h1>

                        <div class="entry-meta">
                                <span class="posted-on"><time class="entry-date" datetime="2014-02-16"><span class="year">2014</span> <span class="month">Feb</span> <span class="day">16</span></time></span>
                                <span class="tags"><ul class="tag-list list-inline"><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/hash">Hash</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/bitcoin">Bitcoin</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/mathematics">Mathematics</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/concurrency">Concurrency</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/dictionary">Dictionary</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/parallelism">Parallelism</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/scheme">Scheme</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/cryptography/hashes">Hashes</a></li></ul></span>
                        </div>

                        <hr />
                </header>
                <div class="entry-content">
                        <p>While I've been getting a fair few programming exercises from Reddit's <a href="http://www.reddit.com/r/dailyprogrammer">/r/dailyprogrammer</a>, more recently I've started following a few other sub-Reddits, such as <a href="http://www.reddit.com/r/programming">/r/programming</a> and <a href="http://www.reddit.com/r/netsec">/r/netsec</a>. While browsing the former, I came across this intriguing gem of a problem: <a tabindex="1" href="http://www.h11e.com/">HashChallenge: can you find the lowest value SHA-512 hash?</a> <!--more--></p>
<p>The basic idea is simple. Find the input string <em>s</em> such that the output SHA-512 hash is minimized. As an an example,</p>
<pre class="bash"><code>$ echo "Hello world" | shasum -a 512
81381f1dacd4824a6c503fd070577630...

$ echo "Even better" | shasum -a 512
77d8af6911952994e2d9597e6962ada1...</code></pre>
<p>Of course, these aren't that great. At the very least we should be looking for hashes with a few leading zeros. Not to mention that this is something that should be downright trivial to automate. Let's start with a straight forward Racket script:</p>
<pre class="scheme"><code>; Mine for the lowest SHA-512 we can find
(define (mine)
  (define alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890")
  (define hashes-tried 0)
  (define start-time (current-inexact-milliseconds))

  ; Store best values
  (define best-str #f)
  (define best-hash #f)

  ; Generate random values one at a time
    (let loop ()
      (define str   (random-string 16))
      (define bytes (string-&gt;bytes/utf-8 str))
      (define hash  (bytes-&gt;hex-string (sha512 bytes)))

      (set! hashes-tried (+ 1 hashes-tried))
      (when (or (not best-hash) (string&lt;? hash best-hash))
        (set! best-str str)
        (set! best-hash hash)
        (print-timing 'main hashes-tried (/ (- (current-inexact-milliseconds) start-time) 1000) best-str best-hash))

      (loop)))</code></pre>
<p>There are a few helper functions there (<code>random-string</code> and <code>print-timing</code>, you can see them in the full code on GitHub: <a href="https://github.com/jpverkamp/small-projects/tree/master/blog/mine-sha512">github/jpverkamp</a>), but those should be straight forward. The hashing itself is done with Greg Hendershott's <a href="https://github.com/greghendershott/sha/tree/master"><code>sha</code> library for Racket</a>, available via the new <a href="http://pkg.racket-lang.org/#[sha]">package manager</a>.</p>
<p>So, how does that do?</p>
<pre class="bash"><code>$ racket mine-sha512.rkt
main: 4ZRZ6R5eQO4GItzK -&gt; 50ce827050c31fd0... (1.0 h @ 1.0 kh/s)
main: bGzP1aAnXjDEJ5tS -&gt; 2a8e1803b7ac4b57... (16.0 h @ 16.0 kh/s)
main: 9IXIWuGDepUUSubp -&gt; 048e4b1b9ae2e893... (20.0 h @ 20.0 kh/s)
main: nwVB9KFI0ieHm0n4 -&gt; 007704acb8e01bcf... (105.0 h @ 52.5 kh/s)
main: WeQFXLb3UhwyaHRr -&gt; 000b17576f358405... (364.0 h @ 91.0 kh/s)
main: D19naE3qFtrKT6Lt -&gt; 000707066075fce0... (6.0 kh @ 100.7 kh/s)
main: 4PQKs7crKnQTBjfs -&gt; 00018fe9e134c366... (11.7 kh @ 113.6 kh/s)
main: NZS717BXvT0ErzSR -&gt; 0000ed34ec5c0222... (120.5 kh @ 131.1 kh/s)
main: 3QuXbtG0xlRaDKqV -&gt; 000005fb0ac4a407... (2.7 Mh @ 133.2 kh/s)</code></pre>
<p>Since it only prints a line when it finds a new best hash, output can be a little chaotic at best, but at the very least this gives us a pretty good baseline. We managed to find a hash with 5 leading zeros and are running at about 133.2 kh/s. Nowhere near what most ASIC bitcoin miners <a href="https://en.bitcoin.it/wiki/Mining_hardware_comparison#ASIC">claim to be able to do</a><span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>, but not terrible for a pure CPU miner.</p>
<p>Let's do better.</p>
<p>The next idea would be to use Racket's threads. Going in to it, I already know that this isn't going to buy us much<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>, but it's an easy enough tweak.</p>
<p>First, pull out the <code>hashes-tried</code>, <code>best-str</code>, and <code>best-hash</code> variables so all threads can access them. Then, create a wrapper function that will fire off the right number of threads:</p>
<pre class="scheme"><code>; Mine with multiple threads concurrently
(define (mine-all thread-count)
  (define threads
    (for/list ([i (in-range thread-count)])
      (thread (thunk (mine i)))))
  (map thread-wait threads))</code></pre>
<p>This way we also get to know which thread found the new best value (although strictly speaking that's not necessary):</p>
<pre class="bash"><code>$ racket mine-sha512-threads.rkt 8
7: OsultHDT905n5mmo -&gt; c0b8ad26ae6472f8... (1.0 h @ 62.5 h/s)
7: pEyhYUxIM74peJxi -&gt; 13c7391822e728c3... (3.0 h @ 187.5 h/s)
7: jPMHHOwwJeGe7bqF -&gt; 0045856cdcfbe797... (10.0 h @ 625.0 h/s)
7: TE2nEcH10rcWefsn -&gt; 003e888a92cd8809... (1.0 kh @ 43.7 kh/s)
7: WTGTqrOpl2x1Czi1 -&gt; 0024448bf70a1247... (1.1 kh @ 49.5 kh/s)
6: EMhqI5ngPwiQr4gK -&gt; 000ae12edd827730... (2.8 kh @ 78.0 kh/s)
5: Gftv6FPZwVF4xTct -&gt; 000031b56d17483b... (3.8 kh @ 88.7 kh/s)
1: gDNLGB6Dzlp9YVBj -&gt; 00002a7fd4a81c8d... (287.5 kh @ 143.2 kh/s)
1: G0F4FLKwPNbUzQGO -&gt; 0000117e20b56196... (646.2 kh @ 144.6 kh/s)
0: 0hmB7jnocqRMuSxu -&gt; 00000a1a4b05d9b7... (2.9 Mh @ 144.8 kh/s)
7: PM59fjq5g2huYTEN -&gt; 000004cb6fd3fe14... (4.8 Mh @ 143.8 kh/s)
4: 4WzSTKXi540JlyJL -&gt; 000004713d42ec3b... (5.1 Mh @ 143.7 kh/s)</code></pre>
<p>So we have a slight speed up. I guess that's something. The problem is that we're still actually only running in a single process on a single processor. With four cores, that's something of a waste. Unfortunately though, we aren't going to be able to do much better than that with threads. We need something a little more powerful:</p>
<p><code><a href="http://docs.racket-lang.org/search/index.html?q=Places">Places</a></code></p>
<p>The basic idea of places is:</p>
<blockquote><code><a href="http://docs.racket-lang.org/search/index.html?q=Places">Places</a></code> enable the development of parallel programs that take advantage of machines with multiple processors, cores, or hardware threads.</blockquote>
<p>Sounds like exactly what we want. Unfortunately, that extra power comes with a bit of extra cost. No longer can we share variables directly between the various threads of the program, but rather now we have to communicate explicitly, using <code><a href="http://docs.racket-lang.org/search/index.html?q=place channels">place channels</a></code>. The basic idea I have is to split the work up into <em>n</em> places. For each place, run two threads: a hashing thread and a feedback thread. The hashing thread is pretty much the mining function we've seen all along.</p>
<p>The feedback thread, on the other hand, will periodically send messages back to the main program relaying how much progress we've made and any new hashes we've found. Then, the main program can compare that to the other place's results and update with the overall best hash.</p>
<p>Starting with the new mining function:</p>
<pre class="scheme"><code>; Create a place that will mine for new low hashes
(define (mine id)
  (place me
    ; Local best values
    (define hashes-tried 0)
    (define best-str #f)
    (define best-hash #f)

    ; Thread to periodically send back new best values
    (thread
      (thunk
        (let loop ()
          (place-channel-put me hashes-tried)
          (place-channel-put me best-str)
          (place-channel-put me best-hash)
          (sleep (* (random) 10.0))
          (loop))))

    ; Look for new values
    ...))</code></pre>
<p>Fairly straight forward. The macro <code>place</code> at the top actually handles all of the work of creating a new place. <code>me</code> will be used to identify the automatically created channel we use a bit later to send messages on. Each time we send messages, we send three values: how many hashes this place has personally tried and the best string/hash pair. So of course, the main program will have to be listening for these three values from each place in turn:</p>
<pre class="scheme"><code>; Run multiple mining places in parallel and sync between them
(define (mine-all thread-count)
  ; Global best values
  (define start-time (current-inexact-milliseconds))
  (define best-str #f)
  (define best-hash #f)

  ; Create places
  (define places
    (for/list ([i (in-range thread-count)])
      (mine i)))

  ; Loop through those, getting their best values in time
  (let loop ()
    (for ([id (in-naturals)]
          [p (in-list places)])
      (define hashes-tried (place-channel-get p))
      (define str (place-channel-get p))
      (define hash (place-channel-get p))

      (when (or (not best-hash) (and hash (string&lt;? hash best-hash)))
        (define estimated-hashes (* hashes-tried thread-count))
        (set! best-str str)
        (set! best-hash hash)
        (print-timing id estimated-hashes (/ (- (current-inexact-milliseconds) start-time) 1000) best-str best-hash)))
    (loop)))</code></pre>
<p>There is a potential inefficiency here, in that we go round robin through the places asking each in turn for their best hash. Because they wait a random amount of time (up to 10 seconds) between reports, it could be a bit before we actually report a new lowest hash<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span>. In fact, it may even be out of date by then. Still, it's a reasonable enough count, especially if you're going to be running the program for a while.</p>
<p>So with that being said, the first thing to try would be a single place. Theoretically, that should give us the same performance as the original program (maybe minus a bit for the channel):</p>
<pre class="bash"><code>$ racket mine-sha512-places.rkt 1
0: 38H0DQxOWh0swGlq -&gt; 000581b5f1373c77... (2.1 kh @ 5.4 kh/s)
0: TZdL5yWiiMb6WFVV -&gt; 00006cc7dac2d460... (252.4 kh @ 116.6 kh/s)
0: 0AnndUtx0XmNfX9a -&gt; 00000893ee217109... (1.3 Mh @ 136.5 kh/s)
0: bGh0LDfnwCiSIb95 -&gt; 000001e204acff0c... (4.4 Mh @ 140.2 kh/s)
0: JoWy6CXotik87OWh -&gt; 0000010fe4646f6f... (6.5 Mh @ 140.7 kh/s)
0: iS6rIH4kClxc0SdF -&gt; 000000ecdcc2cc1e... (16.0 Mh @ 141.3 kh/s)</code></pre>
<p>Well that's not bad at all. If anything, it's a little faster<span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>.</p>
<p>Now, let's really let it go. I have 4 cores, so let's try 4 places:</p>
<pre class="bash"><code>$ racket mine-sha512-places.rkt 4
0: J1vkvS8s1WJJ7CUt -&gt; 003abedaf7fcdab7... (13.2 kh @ 27.6 kh/s)
1: 383Xt0hLlAl0JZWO -&gt; 00098c00746f1807... (11.5 kh @ 24.0 kh/s)
0: 7EmH4gk7T2aecSph -&gt; 0000060d3d0f9ddf... (3.7 Mh @ 505.7 kh/s)
0: XxeeMSUlYWPzrUh1 -&gt; 00000494b2eccdbf... (5.5 Mh @ 519.9 kh/s)
3: 7a5MD2k0uILVj8aB -&gt; 000002037fce01ec... (7.2 Mh @ 520.5 kh/s)
1: A3HTACsXRI5QkwWU -&gt; 000001de799bfeaa... (31.9 Mh @ 529.1 kh/s)</code></pre>
<p>That's a lot more like it. And at a roughly 3.75x speedup over a single place, pretty much exactly what <a href="https://en.wikipedia.org/wiki/Amdal's_law">Amdal's law</a> would expect we'd be able to get in speedup. If we try it with 8, we don't do any better (a brief spike, but overall it's actually worse):</p>
<pre class="bash"><code>$ racket mine-sha512-places.rkt 8
0: JRxl4puWgUCIBvZ1 -&gt; 00016f513c85da0e... (49.6 kh @ 54.8 kh/s)
4: LU5sj3zJmG30w4O3 -&gt; 000026edd66b3458... (13.4 kh @ 11.0 kh/s)
1: AvFOADpeY1vn0q5z -&gt; 000018a5d4019643... (2.0 Mh @ 247.9 kh/s)
2: wyIvWO5nYh7MgbTR -&gt; 00000658bae50546... (4.6 Mh @ 452.7 kh/s)
7: ekrIcXa8CVmXKmVr -&gt; 000004e231c16d72... (5.1 Mh @ 168.4 kh/s)
1: 1mTOnp0weetWHLbp -&gt; 00000270cab144e8... (24.0 Mh @ 736.0 kh/s)
0: 7GG6p6sK1e4EvbzV -&gt; 0000013d126816a5... (34.2 Mh @ 459.2 kh/s)</code></pre>
<p>Of course that's still nothing on the record hashes so far. In the contest running <a href="http://www.h11e.com/">here</a>, the best as of my writing is <code>0000000003aeefb5...</code> A bit of a way to go, that. Still, it's an interesting problem--and a nice excuse to learn a little more about places and channels in Racket. I've used them before, but I think they made a little more sense this time around.</p>
<p>If you'd like to see the entire code for today's post, it's on GitHub: <a href="https://github.com/jpverkamp/small-projects/tree/master/blog/mine-sha512">github/jpverkamp</a></p>
                </div>
                <div class="entry-footnotes">
                        <div id="footnotes"><ol><li><a name="footnote-1"></a>Those are generally measured in Mh/s</li><li><a name="footnote-2"></a>Threads give us <a href="https://en.wikipedia.org/wiki/concurrency">Concurrency (computer science)</a> in Racket, not <a href="https://en.wikipedia.org/wiki/parallelism">Parallel computing</a></li><li><a name="footnote-3"></a>Averaging 5 seconds times the number of places in fact</li><li><a name="footnote-4"></a>Which is probably just an artifact of the timing. There's no particular reason this code should actually be faster.</li></ol></div>
                </div>

                <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "jverkamp";
var disqus_title = "Exploring parallelism in Racket with SHA-512 mining";
var disqus_url = "http://blog.jverkamp.com/2014/02/16/exploring-parallelism-in-racket-with-sha-512-mining/";
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </article>

        <footer class="container" role="contentinfo">
                <nav class="navbar navbar-default" role="navigation"><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/02/15/the-lego-movie">← The Lego Movie</a></li><li><a href="http://blog.jverkamp.com/category/archives">Archives</a></li><li><a href="http://blog.jverkamp.com/2014/02/27/crossing-hands">Crossing hands →</a></li></ul><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/01/27/factoring-factorials">← Factoring factorials</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/2014/02/27/crossing-hands">Crossing hands →</a></li></ul></nav>

                <div class="legal">
                        <a href="http://blog.jverkamp.com/feed/atom.xml">feed <img style="border: 0;" src="http://blog.jverkamp.com/rss.png" /></a><br />
                        All posts unless otherwise mentioned are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
                        Any source code unless otherwise mentioned is licensed under the <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
                </div>
        </footer>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53688146-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>