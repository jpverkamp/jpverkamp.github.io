<!DOCTYPE html>
<html>
<head>
        
        

        <title>Dis/re-emvowelification | jverkamp.com | John-Paul Verkamp</title>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

        <script src="//code.jquery.com/ui/1.11.1/jquery-ui.min.js"></script>

        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css" />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.css" />
        <script src="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.js"></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.9/jquery.transit.min.js"></script>

        <!-- Highlight.js for syntax highlighting -->
        <link rel="stylesheet" href="/highlight/styles/obsidian.css" />
        <script src="/highlight/highlight.pack.js"></script>

        <!-- MathJax for LaTeX support -->
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- nanoGallery for Flickr Galleries -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/css/themes/light/nanogallery_light.css" />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/jquery.nanogallery.min.js"></script>

        <!-- Any custom CSS or JS that I've written; this should be kept minimal -->
        <link rel="stylesheet" href="/custom.css" />
        <script src="/custom.js"></script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="http://blog.jverkamp.com/feed/" />
</head>
<body>
        <header class="container">
        <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://blog.jverkamp.com"><span style="color: green;">jv</span>erkamp.com</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav"><li class="dropdown"><a href="http://blog.jverkamp.com/category/archives" class="dropdown-toggle">Archives<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/archives/2004">2004</a></li><li><a href="http://blog.jverkamp.com/category/archives/2005">2005</a></li><li><a href="http://blog.jverkamp.com/category/archives/2006">2006</a></li><li><a href="http://blog.jverkamp.com/category/archives/2007">2007</a></li><li><a href="http://blog.jverkamp.com/category/archives/2008">2008</a></li><li><a href="http://blog.jverkamp.com/category/archives/2009">2009</a></li><li><a href="http://blog.jverkamp.com/category/archives/2010">2010</a></li><li><a href="http://blog.jverkamp.com/category/archives/2011">2011</a></li><li><a href="http://blog.jverkamp.com/category/archives/2012">2012</a></li><li><a href="http://blog.jverkamp.com/category/archives/2013">2013</a></li><li><a href="http://blog.jverkamp.com/category/archives/2014">2014</a></li><li><a href="http://blog.jverkamp.com/category/archives/2015">2015</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/other" class="dropdown-toggle">Other<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/other/board-game-reviews">Board Game Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/cooking">Cooking</a></li><li><a href="http://blog.jverkamp.com/category/other/movie-reviews">Movie Reviews</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/photography" class="dropdown-toggle">Photography<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/photography/dp-challenge">DP Challenge</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosets">Photosets</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosynth">Photosynth</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/programming" class="dropdown-toggle">Programming<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/programming/by-language">By Language</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-project">By Project</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source">By Source</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/programming/libraries">Libraries</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/research" class="dropdown-toggle">Research<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/research/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/research/publications">Publications</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/writing" class="dropdown-toggle">Writing<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/writing/by-genre">By Genre</a></li><li><a href="http://blog.jverkamp.com/category/writing/nanowrimo">NaNoWriMo</a></li><li><a href="http://blog.jverkamp.com/category/writing/novels">Novels</a></li><li><a href="http://blog.jverkamp.com/category/writing/other">Other</a></li><li><a href="http://blog.jverkamp.com/category/writing/short-stories">Short Stories</a></li></ul></li></ul>

      <form action="http://www.google.com/search" method="get" onSubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input name="q" type="hidden" />
          <input name="qfront" type="text" class="form-control" placeholder="Search" />
          <button type="submit" class="btn btn-default" value="Search">Search</button>
        </p>
      </form>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
        </header>

        <article class="container">
                <header>
                        <h1 class="entry-title">Dis/re-emvowelification</h1>

                        <div class="entry-meta">
                                <span class="posted-on"><time class="entry-date" datetime="2014-02-27"><span class="year">2014</span> <span class="month">Feb</span> <span class="day">27</span></time></span>
                                <span class="tags"><ul class="tag-list list-inline"><li><a href="http://blog.jverkamp.com/category/programming/by-source/daily-programmer">Daily Programmer</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/dictionary">Dictionary</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/scheme">Scheme</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/tree">Tree</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/trie">Trie</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/word-games">Word Games</a></li></ul></span>
                        </div>

                        <hr />
                </header>
                <div class="entry-content">
                        <p>So far this week we've had a pair of related posts at the DailyProgrammer subreddit<span class="footnote"><sup><a href="#footnote-1">[1]</a></sup></span>:</p>
<ul>
  <li><a href="http://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/">[02/24/14] Challenge #149 [Easy] Disemvoweler</a></li>
  <li><a href="http://www.reddit.com/r/dailyprogrammer/comments/1yzlde/022614_challenge_150_intermediate_reemvoweler_1/">[02/26/14] Challenge #150 [Intermediate] Re-emvoweler 1</a></li>
</ul>
<p>Basically, if you're given a string with vowels, take them out. If you're given one without vowels, put them back in. One of the two is certainly easier than the other<span class="footnote"><sup><a href="#footnote-2">[2]</a></sup></span>. :)</p>
<!--more-->
<p>To start off, we need a definition for what exactly a vowel is. That's a bit of a question in and of itself, but we'll go with the easiest definition:</p>
<pre class="scheme"><code>; For this case, y/w are not vowels. Also, latin characters only :)
(define vowels '(#\a #\e #\i #\o #\u))
(define (char-vowel? c) (member c vowels))</code></pre>
<p>Straight forward enough. And it turns out that's enough to write the first function of the day:</p>
<pre class="scheme"><code>; Remove all vowels and non-alphabetic characters
(define (disemvowel str)
  (list-&gt;string
   (for/list ([c (in-string str)]
              #:when (and (char-alphabetic? c)
                          (not (char-vowel? c))))
     c)))</code></pre>
<p>A few test cases:</p>
<pre class="scheme"><code>&gt; (disemvowel "hello world")
"hllwrld"
&gt; (disemvowel "this is a test!")
"thsstst"
&gt; (disemvowel "this is a sparta")
"thsssprt"</code></pre>
<p>Seems good. It turns out that there's a reason this is an easy challenge. Now to the more <del>difficult</del> fun one. Like many of the previous <a href="http://blog.jverkamp.com/tag/word-games/">word games</a> I've worked out, the data structure we need is a <a href="https://en.wikipedia.org/wiki/trie">trie</a>. Since it's been a while, I went ahead and re-implemented one:</p>
<pre class="scheme"><code>; Load a dictionary as a trie, cache the result
(define dictionary
  (let ([rhash #f])
    (thunk
      (when (not rhash)
        (set! rhash (make-hash))
        (with-input-from-file "enable1.txt"
          (thunk
            (for ([word (in-lines)])
              (hash-ref!
               (for/fold ([rhash rhash]) ([c (in-string word)])
                 (hash-ref! rhash c (make-hash)))
               'end
               #t)))))
      rhash)))</code></pre>
<p>There's some pretty strange stuff going on there, so let's take it one chunk at a time. The outermost part is just caching the result. We've done that before. Inside of the <code>when</code>, we first create the hash, then open the dictionary. It's this part that's particularly fancy:</p>
<pre class="scheme"><code>(for ([word (in-lines)])
  (hash-ref!
   (for/fold ([rhash rhash]) ([c (in-string word)])
     (hash-ref! rhash c (make-hash)))
   'end
   #t))</code></pre>
<p>What's that do? Well, as is often the case in Scheme, start on the inside:</p>
<pre class="scheme"><code>(for/fold ([rhash rhash]) ([c (in-string word)])
  (hash-ref! rhash c (make-hash)))</code></pre>
<p><code>for/fold</code> will loop over the parameters in the second set (characters <code>c</code> in this case) using each body to update the first variable (the recursive part of the hash <code>rhash</code>). As a second trick, because we're using <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-ref!">hash-ref!</a></code>, we find the recursive hash if there was already one or create a new one if there wasn't.</p>
<p>So that will recursively build the trie, but what's that bit around it, with another <code>hash-ref!</code>? Well, because <code>for/fold</code> returns the final state of the fold variable, we'll have the innermost hash. So just set the special key <code>end</code> to signify that this is a valid end to a word.</p>
<p>And that's it, we have a trie. Let's see what we can do with it.</p>
<p>Basically, we're going to recur down the characters in our input. At each character, we're going to have three possibilities:</p>
<ul>
  <li>We're at the end of a word</li>
  <li>The consonant is the next character in the output</li>
  <li>A vowel is the next character in the output</li>
</ul>
<p>Around that, we'll have a loop keeping the current remaining characters, the characters in the current word thus far, all of the words we've found thus far (which we could instead have done recursively, although we'd lose <a href="https://en.wikipedia.org/wiki/tail_recursion">tail recursion</a> at that point), and the current location in the dictionary trie we built above. Something like this:</p>
<pre class="scheme"><code>(let loop ([chars (string-&gt;list str)]
           [current-word '()]
           [current-phrase '()]
           [current-dict (dictionary)])
  ; If we're at end of a word, add it and onwards
  ...
  ; Recur if we have a next non-vowel
  ...
  ; Check any vowel-only conditions by recurring
  ...)</code></pre>
<p>To stay consistent, we need to know what we're going to be returning. Let's always return a list of possibilities. If we can't find any word lists at this point, return <code>'()</code>. Otherwise, a list of lists of words.</p>
<p>Assuming that all holds, let's write out each block. First is simple enough. If the <code>current-dict</code> shows the special key <code>end</code>, we have a word. Both the <code>current-word</code> and <code>current-phrase</code> are lists (built in reverse order), so make sure to keep that in mind:</p>
<pre class="scheme"><code>; If we're at end of a word, add it and onwards
(if (and (hash-ref current-dict 'end #f)
         (not (andmap char-vowel? current-word)))
    (loop chars
          '()
          (cons (list-&gt;string (reverse current-word)) current-phrase)
          (dictionary))
    '())</code></pre>
<p>Two possibilities: either we're at the end of the word or we're not. If we are, we don't use up a character, so leave <code>chars</code>. Reset the <code>current-word</code> and add it to <code>current-phrase</code> instead. Likewise, because we've finished the word, we want to reset the <code>dictionary</code> to its original state. Since this function caches, there isn't much of a performance hit to doing it this way.</p>
<p>If not? Well this case doesn't care what's happening. Just return an empty list.</p>
<p>Next case, use the next non-vowel from the input:</p>
<pre class="scheme"><code>; Recur if we have a next non-vowel
(if (and (not (null? chars))
         (hash-ref current-dict (car chars) #f))
    (loop (cdr chars)
          (cons (car chars) current-word)
          current-phrase
          (hash-ref current-dict (car chars)))
    '())</code></pre>
<p>The structure is much the same. If we're not out of characters and the next character is in the <code>current-dict</code> (which is the beauty of the trie: we know right here if we can progress or not), then loop. We eat up a char from <code>chars</code>, adding it to <code>current-word</code> and recurring down the <code>current-dict</code>. The <code>current-phrase</code> is unmodified.</p>
<p>Then, the last case. Since we don't have any vowels, at each point we should be able to insert any of them that makes sense. Like in the previous case, check against the <code>current-dict</code>:</p>
<pre class="scheme"><code>; Check any vowel-only conditions by recurring
(for/list ([c (in-list vowels)]
           #:when (hash-has-key? current-dict c))
  (loop chars
        (cons c current-word)
        current-phrase
        (hash-ref current-dict c)))</code></pre>
<p>The only difference is that this time we don't use up a char from <code>chars</code>, because those are the consonants.</p>
<p>So, that should be all we need, right?</p>
<p>...</p>
<p>Nope!</p>
<p>We forgot pretty much the most important part of recursion--that one part that without which you're guaranteed<span class="footnote"><sup><a href="#footnote-3">[3]</a></sup></span> to never terminate: a base case!</p>
<p>When do we know we can stop? Well, we can only stop when we've used up all of the <code>chars</code>, but that's not it. We also have to make sure that we don't have a current word in progress. So something like this:</p>
<pre class="scheme"><code>; Base case, used the entire input, no pending words
(if (and (null? chars)
         (null? current-word))
    (list (string-join (reverse current-phrase) " "))
    '())</code></pre>
<p>Here we can also put together the phrases in pretty much the same way we did the words. Reverse the list since we built it up tail recursively and stick them together.</p>
<p>So what does it look like all together?</p>
<pre class="scheme"><code>; Take a string of characters sans vowels and figure out all possible phrases that it could have been
(define (reemvowel str)
  (let loop ([chars (string-&gt;list str)]
             [current-word '()]
             [current-phrase '()]
             [current-dict (dictionary)])
    (apply
     append
     ; Base case, used the entire input, no pending words
     (if (and (null? chars)
              (null? current-word))
         (list (string-join (reverse current-phrase) " "))
         '())
     ; If we're at end of a word, add it and onwards
     (if (and (hash-ref current-dict 'end #f)
              (not (andmap char-vowel? current-word)))
         (loop chars
               '()
               (cons (list-&gt;string (reverse current-word)) current-phrase)
               (dictionary))
         '())
     ; Recur if we have a next non-vowel
     (if (and (not (null? chars))
              (hash-ref current-dict (car chars) #f))
         (loop (cdr chars)
               (cons (car chars) current-word)
               current-phrase
               (hash-ref current-dict (car chars)))
         '())
     ; Check any vowel-only conditions by recurring
     (for/list ([c (in-list vowels)]
                #:when (hash-has-key? current-dict c))
       (loop chars
             (cons c current-word)
             current-phrase
             (hash-ref current-dict c))))))</code></pre>
<p>The only new parts should be that <code>(apply append ...)</code> in there. That's to put everything together. Since each of the cases returns a list of phrases, we can just stick them all together.</p>
<p>So let's try it out:</p>
<pre class="scheme"><code>&gt; (reemvowel (disemvowel "this is a sparta"))
...
...
...</code></pre>
<p>Yeah... that's taking a while. Which makes sense if you think about it. With only 8 letters, (<code>"thsssprt"</code>), that's still a heck of a lot of words. As a bit of a side note, you can figure out how many words are made up of each consonant once and all vowels otherwise using a few command line tools <span class="footnote"><sup><a href="#footnote-4">[4]</a></sup></span>:</p>
<pre class="bash"><code>egrep "^[aeiou]*t[aeiou]*$" enable1.txt | wc -l
28</code></pre>
<p>Do the same for the rest of the letters:</p>
<table class="table table-striped">
<tr><td>t</td><td>28</td></tr>
<tr><td>h</td><td>18</td></tr>
<tr><td>s</td><td>21</td></tr>
<tr><td>p</td><td>15</td></tr>
<tr><td>r</td><td>35</td></tr>
</table>
<p>Put that all together, and you have <em>28*18*21*21*21*15*35*28 ≅ 68 billion</em> combinations... and that doesn't even include words with two of the consonants. Or for that matter, words with only vowels...</p>
<p>Wait. Those might cause a problem... Technically, I've already solved it. Did you catch when? Take a look back up at the first subcase, where we were at the end of words:</p>
<pre class="scheme"><code>(not (andmap char-vowel? current-word))</code></pre>
<p>So we can't have a word with all vowels. Technically, this rules out a few particularly useful words like <code>a</code> (along with a few less useful ones), but so it goes.</p>
<p>Anyways, we can't get all of those combinations, so what about a smaller test:</p>
<pre class="scheme"><code>&gt; (reemvowel (disemvowel "hi"))
'("ha" "he" "hi" "ah" "oh" "ooh" "uh")</code></pre>
<p>Seems to be working. Two consonants?</p>
<pre class="scheme"><code>&gt; (reemvowel (disemvowel "good"))
'("go die" "go do" "go idea" "god" "good" "ago die" "ago do" "ago idea")</code></pre>
<p>Now we can get either single letters or doubles. We have the original 'phrase' though, we it seems to be working.</p>
<p>Still, it would be nice to play with longer phrases. How can we do it?</p>
<p>Well, what if we didn't care about finding all of the possible phrases? What if any one of them would be fine? Well, it turns out that's not that big a change to make. We've already done it in a few blog posts before: use <code><a href="http://docs.racket-lang.org/search/index.html?q=let/ec">let/ec</a></code>.</p>
<pre class="scheme"><code>; Take a string of characters sans vowels and figure out a possible phrase
(define (reemvowel/first str)
  (let/ec return
    (let loop ([chars (string-&gt;list str)]
               [current-word '()]
               [current-phrase '()]
               [current-dict (dictionary)])
      ; Out of input and no current word? Found a phrase!
      (when (and (null? chars)
                 (null? current-word))
        (return (string-join (reverse current-phrase) " ")))
      ; If we're at end of a word, add it and onwards
      (when (and (hash-ref current-dict 'end #f)
                 (not (andmap char-vowel? current-word)))
        (loop chars
              '()
              (cons (list-&gt;string (reverse current-word)) current-phrase)
              (dictionary)))
      ; Recur if we have a next non-vowel
      (when (and (not (null? chars))
                 (hash-ref current-dict (car chars) #f))
        (loop (cdr chars)
              (cons (car chars) current-word)
              current-phrase
              (hash-ref current-dict (car chars))))
      ; Check any vowel-only conditions by recurring
      (for ([c (in-list (shuffle vowels))]
            #:when (hash-has-key? current-dict c))
        (loop chars
              (cons c current-word)
              current-phrase
              (hash-ref current-dict c))))))</code></pre>
<p>We no longer care what're we're returning, so we don't need all of those <code>if</code>s. Instead, we just keep going until we find a valid string and <code>return</code> it. But strictly speaking, it's not a 'return', it's a <a href="https://en.wikipedia.org/wiki/continuation">continuation</a>. For all Racket cares, we could have just as well have called it <code>steve</code> or <code>ዱᓹዲțũഓળƝف</code><span class="footnote"><sup><a href="#footnote-5">[5]</a></sup></span><span class="footnote"><sup><a href="#footnote-6">[6]</a></sup></span><span class="footnote"><sup><a href="#footnote-7">[7]</a></sup></span>. In any case, that should run rather faster:</p>
<pre class="scheme"><code>&gt; (reemvowel/first (disemvowel "this is sparta"))
"thae sei si sprout"
&gt; (reemvowel/first (disemvowel "hello world"))
"he lo lwei rule do"</code></pre>
<p>There's still a bit of a bias that I'd like to get rid of<span class="footnote"><sup><a href="#footnote-8">[8]</a></sup></span>, but I think that's good enough for a post. Like always, you can get the whole source on GitHub: <a href="https://github.com/jpverkamp/small-projects/blob/master/blog/disreemvowel.rkt">disreemvowel.rkt</a></p>
                </div>
                <div class="entry-footnotes">
                        <div id="footnotes"><ol><li><a name="footnote-1"></a>Also, it's a great excuse for a crazy title</li><li><a name="footnote-2"></a>Exercise for the reader: which is which :)</li><li><a name="footnote-3"></a>Well, most of the time...</li><li><a name="footnote-4"></a>I'm sure there's a better way to do that</li><li><a name="footnote-5"></a>Racket uses Unicode by default, it's awesome</li><li><a name="footnote-6"></a><code>(list->string (for/list ([i (in-range 10)]) (integer->char (random #x1800))))</code></li><li><a name="footnote-7"></a>I hope that doesn't actually mean anything...</li><li><a name="footnote-8"></a>Exercise for the reader...</li></ol></div>
                </div>

                <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "jverkamp";
var disqus_title = "Dis/re-emvowelification";
var disqus_url = "http://blog.jverkamp.com/2014/02/27/disre-emvowelification/";
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </article>

        <footer class="container" role="contentinfo">
                <nav class="navbar navbar-default" role="navigation"><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/02/27/crossing-hands">← Crossing hands</a></li><li><a href="http://blog.jverkamp.com/category/archives">Archives</a></li><li><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees">Brownian trees →</a></li></ul><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/02/27/crossing-hands">← Crossing hands</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/2014/03/11/brownian-trees">Brownian trees →</a></li></ul></nav>

                <div class="legal">
                        <a href="http://blog.jverkamp.com/feed/atom.xml">feed <img style="border: 0;" src="http://blog.jverkamp.com/rss.png" /></a><br />
                        All posts unless otherwise mentioned are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
                        Any source code unless otherwise mentioned is licensed under the <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
                </div>
        </footer>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53688146-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>