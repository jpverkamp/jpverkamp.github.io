<!doctype html><html><head><title>Dis/re-emvowelification – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet><link rel=stylesheet href=/custom.css defer><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Dis/re-emvowelification</h1><div class=entry-meta><span class=entry-date>2014-02-27</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/02/27/crossing-hands/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/03/11/brownian-trees/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/02/27/crossing-hands/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/03/11/brownian-trees/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2013/12/23/edges-to-adjacency/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/daily-programmer>Daily Programmer</a><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/02/16/exploring-parallelism-in-racket-with-sha-512-mining/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/dictionary>Dictionary</a></li><li><a href=https://blog.jverkamp.com/2013/02/13/predecessor-and-successor-in-a-binary-search-tree/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/trees>Trees</a><a href=https://blog.jverkamp.com/2014/03/11/brownian-trees/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/trie>Trie</a></li><li><a href=https://blog.jverkamp.com/2013/03/28/path-to-philosophy/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/word-games>Word Games</a><a href=https://blog.jverkamp.com/2014/08/13/number-words/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/02/27/crossing-hands/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/03/11/brownian-trees/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/02/27/crossing-hands/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/03/11/brownian-trees/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>So far this week we&rsquo;ve had a pair of related posts at the DailyProgrammer subreddit<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><ul><li><a href=http://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/>[02/24/14] Challenge #149 [Easy] Disemvoweler</a></li><li><a href=http://www.reddit.com/r/dailyprogrammer/comments/1yzlde/022614_challenge_150_intermediate_reemvoweler_1/>[02/26/14] Challenge #150 [Intermediate] Re-emvoweler 1</a></li></ul><p>Basically, if you&rsquo;re given a string with vowels, take them out. If you&rsquo;re given one without vowels, put them back in. One of the two is certainly easier than the other<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. :)</p><p>To start off, we need a definition for what exactly a vowel is. That&rsquo;s a bit of a question in and of itself, but we&rsquo;ll go with the easiest definition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; For this case, y/w are not vowels. Also, latin characters only 😄</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>vowels <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>#\a</span> <span style=color:#e6db74>#\e</span> <span style=color:#e6db74>#\i</span> <span style=color:#e6db74>#\o</span> <span style=color:#e6db74>#\u</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>char-vowel?</span> c) (member c vowels))
</span></span></code></pre></div><p>Straight forward enough. And it turns out that&rsquo;s enough to write the first function of the day:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Remove all vowels and non-alphabetic characters</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>disemvowel</span> str)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>list-&gt;string</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/list</span> ([c (<span style=color:#a6e22e>in-string</span> str)]
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:when (<span style=color:#66d9ef>and </span>(char-alphabetic? c)
</span></span><span style=display:flex><span>                          (not (<span style=color:#a6e22e>char-vowel?</span> c))))
</span></span><span style=display:flex><span>     c)))
</span></span></code></pre></div><p>A few test cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;hello world&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;hllwrld&#34;</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;this is a test!&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;thsstst&#34;</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;this is a sparta&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;thsssprt&#34;</span>
</span></span></code></pre></div><p>Seems good. It turns out that there&rsquo;s a reason this is an easy challenge. Now to the more <del>difficult</del> fun one. Like many of the previous <a href=http://blog.jverkamp.com/tag/word-games/>word games</a> I&rsquo;ve worked out, the data structure we need is a <a href=https://en.wikipedia.org/wiki/trie>trie</a>. Since it&rsquo;s been a while, I went ahead and re-implemented one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Load a dictionary as a trie, cache the result</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>dictionary
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>([rhash <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (not rhash)
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>set! </span>rhash (<span style=color:#a6e22e>make-hash</span>))
</span></span><span style=display:flex><span>        (with-input-from-file <span style=color:#e6db74>&#34;enable1.txt&#34;</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>thunk</span>
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>for</span> ([word (<span style=color:#a6e22e>in-lines</span>)])
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-ref!</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>for/fold</span> ([rhash rhash]) ([c (<span style=color:#a6e22e>in-string</span> word)])
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>hash-ref!</span> rhash c (<span style=color:#a6e22e>make-hash</span>)))
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;end</span>
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>#t</span>)))))
</span></span><span style=display:flex><span>      rhash)))
</span></span></code></pre></div><p>There&rsquo;s some pretty strange stuff going on there, so let&rsquo;s take it one chunk at a time. The outermost part is just caching the result. We&rsquo;ve done that before. Inside of the <code>when</code>, we first create the hash, then open the dictionary. It&rsquo;s this part that&rsquo;s particularly fancy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>for</span> ([word (<span style=color:#a6e22e>in-lines</span>)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-ref!</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/fold</span> ([rhash rhash]) ([c (<span style=color:#a6e22e>in-string</span> word)])
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>hash-ref!</span> rhash c (<span style=color:#a6e22e>make-hash</span>)))
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;end</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>#t</span>))
</span></span></code></pre></div><p>What&rsquo;s that do? Well, as is often the case in Scheme, start on the inside:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>for/fold</span> ([rhash rhash]) ([c (<span style=color:#a6e22e>in-string</span> word)])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>hash-ref!</span> rhash c (<span style=color:#a6e22e>make-hash</span>)))
</span></span></code></pre></div><p><code>for/fold</code> will loop over the parameters in the second set (characters <code>c</code> in this case) using each body to update the first variable (the recursive part of the hash <code>rhash</code>). As a second trick, because we&rsquo;re using <code><a href="http://docs.racket-lang.org/search/index.html?q=hash-ref!">hash-ref!</a></code>
, we find the recursive hash if there was already one or create a new one if there wasn&rsquo;t.</p><p>So that will recursively build the trie, but what&rsquo;s that bit around it, with another <code>hash-ref!</code>? Well, because <code>for/fold</code> returns the final state of the fold variable, we&rsquo;ll have the innermost hash. So just set the special key <code>end</code> to signify that this is a valid end to a word.</p><p>And that&rsquo;s it, we have a trie. Let&rsquo;s see what we can do with it.</p><p>Basically, we&rsquo;re going to recur down the characters in our input. At each character, we&rsquo;re going to have three possibilities:</p><ul><li>We&rsquo;re at the end of a word</li><li>The consonant is the next character in the output</li><li>A vowel is the next character in the output</li></ul><p>Around that, we&rsquo;ll have a loop keeping the current remaining characters, the characters in the current word thus far, all of the words we&rsquo;ve found thus far (which we could instead have done recursively, although we&rsquo;d lose <a href=https://en.wikipedia.org/wiki/tail%20recursion>tail recursion</a> at that point), and the current location in the dictionary trie we built above. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>let </span>loop ([chars (string-&gt;list str)]
</span></span><span style=display:flex><span>           [current-word <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>           [current-phrase <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>           [current-dict (<span style=color:#a6e22e>dictionary</span>)])
</span></span><span style=display:flex><span>  <span style=color:#75715e>; If we&#39;re at end of a word, add it and onwards</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Recur if we have a next non-vowel</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Check any vowel-only conditions by recurring</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>To stay consistent, we need to know what we&rsquo;re going to be returning. Let&rsquo;s always return a list of possibilities. If we can&rsquo;t find any word lists at this point, return <code>'()</code>. Otherwise, a list of lists of words.</p><p>Assuming that all holds, let&rsquo;s write out each block. First is simple enough. If the <code>current-dict</code> shows the special key <code>end</code>, we have a word. Both the <code>current-word</code> and <code>current-phrase</code> are lists (built in reverse order), so make sure to keep that in mind:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; If we&#39;re at end of a word, add it and onwards</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>hash-ref</span> current-dict <span style=color:#e6db74>&#39;end</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>         (not (<span style=color:#a6e22e>andmap</span> char-vowel? current-word)))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>          (cons (list-&gt;string (reverse current-word)) current-phrase)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>dictionary</span>))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#39;</span>())
</span></span></code></pre></div><p>Two possibilities: either we&rsquo;re at the end of the word or we&rsquo;re not. If we are, we don&rsquo;t use up a character, so leave <code>chars</code>. Reset the <code>current-word</code> and add it to <code>current-phrase</code> instead. Likewise, because we&rsquo;ve finished the word, we want to reset the <code>dictionary</code> to its original state. Since this function caches, there isn&rsquo;t much of a performance hit to doing it this way.</p><p>If not? Well this case doesn&rsquo;t care what&rsquo;s happening. Just return an empty list.</p><p>Next case, use the next non-vowel from the input:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Recur if we have a next non-vowel</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(not (null? chars))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars) <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>loop</span> (cdr chars)
</span></span><span style=display:flex><span>          (cons (car chars) current-word)
</span></span><span style=display:flex><span>          current-phrase
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars)))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#39;</span>())
</span></span></code></pre></div><p>The structure is much the same. If we&rsquo;re not out of characters and the next character is in the <code>current-dict</code> (which is the beauty of the trie: we know right here if we can progress or not), then loop. We eat up a char from <code>chars</code>, adding it to <code>current-word</code> and recurring down the <code>current-dict</code>. The <code>current-phrase</code> is unmodified.</p><p>Then, the last case. Since we don&rsquo;t have any vowels, at each point we should be able to insert any of them that makes sense. Like in the previous case, check against the <code>current-dict</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Check any vowel-only conditions by recurring</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>for/list</span> ([c (<span style=color:#a6e22e>in-list</span> vowels)]
</span></span><span style=display:flex><span>           <span style=color:#f92672>#</span>:when (<span style=color:#a6e22e>hash-has-key?</span> current-dict c))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>        (cons c current-word)
</span></span><span style=display:flex><span>        current-phrase
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>hash-ref</span> current-dict c)))
</span></span></code></pre></div><p>The only difference is that this time we don&rsquo;t use up a char from <code>chars</code>, because those are the consonants.</p><p>So, that should be all we need, right?</p><p>&mldr;</p><p>Nope!</p><p>We forgot pretty much the most important part of recursion&ndash;that one part that without which you&rsquo;re guaranteed<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> to never terminate: a base case!</p><p>When do we know we can stop? Well, we can only stop when we&rsquo;ve used up all of the <code>chars</code>, but that&rsquo;s not it. We also have to make sure that we don&rsquo;t have a current word in progress. So something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Base case, used the entire input, no pending words</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(null? chars)
</span></span><span style=display:flex><span>         (null? current-word))
</span></span><span style=display:flex><span>    (list (<span style=color:#a6e22e>string-join</span> (reverse current-phrase) <span style=color:#e6db74>&#34; &#34;</span>))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#39;</span>())
</span></span></code></pre></div><p>Here we can also put together the phrases in pretty much the same way we did the words. Reverse the list since we built it up tail recursively and stick them together.</p><p>So what does it look like all together?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Take a string of characters sans vowels and figure out all possible phrases that it could have been</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>reemvowel</span> str)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([chars (string-&gt;list str)]
</span></span><span style=display:flex><span>             [current-word <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>             [current-phrase <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>             [current-dict (<span style=color:#a6e22e>dictionary</span>)])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>apply</span>
</span></span><span style=display:flex><span>     append
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Base case, used the entire input, no pending words</span>
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(null? chars)
</span></span><span style=display:flex><span>              (null? current-word))
</span></span><span style=display:flex><span>         (list (<span style=color:#a6e22e>string-join</span> (reverse current-phrase) <span style=color:#e6db74>&#34; &#34;</span>))
</span></span><span style=display:flex><span>         <span style=color:#f92672>&#39;</span>())
</span></span><span style=display:flex><span>     <span style=color:#75715e>; If we&#39;re at end of a word, add it and onwards</span>
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>hash-ref</span> current-dict <span style=color:#e6db74>&#39;end</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>              (not (<span style=color:#a6e22e>andmap</span> char-vowel? current-word)))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>               <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>               (cons (list-&gt;string (reverse current-word)) current-phrase)
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>dictionary</span>))
</span></span><span style=display:flex><span>         <span style=color:#f92672>&#39;</span>())
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Recur if we have a next non-vowel</span>
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if </span>(<span style=color:#66d9ef>and </span>(not (null? chars))
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars) <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>loop</span> (cdr chars)
</span></span><span style=display:flex><span>               (cons (car chars) current-word)
</span></span><span style=display:flex><span>               current-phrase
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars)))
</span></span><span style=display:flex><span>         <span style=color:#f92672>&#39;</span>())
</span></span><span style=display:flex><span>     <span style=color:#75715e>; Check any vowel-only conditions by recurring</span>
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>for/list</span> ([c (<span style=color:#a6e22e>in-list</span> vowels)]
</span></span><span style=display:flex><span>                <span style=color:#f92672>#</span>:when (<span style=color:#a6e22e>hash-has-key?</span> current-dict c))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>             (cons c current-word)
</span></span><span style=display:flex><span>             current-phrase
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>hash-ref</span> current-dict c))))))
</span></span></code></pre></div><p>The only new parts should be that <code>(apply append ...)</code> in there. That&rsquo;s to put everything together. Since each of the cases returns a list of phrases, we can just stick them all together.</p><p>So let&rsquo;s try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>reemvowel</span> (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;this is a sparta&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Yeah&mldr; that&rsquo;s taking a while. Which makes sense if you think about it. With only 8 letters, (<code>"thsssprt"</code>), that&rsquo;s still a heck of a lot of words. As a bit of a side note, you can figure out how many words are made up of each consonant once and all vowels otherwise using a few command line tools <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>egrep <span style=color:#e6db74>&#34;^[aeiou]*t[aeiou]*</span>$<span style=color:#e6db74>&#34;</span> enable1.txt | wc -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>28</span>
</span></span></code></pre></div><p>Do the same for the rest of the letters:</p><table><thead><tr><th>t</th><th>28</th></tr></thead><tbody><tr><td>h</td><td>18</td></tr><tr><td>s</td><td>21</td></tr><tr><td>p</td><td>15</td></tr><tr><td>r</td><td>35</td></tr></tbody></table><p>Put that all together, and you have <em>28</em>18<em>21</em>21<em>21</em>15<em>35</em>28 ≅ 68 billion* combinations&mldr; and that doesn&rsquo;t even include words with two of the consonants. Or for that matter, words with only vowels&mldr;</p><p>Wait. Those might cause a problem&mldr; Technically, I&rsquo;ve already solved it. Did you catch when? Take a look back up at the first subcase, where we were at the end of words:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(not (<span style=color:#a6e22e>andmap</span> char-vowel? current-word))
</span></span></code></pre></div><p>So we can&rsquo;t have a word with all vowels. Technically, this rules out a few particularly useful words like <code>a</code> (along with a few less useful ones), but so it goes.</p><p>Anyways, we can&rsquo;t get all of those combinations, so what about a smaller test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>reemvowel</span> (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;hi&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;ha&#34;</span> <span style=color:#e6db74>&#34;he&#34;</span> <span style=color:#e6db74>&#34;hi&#34;</span> <span style=color:#e6db74>&#34;ah&#34;</span> <span style=color:#e6db74>&#34;oh&#34;</span> <span style=color:#e6db74>&#34;ooh&#34;</span> <span style=color:#e6db74>&#34;uh&#34;</span>)
</span></span></code></pre></div><p>Seems to be working. Two consonants?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>reemvowel</span> (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;good&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>&#34;go die&#34;</span> <span style=color:#e6db74>&#34;go do&#34;</span> <span style=color:#e6db74>&#34;go idea&#34;</span> <span style=color:#e6db74>&#34;god&#34;</span> <span style=color:#e6db74>&#34;good&#34;</span> <span style=color:#e6db74>&#34;ago die&#34;</span> <span style=color:#e6db74>&#34;ago do&#34;</span> <span style=color:#e6db74>&#34;ago idea&#34;</span>)
</span></span></code></pre></div><p>Now we can get either single letters or doubles. We have the original &lsquo;phrase&rsquo; though, we it seems to be working.</p><p>Still, it would be nice to play with longer phrases. How can we do it?</p><p>Well, what if we didn&rsquo;t care about finding all of the possible phrases? What if any one of them would be fine? Well, it turns out that&rsquo;s not that big a change to make. We&rsquo;ve already done it in a few blog posts before: use <code><a href="http://docs.racket-lang.org/search/index.html?q=let/ec">let/ec</a></code>
.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Take a string of characters sans vowels and figure out a possible phrase</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>reemvowel/first</span> str)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>let/ec</span> return
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([chars (string-&gt;list str)]
</span></span><span style=display:flex><span>               [current-word <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>               [current-phrase <span style=color:#f92672>&#39;</span>()]
</span></span><span style=display:flex><span>               [current-dict (<span style=color:#a6e22e>dictionary</span>)])
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Out of input and no current word? Found a phrase!</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(null? chars)
</span></span><span style=display:flex><span>                 (null? current-word))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>return</span> (<span style=color:#a6e22e>string-join</span> (reverse current-phrase) <span style=color:#e6db74>&#34; &#34;</span>)))
</span></span><span style=display:flex><span>      <span style=color:#75715e>; If we&#39;re at end of a word, add it and onwards</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(<span style=color:#a6e22e>hash-ref</span> current-dict <span style=color:#e6db74>&#39;end</span> <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>                 (not (<span style=color:#a6e22e>andmap</span> char-vowel? current-word)))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>              <span style=color:#f92672>&#39;</span>()
</span></span><span style=display:flex><span>              (cons (list-&gt;string (reverse current-word)) current-phrase)
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>dictionary</span>)))
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Recur if we have a next non-vowel</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (<span style=color:#66d9ef>and </span>(not (null? chars))
</span></span><span style=display:flex><span>                 (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars) <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> (cdr chars)
</span></span><span style=display:flex><span>              (cons (car chars) current-word)
</span></span><span style=display:flex><span>              current-phrase
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-ref</span> current-dict (car chars))))
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Check any vowel-only conditions by recurring</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for</span> ([c (<span style=color:#a6e22e>in-list</span> (<span style=color:#a6e22e>shuffle</span> vowels))]
</span></span><span style=display:flex><span>            <span style=color:#f92672>#</span>:when (<span style=color:#a6e22e>hash-has-key?</span> current-dict c))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>loop</span> chars
</span></span><span style=display:flex><span>              (cons c current-word)
</span></span><span style=display:flex><span>              current-phrase
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>hash-ref</span> current-dict c))))))
</span></span></code></pre></div><p>We no longer care what&rsquo;re we&rsquo;re returning, so we don&rsquo;t need all of those <code>if</code>s. Instead, we just keep going until we find a valid string and <code>return</code> it. But strictly speaking, it&rsquo;s not a &lsquo;return&rsquo;, it&rsquo;s a <a href=https://en.wikipedia.org/wiki/continuation>continuation</a>. For all Racket cares, we could have just as well have called it <code>steve</code> or <code>ዱᓹዲțũഓળƝف</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup><sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. In any case, that should run rather faster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>reemvowel/first</span> (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;this is sparta&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;thae sei si sprout&#34;</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>reemvowel/first</span> (<span style=color:#a6e22e>disemvowel</span> <span style=color:#e6db74>&#34;hello world&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;he lo lwei rule do&#34;</span>
</span></span></code></pre></div><p>There&rsquo;s still a bit of a bias that I&rsquo;d like to get rid of<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>, but I think that&rsquo;s good enough for a post. Like always, you can get the whole source on GitHub: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/disreemvowel.rkt>disreemvowel.rkt</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Also, it&rsquo;s a great excuse for a crazy title&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Exercise for the reader: which is which 😄&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Well, most of the time&mldr;&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>I&rsquo;m sure there&rsquo;s a better way to do that&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Racket uses Unicode by default, it&rsquo;s awesome&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p><code>(list->string (for/list ([i (in-range 10)]) (integer->char (random #x1800))))</code>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>I hope that doesn&rsquo;t actually mean anything&mldr;&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p>Exercise for the reader&mldr;&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script><script defer src=/custom.js></script></body></html>