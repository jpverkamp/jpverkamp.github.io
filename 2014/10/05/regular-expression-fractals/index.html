<!doctype html><html><head><title>Regular Expression Fractals – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>Regular Expression Fractals</h1><div class=entry-meta><span class=entry-date>2014-10-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/09/15/look-and-say/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/daily-programmer>Daily Programmer</a><a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/09/15/look-and-say/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2021/08/17/immutable.js-solvers/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/09/15/look-and-say/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/cellular-automata>Cellular Automata</a><a href=https://blog.jverkamp.com/2015/01/09/let-it-snow/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/fractals>Fractals</a><a href=https://blog.jverkamp.com/2014/11/04/clockception/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphics>Graphics</a><a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/09/17/invader-fractals/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/10/28/tile-puzzle/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Oops, turns out I haven&rsquo;t had a post in a good long while. Before it gets even longer, I figure that I should take one off my backlog and just write it up, even if it is a little on the shorter side.</p><p>Today&rsquo;s post was inspired by this post on /r/dailyprogrammer a month ago today:
<a href=https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/9052014_challenge_178_hard_regular_expression/>Challenge #178 [Hard] Regular Expression Fractals</a>. The basic idea is that you are going to take a rectangular region and divide it into four quadrants, again and again, recording the path as you go (images from that post):</p><p><figure><img src=/embeds/2014/step-1.png></figure><figure><img src=/embeds/2014/step-2.png></figure><figure><img src=/embeds/2014/step-3.png></figure></p><p>At the end, each point in the image will have a &lsquo;path&rsquo; of decisions that got you there, making a string of the numbers 1, 2, 3, and 4.</p><p><figure><img src=/embeds/2014/step-4.png></figure><figure><img src=/embeds/2014/step-5.png></figure><figure><img src=/embeds/2014/step-6.png></figure></p><p>How does that translate into code?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Generate a fractal by matching a recursive path into an image</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>regex-fractal</span> regex size)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>flomap-&gt;bitmap</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>build-flomap*</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span> size size
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>λ</span> (<span style=color:#a6e22e>x</span> y)
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>let </span>loop ([t <span style=color:#ae81ff>0</span>] [l <span style=color:#ae81ff>0</span>] [s size] [path <span style=color:#e6db74>&#34;&#34;</span>])
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; If we&#39;re at the last level, white, otherwise black</span>
</span></span><span style=display:flex><span>          [(&lt;= s <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>             [(<span style=color:#a6e22e>regexp-match</span> regex path) <span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>             [<span style=color:#66d9ef>else </span>                     <span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>)])]
</span></span><span style=display:flex><span>          <span style=color:#75715e>; Otherwise, divide the region into four subregions</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>; Recur into whichever our current pixel is in</span>
</span></span><span style=display:flex><span>          [else
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>define </span>s/2 (quotient s <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>define </span>x-mid (+ l s/2))
</span></span><span style=display:flex><span>           (<span style=color:#66d9ef>define </span>y-mid (+ t s/2))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>loop</span>
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>if </span>(&lt; y y-mid) t y-mid)
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>if </span>(&lt; x x-mid) l x-mid)
</span></span><span style=display:flex><span>            s/2
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>~a</span> path
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>match</span> (list (&lt; y y-mid) (&lt; x x-mid))
</span></span><span style=display:flex><span>                  [<span style=color:#f92672>&#39;</span>(<span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#t</span>) <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>                  [<span style=color:#f92672>&#39;</span>(<span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#f</span>) <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                  [<span style=color:#f92672>&#39;</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#t</span>) <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>                  [<span style=color:#f92672>&#39;</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span>) <span style=color:#ae81ff>4</span>])))]))))))
</span></span></code></pre></div><p>That&rsquo;s actually pretty close to a lot of the fractal code we&rsquo;ve been writing recently. And it generates some pretty cool images already:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>regex-fractal</span> <span style=color:#f92672>#</span>px<span style=color:#e6db74>&#34;(13|31|24|42)&#34;</span> <span style=color:#ae81ff>256</span>)
</span></span></code></pre></div><figure><img src=/embeds/2014/example-256.png></figure><p>But we can do a little better than that. Let&rsquo;s parameterize a few things:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#66d9ef>define </span>current-size     (<span style=color:#a6e22e>make-parameter</span> <span style=color:#ae81ff>64</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>current-coloring (<span style=color:#a6e22e>make-parameter</span> (<span style=color:#a6e22e>thunk*</span> <span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>current-mode     (<span style=color:#a6e22e>make-parameter</span> <span style=color:#e6db74>&#39;short</span>))
</span></span></code></pre></div><p>Specifically, we&rsquo;ll pull the size out, but also add two more parameters. A mode to short circuit (so that as soon as the pattern matches, return, rather than calculating the entire depth of the image) and another to color the pixel based on a specific match. As an example coloring, consider this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Get the maximum path length; useful for making gradients</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>size-&gt;path-length</span> size)
</span></span><span style=display:flex><span>  (inexact-&gt;exact (floor (/ (log size) (log <span style=color:#ae81ff>2</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Color a pixel based on how long of a match group we have</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>color-by-length</span> m)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>l (string-length (car m)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>p (<span style=color:#a6e22e>size-&gt;path-length</span> (<span style=color:#a6e22e>current-size</span>)))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>(= l p)
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#39;#</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>vector</span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>if </span>(&gt;= (length m) <span style=color:#ae81ff>3</span>) (/ (string-length (list-ref m <span style=color:#ae81ff>2</span>)) p) <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>if </span>(&gt;= (length m) <span style=color:#ae81ff>2</span>) (/ (string-length (list-ref m <span style=color:#ae81ff>1</span>)) p) <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>if </span>(&gt;= (length m) <span style=color:#ae81ff>4</span>) (/ (string-length (list-ref m <span style=color:#ae81ff>3</span>)) p) <span style=color:#ae81ff>0</span>))))
</span></span></code></pre></div><p>Now, let&rsquo;s take another example, one where the matching group must contain a 1. But now, color based on how much of the path is before the one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>parameterize</span> ([current-size <span style=color:#ae81ff>256</span>]
</span></span><span style=display:flex><span>               [current-coloring color-by-length]
</span></span><span style=display:flex><span>               [current-mode <span style=color:#e6db74>&#39;short</span>])
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>regex-fractal</span> <span style=color:#f92672>#</span>px<span style=color:#e6db74>&#34;(.*)1&#34;</span>))
</span></span></code></pre></div><figure><img src=/embeds/2014/color-example-256.png></figure><p>Very cool.</p><p>After that, I just collected and made up a bunch of colorings and regular expressions and generate all of the images. Check the <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt>full source</a> on GitHub for details, but basically I have three colorings: a default white only, the length based coloring above, and another which matches the most common color in a match. Then I have about two dozen regular expression.</p><p>Then I wrote a quick loop that will generate all images in both modes (short circuiting and long), with all three colorings. It&rsquo;s a lot of images&mldr; Here are some of my favorites:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>demo</span> <span style=color:#e6db74>&#34;test256&#34;</span> <span style=color:#ae81ff>256</span>)
</span></span></code></pre></div><p>First, a basic <a href=https://en.wikipedia.org/wiki/Sierpinski%20triangle>Sierpinski triangle</a> <code>1</code>:</p><figure><img src=/embeds/2014/sierpinski_full_by-length_256.png></figure><p>But if you turn on most common color, you see that each color sticks to it&rsquo;s own color (a pattern we&rsquo;ll see oft repeated):</p><figure><img src=/embeds/2014/sierpinski_full_common-voting_256.png></figure><p>What&rsquo;s even more interesting is when you switch to &lsquo;short mode&rsquo;. Since we&rsquo;ll stop recurring as soon as we see a 1, you get blocks rather than each individual pixel colored:</p><figure><img src=/embeds/2014/sierpinski_short_common-voting_256.png></figure><p>Next, four corners. Basically, look for repeated patterns of a single digit: <code>((.)(\\2*))</code>. That should mean that we go out to the four corners, each with its own color:</p><figure><img src=/embeds/2014/four-corners_full_common-voting_256.png></figure><p>Next, split the region into left and right halves, by checking if a 1 or 2 appears first: <code>^[34]*2(.*)</code>. If it&rsquo;s a 2, mark it, if it&rsquo;s a 1, do not.</p><figure><img src=/embeds/2014/left-right_full_by-length_256.png></figure><p>Next, a nice jagged change on the original Sierpinski, match anything with either a 1 or a 2 (or both): <code>(12)</code></p><figure><img src=/embeds/2014/jagged_full_default_256.png></figure><p>Or, similarly, make two Sierpinskis by matching patterns where there&rsquo;s both a 1 and a 2: <code>(1.*2|2.*1)</code>:</p><figure><img src=/embeds/2014/double-sierpinski_full_default_256.png></figure><figure><img src=/embeds/2014/double-sierpinski_full_by-length_256.png></figure><p>Next, match patterns where all 1s (if any) occur before all 2s: <code>^[34]*[134]*[34]*[234]*[34]*$</code></p><figure><img src=/embeds/2014/ones-then-twos_full_default_256.png></figure><p>Or you can invert the Sierpinski triangle by making sure there are <em>no</em> ones at all: <code>^[^1]*$</code></p><figure><img src=/embeds/2014/no-one_full_common-voting_256.png></figure><p>Or go really crazy and do some math. For example, finding all sequences with an even sum: <code>^(2|4|[13][24]*[13])*$</code></p><figure><img src=/embeds/2014/even-sum_full_by-length_256.png></figure><p>Next, we have a few from the comments on the <a href=https://www.reddit.com/r/dailyprogrammer/comments/2fkh8u/>original post</a>.</p><p>Some nice curls: <code>[13][24][^1][^2][^3][^4]</code></p><figure><img src=/embeds/2014/curls_full_common-voting_256.png></figure><p>Patterns where you have the same pattern repeated at least three times, but with other random bits in between: <code>(.)\\1..\\1</code></p><p><figure><img src=/embeds/2014/self-similar_full_default_256.png></figure><br><figure><img src=/embeds/2014/self-similar_full_common-voting_256.png></figure></p><p>Or you can draw some nice boxes: <code>(?:13|31)(.*)</code></p><p><figure><img src=/embeds/2014/boxes_short_default_256.png></figure><figure><img src=/embeds/2014/boxes_full_by-length_256.png></figure></p><p>A nice recursive outline (reminds me of the <a href=https://blog.jverkamp.com/2014/09/16/fractal-invaders/>Fractal Invaders</a>): <code>^(1[124]|2[14]|4[12]|31)*$</code></p><figure><img src=/embeds/2014/outlined_full_by-length_256.png></figure><p>Figure eights: <code>^(?:..)*(?:[13][13]|[24][24])((?:..)*)$</code></p><figure><img src=/embeds/2014/figure-eights_full_by-length_256.png></figure><p>And finally, some nice diagonal lines, by making sure the top left/bottom right are before the top right/bottom left: <code>^[13]*[24]*$</code>:</p><figure><img src=/embeds/2014/scanlines_full_common-voting_256.png></figure><p>And there you have it. Any other awesome patterns you come up with? Share them below. I&rsquo;d love to see them.</p><p>As always, the full source is available on GitHub if you&rsquo;d like to play with it: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/regex-fractal.rkt>regex-fractal.rkt</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>