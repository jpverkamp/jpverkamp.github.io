<!doctype html><html><head><title>Cracker Barrel Peg Game â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script defer src=/jquery_6894410585563545744.min.cc1cade18c999752b7befe111634889dca8d89b24923775954ecebc68c54fcd3.js integrity="sha256-zByt4YyZl1K3vv4RFjSIncqNibJJI3dZVOzrxoxU/NM="></script>
<script defer src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg="></script>
<script defer src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM="></script>
<script defer src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY="></script>
<script defer src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90="></script>
<script defer src=/custom.js></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="></script><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="></script><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="></script><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="></script><link rel=stylesheet href=/custom.css><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Cracker Barrel Peg Game</h1><div class=entry-meta><span class=entry-date>2014-07-05</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/05/02/trigonometric-triangle-trouble/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backtracking>Backtracking</a><a href=https://blog.jverkamp.com/2014/09/03/chess-puzzles-n-queens/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/07/19/racket-roguelike-post-mortem/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/games>Games</a><a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/01/15/graph-coloring/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graph-theory>Graph Theory</a><a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link></a></li><li><a class=taxonomy-value href=/programming/topics/heuristics>Heuristics</a><a href=https://blog.jverkamp.com/2014/09/04/chess-puzzles-knights-tour/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/series/cracker-barrel-peg-game>Cracker Barrel Peg Game</a><a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/07/09/cracker-barrel-peg-game-part-2/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Ever been to <a href=http://www.crackerbarrel.com/>Cracker Barrel</a>? Remember that <a href=http://shop.crackerbarrel.com/Peg-Game/dp/B0050PMMQA>peg game</a>? It seems that rather a few people are interested in how to solve it: <a href="https://www.google.com/?q=cracker+barrel+peg+game">Google</a>. Let&rsquo;s do that.</p><p>Let&rsquo;s start with a bit of ground work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Puzzles are represented as a 15 element vector (#t for pegs)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; but can be entered as a 15 bit integer (1 for pegs)</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>struct</span> puzzle (<span style=color:#a6e22e>data</span>) <span style=color:#f92672>#</span>:transparent)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>make-puzzle</span> v)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and </span>(integer? v) (&lt;= <span style=color:#ae81ff>0</span> v <span style=color:#ae81ff>32767</span>))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>puzzle</span> (<span style=color:#a6e22e>list-&gt;vector</span>
</span></span><span style=display:flex><span>              (map (<span style=color:#a6e22e>curry</span> eq? <span style=color:#e6db74>#\1</span>)
</span></span><span style=display:flex><span>                   (reverse (string-&gt;list (<span style=color:#a6e22e>~a</span> (number-&gt;string v <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                                              <span style=color:#f92672>#</span>:width <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>                                              <span style=color:#f92672>#</span>:align <span style=color:#e6db74>&#39;right</span>
</span></span><span style=display:flex><span>                                              <span style=color:#f92672>#</span>:pad-string <span style=color:#e6db74>&#34;0&#34;</span>))))))]
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and </span>(vector? v) (= <span style=color:#ae81ff>15</span> (vector-length v)))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>puzzle</span> v)]
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and </span>(list? v) (length v <span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>puzzle</span> (list-&gt;vector v))]))
</span></span></code></pre></div><p>It&rsquo;s a bit heavier than it needs to be (in order to support multiple datatypes), but that saved me all sorts of time in testing. It&rsquo;s a lot easier to enter a puzzle like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>make-puzzle</span> <span style=color:#f92672>#</span>b111110010000000)
</span></span></code></pre></div><p>Rather than:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>make-puzzle</span> <span style=color:#f92672>&#39;#</span>(<span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#f</span> <span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#t</span> <span style=color:#66d9ef>#t</span>))
</span></span></code></pre></div><p>(Note that the ordering is opposite. The highest bit is the last peg, while the first vector is the first peg. This is so that puzzle 1 is peg 1 and so on.)</p><p>Anyways.</p><p>Next, we need to be able to visualize what we&rsquo;re working with. You can always see the sequence of pegs, but without putting them in their proper triangular shape, it&rsquo;s a bit hard to tell what exactly is going on. So first, let&rsquo;s render a puzzle as text:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Render a puzzle to text</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>render-text</span> puzzle)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for</span> ([row (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span>)])
</span></span><span style=display:flex><span>    (display (<span style=color:#a6e22e>~a</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>#</span>:width (* <span style=color:#ae81ff>2</span> (- <span style=color:#ae81ff>6</span> row))))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for</span> ([col (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> row))])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>i (+ (* <span style=color:#ae81ff>1</span>/2 row (- row <span style=color:#ae81ff>1</span>)) col))
</span></span><span style=display:flex><span>      (display (<span style=color:#a6e22e>~a</span> (<span style=color:#66d9ef>if </span>(vector-ref (<span style=color:#a6e22e>puzzle-data</span> puzzle) (- i <span style=color:#ae81ff>1</span>)) i <span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>#</span>:width <span style=color:#ae81ff>4</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>newline</span>)))
</span></span></code></pre></div><p><code><a href="http://docs.racket-lang.org/search/index.html?q=~a">~a</a></code>
is rather handy for formatting like this, making sure that each peg (at least the ones still visible) is exactly four characters wide. The formula in the line defining <code>i</code> should look familiar: it&rsquo;s the sum of the first i integers. Neat.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>render-text</span> (<span style=color:#a6e22e>make-puzzle</span> (<span style=color:#a6e22e>random</span> (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>5</span>   <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>9</span>   <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>12</span>  <span style=color:#ae81ff>13</span>      <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>That&rsquo;s all well and good, but it&rsquo;s the 21st century. We should be able to make pretty pictures as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Render a puzzle to a bitmap</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>render</span> puzzle)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>bit-set?</span> i) (vector-ref (<span style=color:#a6e22e>puzzle-data</span> puzzle) (- i <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>imgs
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>for/list</span> ([row (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span>)])
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>for/list</span> ([col (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> (+ <span style=color:#ae81ff>1</span> row))])
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>define </span>i (+ (* <span style=color:#ae81ff>1</span>/2 row (- row <span style=color:#ae81ff>1</span>)) col))
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>define </span>color (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>bit-set?</span> i) <span style=color:#e6db74>&#34;black&#34;</span> <span style=color:#e6db74>&#34;gray&#34;</span>))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>htdp:overlay</span> (<span style=color:#a6e22e>htdp:text</span> (<span style=color:#a6e22e>~a</span> i) <span style=color:#ae81ff>12</span> color)
</span></span><span style=display:flex><span>                      (<span style=color:#a6e22e>htdp:circle</span> <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;outline&#34;</span> color)
</span></span><span style=display:flex><span>                      (<span style=color:#a6e22e>htdp:circle</span> <span style=color:#ae81ff>12</span> <span style=color:#e6db74>&#34;solid&#34;</span> <span style=color:#e6db74>&#34;white&#34;</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>rows (map (<span style=color:#960050;background-color:#1e0010>Î»</span> (<span style=color:#a6e22e>row</span>) (<span style=color:#66d9ef>if </span>(= <span style=color:#ae81ff>1</span> (length row))
</span></span><span style=display:flex><span>                                 (<span style=color:#a6e22e>first</span> row)
</span></span><span style=display:flex><span>                                 (apply htdp:beside row)))
</span></span><span style=display:flex><span>                    imgs))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (apply htdp:above rows))
</span></span></code></pre></div><p>That&rsquo;s a bit more complicated. The basic idea is straight forward enough. First, for each peg we&rsquo;re going to overlay the number as <code><a href="http://docs.racket-lang.org/search/index.html?q=text">text</a></code>
on an outlined <code><a href="http://docs.racket-lang.org/search/index.html?q=circle">circle</a></code>
. The second, white circle is in order to get a bit of spacing. We&rsquo;ll render each of these into nested lists, each of increasing length. Then we shove each row together with <code><a href="http://docs.racket-lang.org/search/index.html?q=beside">beside</a></code>
, then the rows together with <code><a href="http://docs.racket-lang.org/search/index.html?q=above">above</a></code>
. All that to make a picture something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>render</span> (<span style=color:#a6e22e>make-puzzle</span> (<span style=color:#a6e22e>random</span> (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>))))
</span></span></code></pre></div><figure><img src=/embeds/2014/sample-render.png></figure><p>Looks good! (And it&rsquo;s nice being able to see the locations where there currently isn&rsquo;t a peg as well).</p><p>Okay, so now that we have some framework set up, how are we going to attack this problem?</p><p>Well, the first thing we need is the ability to make a move. In this case, given two neighboring pegs, jump one over the other:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Given a peg to move from and the peg to move over, return the new puzzle state</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>jump</span> p ifrom iover)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>from-list <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>13</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>over-list <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>14</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>to-list   <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>8</span>  <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>9</span>  <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>for/first</span> ([from (<span style=color:#a6e22e>in-list</span> (append from-list to-list))]
</span></span><span style=display:flex><span>              [over (<span style=color:#a6e22e>in-list</span> (append over-list over-list))]
</span></span><span style=display:flex><span>              [to   (<span style=color:#a6e22e>in-list</span> (append to-list from-list))]
</span></span><span style=display:flex><span>              <span style=color:#f92672>#</span>:when (<span style=color:#66d9ef>and </span>(= from ifrom)
</span></span><span style=display:flex><span>                          (= over iover)
</span></span><span style=display:flex><span>                          (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- from <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                          (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- over <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                          (not (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- to <span style=color:#ae81ff>1</span>)))))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>([new-data (<span style=color:#a6e22e>vector-copy</span> (<span style=color:#a6e22e>puzzle-data</span> p))])
</span></span><span style=display:flex><span>      (vector-set! new-data (- from <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>      (vector-set! new-data (- over <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>      (vector-set! new-data (- to   <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>puzzle</span> new-data))))
</span></span></code></pre></div><p>That&rsquo;s a bit of an ugly function. Unfortunately, I&rsquo;m not entirely sure how it could be made better. Still, it works. By virtue of <code><a href="http://docs.racket-lang.org/search/index.html?q=for/first">for/first</a></code>
, we&rsquo;ll either get the new puzzle or <code>#f</code> if it&rsquo;s not a valid move.</p><p>Next, we take this function and map it over a puzzle in order to generate all possible next states. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Get a list of all next states from a given puzzles</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>next</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>filter</span> identity
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>for*/list</span> ([from (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>16</span>)]
</span></span><span style=display:flex><span>                      [over (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>16</span>)])
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>jump</span> p from over))))
</span></span></code></pre></div><p>This one though, you should see a fairly easy way to optimize. Right now, no matter how many pegs there are in a puzzle, we&rsquo;re going to try every neighboring pair. <code>jump</code> can deal with the weird cases, but we shouldn&rsquo;t have to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Get a list of all next states from a given puzzles</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>next</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>filter</span> identity
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>for*/list</span> ([from (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>16</span>)]
</span></span><span style=display:flex><span>                      <span style=color:#f92672>#</span>:when (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- from <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                      [over (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>16</span>)]
</span></span><span style=display:flex><span>                      <span style=color:#f92672>#</span>:when (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- over <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>jump</span> p from over))))
</span></span></code></pre></div><p>That way, the further we get down the puzzle, the fewer cases we will check while still not duplicating <em>too</em> much of the code between the two.</p><p>Believe it or not&mldr; That&rsquo;s it. That&rsquo;s all we need:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Solve a puzzle using backtracking</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>solve</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    [(= <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>count</span> p))
</span></span><span style=display:flex><span>     (list p)]
</span></span><span style=display:flex><span>    [else
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>let </span>([n (<span style=color:#a6e22e>ormap</span> solve (<span style=color:#a6e22e>next</span> p))])
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>and </span>n (cons p n)))]))
</span></span></code></pre></div><p><code>count</code> returns the number of pegs left on the current board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Count how many pegs are left in a puzzle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>count</span> p)
</span></span><span style=display:flex><span>  (vector-length (<span style=color:#a6e22e>vector-filter</span> identity (<span style=color:#a6e22e>puzzle-data</span> p))))
</span></span></code></pre></div><p>That&rsquo;s it. Give it any peg puzzle and it will solve it. Quickly too. On my machine, it might as well be instantaneous. So how does it work?</p><p>Two cases: Either we&rsquo;re done or we&rsquo;re not. If we&rsquo;re done, return the end state. Otherwise, we need to find a state we can move forward from. With <code>ormap</code>, we&rsquo;re going to try each in turn, returning the first thing that isn&rsquo;t <code>#f</code>. Since we&rsquo;re mapping <code>solve</code> (recurring) and almost making progress (<code>next</code> always has at least one less peg), we can rely on the recursion to do it&rsquo;s job. In this case, we&rsquo;ll either find a solution one step down (return that one) or not (check the next one).</p><p>Don&rsquo;t believe me? Let&rsquo;s check it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (map render (<span style=color:#a6e22e>solve</span> (<span style=color:#a6e22e>make-puzzle</span> <span style=color:#f92672>#</span>b111111111111110)))
</span></span></code></pre></div><p><figure><img src=/embeds/2014/solve-01.png></figure><figure><img src=/embeds/2014/solve-02.png></figure><figure><img src=/embeds/2014/solve-03.png></figure><figure><img src=/embeds/2014/solve-04.png></figure><figure><img src=/embeds/2014/solve-05.png></figure><figure><img src=/embeds/2014/solve-06.png></figure><figure><img src=/embeds/2014/solve-07.png></figure><figure><img src=/embeds/2014/solve-08.png></figure><figure><img src=/embeds/2014/solve-09.png></figure><figure><img src=/embeds/2014/solve-10.png></figure><figure><img src=/embeds/2014/solve-11.png></figure><figure><img src=/embeds/2014/solve-12.png></figure><figure><img src=/embeds/2014/solve-13.png></figure><figure><img src=/embeds/2014/solve-14.png></figure></p><p>Flip the board over and it looks like we&rsquo;re genius. ðŸ˜„ Sweet.</p><p>That&rsquo;s all for today. I am working on a part two though. As a preview: If you take rotations and reflections into account, there are only four possible starting pegs (1, 2, 4, and 5). But it turns out that not all four are created equal&ndash;some are (relatively) easy to solve. Some are not.</p><p>If you&rsquo;d like to check out the full source code (and possibly a preview for next time), you can do so on GitHub: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt>pegs.rkt</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>