<!doctype html><html><head><title>Cracker Barrel Peg Game, Part 2 – jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_6894410585563545744.min.cc1cade18c999752b7befe111634889dca8d89b24923775954ecebc68c54fcd3.js integrity="sha256-zByt4YyZl1K3vv4RFjSIncqNibJJI3dZVOzrxoxU/NM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/custom.min.9bb1a6d1e0b58ced38df246e4479317e4561461cfabab31b36fbc36035186214.js integrity="sha256-m7Gm0eC1jO043yRuRHkxfkVhRhz6urMbNvvDYDUYYhQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="><link rel=stylesheet href=/custom.min.3bcba67844fc4a76aa7c1947a1fcf14cddaf8e9e0f1e734fde0fa219416f058d.css integrity="sha256-O8umeET8SnaqfBlHofzxTN2vjp4PHnNP3g+iGUFvBY0="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Cracker Barrel Peg Game, Part 2</h1><div class=entry-meta><span class=entry-date>2014-07-09</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/games>Games</a><a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graph-theory>Graph Theory</a><a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link></a><a class=taxonomy-value href=/series/cracker-barrel-peg-game>Cracker Barrel Peg Game</a><a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/07/05/cracker-barrel-peg-game/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Hey, remember that post a few days ago about the <a href=https://blog.jverkamp.com/2014/07/10/cracker-barrel-peg-game-part-3/>Cracker Barrel peg game</a>? Right at the end, I mentioned that there would be a part two, all about how to bend the puzzle at least a bit to your advantage. Basically, rather than finding the first solution to the peg game, we&rsquo;re going to find <em>all</em> of them. From there, we can determine which moves are easier to win from, which are harder, and which are downright impossible. Let&rsquo;s do it!</p><p>Okay, first things first. Remember how we represented the puzzles as either a 15 element vector or 15 bit integer? Well that gives us a pretty solid upper bound on how many possible ways that the puzzle can end up being arrange. Specifically, <span class=latex-inline>2^{15</span>
= 32768} total states. For a computer&mldr; that&rsquo;s actually not that big of a number. First, let&rsquo;s see how many of those we can actually reach.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Count how many total states are reachable from any initial state</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; By default, start with one copy of each peg missing</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>reachable</span> [queue (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>15</span>)])
</span></span><span style=display:flex><span>                            (<span style=color:#a6e22e>invert</span> (<span style=color:#a6e22e>make-puzzle</span> (expt <span style=color:#ae81ff>2</span> i))))])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([reached (<span style=color:#a6e22e>hash</span>)] [queue queue])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Queue is empty, done</span>
</span></span><span style=display:flex><span>      [(null? queue)
</span></span><span style=display:flex><span>       reached]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Already checked this state, check the rest</span>
</span></span><span style=display:flex><span>      [(<span style=color:#a6e22e>hash-ref</span> reached (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>first</span> queue)) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> reached (<span style=color:#a6e22e>rest</span> queue))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; New state, add it to the hash and all next states to the queue</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>hash-set</span> reached (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>first</span> queue)) <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>             (append (<span style=color:#a6e22e>rest</span> queue) (<span style=color:#a6e22e>next</span> (<span style=color:#a6e22e>first</span> queue))))])))
</span></span></code></pre></div><p>Hopefully straight forward algorithm, basically we start with an (empty) index of which nodes we&rsquo;ve visited&ndash;a hash in our case. Start with each of the fifteen opening moves in a queue. Then, keep taking one nodes off the queue. For new nodes, add that to the list of visited nodes and all its neighbors to the queue. A <a href=https://en.wikipedia.org/wiki/Breadth-first_search>breadth-first search</a>. Give it a run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>hash-count</span> (<span style=color:#a6e22e>reachable</span>))
</span></span><span style=display:flex><span><span style=color:#ae81ff>13935</span>
</span></span></code></pre></div><p>So only 42.5%. Huh. A few examples of states that can&rsquo;t be reached:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#66d9ef>define </span>r (<span style=color:#a6e22e>reachable</span>))
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>5</span>)])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ()
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>p (<span style=color:#a6e22e>make-puzzle</span> (<span style=color:#a6e22e>random</span> (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>))))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>hash-ref</span> r (<span style=color:#a6e22e>index</span> p) <span style=color:#66d9ef>#f</span>)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>render</span> p)
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>loop</span>))))
</span></span></code></pre></div><p><figure><img src=/embeds/2014/unreachable-1.png></figure><figure><img src=/embeds/2014/unreachable-2.png></figure><figure><img src=/embeds/2014/unreachable-3.png></figure><figure><img src=/embeds/2014/unreachable-4.png></figure><figure><img src=/embeds/2014/unreachable-5.png></figure></p><p>But that doesn&rsquo;t necessary tell us which starting positions are easier. For that, we need something more like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>require</span> plot)
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>plot</span> (<span style=color:#a6e22e>discrete-histogram</span>
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>15</span>)])
</span></span><span style=display:flex><span>           (vector (+ i <span style=color:#ae81ff>1</span>) 
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>hash-count</span> (<span style=color:#a6e22e>reachable</span> (list (<span style=color:#a6e22e>invert</span> (<span style=color:#a6e22e>make-puzzle</span> (expt <span style=color:#ae81ff>2</span> i))))))))))
</span></span></code></pre></div><figure><img src=/embeds/2014/reachable-by-initial.png></figure><p>Interesting. So there are three states that reach the most (4, 6, and 13), three on the next tier (1, 11, and 15), 6 on the next, and 3 that reach the least (5, 8, and 9). If you think about it, that makes a lot of sense. For each position, there are two other identical positions&ndash;rotations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Rotate a puzzle clockwise</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>rotate</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>puzzle</span> (<span style=color:#a6e22e>for/vector</span> ([i (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>11</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span>))])
</span></span><span style=display:flex><span>            (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- i <span style=color:#ae81ff>1</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#66d9ef>define </span>random-puzzle (<span style=color:#a6e22e>make-puzzle</span> (<span style=color:#a6e22e>random</span> (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>))))
</span></span><span style=display:flex><span>&gt; (map render (list random-puzzle 
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>rotate</span> random-puzzle)
</span></span><span style=display:flex><span>                    (<span style=color:#a6e22e>rotate</span> (<span style=color:#a6e22e>rotate</span> random-puzzle))))
</span></span></code></pre></div><p><figure><img src=/embeds/2014/rotation-example-1.png></figure><figure><img src=/embeds/2014/rotation-example-2.png></figure><figure><img src=/embeds/2014/rotation-example-3.png></figure></p><p>Further than that, there are also reflections:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Reflect a puzzle left to right</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>reflect</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>puzzle</span> (<span style=color:#a6e22e>for/vector</span> ([i (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>14</span> <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>11</span>))])
</span></span><span style=display:flex><span>            (vector-ref (<span style=color:#a6e22e>puzzle-data</span> p) (- i <span style=color:#ae81ff>1</span>)))))
</span></span></code></pre></div><p><figure><img src=/embeds/2014/reflection-example-2.png></figure><figure><img src=/embeds/2014/reflection-example-1.png></figure></p><p>This is what I meant last time, when I said that there were only four initial states (1, 2, 4, and 5). All of the rest are reflections and/or rotations of one of those 4.</p><p>Finally, if you combine these two functions, it should be possible to get a real idea of how many truly unique states there are. Since each puzzle has a numeric form and each puzzle has up to six unique states (three rotations, each with two reflections), we can consistently find the one of those six with the lowest value. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Minimize a puzzle by finding the reflection/rotation with the minimal vector</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>minify</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>r1 (<span style=color:#a6e22e>rotate</span> p))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>r2 (<span style=color:#a6e22e>rotate</span> r1))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>first</span> (<span style=color:#a6e22e>sort</span> (list p r1 r2 (<span style=color:#a6e22e>reflect</span> p) (<span style=color:#a6e22e>reflect</span> r1) (<span style=color:#a6e22e>reflect</span> r2))
</span></span><span style=display:flex><span>               (<span style=color:#960050;background-color:#1e0010>λ</span> (<span style=color:#a6e22e>p1</span> p2)
</span></span><span style=display:flex><span>                 (&lt; (<span style=color:#a6e22e>index</span> p1) (<span style=color:#a6e22e>index</span> p2))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (map index (list random-puzzle
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>reflect</span> random-puzzle)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>rotate</span> random-puzzle)
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>reflect</span> (<span style=color:#a6e22e>rotate</span> random-puzzle))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>rotate</span> (<span style=color:#a6e22e>rotate</span> random-puzzle))
</span></span><span style=display:flex><span>                   (<span style=color:#a6e22e>reflect</span> (<span style=color:#a6e22e>rotate</span> (<span style=color:#a6e22e>rotate</span> random-puzzle)))))
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>26794</span> <span style=color:#ae81ff>21322</span> <span style=color:#ae81ff>10025</span> <span style=color:#ae81ff>7474</span> <span style=color:#ae81ff>12412</span> <span style=color:#ae81ff>12679</span>)
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>minify</span> random-puzzle))
</span></span><span style=display:flex><span><span style=color:#ae81ff>7474</span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>render</span> (<span style=color:#a6e22e>minify</span> random-puzzle))
</span></span></code></pre></div><figure><img src=/embeds/2014/minimum-random-puzzle.png></figure><p>So how many states do we get if we take only the minimum form? Both overall and reachable?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>set-count</span> 
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>for/set</span> ([i (<span style=color:#a6e22e>in-range</span> (expt <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>15</span>))])
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>minify</span> (<span style=color:#a6e22e>make-puzzle</span> i)))))
</span></span><span style=display:flex><span><span style=color:#ae81ff>5728</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Modification of reachable states, only minified </span>
</span></span><span style=display:flex><span><span style=color:#75715e>; By default, start with one copy of each peg missing</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>reachable-min</span> [queue (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-range</span> <span style=color:#ae81ff>15</span>)])
</span></span><span style=display:flex><span>                                (<span style=color:#a6e22e>invert</span> (<span style=color:#a6e22e>make-puzzle</span> (expt <span style=color:#ae81ff>2</span> i))))])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([reached (<span style=color:#a6e22e>hash</span>)] [queue queue])
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Queue is empty, done</span>
</span></span><span style=display:flex><span>      [(null? queue)
</span></span><span style=display:flex><span>       reached]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Already checked this state, check the rest</span>
</span></span><span style=display:flex><span>      [else
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>p (<span style=color:#a6e22e>minify</span> (<span style=color:#a6e22e>first</span> queue)))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>define </span>i (<span style=color:#a6e22e>index</span> p))
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>         [(<span style=color:#a6e22e>hash-ref</span> reached i <span style=color:#66d9ef>#f</span>) 
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>loop</span> reached (<span style=color:#a6e22e>rest</span> queue))]
</span></span><span style=display:flex><span>         [else
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>loop</span> (<span style=color:#a6e22e>hash-set</span> reached i <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>                (append (<span style=color:#a6e22e>rest</span> queue) (<span style=color:#a6e22e>next</span> p)))])])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; (<span style=color:#a6e22e>hash-count</span> (<span style=color:#a6e22e>reachable-min</span>))
</span></span><span style=display:flex><span><span style=color:#ae81ff>2383</span>
</span></span></code></pre></div><p>Still about the same (technically slightly lower, it&rsquo;s only 41.6%). That&rsquo;s a good sign. We&rsquo;re all of the way down to 2,383 states from the original potential 32,768. A lot more manageable.</p><p>Next, let&rsquo;s shift to moves rather than states. Given two states, they are connected with a move if you could make a single jump to get from one to the other. So now rather than a set, we have a graph. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Find a map of all possible moves from a given puzzle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>all-moves</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>moves (<span style=color:#a6e22e>make-hash</span>))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>loop ([p p])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>([p (<span style=color:#a6e22e>minify</span> p)])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>i (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>minify</span> p)))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>when</span> (not (<span style=color:#a6e22e>hash-has-key?</span> moves i))
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>define </span>next-ps (<span style=color:#a6e22e>next</span> p))
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>hash-set!</span> moves i (<span style=color:#a6e22e>list-&gt;set</span> (map index (map minify next-ps))))
</span></span><span style=display:flex><span>        (map loop next-ps))))
</span></span><span style=display:flex><span>  moves)
</span></span></code></pre></div><p>From there, we can recursively build up a count for each state how many times we win (end up with only a single peg) and how many times we lose.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; Count the number of winning and losing states from a given puzzle</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>score</span> p)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define </span>moves (<span style=color:#a6e22e>all-moves</span> p))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>wins</span> losses)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>loop ([i (<span style=color:#a6e22e>index</span> (<span style=color:#a6e22e>minify</span> p))])
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define </span>nxt (<span style=color:#a6e22e>hash-ref</span> moves i (<span style=color:#a6e22e>set</span>)))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>        [(<span style=color:#a6e22e>set-empty?</span> nxt)
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>if </span>(= <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>count</span> (<span style=color:#a6e22e>make-puzzle</span> i)))
</span></span><span style=display:flex><span>             (values <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>             (values <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>))]
</span></span><span style=display:flex><span>        [else
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>for/fold</span> ([wins <span style=color:#ae81ff>0</span>] [losses <span style=color:#ae81ff>0</span>]) ([n (<span style=color:#a6e22e>in-set</span> nxt)])
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>define-values</span> (<span style=color:#a6e22e>r-wins</span> r-losses) (<span style=color:#a6e22e>loop</span> n))
</span></span><span style=display:flex><span>           (values (+ wins   r-wins)
</span></span><span style=display:flex><span>                   (+ losses r-losses)))])))
</span></span><span style=display:flex><span>  (* <span style=color:#ae81ff>1.0</span> (/ wins (+ wins losses))))
</span></span></code></pre></div><p>That way we can tell how &lsquo;hard&rsquo; each puzzle is, assuming that you always rotate/reflect to avoid potential duplicate state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>&gt; (<span style=color:#a6e22e>for/list</span> ([i (<span style=color:#a6e22e>in-list</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>5</span>))])
</span></span><span style=display:flex><span>    (list i (<span style=color:#a6e22e>score</span> (<span style=color:#a6e22e>invert</span> (<span style=color:#a6e22e>make-puzzle</span> i)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&#39;</span>((<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0.05239514926876435</span>)
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>0.05138285262741999</span>)
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>0.08392304995059131</span>)
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>0.08392304995059131</span>))
</span></span></code></pre></div><p>So there you have it. If you&rsquo;re playing optimally, it&rsquo;s slightly easier to do so starting with a corner or the second. The center or center of each edge are slightly harder.</p><p>And that&rsquo;s all we have for today. Originally, I meant to use the graph library I&rsquo;ve used a number of times before to visualize the solution space (there&rsquo;s a function that will do that on GitHub), but the graphs honestly aren&rsquo;t that helpful. There nodes are too nested and there are just too many to helpfully visualize. So it goes. Still, I think we found a few interesting things.</p><p>As always, the code is available on GitHub: <a href=https://github.com/jpverkamp/small-projects/blob/master/blog/pegs.rkt>pegs.rkt</a></p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>