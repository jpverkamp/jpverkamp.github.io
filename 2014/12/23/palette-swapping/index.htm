<!DOCTYPE html>
<html>
<head>
        
        

        <title>Palette Swapping | jverkamp.com | John-Paul Verkamp</title>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js" defer></script>
        <script src="//code.jquery.com/ui/1.11.1/jquery-ui.min.js" defer></script>

        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" defer />
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css" defer />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js" defer></script>

        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.css" defer />
        <script src="//cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/3.0.3a/ekko-lightbox.min.js" defer></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.9/jquery.transit.min.js" defer></script>

        <!-- Highlight.js for syntax highlighting -->
        <link rel="stylesheet" href="/highlight/styles/obsidian.css" defer />
        <script src="/highlight/highlight.pack.js" defer></script>

        <!-- MathJax for LaTeX support -->
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

        <!-- nanoGallery for Flickr Galleries -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/css/themes/light/nanogallery_light.css" defer />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/nanogallery/4.4.2/jquery.nanogallery.min.js" defer ></script>

        <!-- Pretty pretty fonts -->
        <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Calligraffitti" defer />

        <!-- Any custom CSS or JS that I've written; this should be kept minimal -->
        <link rel="stylesheet" href="/custom.css" defer />
        <script src="/custom.js" defer></script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="http://blog.jverkamp.com/feed/" />
</head>
<body>
        <header class="container">
        <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://blog.jverkamp.com"><span style="color: green;">jv</span>erkamp.com</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav"><li class="dropdown"><a href="http://blog.jverkamp.com/category/archives" class="dropdown-toggle">Archives<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/archives/2004">2004</a></li><li><a href="http://blog.jverkamp.com/category/archives/2005">2005</a></li><li><a href="http://blog.jverkamp.com/category/archives/2006">2006</a></li><li><a href="http://blog.jverkamp.com/category/archives/2007">2007</a></li><li><a href="http://blog.jverkamp.com/category/archives/2008">2008</a></li><li><a href="http://blog.jverkamp.com/category/archives/2009">2009</a></li><li><a href="http://blog.jverkamp.com/category/archives/2010">2010</a></li><li><a href="http://blog.jverkamp.com/category/archives/2011">2011</a></li><li><a href="http://blog.jverkamp.com/category/archives/2012">2012</a></li><li><a href="http://blog.jverkamp.com/category/archives/2013">2013</a></li><li><a href="http://blog.jverkamp.com/category/archives/2014">2014</a></li><li><a href="http://blog.jverkamp.com/category/archives/2015">2015</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/other" class="dropdown-toggle">Other<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/other/board-game-reviews">Board Game Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/book-reviews">Book Reviews</a></li><li><a href="http://blog.jverkamp.com/category/other/cooking">Cooking</a></li><li><a href="http://blog.jverkamp.com/category/other/movie-reviews">Movie Reviews</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/photography" class="dropdown-toggle">Photography<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/photography/dp-challenge">DP Challenge</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosets">Photosets</a></li><li><a href="http://blog.jverkamp.com/category/photography/photosynth">Photosynth</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/programming" class="dropdown-toggle">Programming<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/programming/by-language">By Language</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-project">By Project</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source">By Source</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/programming/libraries">Libraries</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/research" class="dropdown-toggle">Research<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/research/by-topic">By Topic</a></li><li><a href="http://blog.jverkamp.com/category/research/publications">Publications</a></li></ul></li><li class="dropdown"><a href="http://blog.jverkamp.com/category/writing" class="dropdown-toggle">Writing<span class="caret"></span></a><ul class="dropdown-menu"><li><a href="http://blog.jverkamp.com/category/writing/by-genre">By Genre</a></li><li><a href="http://blog.jverkamp.com/category/writing/ideas">Ideas</a></li><li><a href="http://blog.jverkamp.com/category/writing/nanowrimo">NaNoWriMo</a></li><li><a href="http://blog.jverkamp.com/category/writing/novels">Novels</a></li><li><a href="http://blog.jverkamp.com/category/writing/other">Other</a></li><li><a href="http://blog.jverkamp.com/category/writing/short-stories">Short Stories</a></li><li><a href="http://blog.jverkamp.com/category/writing/writing-excuses">Writing Excuses</a></li></ul></li></ul>

      <form action="http://www.google.com/search" method="get" onSubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input name="q" type="hidden" />
          <input name="qfront" type="text" class="form-control" placeholder="Search" />
          <button type="submit" class="btn btn-default" value="Search">Search</button>
        </p>
      </form>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
        </header>

        <article class="container">
                <header>
                        <h1 class="entry-title">Palette Swapping</h1>

                        <div class="entry-meta">
                                <span class="posted-on"><time class="entry-date" datetime="2014-12-23"><span class="year">2014</span> <span class="month">Dec</span> <span class="day">23</span></time></span>
                                <span class="tags"><ul class="tag-list list-inline"><li><a href="http://blog.jverkamp.com/category/programming/by-topic/graphics">Graphics</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/optimization">Optimization</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/racket">Racket</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-language/scheme">Scheme</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-source/stack-exchange">Stack Exchange</a></li><li><a href="http://blog.jverkamp.com/category/programming/by-topic/data-structures/trees">Trees</a></li></ul></span>
                        </div>

                        <hr />
                </header>
                <div class="entry-content">
                        <p>Today's task comes from the <a href="https://codegolf.stackexchange.com/">Code Golf StackExchange</a>. The idea behind <a href="https://en.wikipedia.org/wiki/code_golf">code golf</a> is to write a program with as few characters as possible, often rendering the code nigh on unreadable. Luckily, the same StackExchange also host popularity contests, one of which is the inspiration behind today's post:</p>
<blockquote>
You are given two true color images, the Source and the Palette. They do not necessarily have the same dimensions but it is guaranteed that their areas are the same, i.e. they have the same number of pixels.

Your task is to create an algorithm that makes the most accurate looking copy of the Source by only using the pixels in the Palette. Each pixel in the Palette must be used exactly once in a unique position in this copy. The copy must have the same dimensions as the Source.

-- <a href="https://codegolf.stackexchange.com/questions/33172/american-gothic-in-the-palette-of-mona-lisa-rearrange-the-pixels">American Gothic in the palette of Mona Lisa: Rearrange the pixels</a>
</blockquote>
<!--more-->
<p>Specifically for this post, we'll be using two source images, although for testing I had a whole pile more:</p>
<table>
    <tr>
        <td>
<a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa.png" /></a> <br />
-- <a href="https://en.wikipedia.org/wiki/Mona_Lisa">Mona Lisa</a> by <a href="https://en.wikipedia.org/wiki/Leonardo_da Vinci">Leonardo da Vinci</a>, c. 1503-1506
        </td><td>
<a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream.png" /></a> <br />
-- <a href="https://en.wikipedia.org/wiki/The_Scream">The Scream</a> by <a href="https://en.wikipedia.org/wiki/Edvard_Munch">Edvard Munch</a>, 1893
        </td>
    </tr>
</table>
<p>There are a bunch of different ways to solve this, but today we'll go through three of them:</p>
<ul>
    <li>Sort the colors in both images</li>
    <li>Swap pixels until the image is 'close enough'</li>
    <li>Fill in pixels greedily</li>
</ul>
<h2>Sort the colors in both images</h2>
<p>The first algorithm sounds crazy until you try it. In psuedocode:</p>
<ol>
    <li>Create a list of pixels from each image</li>
    <li>Sort the two lists by a given comparator</li>
    <li>For each pair of pixels in the two lists, take the color from the target image and the location from the source image</li>
</ol>
<p>And that's actually it. It turns out the code is just about as simple, with most of the length going into loading and saving the images and format juggling. First, we want a way of representing pixels which in this context are a color and a location:</p>
<pre class="racket"><code>; A color with a location
(struct pixel (x y c) #:transparent)

; Sorting function based on grayscale value
(define (pixel&lt;?/grayscale p1 p2)
    (&lt; (apply + (flvector-&gt;list (pixel-c p1)))
       (apply + (flvector-&gt;list (pixel-c p2)))))</code></pre>
<p>We'll use <code>pixel&lt;?/grayscale</code> as a basic sorting function. It works well enough, although it could probably be tuned to more accurately model human vision.</p>
<p>Next, the pièce de résistance:</p>
<pre class="racket"><code>; Recolor an image by sorting the pixels in both images
(define (recolor/sort original-src target-src
                      #:pixel&lt;? [pixel&lt;? pixel&lt;?/grayscale])
  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  ; Generate a list of pixels in each image
  (define (pixel-list fm)
    (for*/list ([x (in-range (flomap-width fm))]
                [y (in-range (flomap-height fm))])
      (pixel x y (flomap-ref* fm x y))))

  (define original-pixels (pixel-list original))
  (define target-pixels (pixel-list target))

  ; Sort both lists by the given sorting function
  (define sorted-original-pixels (sort original-pixels pixel&lt;?))
  (define sorted-target-pixels (sort target-pixels pixel&lt;?))

  ; Build a map from source xy to list index to target color
  (define transition-hash
    (for/fold ([h (hash)])
              ([original-pixel (in-list sorted-original-pixels)]
               [target-pixel (in-list sorted-target-pixels)])
      (hash-set h
                (list (pixel-x original-pixel)
                      (pixel-y original-pixel))
                (pixel-c target-pixel))))

  ; Build the new image from that transition matrix
  (flomap-&gt;bitmap
   (build-flomap*
    (flomap-components original)
    (flomap-width original) (flomap-height original)
    (λ (x y)
      (hash-ref transition-hash (list x y))))))</code></pre>
<p>Going through the commented blocks, we have a fairly direct match for the psuedocode. One difference is because of the structure of the <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code> function. Since it's expects a generator rather than allowing us to generate arbitrary points, it's easier to make a map first. Still, about the same.</p>
<p>And when you apply it to the source images above?</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_sort.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_sort.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_sort.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_sort.png" /></a>
        </td>
    </tr>
</table>
<p>That's actually really cool. It's really interesting how sorting by the grayscale values ends up recoloring the images while preserving small details in the grain of the background. Very neat. Even cooler, it's wicked fast. Since sorting is one of the more well understood problems in computer science, there are well known algorithms to use. In this case, our runtime is probably <span>\( \mathcal{O}(n\log{}n) \)</span> (with <em>n</em> as the number of pixels), since that is the runtime for the sort and both loading and writing the image are  <span>\( \mathcal{O}(n) \)</span>.</p>
<h2>Swap pixels until the image is 'close enough'</h2>
<p>Okay, that was straight forward. Let's see if we can do something different. This time, let's just brute force the problem. Rather than systematically dealing with the entire image at once:</p>
<ol>
    <li>Scramble the pixels of the target image</li>
    <li>Set <code>counter = 0</code></li>
    <li>While <code>counter</code> &lt; <code>threshold</code>
        <ol>
            <li>Choose two random pixels</li>
            <li>Calculate the 'error' of the image with the pixels at their current location, and the error with those two pixels swapped</li>
            <li>If the swapped error is lower, swap the pixels and set <code>counter = 0</code>; otherwise, increment <code>counter</code></li>
        </ol>
    </li>
</ol>
<p>First, let's define an error function based on the distance between two colors in RGB space (again, there are better functions we could use here):</p>
<pre class="racket"><code>; Find the distance between two flvectors
(define (fl-distance fl1 fl2)
  (sqrt (for/sum ([a (in-vector (flvector-&gt;vector fl1))]
                  [b (in-vector (flvector-&gt;vector fl2))])
          (sqr (- a b)))))

; Simple error function based on RGB distance
(define (error/rgb-distance original-fm target-fm color-pixel location-pixel)
    (match-define (pixel x y _) location-pixel)
    (match-define (pixel _ _ c) color-pixel)
    (fl-distance (flomap-ref* original-fm x y) c))</code></pre>
<p>Using that, we can  the algorithm fairly directly into Racket:</p>
<pre class="racket"><code>; Recolor an image by randomly swapping pixels based on improving error
(define (recolor/swap original-src target-src
                      #:threshold [threshold 100]
                      #:error-function [err error/rgb-distance])

  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  (define width (flomap-width original))
  (define height (flomap-height original))

  ; Generate a 2d vector of pixels
  (define pixels
    (list-&gt;vector
     (shuffle
      (for*/list ([y (in-range (flomap-height target))]
                  [x (in-range (flomap-width target))])
        (flomap-ref* target x y)))))

  ; Get/set a pixel in the pixel map
  (define (get x y)
    (pixel x y (vector-ref pixels (+ x (* width y)))))

  (define (set! x y c)
    (vector-set! pixels (+ x (* width y)) c))

  ; Get a random pixel (sized from the original image)
  (define (rnd) (get (random width) (random height)))

  ; Keep swapping pixels until we get a certain number of non-swaps in a row
  (let loop ([swap-count 0] [non-swap-count 0])
    (define p1 (rnd))
    (define p2 (rnd))

    (cond
      ; Haven't swapped recently, return the result
      [(&gt;= non-swap-count threshold)
       (flomap-&gt;bitmap
        (build-flomap*
         (flomap-components original)
         (flomap-width original) (flomap-height original)
         (λ (x y)
           (pixel-c (get x y)))))]
      ; Swap is better, swap and reset count
      [(&lt; (+ (err original target p1 p2) (err original target p2 p1))
          (+ (err original target p1 p1) (err original target p2 p2)))

       (set! (pixel-x p1) (pixel-y p1) (pixel-c p2))
       (set! (pixel-x p2) (pixel-y p2) (pixel-c p1))
       (loop (+ swap-count 1) 0)]
      ; Swap is worse, just count
      [else
       (loop swap-count (+ non-swap-count 1))])))</code></pre>
<p>To start with, let's go for the default threshold of 100 consecutive errors:</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-100.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-100.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-100.png" /></a>
        </td>
    </tr>
</table>
<p>It's a little grainy, mostly because you actually get a random spike of 100 error free swaps fairly easily (it turns out 'random' isn't as uniform as most people think). Let's try cranking the threshold up to a thousand instead:</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k.png" /></a>
        </td>
    </tr>
</table>
<p>That's a lot better for The Scream, but now the Mona Lisa is having some issues with the red in hear hair. It turns out there's a reasonable amount of brown, but too much red so they're both fairly close in grayscale distance. Perhaps a better error metric would work better.</p>
<p>Also, it takes a lot longer. While sorting worked in seconds and 100 took about 30 seconds, 1000 took about 5 minutes per image. Especially in The Scream recolored, the different in quality is obvious, but the cost really isn't worth it when you compare to how just sorting the pixels did.</p>
<p>Alternatively, you can try a different error function. For example, this one takes the weighted average of a 3x3 area rather than a single pixel (threshold = 1000).</p>
<pre class="racket"><code>; Slightly more complicated error function takes original image average into account
(define (error/rgb-distance/average
         original-fm target-fm
         color-pixel location-pixel)
  (match-define (pixel x y _) location-pixel)
  (match-define (pixel _ _ c) color-pixel)
  (fl-distance (flvector-scale
                (foldl flvector+
                       (flomap-ref* original-fm x y)
                       (for*/list ([xd (in-range -1 2)] [yd (in-range -1 2)])
                         (flomap-ref* original-fm (+ x xd) (+ y yd))))
                (/ 1.0 9.0))
               c))</code></pre>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k-average.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_swap-1k-average.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k-average.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_swap-1k-average.png" /></a>
        </td>
    </tr>
</table>
<p>Mostly, it just made it blurry. Which makes sense, since we're comparing regions rather than a single pixel, so edges are less heavily influential than they were. So it goes.</p>
<h2>Fill in pixels greedily</h2>
<p>The third and final option was actually the first one that I came up with:</p>
<ol>
    <li>Generate a list of all colors in the target image</li>
    <li>For each pixel in the source image:
        <ol>
            <li>Find the most similar color in the target list</li>
            <li>Place that color in the result</li>
            <li>Remove it from the target list</li>
        </ol>
    </li>
</ol>
<p>As a <a href="https://en.wikipedia.org/wiki/greedy_algorithm">greedy algorithm</a>, it's theoretically fast but likely not optimal. What you end up getting is really good results for the first part of the image but increasingly bad results as the images diverge.</p>
<p>One neat trick I did here was that I could have just run from the top of the image down. But that would have lost out on a lot of the detail from the center of the image. So instead, I used the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/generator">racket/generator</a></code> library to make this neat gem:</p>
<pre class="racket"><code>; Spiral outwards from (0,0) in squares
(define (in-spiral [radius +inf.0])
  (in-generator
    (yield (list 0 0))
    (for ([r (in-range 1 radius)])
      (yield (list (- r) (- r)))
      (yield (list (- r) r))
      (yield (list r (- r)))
      (yield (list r r))
      (for ([d (in-range (+ (- r) 1) r)])
        (yield (list (- r) d))
        (yield (list r     d))
        (yield (list d (- r)))
        (yield (list d r))))))</code></pre>
<p>That's much more Pythonic than Rackety, but it does work. Essentially, you get a square spiral moving out from the origin, first every pixel with x or y 1 different from the origin, then 2, then 3, etc. Neat.</p>
<p>Using that, we can  the psuedocode into Racket:</p>
<pre class="racket"><code>; Recolor an image finding the best pixels from the center out
(define (recolor/fill/slow original-src target-src)
  (define original (load-flomap original-src))
  (define target (load-flomap target-src))

  (define width (flomap-width original))
  (define height (flomap-height original))

  ; Generate a list of target colors
  (define colors
    (for*/list ([y (in-range (flomap-height target))]
                [x (in-range (flomap-width target))])
      (flomap-ref* target x y)))

  ; Generate a 2d vector of pixels
  (define result
    (for*/vector ([y (in-range (flomap-height original))]
                  [x (in-range (flomap-width original))])
      #f))

  ; Get/set a pixel in the pixel map
  (define (result-get x y)
    (vector-ref result (+ x (* width y))))

  (define (result-set! x y c)
    (vector-set! result (+ x (* width y)) c))

  ; Spiral outwards from the center of the image
  (for ([pt (in-spiral (+ 2 (quotient (max width height) 2)))])
    ; Convert to image coordinates and verify that we're in the image
    (define x (+ (first pt) (quotient width 2)))
    (define y (+ (second pt) (quotient height 2)))
    (when (and (&gt;= x 0) (&lt; x width) (&gt;= y 0) (&lt; y height))
      ; Get the source color at that point
      (define target-color (flomap-ref* original x y))

      ; Choose the closest remaining color
      (define-values (_ color)
        (for/fold ([minimum-distance +inf.0] [best-color #f])
                  ([color (in-list colors)])
          (define new-distance (fl-distance target-color color))
          (if (&lt; new-distance minimum-distance)
              (values new-distance color)
              (values minimum-distance best-color))))

      ; Remove that color from the list to place, add it to the result
      (set! colors (remove color colors))
      (result-set! x y color)))

  ; Turn that into a bitmap
  (flomap-&gt;bitmap
   (build-flomap*
    (flomap-components original)
    (flomap-width original) (flomap-height original)
    result-get)))</code></pre>
<p>That's pretty straight forward. The most interesting bit is probably the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code> in the middle. It's a quick way of finding the minimum value in a list where the value itself isn't what you're interested in. Another option would have been to <code>sort</code> with a custom sorting function, but that would in this case be slower (<span>\( \mathcal{O}(n) \)</span> versus <span>\( \mathcal{O}(n\log{}n) \)</span>).</p>
<table>
    <tr>
        <td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_fill.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/mona-lisa_scream_fill.png" /></a>
        </td><td>
            <a href="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_fill.png" data-toggle="lightbox"><img src="http://blog.jverkamp.com/2014/12/23/palette-swapping/scream_mona-lisa_fill.png" /></a>
        </td>
    </tr>
</table>
<p>Okay, that's just weird. <img alt="smile" class="emoji" src="/emoji/smile.svg" /> Basically, there are enough shared pixels in the two images that you can more or less reconstruct the center sections. After that though... All bets are off. You didn't get this in either of the previous solutions because in the sorting case, they ended up spread throughout similarly color regions while in swapping they just didn't move from where they started.</p>
<p>Also, there's another problem. It's slow. Since this was actually the first thing that I worked on, I did wanit to take a little bit of time to make it faster:</p>
<h2>Filling pixels: Data structures strike back</h2>
<p>The main problem with the fill solution is that for each pixel <span>\( \mathcal{O}(n) \)</span>, you're going to run through every pixel in the target image (another <span>\( \mathcal{O}(n) \)</span>), resulting in an <span>\( \mathcal{O}(n^2) \)</span> runtime. Not particularly great. Especially because we shouldn't have to scan through the entire list (or even the average of half of it) to find the closest matching pixel.</p>
<p>Instead, we should be able to do something like a <a href="https://en.wikipedia.org/wiki/binary_search">binary search</a>:</p>
<ol>
    <li>Start with a lower and upper bound of the entire list</li>
    <li>Until we find the closest color:
        <ol>
            <li>Find the midpoint of the current bounds</li>
            <li>If the target color is 'less than' that, set the upper bound to the midpoint, otherwise set the lower bound to the midpoint</li>
            <li>Repeat</li>
        </ol>
    </li>
</ol>
<p>If we could get something like that working, we would only need <span>\( \mathcal{O}(\log{}n) \)</span> per lookup, reducing the runtime to the same as the <code>recolor/sort</code> method. And... it turns out that Racket has just the sort of data strucure we need: a <a href="https://en.wikipedia.org/wiki/splay_tree">splay tree</a>. Specifically, a splay tree is a binary tree (enabling binary search), that self-adjusts (to avoid worst case badly unbalanced trees), which has the additional property of making recently accessed elements quick to access. That's helpful in this case, since we'll have blocks of similar colors, which are close in the tree. Neat!</p>
<p>In Racket, to build a splay tree, we need to set up a couple of things in the <code><a href="http://docs.racket-lang.org/search/index.html?q=data/order">data/order</a></code> and <code><a href="http://docs.racket-lang.org/search/index.html?q=data/splay-tree">data/splay-tree</a></code> modules:</p>
<pre class="racket"><code>; Find the distance between two flvectors
(define (fl-distance fl1 fl2)
  (sqrt (for/sum ([a (in-vector (flvector-&gt;vector fl1))]
                  [b (in-vector (flvector-&gt;vector fl2))])
          (sqr (- a b)))))

; Test if two flvectors are equal
(define (flvector=? flv1 flv2)
  (not (for/first ([v1 (in-flvector flv1)]
                   [v2 (in-flvector flv2)]
                   #:when (not (= v1 v2)))
         #t)))

; Test if one flvector is less than another by comparing each channel in order
(define (flvector&lt;? flv1 flv2)
  (for/first ([v1 (in-flvector flv1)]
              [v2 (in-flvector flv2)]
              #:when (not (= v1 v2)))
    (&lt; v1 v2)))</code></pre>
<p>Then, when loading the colors instead of building a list, we can make the splay tree:</p>
<pre class="racket"><code>; Generate a list of target colors
(define colors
  (make-splay-tree
   (order 'pixel-grayscale-order
          flvector?
          flvector=?
          flvector&lt;?)))

(for* ([y (in-range (flomap-height target))]
       [x (in-range (flomap-width target))])

  (define color (flomap-ref* target x y))
  (define count (+ 1 (splay-tree-ref colors color 0)))
  (splay-tree-set! colors color count))</code></pre>
<p>One thing we didn't have to do earlier was to keep track of counts for each pixel. In a list, we just duplicated the elements, for the splay tree this won't work as well.</p>
<p>Then, in the <code>recolor/fill</code> method, we tweak the color choosing function (previously the <code>for/fold</code>):</p>
<pre class="racket"><code>...

; Get the source color at that point
(define target-color (flomap-ref* original x y))

; Choose the closest remaining color
(define iter/&gt;= (splay-tree-iterate-least/&gt;=? colors target-color))
(define iter/&lt;= (splay-tree-iterate-greatest/&lt;=? colors target-color))

(define color
  (cond
    [(and iter/&gt;= iter/&lt;=)
     (define c1 (splay-tree-iterate-key colors iter/&gt;=))
     (define c2 (splay-tree-iterate-key colors iter/&lt;=))
     (if (&lt; (fl-distance target-color c1)
            (fl-distance target-color c2))
         c1
         c2)]
    [iter/&gt;= (splay-tree-iterate-key colors iter/&gt;=)]
    [iter/&lt;= (splay-tree-iterate-key colors iter/&lt;=)]))

(define count (splay-tree-ref colors color))
(if (= count 1)
    (splay-tree-remove! colors color)
    (splay-tree-set! colors color (- count 1)))

(result-set! x y color)

...</code></pre>
<p>The method for finding the smallest element greater than / largest less than a given element that isn't actually in the tree is a little weird, but it works out in the end. That's one nice thing about how crosslinked all of the Racket documentation is, I could just keep looking until I found the functions that I needed.</p>
<p>Give this a run... And it's a <em>lot</em> faster. Rather than an hour or more to run, it takes only seconds. It's a little bit slower than the sort (since the data structure is a little more complicated), but well within the same order of runtime.</p>
<p>Yet more evidence that perhaps you should pay attention in data structures class. <img alt="smile" class="emoji" src="/emoji/smile.svg" /></p>
<h2>Conclusion</h2>
<p>And, that's it. That was a lot of fun to work out. I really love how the simplest algorithm is also the fastest and has arguably the best results (at least for these two images). So cool!</p>
<p>If you would like to check out the source code for today's post, you can do so here: <a href="https://github.com/jpverkamp/small-projects/tree/master/blog/palette-swap">palette-swap</a>. If you place multiple PNG images with the same number of pixels (aspect ratios don't matter) in the <code>input</code> subdirectory and run <code>test.rkt</code> it will generate a whole pile of images like you've seen here.</p>
                </div>
                <div class="entry-footnotes">
                        <div id="footnotes"><ol></ol></div>
                </div>

                <div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = "jverkamp";
var disqus_title = "Palette Swapping";
var disqus_url = "http://blog.jverkamp.com/2014/12/23/palette-swapping/";
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </article>

        <footer class="container" role="contentinfo">
                <nav class="navbar navbar-default" role="navigation"><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/11/30/nanowrimo-2014-winner">← NaNoWriMo 2014 Winner!</a></li><li><a href="http://blog.jverkamp.com/category/archives">Archives</a></li><li><a href="http://blog.jverkamp.com/2015/01/01/2015-reading-list">2015 Reading List →</a></li></ul><ul class="nav navbar-nav nav-justified"><li><a href="http://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket">← A "one" line echo server using let in Racket</a></li><li><a href="http://blog.jverkamp.com/category/programming">Programming</a></li><li><a href="http://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images">Generating omnichromatic images →</a></li></ul></nav>

                <div class="legal">
                        <a href="http://blog.jverkamp.com/feed/atom.xml">feed <img style="border: 0;" src="http://blog.jverkamp.com/rss.png" /></a><br />
                        All posts unless otherwise mentioned are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
                        Any source code unless otherwise mentioned is licensed under the <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
                </div>
        </footer>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.defer=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53688146-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>