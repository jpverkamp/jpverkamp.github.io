<!doctype html><html><head><title>Palette Swapping â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.30448892aa1f91e9c4cb5494e5c5e5abc13b7778de7786e5256cdc7d2424813a.js integrity="sha256-MESIkqofkenEy1SU5cXlq8E7d3jed4blJWzcfSQkgTo=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.6ba037466db9f8843b66c38c32fe5a353344e7fd68ecda97efb63a84c881f828.js integrity="sha256-a6A3Rm25+IQ7ZsOMMv5aNTNE5/1o7NqX77Y6hMiB+Cg=" defer></script>
<script src=/katex_12008035502722260518.min.3cc3a080c0368785179e37b0cd0a71c6cf60c4fc5a8dce503f5a542ec0a25043.js integrity="sha256-PMOggMA2h4UXnjewzQpxxs9gxPxajc5QP1pULsCiUEM=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.e8f19283a632077085b9ad74aecad54abe84429c69789fd29ffa3a254d86abdd.js integrity="sha256-6PGSg6YyB3CFua10rsrVSr6EQpxpeJ/Sn/o6JU2Gq90=" defer></script>
<script src=/main.min.82ab51144325fae71ddbca46269a80c63b28bdab6be6b01aa9ec638c013748e6.js integrity="sha256-gqtRFEMl+ucd28pGJpqAxjsovatr5rAaqexjjAE3SOY=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.7cfac95bdd962d85ceec560e50fe7b04c44b58a76e5202006ef36ca8c0a7d836.css integrity="sha256-fPrJW92WLYXO7FYOUP57BMRLWKduUgIAbvNsqMCn2DY="><link rel=stylesheet href=/main.min.21cc0ec02bdbc197a68cb2e246e6db6d9df556ba2994084c55a6f8b6713e604d.css integrity="sha256-IcwOwCvbwZemjLLiRubbbZ31VroplAhMVab4tnE+YE0="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Palette Swapping</h1><div class=entry-meta><span class=entry-date>2014-12-23</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/racket>Racket</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/scheme>Scheme</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a class=taxonomy-value href=/programming/sources/stack-exchange>Stack Exchange</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2014/11/04/clockception/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/graphics>Graphics</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2013/04/16/adventures-in-optimization-re-typed-racket/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2014/06/17/factor-trees/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/trees>Trees</a><a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2014/11/13/a-one-line-echo-server-using-let-in-racket/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2015/01/01/generating-omnichromatic-images/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2014/11/30/nanowrimo-2014-winner/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2015/01/01/2015-reading-list/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>Today&rsquo;s task comes from the <a href=https://codegolf.stackexchange.com/>Code Golf StackExchange</a>. The idea behind <a href=https://en.wikipedia.org/wiki/code%20golf>code golf</a> is to write a program with as few characters as possible, often rendering the code nigh on unreadable. Luckily, the same StackExchange also host popularity contests, one of which is the inspiration behind today&rsquo;s post:</p><blockquote><p>You are given two true color images, the Source and the Palette. They do not necessarily have the same dimensions but it is guaranteed that their areas are the same, i.e. they have the same number of pixels.
Your task is to create an algorithm that makes the most accurate looking copy of the Source by only using the pixels in the Palette. Each pixel in the Palette must be used exactly once in a unique position in this copy. The copy must have the same dimensions as the Source.
&ndash; <a href=https://codegolf.stackexchange.com/questions/33172/american-gothic-in-the-palette-of-mona-lisa-rearrange-the-pixels>American Gothic in the palette of Mona Lisa: Rearrange the pixels</a></p></blockquote><p>Specifically for this post, we&rsquo;ll be using two source images, although for testing I had a whole pile more:</p><table><thead><tr><th><a href=https://en.wikipedia.org/wiki/Mona%20Lisa>Mona Lisa</a> by <a href=https://en.wikipedia.org/wiki/Leonardo%20da%20Vinci>Leonardo da Vinci</a>, c. 1503-1506</th><th><a href=https://en.wikipedia.org/wiki/The%20Scream>The Scream</a> by <a href=https://en.wikipedia.org/wiki/Edvard%20Munch>Edvard Munch</a>, 1893</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa.png></figure></td><td><figure><img src=/embeds/2014/scream.png></figure></td></tr></tbody></table><p>There are a bunch of different ways to solve this, but today we&rsquo;ll go through three of them:</p><ul><li>Sort the colors in both images</li><li>Swap pixels until the image is &lsquo;close enough&rsquo;</li><li>Fill in pixels greedily</li></ul><h2 id=sort-the-colors-in-both-images>Sort the colors in both images</h2><p>The first algorithm sounds crazy until you try it. In psuedocode:</p><ul><li>Create a list of pixels from each image</li><li>Sort the two lists by a given comparator</li><li>For each pair of pixels in the two lists, take the color from the target image and the location from the source image</li></ul><p>And that&rsquo;s actually it. It turns out the code is just about as simple, with most of the length going into loading and saving the images and format juggling.
First, we want a way of representing pixels which in this context are a color and a location:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; A color with a location</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>struct</span> pixel (x y c) <span style=color:#66d9ef>#:transparent</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Sorting function based on grayscale value</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (pixel&lt;?/grayscale p1 p2)
</span></span><span style=display:flex><span>    (&lt; (apply + (flvector-&gt;list (pixel-c p1)))
</span></span><span style=display:flex><span>       (apply + (flvector-&gt;list (pixel-c p2)))))
</span></span></code></pre></div><p>We&rsquo;ll use <code>pixel&amp;lt;?/grayscale</code> as a basic sorting function. It works well enough, although it could probably be tuned to more accurately model human vision.</p><p>Next, the piÃ¨ce de rÃ©sistance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Recolor an image by sorting the pixels in both images</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (recolor/sort original-src target-src
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>#:pixel&lt;?</span> [pixel&lt;? pixel&lt;?/grayscale])
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> original (load-flomap original-src))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> target (load-flomap target-src))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Generate a list of pixels in each image</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (pixel-list fm)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for*/list</span> ([x (in-range (flomap-width fm))]
</span></span><span style=display:flex><span>                [y (in-range (flomap-height fm))])
</span></span><span style=display:flex><span>      (pixel x y (flomap-ref* fm x y))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> original-pixels (pixel-list original))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> target-pixels (pixel-list target))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Sort both lists by the given sorting function</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> sorted-original-pixels (sort original-pixels pixel&lt;?))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> sorted-target-pixels (sort target-pixels pixel&lt;?))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Build a map from source xy to list index to target color</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> transition-hash
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for/fold</span> ([h (hash)])
</span></span><span style=display:flex><span>              ([original-pixel (in-list sorted-original-pixels)]
</span></span><span style=display:flex><span>               [target-pixel (in-list sorted-target-pixels)])
</span></span><span style=display:flex><span>      (hash-set h
</span></span><span style=display:flex><span>                (list (pixel-x original-pixel)
</span></span><span style=display:flex><span>                      (pixel-y original-pixel))
</span></span><span style=display:flex><span>                (pixel-c target-pixel))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Build the new image from that transition matrix</span>
</span></span><span style=display:flex><span>  (flomap-&gt;bitmap
</span></span><span style=display:flex><span>   (build-flomap*
</span></span><span style=display:flex><span>    (flomap-components original)
</span></span><span style=display:flex><span>    (flomap-width original) (flomap-height original)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>Î»</span> (x y)
</span></span><span style=display:flex><span>      (hash-ref transition-hash (list x y))))))
</span></span></code></pre></div><p>Going through the commented blocks, we have a fairly direct match for the psuedocode. One difference is because of the structure of the <code><a href="http://docs.racket-lang.org/search/index.html?q=build-flomap*">build-flomap*</a></code>
function. Since it&rsquo;s expects a generator rather than allowing us to generate arbitrary points, it&rsquo;s easier to make a map first. Still, about the same.</p><p>And when you apply it to the source images above?</p><table><thead><tr><th>Mona Lisa</th><th>The Scream</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa_scream_sort.png></figure></td><td><figure><img src=/embeds/2014/scream_mona-lisa_sort.png></figure></td></tr></tbody></table><p>That&rsquo;s actually really cool. It&rsquo;s really interesting how sorting by the grayscale values ends up recoloring the images while preserving small details in the grain of the background. Very neat. Even cooler, it&rsquo;s wicked fast. Since sorting is one of the more well understood problems in computer science, there are well known algorithms to use. In this case, our runtime is probably <span class=latex-inline>\mathcal{O}(n\log{}n)</span>
(with <em>n</em> as the number of pixels), since that is the runtime for the sort and both loading and writing the image are <span class=latex-inline>\mathcal{O}(n)</span>
.</p><h2 id=swap-pixels-until-the-image-is-close-enough>Swap pixels until the image is &lsquo;close enough&rsquo;</h2><p>Okay, that was straight forward. Let&rsquo;s see if we can do something different. This time, let&rsquo;s just brute force the problem. Rather than systematically dealing with the entire image at once:</p><ul><li>Scramble the pixels of the target image</li><li>Set <code>counter = 0</code></li><li>While <code>counter</code> &lt; <code>threshold</code></li></ul><ol><li>Choose two random pixels</li><li>Calculate the &rsquo;error&rsquo; of the image with the pixels at their current location, and the error with those two pixels swapped</li><li>If the swapped error is lower, swap the pixels and set <code>counter = 0</code>; otherwise, increment <code>counter</code></li></ol><p>First, let&rsquo;s define an error function based on the distance between two colors in RGB space (again, there are better functions we could use here):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Find the distance between two flvectors</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (fl-distance fl1 fl2)
</span></span><span style=display:flex><span>  (sqrt (<span style=color:#66d9ef>for/sum</span> ([a (in-vector (flvector-&gt;vector fl1))]
</span></span><span style=display:flex><span>                  [b (in-vector (flvector-&gt;vector fl2))])
</span></span><span style=display:flex><span>          (sqr (- a b)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Simple error function based on RGB distance</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (error/rgb-distance original-fm target-fm color-pixel location-pixel)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>match-define</span> (pixel x y <span style=color:#66d9ef>_</span>) location-pixel)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>match-define</span> (pixel <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> c) color-pixel)
</span></span><span style=display:flex><span>    (fl-distance (flomap-ref* original-fm x y) c))
</span></span></code></pre></div><p>Using that, we can the algorithm fairly directly into Racket:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Recolor an image by randomly swapping pixels based on improving error</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (recolor/swap original-src target-src
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>#:threshold</span> [threshold <span style=color:#ae81ff>100</span>]
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>#:error-function</span> [err error/rgb-distance])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> original (load-flomap original-src))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> target (load-flomap target-src))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> width (flomap-width original))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> height (flomap-height original))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Generate a 2d vector of pixels</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> pixels
</span></span><span style=display:flex><span>    (list-&gt;vector
</span></span><span style=display:flex><span>     (shuffle
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>for*/list</span> ([y (in-range (flomap-height target))]
</span></span><span style=display:flex><span>                  [x (in-range (flomap-width target))])
</span></span><span style=display:flex><span>        (flomap-ref* target x y)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Get/set a pixel in the pixel map</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (get x y)
</span></span><span style=display:flex><span>    (pixel x y (vector-ref pixels (+ x (* width y)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (<span style=color:#66d9ef>set!</span> x y c)
</span></span><span style=display:flex><span>    (vector-set! pixels (+ x (* width y)) c))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Get a random pixel (sized from the original image)</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (rnd) (get (random width) (random height)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Keep swapping pixels until we get a certain number of non-swaps in a row</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let</span> loop ([swap-count <span style=color:#ae81ff>0</span>] [non-swap-count <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> p1 (rnd))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> p2 (rnd))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Haven&#39;t swapped recently, return the result</span>
</span></span><span style=display:flex><span>      [(&gt;= non-swap-count threshold)
</span></span><span style=display:flex><span>       (flomap-&gt;bitmap
</span></span><span style=display:flex><span>        (build-flomap*
</span></span><span style=display:flex><span>         (flomap-components original)
</span></span><span style=display:flex><span>         (flomap-width original) (flomap-height original)
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>Î»</span> (x y)
</span></span><span style=display:flex><span>           (pixel-c (get x y)))))]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Swap is better, swap and reset count</span>
</span></span><span style=display:flex><span>      [(&lt; (+ (err original target p1 p2) (err original target p2 p1))
</span></span><span style=display:flex><span>          (+ (err original target p1 p1) (err original target p2 p2)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>set!</span> (pixel-x p1) (pixel-y p1) (pixel-c p2))
</span></span><span style=display:flex><span>       (<span style=color:#66d9ef>set!</span> (pixel-x p2) (pixel-y p2) (pixel-c p1))
</span></span><span style=display:flex><span>       (loop (+ swap-count <span style=color:#ae81ff>1</span>) <span style=color:#ae81ff>0</span>)]
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Swap is worse, just count</span>
</span></span><span style=display:flex><span>      [<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       (loop swap-count (+ non-swap-count <span style=color:#ae81ff>1</span>))])))
</span></span></code></pre></div><p>To start with, let&rsquo;s go for the default threshold of 100 consecutive errors:</p><table><thead><tr><th>Mona Lisa</th><th>The Scream</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa_scream_swap-100.png></figure></td><td><figure><img src=/embeds/2014/scream_mona-lisa_swap-100.png></figure></td></tr></tbody></table><p>It&rsquo;s a little grainy, mostly because you actually get a random spike of 100 error free swaps fairly easily (it turns out &lsquo;random&rsquo; isn&rsquo;t as uniform as most people think). Let&rsquo;s try cranking the threshold up to a thousand instead:</p><table><thead><tr><th>Mona Lisa</th><th>The Scream</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa_scream_swap-1k.png></figure></td><td><figure><img src=/embeds/2014/scream_mona-lisa_swap-1k.png></figure></td></tr></tbody></table><p>That&rsquo;s a lot better for The Scream, but now the Mona Lisa is having some issues with the red in hear hair. It turns out there&rsquo;s a reasonable amount of brown, but too much red so they&rsquo;re both fairly close in grayscale distance. Perhaps a better error metric would work better.</p><p>Also, it takes a lot longer. While sorting worked in seconds and 100 took about 30 seconds, 1000 took about 5 minutes per image. Especially in The Scream recolored, the different in quality is obvious, but the cost really isn&rsquo;t worth it when you compare to how just sorting the pixels did.</p><p>Alternatively, you can try a different error function. For example, this one takes the weighted average of a 3x3 area rather than a single pixel (threshold = 1000).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Slightly more complicated error function takes original image average into account</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (error/rgb-distance/average
</span></span><span style=display:flex><span>         original-fm target-fm
</span></span><span style=display:flex><span>         color-pixel location-pixel)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (pixel x y <span style=color:#66d9ef>_</span>) location-pixel)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>match-define</span> (pixel <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> c) color-pixel)
</span></span><span style=display:flex><span>  (fl-distance (flvector-scale
</span></span><span style=display:flex><span>                (foldl flvector+
</span></span><span style=display:flex><span>                       (flomap-ref* original-fm x y)
</span></span><span style=display:flex><span>                       (<span style=color:#66d9ef>for*/list</span> ([xd (in-range <span style=color:#ae81ff>-1</span> <span style=color:#ae81ff>2</span>)] [yd (in-range <span style=color:#ae81ff>-1</span> <span style=color:#ae81ff>2</span>)])
</span></span><span style=display:flex><span>                         (flomap-ref* original-fm (+ x xd) (+ y yd))))
</span></span><span style=display:flex><span>                (/ <span style=color:#ae81ff>1.0</span> <span style=color:#ae81ff>9.0</span>))
</span></span><span style=display:flex><span>               c))
</span></span></code></pre></div><table><thead><tr><th>Mona Lisa</th><th>The Scream</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa_scream_swap-1k-average.png></figure></td><td><figure><img src=/embeds/2014/scream_mona-lisa_swap-1k-average.png></figure></td></tr></tbody></table><p>Mostly, it just made it blurry. Which makes sense, since we&rsquo;re comparing regions rather than a single pixel, so edges are less heavily influential than they were. So it goes.</p><h2 id=fill-in-pixels-greedily>Fill in pixels greedily</h2><p>The third and final option was actually the first one that I came up with:</p><ul><li>Generate a list of all colors in the target image</li><li>For each pixel in the source image:</li></ul><ol><li>Find the most similar color in the target list</li><li>Place that color in the result</li><li>Remove it from the target list</li></ol><p>As a <a href=https://en.wikipedia.org/wiki/greedy%20algorithm>greedy algorithm</a>, it&rsquo;s theoretically fast but likely not optimal. What you end up getting is really good results for the first part of the image but increasingly bad results as the images diverge.</p><p>One neat trick I did here was that I could have just run from the top of the image down. But that would have lost out on a lot of the detail from the center of the image. So instead, I used the <code><a href="http://docs.racket-lang.org/search/index.html?q=racket/generator">racket/generator</a></code>
library to make this neat gem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Spiral outwards from (0,0) in squares</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (in-spiral [radius <span style=color:#ae81ff>+inf.0</span>])
</span></span><span style=display:flex><span>  (in-generator
</span></span><span style=display:flex><span>    (yield (list <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for</span> ([r (in-range <span style=color:#ae81ff>1</span> radius)])
</span></span><span style=display:flex><span>      (yield (list (- r) (- r)))
</span></span><span style=display:flex><span>      (yield (list (- r) r))
</span></span><span style=display:flex><span>      (yield (list r (- r)))
</span></span><span style=display:flex><span>      (yield (list r r))
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>for</span> ([d (in-range (+ (- r) <span style=color:#ae81ff>1</span>) r)])
</span></span><span style=display:flex><span>        (yield (list (- r) d))
</span></span><span style=display:flex><span>        (yield (list r     d))
</span></span><span style=display:flex><span>        (yield (list d (- r)))
</span></span><span style=display:flex><span>        (yield (list d r))))))
</span></span></code></pre></div><p>That&rsquo;s much more Pythonic than Rackety, but it does work. Essentially, you get a square spiral moving out from the origin, first every pixel with x or y 1 different from the origin, then 2, then 3, etc. Neat.</p><p>Using that, we can the psuedocode into Racket:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Recolor an image finding the best pixels from the center out</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (recolor/fill/slow original-src target-src)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> original (load-flomap original-src))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> target (load-flomap target-src))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> width (flomap-width original))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> height (flomap-height original))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Generate a list of target colors</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> colors
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for*/list</span> ([y (in-range (flomap-height target))]
</span></span><span style=display:flex><span>                [x (in-range (flomap-width target))])
</span></span><span style=display:flex><span>      (flomap-ref* target x y)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Generate a 2d vector of pixels</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> result
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>for*/vector</span> ([y (in-range (flomap-height original))]
</span></span><span style=display:flex><span>                  [x (in-range (flomap-width original))])
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>#f</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Get/set a pixel in the pixel map</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (result-get x y)
</span></span><span style=display:flex><span>    (vector-ref result (+ x (* width y))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> (result-set! x y c)
</span></span><span style=display:flex><span>    (vector-set! result (+ x (* width y)) c))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Spiral outwards from the center of the image</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for</span> ([pt (in-spiral (+ <span style=color:#ae81ff>2</span> (quotient (max width height) <span style=color:#ae81ff>2</span>)))])
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Convert to image coordinates and verify that we&#39;re in the image</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> x (+ (first pt) (quotient width <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>define</span> y (+ (second pt) (quotient height <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>and</span> (&gt;= x <span style=color:#ae81ff>0</span>) (&lt; x width) (&gt;= y <span style=color:#ae81ff>0</span>) (&lt; y height))
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Get the source color at that point</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define</span> target-color (flomap-ref* original x y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Choose the closest remaining color</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>define-values</span> (<span style=color:#66d9ef>_</span> color)
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>for/fold</span> ([minimum-distance <span style=color:#ae81ff>+inf.0</span>] [best-color <span style=color:#66d9ef>#f</span>])
</span></span><span style=display:flex><span>                  ([color (in-list colors)])
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>define</span> new-distance (fl-distance target-color color))
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>if</span> (&lt; new-distance minimum-distance)
</span></span><span style=display:flex><span>              (values new-distance color)
</span></span><span style=display:flex><span>              (values minimum-distance best-color))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>; Remove that color from the list to place, add it to the result</span>
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>set!</span> colors (remove color colors))
</span></span><span style=display:flex><span>      (result-set! x y color)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Turn that into a bitmap</span>
</span></span><span style=display:flex><span>  (flomap-&gt;bitmap
</span></span><span style=display:flex><span>   (build-flomap*
</span></span><span style=display:flex><span>    (flomap-components original)
</span></span><span style=display:flex><span>    (flomap-width original) (flomap-height original)
</span></span><span style=display:flex><span>    result-get)))
</span></span></code></pre></div><p>That&rsquo;s pretty straight forward. The most interesting bit is probably the <code><a href="http://docs.racket-lang.org/search/index.html?q=for/fold">for/fold</a></code>
in the middle. It&rsquo;s a quick way of finding the minimum value in a list where the value itself isn&rsquo;t what you&rsquo;re interested in. Another option would have been to <code>sort</code> with a custom sorting function, but that would in this case be slower (<span class=latex-inline>\mathcal{O}(n)</span>
versus <span class=latex-inline>\mathcal{O}(n\log{}n)</span>
).</p><table><thead><tr><th>Mona Lisa</th><th>The Scream</th></tr></thead><tbody><tr><td><figure><img src=/embeds/2014/mona-lisa_scream_fill.png></figure></td><td><figure><img src=/embeds/2014/scream_mona-lisa_fill.png></figure></td></tr></tbody></table><p>Okay, that&rsquo;s just weird. ðŸ˜„ Basically, there are enough shared pixels in the two images that you can more or less reconstruct the center sections. After that though&mldr; All bets are off. You didn&rsquo;t get this in either of the previous solutions because in the sorting case, they ended up spread throughout similarly color regions while in swapping they just didn&rsquo;t move from where they started.</p><p>Also, there&rsquo;s another problem. It&rsquo;s slow. Since this was actually the first thing that I worked on, I did wanit to take a little bit of time to make it faster:</p><h2 id=filling-pixels-data-structures-strike-back>Filling pixels: Data structures strike back</h2><p>The main problem with the fill solution is that for each pixel <span class=latex-inline>\mathcal{O}(n)</span>
, you&rsquo;re going to run through every pixel in the target image (another <span class=latex-inline>\mathcal{O}(n)</span>
), resulting in an <span class=latex-inline>\mathcal{O}(n^2)</span>
runtime. Not particularly great. Especially because we shouldn&rsquo;t have to scan through the entire list (or even the average of half of it) to find the closest matching pixel.</p><p>Instead, we should be able to do something like a <a href=https://en.wikipedia.org/wiki/binary%20search>binary search</a>:</p><ul><li>Start with a lower and upper bound of the entire list</li><li>Until we find the closest color:</li></ul><ol><li>Find the midpoint of the current bounds</li><li>If the target color is &rsquo;less than&rsquo; that, set the upper bound to the midpoint, otherwise set the lower bound to the midpoint</li><li>Repeat</li></ol><p>If we could get something like that working, we would only need <span class=latex-inline>\mathcal{O}(\log{}n)</span>
per lookup, reducing the runtime to the same as the <code>recolor/sort</code> method. And&mldr; it turns out that Racket has just the sort of data strucure we need: a <a href=https://en.wikipedia.org/wiki/splay%20tree>splay tree</a>. Specifically, a splay tree is a binary tree (enabling binary search), that self-adjusts (to avoid worst case badly unbalanced trees), which has the additional property of making recently accessed elements quick to access. That&rsquo;s helpful in this case, since we&rsquo;ll have blocks of similar colors, which are close in the tree. Neat!</p><p>In Racket, to build a splay tree, we need to set up a couple of things in the <code><a href="http://docs.racket-lang.org/search/index.html?q=data/order">data/order</a></code>
and <code><a href="http://docs.racket-lang.org/search/index.html?q=data/splay-tree">data/splay-tree</a></code>
modules:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Find the distance between two flvectors</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (fl-distance fl1 fl2)
</span></span><span style=display:flex><span>  (sqrt (<span style=color:#66d9ef>for/sum</span> ([a (in-vector (flvector-&gt;vector fl1))]
</span></span><span style=display:flex><span>                  [b (in-vector (flvector-&gt;vector fl2))])
</span></span><span style=display:flex><span>          (sqr (- a b)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Test if two flvectors are equal</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (flvector=? flv1 flv2)
</span></span><span style=display:flex><span>  (not (<span style=color:#66d9ef>for/first</span> ([v1 (in-flvector flv1)]
</span></span><span style=display:flex><span>                   [v2 (in-flvector flv2)]
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>#:when</span> (not (= v1 v2)))
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>#t</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Test if one flvector is less than another by comparing each channel in order</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (flvector&lt;? flv1 flv2)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>for/first</span> ([v1 (in-flvector flv1)]
</span></span><span style=display:flex><span>              [v2 (in-flvector flv2)]
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>#:when</span> (not (= v1 v2)))
</span></span><span style=display:flex><span>    (&lt; v1 v2)))
</span></span></code></pre></div><p>Then, when loading the colors instead of building a list, we can make the splay tree:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#75715e>; Generate a list of target colors</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> colors
</span></span><span style=display:flex><span>  (make-splay-tree
</span></span><span style=display:flex><span>   (order <span style=color:#f92672>&#39;</span><span style=color:#e6db74>pixel-grayscale-order</span>
</span></span><span style=display:flex><span>          flvector?
</span></span><span style=display:flex><span>          flvector=?
</span></span><span style=display:flex><span>          flvector&lt;?)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>for*</span> ([y (in-range (flomap-height target))]
</span></span><span style=display:flex><span>       [x (in-range (flomap-width target))])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> color (flomap-ref* target x y))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>define</span> count (+ <span style=color:#ae81ff>1</span> (splay-tree-ref colors color <span style=color:#ae81ff>0</span>)))
</span></span><span style=display:flex><span>  (splay-tree-set! colors color count))
</span></span></code></pre></div><p>One thing we didn&rsquo;t have to do earlier was to keep track of counts for each pixel. In a list, we just duplicated the elements, for the splay tree this won&rsquo;t work as well.</p><p>Then, in the <code>recolor/fill</code> method, we tweak the color choosing function (previously the <code>for/fold</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#66d9ef>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Get the source color at that point</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> target-color (flomap-ref* original x y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Choose the closest remaining color</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> iter/&gt;= (splay-tree-iterate-least/&gt;=? colors target-color))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> iter/&lt;= (splay-tree-iterate-greatest/&lt;=? colors target-color))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> color
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>cond</span>
</span></span><span style=display:flex><span>    [(<span style=color:#66d9ef>and</span> iter/&gt;= iter/&lt;=)
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>define</span> c1 (splay-tree-iterate-key colors iter/&gt;=))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>define</span> c2 (splay-tree-iterate-key colors iter/&lt;=))
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if</span> (&lt; (fl-distance target-color c1)
</span></span><span style=display:flex><span>            (fl-distance target-color c2))
</span></span><span style=display:flex><span>         c1
</span></span><span style=display:flex><span>         c2)]
</span></span><span style=display:flex><span>    [iter/&gt;= (splay-tree-iterate-key colors iter/&gt;=)]
</span></span><span style=display:flex><span>    [iter/&lt;= (splay-tree-iterate-key colors iter/&lt;=)]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> count (splay-tree-ref colors color))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>if</span> (= count <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    (splay-tree-remove! colors color)
</span></span><span style=display:flex><span>    (splay-tree-set! colors color (- count <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(result-set! x y color)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>...</span>
</span></span></code></pre></div><p>The method for finding the smallest element greater than / largest less than a given element that isn&rsquo;t actually in the tree is a little weird, but it works out in the end. That&rsquo;s one nice thing about how crosslinked all of the Racket documentation is, I could just keep looking until I found the functions that I needed.</p><p>Give this a run&mldr; And it&rsquo;s a <em>lot</em> faster. Rather than an hour or more to run, it takes only seconds. It&rsquo;s a little bit slower than the sort (since the data structure is a little more complicated), but well within the same order of runtime.</p><p>Yet more evidence that perhaps you should pay attention in data structures class. ðŸ˜„</p><h2 id=conclusion>Conclusion</h2><p>And, that&rsquo;s it. That was a lot of fun to work out. I really love how the simplest algorithm is also the fastest and has arguably the best results (at least for these two images). So cool!</p><p>If you would like to check out the source code for today&rsquo;s post, you can do so here: <a href=https://github.com/jpverkamp/small-projects/tree/master/blog/palette-swap>palette-swap</a>. If you place multiple PNG images with the same number of pixels (aspect ratios don&rsquo;t matter) in the <code>input</code> subdirectory and run <code>test.rkt</code> it will generate a whole pile of images like you&rsquo;ve seen here.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>