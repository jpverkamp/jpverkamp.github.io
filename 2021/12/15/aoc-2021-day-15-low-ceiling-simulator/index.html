<!DOCTYPE html>
<html onclick >
<head>
    <title>AoC 2021 Day 15: Low Ceiling Simulator â€“ jverkamp.com</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8"><link rel="alternate" type="application/atom+xml" title="jverkamp.com (Atom 2.0)" href="//blog.jverkamp.com/feed/">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css" integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" />

<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel="stylesheet">

<link rel="stylesheet" href="/custom.css" defer />

    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
</head>
<body>
    <div id="wrapper"><header id="page-header" role="banner">
    <h1><a href="/">JP's Blog</a></h1>

    <ul id="page-header-links">
        <li>
            <a href="https://github.com/jpverkamp">GitHub</a> *
            <a href="https://www.flickr.com/photos/jpverkamp">Flickr</a> *
            <a href="/resume">Resume</a>
        </li>
        <li>
            <form action="//www.google.com/search" method="get" onsubmit="(function(obj){obj.q.value='site:blog.jverkamp.com '+obj.qfront.value;})(this)" class="navbar-form navbar-right" role="search" _lpchecked="1">
                <div class="form-group">
                    <input name="q" type="hidden">
                    <input name="qfront" type="text" class="form-control" placeholder="Search">
                    <button type="submit" class="btn btn-default" value="Search">Search</button>
                </div>
            </form>
        </li>
    </ul>

    <nav id="header-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation"><li><a href="https://blog.jverkamp.com/programming/">Programming</a></li><li><a href="https://blog.jverkamp.com/photography/">Photography</a></li><li><a href="https://blog.jverkamp.com/reviews/">Reviews</a></li><li><a href="https://blog.jverkamp.com/maker/">Maker</a></li><li><a href="https://blog.jverkamp.com/writing/">Writing</a></li><li><a href="https://blog.jverkamp.com/research/">Research</a></li><li class="subscription" data-subscription="rss"><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
        </ul>
    </nav>
</header>
<div id="page-content-wrapper">
            <div id="page-content"><article>
	<header>
		<h1 class="entry-title">AoC 2021 Day 15: Low Ceiling Simulator</h1>

        <div class="entry-meta"><span class="entry-date">2021-12-15</span>
            </div>

        <div class="entry-taxonomies"><div class="entry-tags"><ul class="taxonomy-keys"><li>
            <a class="taxonomy-key" href="/programming/languages/">Languages</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/" class="previous-link"></a><a class="taxonomy-value" href="/programming/languages/python">Python</a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/programming/sources/">Sources</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/" class="previous-link"></a><a class="taxonomy-value" href="/programming/sources/advent-of-code">Advent of Code</a></li></ul>
        </li><li>
            <a class="taxonomy-key" href="/series/">Series</a>
            <ul class="taxonomy-values"><li><a href="https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/" class="previous-link"></a><a class="taxonomy-value" href="/series/advent-of-code-2021">Advent of Code 2021</a></li></ul>
        </li><li><a class="taxonomy-key" href="/programming">programming</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/" class="previous-link">Prev</a>
                </ul>
        </li><li><a class="taxonomy-key" href="/">All Posts</a>
            <ul>
                <li><a href="https://blog.jverkamp.com/2021/12/14/eiteljorg-etc/" class="previous-link">Prev</a>
                </ul>
        </li></ul>
</div>
</div>
    </header>

	<div class="entry-content"><h3 id="source-chitonhttpsadventofcodecom2021day15">Source: <a href="https://adventofcode.com/2021/day/15">Chiton</a></h3>
<h4 id="part-1-given-a-grid-of-weights-find-the-minimum-path-from-top-left-to-top-right-return-the-total-weight-along-that-path"><strong>Part 1:</strong> Given a grid of weights, find the minimum path from top left to top right. Return the total weight along that path.</h4>
<p>A fairly standard thing to have to do, ripe for the <a href="https://en.wikipedia.org/wiki/A*%20search%20algorithm">A* search algorithm</a>. Which eventually I&rsquo;ll get to, but I&rsquo;ll admit, it wasn&rsquo;t the first algorithm I tried. ðŸ˜„</p>
<p>Let&rsquo;s do this. First, let&rsquo;s assume that we already have a <code>load</code> function that returns a map of <code>(x, y) -&gt; cost</code> as we&rsquo;ve done a number of times before. No matter what algorithm we use, the wrapping code is going to be the same:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">part1</span>(file: typer<span style="color:#f92672">.</span>FileText):

    map <span style="color:#f92672">=</span> load(file)
    best_path <span style="color:#f92672">=</span> explore(map)
    best_score <span style="color:#f92672">=</span> sum(map[x, y] <span style="color:#66d9ef">for</span> (x, y) <span style="color:#f92672">in</span> best_path[<span style="color:#ae81ff">1</span>:])

    logging<span style="color:#f92672">.</span>info(f<span style="color:#e6db74">&#39;{best_path=}&#39;</span>)
    <span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;{best_score=}&#39;</span>)
</code></pre></div><p>Now, all we have to do is write an explore function. The first algorithm I tried was to write a cached recursive function (like last time). Essentially:</p>
<div class="latex-block">
bestPath(x, y) = cost(x,y) + minimum \left\{\begin{matrix}
bestPath(x+1, y) \\ 
bestPath(x-1, y) \\ 
bestPath(x, y+1) \\ 
bestPath(x, y-1)
\end{matrix}\right.
</div>

<p>You have to make sure that you don&rsquo;t recur infinitely (so you have to pass around the points you&rsquo;ve visited so you don&rsquo;t form loops), but other than that, it should work&hellip; Except Python isn&rsquo;t really designed for that. Oh the number of &lsquo;maximum recursion depth reached&rsquo; errors I got. Anyways.</p>
<p>Next solution:</p>
<ul>
<li>Start with a map of &lsquo;best known paths&rsquo; from each point to the goal (store the path + the cost)</li>
<li>Until the map has stabilized (doesn&rsquo;t change for an entire loop), loop across every point (x, y)
<ul>
<li>For each point, check each four neighbors for their minimum (path, cost)</li>
<li>If their (path, cost) + your cost is less than your current cost (or yours hasn&rsquo;t been set), store it</li>
</ul>
</li>
</ul>
<p>That means that you&rsquo;ll eventually fill in the entire graph. It&rsquo;s not super efficient, since you&rsquo;re going to be running it from top left to bottom right, where the grid fills from bottom right to top left&hellip; but it does work.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ python3 low-ceiling-simulator.py part1 input.txt
best_score<span style="color:#f92672">=</span><span style="color:#ae81ff">687</span>
<span style="color:#75715e"># time 2041809750ns / 2.04s</span>
</code></pre></div><p>That&rsquo;s&hellip; fairly slow already for such a small graph&hellip; but it works for part one. How does the code work?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">explore</span>(map: Mapping[Point, int]) <span style="color:#f92672">-&gt;</span> List[Point]:
    <span style="color:#e6db74">&#39;&#39;&#39;
</span><span style="color:#e6db74">    Version 1: Brute force, update all paths and iterate until stable. 
</span><span style="color:#e6db74">    &#39;&#39;&#39;</span>

    width <span style="color:#f92672">=</span> max(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> (x, _) <span style="color:#f92672">in</span> map)
    height <span style="color:#f92672">=</span> max(y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> (_, y) <span style="color:#f92672">in</span> map)

    bottom_right <span style="color:#f92672">=</span> (width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

    best_paths <span style="color:#f92672">=</span> {
        bottom_right: (<span style="color:#ae81ff">1</span>, [bottom_right])
    }

    <span style="color:#75715e"># Pass until the best path map stops changing</span>
    best_paths_changed <span style="color:#f92672">=</span> True
    generation <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">while</span> best_paths_changed:
        best_paths_changed <span style="color:#f92672">=</span> False
        generation <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        logging<span style="color:#f92672">.</span>info(f<span style="color:#e6db74">&#39;{generation=}, {len(best_paths)}/{len(map)} paths populated&#39;</span>)

        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(width):
            <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(height):
                neighbor_scores <span style="color:#f92672">=</span> [
                    best_paths[x <span style="color:#f92672">+</span> xd, y <span style="color:#f92672">+</span> yd]
                    <span style="color:#66d9ef">for</span> xd, yd <span style="color:#f92672">in</span> ORTHAGONAL
                    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">+</span> xd, y <span style="color:#f92672">+</span> yd) <span style="color:#f92672">in</span> best_paths
                ]

                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> neighbor_scores:
                    <span style="color:#66d9ef">continue</span>

                <span style="color:#75715e"># Find the best neighbor</span>
                best_score, best_path <span style="color:#f92672">=</span> min(neighbor_scores)

                new_score <span style="color:#f92672">=</span> map[x, y] <span style="color:#f92672">+</span> best_score
                new_path <span style="color:#f92672">=</span> [(x, y)] <span style="color:#f92672">+</span> best_path

                <span style="color:#75715e"># If we haven&#39;t found a path for this point or we found a better one, update</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> (x, y) <span style="color:#f92672">in</span> best_paths <span style="color:#f92672">or</span> new_score <span style="color:#f92672">&lt;</span> best_paths[x, y][<span style="color:#ae81ff">0</span>]:
                    best_paths_changed <span style="color:#f92672">=</span> True
                    best_paths[x, y] <span style="color:#f92672">=</span> (new_score, new_path)

    <span style="color:#66d9ef">return</span> best_paths[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]
</code></pre></div><p>More or less exactly what I described in the psuedo-code, just much longer.</p>
<p>Okay, let&rsquo;s see what part 2 has in store for us!</p>
<h4 id="part-2-extend-the-map-5x-in-each-direction-each-time-you-copy-the-map-rightdown-increase-all-values-by-1-wrapping-10-back-to-1-calculate-the-new-shortest-path"><strong>Part 2:</strong> Extend the map 5x in each direction. Each time you copy the map right/down, increase all values by 1, wrapping 10 back to 1. Calculate the new shortest path.</h4>
<p>Yeah. That&rsquo;s what I was worried about. It was already taking 2 seconds for a 100x100 grid and now we have to do 500x500. And that&rsquo;s not just 25 times as many paths&hellip; Even if you assume you can only go right or down (we&rsquo;ll come back to that), that&rsquo;s still a lot of paths&hellip;</p>
<div class="latex-block">
paths(N) = \binom{2(N-1)}{N-1}
<div class="latex-block">

<span class="latex-inline">paths(10, 10) = 48,620</span>
, <span class="latex-inline">paths(100, 100) = 2.27x10^58</span>
, <span class="latex-inline">paths(500) = 6.76x10^298</span>


Yeah. That grows fast. The algorithm that I wrote in part 1 certainly doesn't check all of those, but it's still far slower than I'd like:

```bash
$ python3 low-ceiling-simulator.py part2 input.txt
best_score=2957
# time 425408701709ns / 425.41s
```

Okay, before we go anywhere, let's build that new map. Not that bad, but a bit interesting to properly handle the increasing/changing values:

```python
def part2(file: typer.FileText):

    original_map = load(file)
    map: MutableMapping[Point, int] = dict(original_map)

    width = max(x + 1 for (x, _) in map)
    height = max(y + 1 for (_, y) in map)

    for bigx in range(5):
        for bigy in range(5):
            offset = bigy + bigy

            for x in range(width):
                for y in range(height):
                    newx = x + bigx * width
                    newy = y + bigy * height

                    map[newx, newy] = (map[x, y] + bigx + bigy)
                    if map[newx, newy] > 9:
                        map[newx, newy] -= 9

    best_path = explore(map)
    best_score = sum(map[x, y] for (x, y) in best_path[1:])

    logging.info(f'{best_path=}')
    print(f'{best_score=}')
```

Cool. 

Now let's explore a few more choices. First, let's assume that you can only go down or right. That makes the algorithm much simpler, since you can essentially start in the bottom right and fill in each square that has a value down and right of itself. Something like this:

```python
def explore_2(map: Mapping[Point, int]) -> List[Point]:
    '''
    Version 2: Scan from the bottom right.

    NOTE: This version cannot handle paths that move up or left.
    '''

    width = max(x + 1 for (x, _) in map)
    height = max(y + 1 for (_, y) in map)

    bottom_right = (width - 1, height - 1)

    best_paths = {
        bottom_right: (1, [bottom_right])
    }

    # Start with the two points adjacent to bottom right
    to_scan = [
        (width - 2, height - 1),
        (width - 1, height - 2),
    ]

    while to_scan:
        (x, y) = to_scan[0]
        to_scan = to_scan[1:]

        # If it's out of bounds, skip
        if (x, y) not in map:
            continue

        # If it's already been scanned, skip
        if (x, y) in best_paths:
            continue

        logging.info(f'Scanning ({x}, {y}), {len(to_scan)}/{len(map)} remaining')

        # Find the best path to get to this point
        neighbors = [
            best_paths[x + xd, y + yd]
            for xd, yd in ORTHAGONAL
            if (x + xd, y + yd) in best_paths
        ]

        best_score, best_path = min(neighbors)

        best_paths[x, y] = (
            map[x, y] + best_score,
            [(x, y)] + best_path
        )

        # Add adjacent points to scan next
        # We'll handle duplicates and out of bounds at the top of the loop
        for xd, yd in ORTHAGONAL:
            to_scan.append((x + xd, y + yd))

    return best_paths[0, 0][1]
```

It's using a queue to keep track of where we're going, so essentially scanning in a circle from the bottom right (that makes the code a bit longer). But, it only takes one past and doesn't have to settle. But most importantly, is it faster? (And I guess... does it work?)

```bash
$ python3 low-ceiling-simulator.py --version 2 part2 input.txt
best_score=2962
# time 6651538833ns / 6.65s
```

Yes! ... and no. 

It does return much faster, only taking a few seconds. But it doesn't actually work. It seems that somewhere in my actual input data, there is a case where it's cheaper to go back up/left and loop a bit than to always go directly down/right. Fascinating. But it also means that, while fast, this algorithm is a no go. 

So let's go back to part 1 and mix in a bit of part 2 to try to make it a little smarter. Continue with the same 'iterate until stable' algorithm, but instead of starting in the top left, start in the bottom right. That should mean we can fill in initial values for the entire graph in one pass, then only start cleaning up after that. It will do roughly the same amount of work, but should converge a lot faster. Something like this:

```python
def explore_3(map: Mapping[Point, int]) -> List[Point]:
    '''
    Version 3: Iterate until stable again, but this time from the bottom right.
    '''

    width = max(x + 1 for (x, _) in map)
    height = max(y + 1 for (_, y) in map)

    bottom_right = (width - 1, height - 1)

    best_paths = {
        bottom_right: (1, [bottom_right])
    }

    changed_paths = 1
    while changed_paths:
        changed_paths = 0

        for x in range(width - 1, -1, -1):
            for y in range(height - 1, -1, -1):
                if (x, y) == bottom_right:
                    continue

                # Find the best path to get to this point
                neighbors = [
                    best_paths[x + xd, y + yd]
                    for xd, yd in ORTHAGONAL
                    if (x + xd, y + yd) in best_paths
                ]

                best_score, best_path = min(neighbors)
                new_score = map[x, y] + best_score
                new_path = [(x, y)] + best_path

                if (x, y) not in best_paths or new_score < best_paths[x, y][0]:
                    best_paths[x, y] = (new_score, new_path)
                    changed_paths += 1

        logging.info(f'Finished iteration, {changed_paths} paths changed')

    return best_paths[0, 0][1]
```

So... did that help?

```bash
$ python3 low-ceiling-simulator.py --version 3 part2 input.txt
best_score=2957
# time 43515557208ns / 43.52s
```

Yes... ish? We have the right answer again and it is about an order of magnitude faster. And it does run in under a minute. So that's probably enough to leave it.

But I know we can do better. After all, there wouldn't happen to be an entire field dedicated to studying exactly these sorts of algorithms, now wouldn't there be?

ðŸ˜„

Yeah, I know. I should have just started with A*. It's designed exactly for this sort of thing. Let's start with code this time, then explain it:

```python
def explore_astar(map: Mapping[Point, int]) -> List[Point]:
    '''
    Solve the problem using the A* algorithm.
    '''

    from queue import PriorityQueue

    width = max(x + 1 for (x, _) in map)
    height = max(y + 1 for (_, y) in map)

    start = (0, 0)
    goal = (width - 1, height - 1)

    def h(p):
        return abs(goal[0] - p[0]) + abs(goal[1] - p[1])

    sources: MutableMapping[Point, Tuple[Optional[Point], int]] = {
        start: (None, 0)
    }

    q: PriorityQueue = PriorityQueue()

    q.put((0, start))

    while q:
        logging.info(f'Queue size: {q.qsize()}')

        _, current = q.get()
        (x, y) = current

        if current == goal:
            break

        for xd, yd in ORTHAGONAL:
            next = (x + xd, y + yd)
            if next not in map:
                continue

            new_cost = sources[current][1] + map[current]

            if next not in sources or new_cost < sources[next][1]:
                sources[next] = (current, new_cost)
                q.put((new_cost + h(next), next))

    logging.info(f'Found solution after evaluating {len(sources)} paths')

    best_path = []
    current = goal

    while current:
        best_path.append(current)
        current, score = sources[current]

    best_path = list(reversed(best_path))

    return best_path
```

Okay, so the code is longer, but I don't think it's that much more confusing to read. I think the more confusing part is the guarantee that this *will work*. And that comes down to the heuristic function `h`. So long as `h` is 'admissible' (it will never underestimate the minimum possible cost), you are guaranteed that when you find a solution, it will be optimal. 

And it is *fast*:

```bash
$ python3 low-ceiling-simulator.py --version 4 part2 input.txt
best_score=2957
# time 1903772750ns / 1.90s
```

Yeah... I probably should have just started with that. Oh, and technically all of these algorithms work on part 1 as well:

```bash
$ python3 low-ceiling-simulator.py part1 input.txt
best_score=687
# time 1759175041ns / 1.76s

$ python3 low-ceiling-simulator.py --version 2 part1 input.txt
best_score=687
# time 94618792ns / 0.09s

$ python3 low-ceiling-simulator.py --version 3 part1 input.txt
best_score=687
# time 300569292ns / 0.30s

$ python3 low-ceiling-simulator.py --version 4 part1 input.txt
best_score=687
# time 97045500ns / 0.10s
```

Just less necessary.

Journey before destination and all that. ðŸ˜„</div>
</div></div>
</article></div>
        </div><footer id="page-footer" role="contentinfo">
    <nav id="footer-navigation" role="navigation" class="ribbon">
        <ul class="main-navigation">
            <li><a href="/archive-by-date/">All posts: By Date</a></li>
            <li><a href="/archive-by-tag/">All posts: By Tag</a></li>

            <li>
                <a href="/atom.xml">
                    RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li><li>
                <a href="/programming/atom.xml">
                    RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24">
    <path fill="white" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z" />
</svg>
</sup>
                </a>
            </li></ul>
    </nav>

    <div id="page-footer-content">
        <div class="legal">
            <p>
                All posts unless otherwise mentioned are licensed under
                <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">
                    <img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png">
                </a>
            </p>

            <p>
                Any source code unless otherwise mentioned is licensed under the <a href="//directory.fsf.org/wiki/License:BSD_3Clause">3 clause BSD license</a>
            </p>
        </div>
    </div>
</footer>
</div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js" integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js" integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin="anonymous"></script>

<script src="/custom.js"></script>
</body>
</html>
