<!doctype html><html>
<head>
<title>AoC 2021 Day 15: Low Ceiling Simulator â€“ jverkamp.com</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous>
<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet>
<link rel=stylesheet href=/custom.css defer>
<script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script>
</head>
<body>
<div id=wrapper><header id=page-header role=banner>
<h1><a href=/>JP's Blog</a></h1>
<ul id=page-header-links>
<li>
<a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a>
</li>
<li>
<form action=//www.google.com/search method=get onsubmit="(function(a){a.q.value='site:blog.jverkamp.com '+a.qfront.value})(this)" class="navbar-form navbar-right" role=search _lpchecked=1>
<div class=form-group>
<input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button>
</div>
</form>
</li>
</ul>
<nav id=header-navigation role=navigation class=ribbon>
<ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li>
</ul>
</nav>
</header>
<div id=page-content-wrapper>
<div id=page-content><article>
<header>
<h1 class=entry-title>AoC 2021 Day 15: Low Ceiling Simulator</h1>
<div class=entry-meta><span class=entry-date>2021-12-15</span>
</div>
<div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li>
<a class=taxonomy-key href=/programming/languages/>Languages</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2021/12/16/aoc-2021-day-16-depacketinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/programming/sources/>Sources</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2021/12/16/aoc-2021-day-16-depacketinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/programming/topics/>Topics</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/12/aoc-2021-day-12-submarine-spider/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/a-star>A-Star</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/12/aoc-2021-day-12-submarine-spider/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/12/aoc-2021-day-12-submarine-spider/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/series/>Series</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2021>Advent of Code 2021</a><a href=https://blog.jverkamp.com/2021/12/16/aoc-2021-day-16-depacketinator/ class=next-link></a></li></ul>
</li><li><a class=taxonomy-key href=/programming>programming</a>
<ul>
<li><a href=https://blog.jverkamp.com/2021/12/14/aoc-2021-day-14-polymerizationinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/16/aoc-2021-day-16-depacketinator/ class=next-link>Next</a></ul>
</li><li><a class=taxonomy-key href=/>All Posts</a>
<ul>
<li><a href=https://blog.jverkamp.com/2021/12/14/eiteljorg-etc/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/16/aoc-2021-day-16-depacketinator/ class=next-link>Next</a></ul>
</li></ul>
</div>
</div>
</header>
<div class=entry-content><h3 id=source-chitonhttpsadventofcodecom2021day15>Source: <a href=https://adventofcode.com/2021/day/15>Chiton</a></h3>
<h4 id=part-1-given-a-grid-of-weights-find-the-minimum-path-from-top-left-to-top-right-return-the-total-weight-along-that-path><strong>Part 1:</strong> Given a grid of weights, find the minimum path from top left to top right. Return the total weight along that path.</h4>
<p>A fairly standard thing to have to do, ripe for the <a href=https://en.wikipedia.org/wiki/A*%20search%20algorithm>A* search algorithm</a>. Which eventually I&rsquo;ll get to, but I&rsquo;ll admit, it wasn&rsquo;t the first algorithm I tried. ðŸ˜„</p>
<p>Let&rsquo;s do this. First, let&rsquo;s assume that we already have a <code>load</code> function that returns a map of <code>(x, y) -> cost</code> as we&rsquo;ve done a number of times before. No matter what algorithm we use, the wrapping code is going to be the same:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(file: typer<span style=color:#f92672>.</span>FileText):

    map <span style=color:#f92672>=</span> load(file)
    best_path <span style=color:#f92672>=</span> explore(map)
    best_score <span style=color:#f92672>=</span> sum(map[x, y] <span style=color:#66d9ef>for</span> (x, y) <span style=color:#f92672>in</span> best_path[<span style=color:#ae81ff>1</span>:])

    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>best_path<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)
    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>best_score<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>Now, all we have to do is write an explore function. The first algorithm I tried was to write a cached recursive function (like last time). Essentially:</p>
<div class=latex-block>
bestPath(x, y) = cost(x,y) + minimum \left\{\begin{matrix}
bestPath(x+1, y) \\
bestPath(x-1, y) \\
bestPath(x, y+1) \\
bestPath(x, y-1)
\end{matrix}\right.
</div>
<p>You have to make sure that you don&rsquo;t recur infinitely (so you have to pass around the points you&rsquo;ve visited so you don&rsquo;t form loops), but other than that, it should work&mldr; Except Python isn&rsquo;t really designed for that. Oh the number of &lsquo;maximum recursion depth reached&rsquo; errors I got. Anyways.</p>
<p>Next solution:</p>
<ul>
<li>Start with a map of &lsquo;best known paths&rsquo; from each point to the goal (store the path + the cost)</li>
<li>Until the map has stabilized (doesn&rsquo;t change for an entire loop), loop across every point (x, y)
<ul>
<li>For each point, check each four neighbors for their minimum (path, cost)</li>
<li>If their (path, cost) + your cost is less than your current cost (or yours hasn&rsquo;t been set), store it</li>
</ul>
</li>
</ul>
<p>That means that you&rsquo;ll eventually fill in the entire graph. It&rsquo;s not super efficient, since you&rsquo;re going to be running it from top left to bottom right, where the grid fills from bottom right to top left&mldr; but it does work.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py part1 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>687</span>
<span style=color:#75715e># time 2041809750ns / 2.04s</span>
</code></pre></div><p>That&rsquo;s&mldr; fairly slow already for such a small graph&mldr; but it works for part one. How does the code work?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>explore</span>(map: Mapping[Point, int]) <span style=color:#f92672>-&gt;</span> List[Point]:
    <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>    Version 1: Brute force, update all paths and iterate until stable. 
</span><span style=color:#e6db74>    &#39;&#39;&#39;</span>

    width <span style=color:#f92672>=</span> max(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (x, _) <span style=color:#f92672>in</span> map)
    height <span style=color:#f92672>=</span> max(y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (_, y) <span style=color:#f92672>in</span> map)

    bottom_right <span style=color:#f92672>=</span> (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

    best_paths <span style=color:#f92672>=</span> {
        bottom_right: (<span style=color:#ae81ff>1</span>, [bottom_right])
    }

    <span style=color:#75715e># Pass until the best path map stops changing</span>
    best_paths_changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
    generation <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

    <span style=color:#66d9ef>while</span> best_paths_changed:
        best_paths_changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
        generation <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>generation<span style=color:#e6db74>=}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>len(best_paths)<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>{</span>len(map)<span style=color:#e6db74>}</span><span style=color:#e6db74> paths populated&#39;</span>)

        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(width):
            <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(height):
                neighbor_scores <span style=color:#f92672>=</span> [
                    best_paths[x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd]
                    <span style=color:#66d9ef>for</span> xd, yd <span style=color:#f92672>in</span> ORTHAGONAL
                    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd) <span style=color:#f92672>in</span> best_paths
                ]

                <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> neighbor_scores:
                    <span style=color:#66d9ef>continue</span>

                <span style=color:#75715e># Find the best neighbor</span>
                best_score, best_path <span style=color:#f92672>=</span> min(neighbor_scores)

                new_score <span style=color:#f92672>=</span> map[x, y] <span style=color:#f92672>+</span> best_score
                new_path <span style=color:#f92672>=</span> [(x, y)] <span style=color:#f92672>+</span> best_path

                <span style=color:#75715e># If we haven&#39;t found a path for this point or we found a better one, update</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> (x, y) <span style=color:#f92672>in</span> best_paths <span style=color:#f92672>or</span> new_score <span style=color:#f92672>&lt;</span> best_paths[x, y][<span style=color:#ae81ff>0</span>]:
                    best_paths_changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
                    best_paths[x, y] <span style=color:#f92672>=</span> (new_score, new_path)

    <span style=color:#66d9ef>return</span> best_paths[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</code></pre></div><p>More or less exactly what I described in the psuedo-code, just much longer.</p>
<p>Okay, let&rsquo;s see what part 2 has in store for us!</p>
<h4 id=part-2-extend-the-map-5x-in-each-direction-each-time-you-copy-the-map-rightdown-increase-all-values-by-1-wrapping-10-back-to-1-calculate-the-new-shortest-path><strong>Part 2:</strong> Extend the map 5x in each direction. Each time you copy the map right/down, increase all values by 1, wrapping 10 back to 1. Calculate the new shortest path.</h4>
<p>Yeah. That&rsquo;s what I was worried about. It was already taking 2 seconds for a 100x100 grid and now we have to do 500x500. And that&rsquo;s not just 25 times as many paths&mldr; Even if you assume you can only go right or down (we&rsquo;ll come back to that), that&rsquo;s still a lot of paths&mldr;</p>
<div class=latex-block>
paths(N) = \binom{2(N-1)}{N-1}
</div>
<p><span class=latex-inline>paths(10, 10) = 48620</span>
, <span class=latex-inline>paths(100, 100) = 2.27x10^{58}</span>
, <span class=latex-inline>paths(500) = 6.76x10^{298}</span>
</p>
<p>Yeah. That grows fast. The algorithm that I wrote in part 1 certainly doesn&rsquo;t check all of those, but it&rsquo;s still far slower than I&rsquo;d like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py part2 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>2957</span>
<span style=color:#75715e># time 425408701709ns / 425.41s</span>
</code></pre></div><p>Okay, before we go anywhere, let&rsquo;s build that new map. Not that bad, but a bit interesting to properly handle the increasing/changing values:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(file: typer<span style=color:#f92672>.</span>FileText):

    original_map <span style=color:#f92672>=</span> load(file)
    map: MutableMapping[Point, int] <span style=color:#f92672>=</span> dict(original_map)

    width <span style=color:#f92672>=</span> max(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (x, _) <span style=color:#f92672>in</span> map)
    height <span style=color:#f92672>=</span> max(y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (_, y) <span style=color:#f92672>in</span> map)

    <span style=color:#66d9ef>for</span> bigx <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
        <span style=color:#66d9ef>for</span> bigy <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
            offset <span style=color:#f92672>=</span> bigy <span style=color:#f92672>+</span> bigy

            <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(width):
                <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(height):
                    newx <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> bigx <span style=color:#f92672>*</span> width
                    newy <span style=color:#f92672>=</span> y <span style=color:#f92672>+</span> bigy <span style=color:#f92672>*</span> height

                    map[newx, newy] <span style=color:#f92672>=</span> (map[x, y] <span style=color:#f92672>+</span> bigx <span style=color:#f92672>+</span> bigy)
                    <span style=color:#66d9ef>if</span> map[newx, newy] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>9</span>:
                        map[newx, newy] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>9</span>

    best_path <span style=color:#f92672>=</span> explore(map)
    best_score <span style=color:#f92672>=</span> sum(map[x, y] <span style=color:#66d9ef>for</span> (x, y) <span style=color:#f92672>in</span> best_path[<span style=color:#ae81ff>1</span>:])

    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>best_path<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)
    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>best_score<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>Cool.</p>
<p>Now let&rsquo;s explore a few more choices. First, let&rsquo;s assume that you can only go down or right. That makes the algorithm much simpler, since you can essentially start in the bottom right and fill in each square that has a value down and right of itself. Something like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>explore_2</span>(map: Mapping[Point, int]) <span style=color:#f92672>-&gt;</span> List[Point]:
    <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>    Version 2: Scan from the bottom right.
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>    NOTE: This version cannot handle paths that move up or left.
</span><span style=color:#e6db74>    &#39;&#39;&#39;</span>

    width <span style=color:#f92672>=</span> max(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (x, _) <span style=color:#f92672>in</span> map)
    height <span style=color:#f92672>=</span> max(y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (_, y) <span style=color:#f92672>in</span> map)

    bottom_right <span style=color:#f92672>=</span> (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

    best_paths <span style=color:#f92672>=</span> {
        bottom_right: (<span style=color:#ae81ff>1</span>, [bottom_right])
    }

    <span style=color:#75715e># Start with the two points adjacent to bottom right</span>
    to_scan <span style=color:#f92672>=</span> [
        (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>),
        (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>),
    ]

    <span style=color:#66d9ef>while</span> to_scan:
        (x, y) <span style=color:#f92672>=</span> to_scan[<span style=color:#ae81ff>0</span>]
        to_scan <span style=color:#f92672>=</span> to_scan[<span style=color:#ae81ff>1</span>:]

        <span style=color:#75715e># If it&#39;s out of bounds, skip</span>
        <span style=color:#66d9ef>if</span> (x, y) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> map:
            <span style=color:#66d9ef>continue</span>

        <span style=color:#75715e># If it&#39;s already been scanned, skip</span>
        <span style=color:#66d9ef>if</span> (x, y) <span style=color:#f92672>in</span> best_paths:
            <span style=color:#66d9ef>continue</span>

        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Scanning (</span><span style=color:#e6db74>{</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>), </span><span style=color:#e6db74>{</span>len(to_scan)<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>{</span>len(map)<span style=color:#e6db74>}</span><span style=color:#e6db74> remaining&#39;</span>)

        <span style=color:#75715e># Find the best path to get to this point</span>
        neighbors <span style=color:#f92672>=</span> [
            best_paths[x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd]
            <span style=color:#66d9ef>for</span> xd, yd <span style=color:#f92672>in</span> ORTHAGONAL
            <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd) <span style=color:#f92672>in</span> best_paths
        ]

        best_score, best_path <span style=color:#f92672>=</span> min(neighbors)

        best_paths[x, y] <span style=color:#f92672>=</span> (
            map[x, y] <span style=color:#f92672>+</span> best_score,
            [(x, y)] <span style=color:#f92672>+</span> best_path
        )

        <span style=color:#75715e># Add adjacent points to scan next</span>
        <span style=color:#75715e># We&#39;ll handle duplicates and out of bounds at the top of the loop</span>
        <span style=color:#66d9ef>for</span> xd, yd <span style=color:#f92672>in</span> ORTHAGONAL:
            to_scan<span style=color:#f92672>.</span>append((x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd))

    <span style=color:#66d9ef>return</span> best_paths[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</code></pre></div><p>It&rsquo;s using a queue to keep track of where we&rsquo;re going, so essentially scanning in a circle from the bottom right (that makes the code a bit longer). But, it only takes one past and doesn&rsquo;t have to settle. But most importantly, is it faster? (And I guess&mldr; does it work?)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>2</span> part2 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>2962</span>
<span style=color:#75715e># time 6651538833ns / 6.65s</span>
</code></pre></div><p>Yes! &mldr; and no.</p>
<p>It does return much faster, only taking a few seconds. But it doesn&rsquo;t actually work. It seems that somewhere in my actual input data, there is a case where it&rsquo;s cheaper to go back up/left and loop a bit than to always go directly down/right. Fascinating. But it also means that, while fast, this algorithm is a no go.</p>
<p>So let&rsquo;s go back to part 1 and mix in a bit of part 2 to try to make it a little smarter. Continue with the same &lsquo;iterate until stable&rsquo; algorithm, but instead of starting in the top left, start in the bottom right. That should mean we can fill in initial values for the entire graph in one pass, then only start cleaning up after that. It will do roughly the same amount of work, but should converge a lot faster. Something like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>explore_3</span>(map: Mapping[Point, int]) <span style=color:#f92672>-&gt;</span> List[Point]:
    <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>    Version 3: Iterate until stable again, but this time from the bottom right.
</span><span style=color:#e6db74>    &#39;&#39;&#39;</span>

    width <span style=color:#f92672>=</span> max(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (x, _) <span style=color:#f92672>in</span> map)
    height <span style=color:#f92672>=</span> max(y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (_, y) <span style=color:#f92672>in</span> map)

    bottom_right <span style=color:#f92672>=</span> (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

    best_paths <span style=color:#f92672>=</span> {
        bottom_right: (<span style=color:#ae81ff>1</span>, [bottom_right])
    }

    changed_paths <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>while</span> changed_paths:
        changed_paths <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
            <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
                <span style=color:#66d9ef>if</span> (x, y) <span style=color:#f92672>==</span> bottom_right:
                    <span style=color:#66d9ef>continue</span>

                <span style=color:#75715e># Find the best path to get to this point</span>
                neighbors <span style=color:#f92672>=</span> [
                    best_paths[x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd]
                    <span style=color:#66d9ef>for</span> xd, yd <span style=color:#f92672>in</span> ORTHAGONAL
                    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd) <span style=color:#f92672>in</span> best_paths
                ]

                best_score, best_path <span style=color:#f92672>=</span> min(neighbors)
                new_score <span style=color:#f92672>=</span> map[x, y] <span style=color:#f92672>+</span> best_score
                new_path <span style=color:#f92672>=</span> [(x, y)] <span style=color:#f92672>+</span> best_path

                <span style=color:#66d9ef>if</span> (x, y) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> best_paths <span style=color:#f92672>or</span> new_score <span style=color:#f92672>&lt;</span> best_paths[x, y][<span style=color:#ae81ff>0</span>]:
                    best_paths[x, y] <span style=color:#f92672>=</span> (new_score, new_path)
                    changed_paths <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>

        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Finished iteration, </span><span style=color:#e6db74>{</span>changed_paths<span style=color:#e6db74>}</span><span style=color:#e6db74> paths changed&#39;</span>)

    <span style=color:#66d9ef>return</span> best_paths[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</code></pre></div><p>So&mldr; did that help?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>3</span> part2 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>2957</span>
<span style=color:#75715e># time 43515557208ns / 43.52s</span>
</code></pre></div><p>Yes&mldr; ish? We have the right answer again and it is about an order of magnitude faster. And it does run in under a minute. So that&rsquo;s probably enough to leave it.</p>
<p>But I know we can do better. After all, there wouldn&rsquo;t happen to be an entire field dedicated to studying exactly these sorts of algorithms, now wouldn&rsquo;t there be?</p>
<p>ðŸ˜„</p>
<p>Yeah, I know. I should have just started with A*. It&rsquo;s designed exactly for this sort of thing. Let&rsquo;s start with code this time, then explain it:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>explore_astar</span>(map: Mapping[Point, int]) <span style=color:#f92672>-&gt;</span> List[Point]:
    <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>    Solve the problem using the A* algorithm.
</span><span style=color:#e6db74>    &#39;&#39;&#39;</span>

    <span style=color:#f92672>from</span> queue <span style=color:#f92672>import</span> PriorityQueue

    width <span style=color:#f92672>=</span> max(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (x, _) <span style=color:#f92672>in</span> map)
    height <span style=color:#f92672>=</span> max(y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> (_, y) <span style=color:#f92672>in</span> map)

    start <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
    goal <span style=color:#f92672>=</span> (width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, height <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>h</span>(p):
        <span style=color:#66d9ef>return</span> abs(goal[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> p[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> abs(goal[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p[<span style=color:#ae81ff>1</span>])

    sources: MutableMapping[Point, Tuple[Optional[Point], int]] <span style=color:#f92672>=</span> {
        start: (<span style=color:#66d9ef>None</span>, <span style=color:#ae81ff>0</span>)
    }

    q: PriorityQueue <span style=color:#f92672>=</span> PriorityQueue()

    q<span style=color:#f92672>.</span>put((<span style=color:#ae81ff>0</span>, start))

    <span style=color:#66d9ef>while</span> q:
        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Queue size: </span><span style=color:#e6db74>{</span>q<span style=color:#f92672>.</span>qsize()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)

        _, current <span style=color:#f92672>=</span> q<span style=color:#f92672>.</span>get()
        (x, y) <span style=color:#f92672>=</span> current

        <span style=color:#66d9ef>if</span> current <span style=color:#f92672>==</span> goal:
            <span style=color:#66d9ef>break</span>

        <span style=color:#66d9ef>for</span> xd, yd <span style=color:#f92672>in</span> ORTHAGONAL:
            next <span style=color:#f92672>=</span> (x <span style=color:#f92672>+</span> xd, y <span style=color:#f92672>+</span> yd)
            <span style=color:#66d9ef>if</span> next <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> map:
                <span style=color:#66d9ef>continue</span>

            new_cost <span style=color:#f92672>=</span> sources[current][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> map[current]

            <span style=color:#66d9ef>if</span> next <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> sources <span style=color:#f92672>or</span> new_cost <span style=color:#f92672>&lt;</span> sources[next][<span style=color:#ae81ff>1</span>]:
                sources[next] <span style=color:#f92672>=</span> (current, new_cost)
                q<span style=color:#f92672>.</span>put((new_cost <span style=color:#f92672>+</span> h(next), next))

    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Found solution after evaluating </span><span style=color:#e6db74>{</span>len(sources)<span style=color:#e6db74>}</span><span style=color:#e6db74> paths&#39;</span>)

    best_path <span style=color:#f92672>=</span> []
    current <span style=color:#f92672>=</span> goal

    <span style=color:#66d9ef>while</span> current:
        best_path<span style=color:#f92672>.</span>append(current)
        current, score <span style=color:#f92672>=</span> sources[current]

    best_path <span style=color:#f92672>=</span> list(reversed(best_path))

    <span style=color:#66d9ef>return</span> best_path
</code></pre></div><p>Okay, so the code is longer, but I don&rsquo;t think it&rsquo;s that much more confusing to read. I think the more confusing part is the guarantee that this <em>will work</em>. And that comes down to the heuristic function <code>h</code>. So long as <code>h</code> is &lsquo;admissible&rsquo; (it will never underestimate the minimum possible cost), you are guaranteed that when you find a solution, it will be optimal.</p>
<p>And it is <em>fast</em>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>4</span> part2 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>2957</span>
<span style=color:#75715e># time 1903772750ns / 1.90s</span>
</code></pre></div><p>Yeah&mldr; I probably should have just started with that. Oh, and technically all of these algorithms work on part 1 as well:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 low-ceiling-simulator.py part1 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>687</span>
<span style=color:#75715e># time 1759175041ns / 1.76s</span>

$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>2</span> part1 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>687</span>
<span style=color:#75715e># time 94618792ns / 0.09s</span>

$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>3</span> part1 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>687</span>
<span style=color:#75715e># time 300569292ns / 0.30s</span>

$ python3 low-ceiling-simulator.py --version <span style=color:#ae81ff>4</span> part1 input.txt
best_score<span style=color:#f92672>=</span><span style=color:#ae81ff>687</span>
<span style=color:#75715e># time 97045500ns / 0.10s</span>
</code></pre></div><p>Just less necessary.</p>
<p>Journey before destination and all that. ðŸ˜„</p></div>
</article></div>
</div><footer id=page-footer role=contentinfo>
<nav id=footer-navigation role=navigation class=ribbon>
<ul class=main-navigation>
<li><a href=/archive-by-date/>All posts: By Date</a></li>
<li><a href=/archive-by-tag/>All posts: By Tag</a></li>
<li>
<a href=/atom.xml>
RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
</sup>
</a>
</li><li>
<a href=/programming/atom.xml>
RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
</sup>
</a>
</li></ul>
</nav>
<div id=page-footer-content>
<div class=legal>
<p>
All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US>
<img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png>
</a>
</p>
<p>
Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a>
</p>
</div>
</div>
</footer>
</div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer>mermaid.initialize({startOnLoad:!0,securityLevel:'loose'})</script>
<script defer src=/custom.js></script>
</body>
</html>