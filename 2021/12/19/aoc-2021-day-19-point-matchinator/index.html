<!doctype html><html>
<head>
<title>AoC 2021 Day 19: Point Matchinator â€“ jverkamp.com</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css integrity=sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb crossorigin=anonymous>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot-default.min.css integrity="sha256-s0KLB0LnI5oqhHF8gkgfmxU4usUFEHlWJTxT8q72Tq4=" crossorigin=anonymous>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous>
<link href="https://fonts.googleapis.com/css?family=Spectral+SC|Lato|Share+Tech+Mono" rel=stylesheet>
<link rel=stylesheet href=/custom.css defer>
<script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script>
</head>
<body>
<div id=wrapper><header id=page-header role=banner>
<h1><a href=/>JP's Blog</a></h1>
<ul id=page-header-links>
<li>
<a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a>
</li>
<li>
<form action=//www.google.com/search method=get onsubmit="(function(a){a.q.value='site:blog.jverkamp.com '+a.qfront.value})(this)" class="navbar-form navbar-right" role=search _lpchecked=1>
<div class=form-group>
<input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button>
</div>
</form>
</li>
</ul>
<nav id=header-navigation role=navigation class=ribbon>
<ul class=main-navigation><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li>
</ul>
</nav>
</header>
<div id=page-content-wrapper>
<div id=page-content><article>
<header>
<h1 class=entry-title>AoC 2021 Day 19: Point Matchinator</h1>
<div class=entry-meta><span class=entry-date>2021-12-19</span>
</div>
<div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li>
<a class=taxonomy-key href=/programming/languages/>Languages</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/18/aoc-2021-day-18-pairs-of-pairs/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/programming/sources/>Sources</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/18/aoc-2021-day-18-pairs-of-pairs/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/programming/topics/>Topics</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/18/aoc-2021-day-18-pairs-of-pairs/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/11/aoc-2021-day-11-octopus-flashinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a><a href=https://blog.jverkamp.com/2021/12/22/aoc-2021-day-22-cubinator/ class=next-link></a></li></ul>
</li><li>
<a class=taxonomy-key href=/series/>Series</a>
<ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/18/aoc-2021-day-18-pairs-of-pairs/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2021>Advent of Code 2021</a><a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=next-link></a></li></ul>
</li><li><a class=taxonomy-key href=/programming>programming</a>
<ul>
<li><a href=https://blog.jverkamp.com/2021/12/18/aoc-2021-day-18-pairs-of-pairs/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=next-link>Next</a></ul>
</li><li><a class=taxonomy-key href=/>All Posts</a>
<ul>
<li><a href=https://blog.jverkamp.com/2021/12/19/star-wars-episode-vi-return-of-the-jedi/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/20/mr.-robot-season-3/ class=next-link>Next</a></ul>
</li></ul>
</div>
</div>
</header>
<div class=entry-content><h3 id=source-snailfishhttpsadventofcodecom2021day19>Source: <a href=https://adventofcode.com/2021/day/19>Snailfish</a></h3>
<h4 id=part-1-you-will-be-given-a-series-of-scanners-each-of-which-will-tell-you-the-location-from-their-point-of-view-of-a-series-of-beacons-each-scanner-may-be-flipped-or-rotated-in-increments-of-90-degrees-in-any-direction-determine-where-each-scanner-and-beacon-is-by-overlaying-the-maps-with-at-least-pairwise-12-matches><strong>Part 1:</strong> You will be given a series of Scanners, each of which will tell you the location (from their point of view) of a series of Beacons. Each Scanner may be flipped or rotated in increments of 90 degrees in any direction. Determine where each Scanner and Beacon is by overlaying the maps (with at least pairwise 12 matches).</h4>
<p>That&mldr; was quite a problem to get right. It&rsquo;s a lot of match to make sure that the various coordinate systems can be converted between one another and computationally expensive to brute force. I haven&rsquo;t gotten this one much below 10 minutes&mldr; but at this point, I&rsquo;m just going to have to call it. It&rsquo;s a crazy problem.</p>
<p>Okay. Let&rsquo;s start with a 3-dimensional point:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@dataclass</span>(frozen<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span>:
    x: int
    y: int
    z: int

    <span style=color:#66d9ef>def</span> __repr__(self):
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>z<span style=color:#e6db74>}</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>&#39;</span>

    <span style=color:#a6e22e>@staticmethod</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>all_waggles</span>() <span style=color:#f92672>-&gt;</span> Generator[<span style=color:#e6db74>&#39;Point&#39;</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>]:
        <span style=color:#e6db74>&#39;&#39;&#39;Generate all waggle parameters (see Point.waggle)&#39;&#39;&#39;</span>

        <span style=color:#66d9ef>for</span> i, j, k <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>permutations((<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)):
            <span style=color:#66d9ef>for</span> ix <span style=color:#f92672>in</span> (<span style=color:#f92672>-</span>i, i):
                <span style=color:#66d9ef>for</span> jx <span style=color:#f92672>in</span> (<span style=color:#f92672>-</span>j, j):
                    <span style=color:#66d9ef>for</span> kx <span style=color:#f92672>in</span> (<span style=color:#f92672>-</span>k, k):
                        <span style=color:#66d9ef>yield</span> Point(ix, jx, kx)

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>waggle</span>(self, w: <span style=color:#e6db74>&#39;Point&#39;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#39;Point&#39;</span>:
        <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>        Return a new point reflected/reordered by the given coordinates.
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>        Each of w&#39;s x,y,z should be +- 1,2,3 and each of 1,2,3 should be used exactly once.
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>        reflect(3, 2, -1) should return Point(z, y, -x) for example.
</span><span style=color:#e6db74>        &#39;&#39;&#39;</span>

        d <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, self<span style=color:#f92672>.</span>x, self<span style=color:#f92672>.</span>y, self<span style=color:#f92672>.</span>z)

        <span style=color:#66d9ef>return</span> Point(
            d[abs(w<span style=color:#f92672>.</span>x)] <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> w<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>1</span>),
            d[abs(w<span style=color:#f92672>.</span>y)] <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> w<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>1</span>),
            d[abs(w<span style=color:#f92672>.</span>z)] <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> w<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>1</span>),
        )

    <span style=color:#66d9ef>def</span> __add__(self, other: <span style=color:#e6db74>&#39;Point&#39;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#39;Point&#39;</span>:
        <span style=color:#e6db74>&#39;&#39;&#39;Return the sum of two points.&#39;&#39;&#39;</span>

        <span style=color:#66d9ef>return</span> Point(self<span style=color:#f92672>.</span>x <span style=color:#f92672>+</span> other<span style=color:#f92672>.</span>x, self<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> other<span style=color:#f92672>.</span>y, self<span style=color:#f92672>.</span>z <span style=color:#f92672>+</span> other<span style=color:#f92672>.</span>z)

    <span style=color:#66d9ef>def</span> __sub__(self, other: <span style=color:#e6db74>&#39;Point&#39;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#39;Point&#39;</span>:
        <span style=color:#e6db74>&#39;&#39;&#39;Return the difference of two points, obv.&#39;&#39;&#39;</span>

        <span style=color:#66d9ef>return</span> Point(self<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> other<span style=color:#f92672>.</span>x, self<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> other<span style=color:#f92672>.</span>y, self<span style=color:#f92672>.</span>z <span style=color:#f92672>-</span> other<span style=color:#f92672>.</span>z)
</code></pre></div><p>Waggle? Waggle. Basically, that&rsquo;s the name I&rsquo;m using for flipping and mirroring about any of x/y/z. Specifically, any ordering of <code>(1, 2, 3)</code> (each can be positive or negative) to re-order the coordinates and possibly flip them around. That ends up with the 24 possible orientations (<code>all_waggles</code>).</p>
<p>Next, Scanners:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@dataclass</span>(frozen<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Scanner</span>:
    name: str
    points: FrozenSet[Point]

    <span style=color:#a6e22e>@staticmethod</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read</span>(file: TextIO) <span style=color:#f92672>-&gt;</span> Optional[<span style=color:#e6db74>&#39;Scanner&#39;</span>]:
        <span style=color:#e6db74>&#39;&#39;&#39;Read a Scanner from a filelike object&#39;&#39;&#39;</span>

        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> (name <span style=color:#f92672>:=</span> file<span style=color:#f92672>.</span>readline()<span style=color:#f92672>.</span>strip(<span style=color:#e6db74>&#39;- </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)):
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>

        points <span style=color:#f92672>=</span> set()
        <span style=color:#66d9ef>while</span> line <span style=color:#f92672>:=</span> file<span style=color:#f92672>.</span>readline()<span style=color:#f92672>.</span>strip():
            points<span style=color:#f92672>.</span>add(Point(<span style=color:#f92672>*</span>[int(v) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> line<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;,&#39;</span>)]))

        <span style=color:#66d9ef>return</span> Scanner(name, frozenset(points))

    <span style=color:#66d9ef>def</span> __or__(self, other: <span style=color:#e6db74>&#39;Scanner&#39;</span>) <span style=color:#f92672>-&gt;</span> Optional[Tuple[Point, Point, Set[Point]]]:
        <span style=color:#e6db74>&#39;&#39;&#39;Given another scanner, try to find the overlapping points.&#39;&#39;&#39;</span>

        <span style=color:#75715e># Try every waggle of their scanners, assume I&#39;m always right</span>
        <span style=color:#66d9ef>for</span> their_waggle <span style=color:#f92672>in</span> Point<span style=color:#f92672>.</span>all_waggles():
            their_waggled_points <span style=color:#f92672>=</span> {
                p<span style=color:#f92672>.</span>waggle(their_waggle)
                <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> other<span style=color:#f92672>.</span>points
            }

            logging<span style=color:#f92672>.</span>debug(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Comparing </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>points<span style=color:#e6db74>=}</span><span style=color:#e6db74> and </span><span style=color:#e6db74>{</span>their_waggled_points<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)

            <span style=color:#75715e># Choose where we think the &#39;other&#39; scanner is from our perspective</span>
            <span style=color:#66d9ef>for</span> my_zero <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>points:
                my_zeroed_points <span style=color:#f92672>=</span> {p <span style=color:#f92672>-</span> my_zero <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>points}

                <span style=color:#66d9ef>for</span> their_waggled_zero <span style=color:#f92672>in</span> their_waggled_points:
                    their_zeroed_points <span style=color:#f92672>=</span> {p <span style=color:#f92672>-</span> their_waggled_zero <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> their_waggled_points}

                    <span style=color:#75715e># Try to subtract that from all of our points</span>
                    <span style=color:#75715e># If we have enough matches, that means we know their scanner from our point of view</span>
                    matches <span style=color:#f92672>=</span> my_zeroed_points <span style=color:#f92672>&amp;</span> their_zeroed_points

                    <span style=color:#66d9ef>if</span> len(matches) <span style=color:#f92672>&gt;=</span> BEACON_OVERLAPPINGNESS:
                        <span style=color:#66d9ef>return</span> (their_waggle, my_zero <span style=color:#f92672>-</span> their_waggled_zero, {p <span style=color:#f92672>+</span> my_zero <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> matches})

        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>

    <span style=color:#66d9ef>def</span> __repr__(self):
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;@</span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>&#39;</span>
</code></pre></div><p>I don&rsquo;t know why I used <code>s0 | s1</code> as the operator for overlapping two scanners&mldr; but I did. Yay dunder methods?</p>
<p>The method here is actually pretty neat. Essentially, the matching algorithm is:</p>
<ul>
<li>Try every possible <code>waggle</code> (orientation that the other Scanner could be at)</li>
<li>Try every possible point from each scanner as the &lsquo;<code>zero</code>&rsquo; (the point at which we&rsquo;ve overlapping), <code>other</code> has to have their <code>zero</code> waggled</li>
<li>Calculate the offsets from the zero for each</li>
<li>If the <code>waggle</code> is correct (so that both Scanners are now facing the same way) and the <code>zeros</code> actually match&mldr; we&rsquo;re golden. We&rsquo;ll have at least 12 matches and can return</li>
<li>Calculate the points that overlapped along with the <code>waggle</code> necessary to convert between the zones</li>
</ul>
<p>That last step took&mldr; rather a while to get right. And all because of a much lower level bug up in the <code>their_waggled_points</code> part. Man it&rsquo;s hard to debug bad data. Garbage in, garbage out. That&rsquo;s still a neat algorithm though.</p>
<p>Next&mldr; let&rsquo;s combine these and try to figure out how to actually calculate all of the Beacons.</p>
<p>First, load the input and find initial mappings between every pair of Scanners. This is&mldr; horribly inefficient. I did at least make sure that if I do <code>[s0, s1]</code>, then I don&rsquo;t have to do <code>[s1, s0]</code> (they&rsquo;re the same). But otherwise, I really am going through all of them.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>scanners <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>while</span> s <span style=color:#f92672>:=</span> Scanner<span style=color:#f92672>.</span>read(file):
    scanners<span style=color:#f92672>.</span>append(s)
s0 <span style=color:#f92672>=</span> scanners[<span style=color:#ae81ff>0</span>]

logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;=== FINDING INITIAL OFFSETS ===&#39;</span>)
offsets: MutableMapping[Tuple[Scanner, Scanner], Tuple[Point, Point, Set[Point]]] <span style=color:#f92672>=</span> {}

<span style=color:#66d9ef>for</span> s0 <span style=color:#f92672>in</span> scanners:
    <span style=color:#66d9ef>for</span> s1 <span style=color:#f92672>in</span> scanners:
        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Finding the offset from </span><span style=color:#e6db74>{</span>s0<span style=color:#e6db74>=}</span><span style=color:#e6db74> to </span><span style=color:#e6db74>{</span>s1<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)

        <span style=color:#66d9ef>if</span> (s1, s0) <span style=color:#f92672>in</span> offsets:
            offsets[s0, s1] <span style=color:#f92672>=</span> offsets[s1, s0]

        <span style=color:#66d9ef>if</span> result <span style=color:#f92672>:=</span> (s0 <span style=color:#f92672>|</span> s1):
            offsets[s0, s1] <span style=color:#f92672>=</span> result
</code></pre></div><p>That will find Unfortunately, not every pair overlaps. So we can go from 0 to 1 and 1 to 4, but not directly from 0 to 4. And we want to be able to do that, to make sure we have <em>everything</em> in the same universal coordinate system. So next:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Fill in the entire chart</span>
logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;=== EXPANDING CHART ===&#39;</span>)
s0 <span style=color:#f92672>=</span> scanners[<span style=color:#ae81ff>0</span>]

<span style=color:#75715e># If we don&#39;t have a path from s0 to s1, try to go s0 -&gt; svia -&gt; s1</span>
updating <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
<span style=color:#66d9ef>while</span> updating:
    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;Working on expanding iteration&#39;</span>)
    updating <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>

    <span style=color:#66d9ef>for</span> s1 <span style=color:#f92672>in</span> scanners[<span style=color:#ae81ff>1</span>:]:
        <span style=color:#66d9ef>if</span> (s0, s1) <span style=color:#f92672>in</span> offsets:
            <span style=color:#66d9ef>continue</span>

        <span style=color:#66d9ef>for</span> svia <span style=color:#f92672>in</span> scanners[<span style=color:#ae81ff>1</span>:]:
            <span style=color:#66d9ef>if</span> s0 <span style=color:#f92672>==</span> svia <span style=color:#f92672>or</span> svia <span style=color:#f92672>==</span> s1:
                <span style=color:#66d9ef>continue</span>

            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> ((s0, svia) <span style=color:#f92672>in</span> offsets <span style=color:#f92672>and</span> (svia, s1) <span style=color:#f92672>in</span> offsets):
                <span style=color:#66d9ef>continue</span>

            logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Building a new path from </span><span style=color:#e6db74>{</span>s0<span style=color:#e6db74>}</span><span style=color:#e6db74> via </span><span style=color:#e6db74>{</span>svia<span style=color:#e6db74>}</span><span style=color:#e6db74> to </span><span style=color:#e6db74>{</span>s1<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)

            waggle1, offset1, _ <span style=color:#f92672>=</span> offsets[s0, svia]
            waggle2, offset2, points2 <span style=color:#f92672>=</span> offsets[svia, s1]

            new_waggle <span style=color:#f92672>=</span> waggle2<span style=color:#f92672>.</span>waggle(waggle1)
            new_offset <span style=color:#f92672>=</span> offset1 <span style=color:#f92672>+</span> offset2<span style=color:#f92672>.</span>waggle(waggle1)

            new_points <span style=color:#f92672>=</span> {
                offset1 <span style=color:#f92672>+</span> p<span style=color:#f92672>.</span>waggle(waggle1)
                <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> points2
            }

            offsets[s0, s1] <span style=color:#f92672>=</span> new_waggle, new_offset, new_points
            updating <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</code></pre></div><p>Getting that <code>new_points</code> right took a bit too. And it&rsquo;s all so simple&mldr; I enjoy naming things.</p>
<p>And that&rsquo;s mostly it. Go through now that we know the <code>offset</code> and <code>waggle</code> for every Scanner, we can actually map all of the Beacons they&rsquo;d seen into the same coordinate space and de-duplicate:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(file: typer<span style=color:#f92672>.</span>FileText):

    scanners <span style=color:#f92672>=</span> []
    <span style=color:#66d9ef>while</span> s <span style=color:#f92672>:=</span> Scanner<span style=color:#f92672>.</span>read(file):
        scanners<span style=color:#f92672>.</span>append(s)
    s0 <span style=color:#f92672>=</span> scanners[<span style=color:#ae81ff>0</span>]

    offsets <span style=color:#f92672>=</span> do_the_actual_work(scanners)

    <span style=color:#75715e># Finally, calculate all of the beacon points</span>
    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;=== FINDING BEACONS ===&#39;</span>)

    all_beacons <span style=color:#f92672>=</span> set()
    <span style=color:#66d9ef>for</span> scanner <span style=color:#f92672>in</span> scanners:
        waggle, offset, _ <span style=color:#f92672>=</span> offsets[s0, scanner]
        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Adding beacons from </span><span style=color:#e6db74>{</span>scanner<span style=color:#e6db74>}</span><span style=color:#e6db74> at </span><span style=color:#e6db74>{</span>offset<span style=color:#e6db74>}</span><span style=color:#e6db74> (with </span><span style=color:#e6db74>{</span>waggle<span style=color:#e6db74>=}</span><span style=color:#e6db74>)&#39;</span>)

        all_beacons <span style=color:#f92672>|=</span> {
            offset <span style=color:#f92672>+</span> p<span style=color:#f92672>.</span>waggle(waggle)
            <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> scanner<span style=color:#f92672>.</span>points
        }

    print(len(all_beacons))
</code></pre></div><p>And that&rsquo;s it!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 point-matchinator.py part1 input.txt
<span style=color:#ae81ff>313</span>
<span style=color:#75715e># time 412607815209ns / 412.61s</span>
</code></pre></div><p>Yeah. That&rsquo;s slow. But it works and at this point, that&rsquo;s enough for me.</p>
<h4 id=part-2-find-the-largest-manhattan-distance-between-any-two-scanners><strong>Part 2:</strong> Find the largest Manhattan Distance between any two Scanners.</h4>
<p>This actually doesn&rsquo;t need any more work. Just use the data we have and calculate the distances. That part is fast.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(file: typer<span style=color:#f92672>.</span>FileText):

    scanners <span style=color:#f92672>=</span> []
    <span style=color:#66d9ef>while</span> s <span style=color:#f92672>:=</span> Scanner<span style=color:#f92672>.</span>read(file):
        scanners<span style=color:#f92672>.</span>append(s)
    s0 <span style=color:#f92672>=</span> scanners[<span style=color:#ae81ff>0</span>]

    offsets <span style=color:#f92672>=</span> do_the_actual_work(scanners)

    <span style=color:#75715e># Finally, calculate all of the beacon points</span>
    logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;=== FINDING SCANNERS ===&#39;</span>)

    locations <span style=color:#f92672>=</span> set()
    <span style=color:#66d9ef>for</span> scanner <span style=color:#f92672>in</span> scanners:
        _, offset, _ <span style=color:#f92672>=</span> offsets[s0, scanner]
        locations<span style=color:#f92672>.</span>add(offset)

    print(max(
        abs(l1<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> l2<span style=color:#f92672>.</span>x) <span style=color:#f92672>+</span> abs(l1<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> l2<span style=color:#f92672>.</span>y) <span style=color:#f92672>+</span> abs(l1<span style=color:#f92672>.</span>z <span style=color:#f92672>-</span> l2<span style=color:#f92672>.</span>z)
        <span style=color:#66d9ef>for</span> l1 <span style=color:#f92672>in</span> locations
        <span style=color:#66d9ef>for</span> l2 <span style=color:#f92672>in</span> locations
    ))
</code></pre></div><p>It&rsquo;s no faster since I&rsquo;m still <code>doing_all_the_actual_work</code>, but if I&rsquo;m doing both parts, I could at least cache it. For now, onwards and good enoughwards.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ python3 point-matchinator.py part2 input.txt
<span style=color:#ae81ff>10656</span>
<span style=color:#75715e># time 397226430042ns / 397.23s</span>
</code></pre></div></div>
</article></div>
</div><footer id=page-footer role=contentinfo>
<nav id=footer-navigation role=navigation class=ribbon>
<ul class=main-navigation>
<li><a href=/archive-by-date/>All posts: By Date</a></li>
<li><a href=/archive-by-tag/>All posts: By Tag</a></li>
<li>
<a href=/atom.xml>
RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
</sup>
</a>
</li><li>
<a href=/programming/atom.xml>
RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
</sup>
</a>
</li></ul>
</nav>
<div id=page-footer-content>
<div class=legal>
<p>
All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US>
<img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png>
</a>
</p>
<p>
Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a>
</p>
</div>
</div>
</footer>
</div><script defer src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js integrity="sha256-yDarFEUo87Z0i7SaC6b70xGAKCghhWYAZ/3p+89o4lE=" crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js integrity=sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h crossorigin=anonymous></script>
<script defer src=https://cdnjs.cloudflare.com/ajax/libs/bigfoot/2.1.4/bigfoot.min.js integrity="sha256-2ylggML6rCJMc817KbE8Cx+cuxYIM+6bjG2Gpq2g7iU=" crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script defer>mermaid.initialize({startOnLoad:!0,securityLevel:'loose'})</script>
<script defer src=/custom.js></script>
</body>
</html>