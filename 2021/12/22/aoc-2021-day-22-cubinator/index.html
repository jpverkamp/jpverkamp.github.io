<!doctype html><html><head><title>AoC 2021 Day 22: Cubinator â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_17422284542669262002.min.834c1e2313951f0c25b90152fe8b62250eab4a2e8cbd2560fa1a1cdc91c71733.js integrity="sha256-g0weIxOVHwwluQFS/otiJQ6rSi6MvSVg+hoc3JHHFzM=" defer></script><script src=/jquery.fancybox_16245765822111608191.min.ef050764ff69f3287c89ff655825479dd8304dcd9bc653d1ddd4772a701ad445.js integrity="sha256-7wUHZP9p8yh8if9lWCVHndgwTc2bxlPR3dR3KnAa1EU=" defer></script><script src=/katex_17296078054267651618.min.deed0e78a77391517d530a00324ce7b760ac204134992ef22d36f583615ae498.js integrity="sha256-3u0OeKdzkVF9UwoAMkznt2CsIEE0mS7yLTb1g2Fa5Jg=" defer></script><script src=/auto-render_14944144240389301023.min.e694d9d5eae2917984179683ead27b998784a81398e8836c369373d2c67fc32a.js integrity="sha256-5pTZ1erikXmEF5aD6tJ7mYeEqBOY6INsNpNz0sZ/wyo=" defer></script><script src=/bigfoot_28293813221957978.min.af671f08986f0a2267c5a0cb2748b005489e47fa25f55479b200e2a563d23022.js integrity="sha256-r2cfCJhvCiJnxaDLJ0iwBUieR/ol9VR5sgDipWPSMCI=" defer></script><script src=/mermaid_9520146763733687737.min.bfe50b47c0387e3c3bf97ec5f338bba94f7ccb02f962a4aec8cf0b4d68c8434d.js integrity="sha256-v+ULR8A4fjw7+X7F8zi7qU98ywL5YqSuyM8LTWjIQ00=" defer></script><script src=/main.min.d60298c89fc4f1e938aceb45c60926efee8b03efc8b50683082e669a100da643.js integrity="sha256-1gKYyJ/E8ek4rOtFxgkm7+6LA+/ItQaDCC5mmhANpkM=" defer></script><link rel=stylesheet href=/katex_13658330645258633971.min.64e42891d651aee0b8cd02ec9227ff271d37bcf06dae985d1acf0eba1623e850.css integrity="sha256-ZOQokdZRruC4zQLskif/Jx03vPBtrphdGs8OuhYj6FA="><link rel=stylesheet href=/bigfoot-default_8781527669040159104.min.0d2b289fa3451447692959fcee5676b846532fe7ab50ddc4660824c42d4adcd7.css integrity="sha256-DSson6NFFEdpKVn87lZ2uEZTL+erUN3EZggkxC1K3Nc="><link rel=stylesheet href=/jquery.fancybox_5330465509389191777.min.67505d77381ebd82623ab9296c1989c44ec828d867c00296e80e52ef860cac37.css integrity="sha256-Z1BddzgevYJiOrkpbBmJxE7IKNhnwAKW6A5S74YMrDc="><link rel=stylesheet href=/css_1846377409604050217.min.fffe842bc000dd1fe8661ac6427a392a08faa95e8edab1ea7fb98c5f8dac6a6f.css integrity="sha256-//6EK8AA3R/oZhrGQno5Kgj6qV6O2rHqf7mMX42sam8="><link rel=stylesheet href=/main.min.b60cba31b8c292392a2d336408f8f344e261df78516eb17bcf029173b24a42b5.css integrity="sha256-tgy6MbjCkjkqLTNkCPjzROJh33hRbrF7zwKRc7JKQrU="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=/search/ method=get class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/home-automation/>Home Automation</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li><a href=https://blog.jverkamp.com/search/>Search</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article data-pagefind-body><header><h1 class=entry-title data-pagefind-meta=title>AoC 2021 Day 22: Cubinator</h1><div class=entry-meta><span class=entry-date>2021-12-22</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/sources/>Sources</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/programming/sources/advent-of-code>Advent of Code</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/algorithms>Algorithms</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/20/aoc-2021-day-20-enhancinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/data-structures>Data Structures</a><a href=https://blog.jverkamp.com/2021/12/24/aoc-2021-day-24-aluinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/19/aoc-2021-day-19-point-matchinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/mathematics>Mathematics</a><a href=https://blog.jverkamp.com/2021/12/24/aoc-2021-day-24-aluinator/ class=next-link></a></li><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/optimization>Optimization</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/series/>Series</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link></a><a class=taxonomy-value href=/series/advent-of-code-2021>Advent of Code 2021</a><a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2021/12/21/aoc-2021-day-21-dicinator/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/23/aoc-2021-day-23-amphipodinator/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2021/12/22/hawkeye/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2021/12/23/the-wheel-of-time-season-1/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><h3 id=source-reactor-reboot>Source: <a href=https://adventofcode.com/2021/day/22 target=_blank rel=noopener>Reactor Reboot</a></h3><h4 id=part-1-given-a-series-of-3d-cubes-that-either-turn-on-all-or-turn-off-all-points-in-their-region-calculate-how-many-points-in-the-region--5050-5050-5050-are-on-at-the-end><strong>Part 1:</strong> Given a series of 3D cubes that either turn ON all or turn OFF all points in their region, calculate how many points in the region (-50..50,-50..50,-50..50) are ON at the end.</h4><p>Wow. This one took me literal days of work to get working for some reason. I actually got to writing unit tests, which is saying something. :D And then after I had one aha moment (changing from cube to edge focussed, see later), it worked basically immediately. Oh data structure choices.</p><p>The basic idea I had all along was to make a <code>Cube</code> object that would have all of the operators I need: <code>a & b</code> to intersect two cubes, <code>a | b</code> (or <code>a + b</code>) to union/add them, and <code>a - b</code> to subtract one cube from another (each of which will return a list of cubes that make up the result). Then I could:</p><ul><li>Start with an empty list of cubes</li><li>For each cube<ul><li>If ON:<ul><li>Create a sublist of just <code>[cube]</code></li><li>For each current cube, remove it from every element in the sublist</li><li>The result is just the new cubes to turn ON, add them to the main list</li></ul></li><li>If OFF:<ul><li>For each current cube, remove the new cube from it (generating 0, 1, or many subcubes)</li></ul></li></ul></li></ul><p>This will be the final list. Let&rsquo;s make that class!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>(frozen<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, order<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span>:
</span></span><span style=display:flex><span>    x: int
</span></span><span style=display:flex><span>    y: int
</span></span><span style=display:flex><span>    z: int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>(frozen<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>:
</span></span><span style=display:flex><span>    min: Point
</span></span><span style=display:flex><span>    max: Point
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__repr__</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Cube(</span><span style=color:#e6db74>{</span>len(self)<span style=color:#e6db74>}</span><span style=color:#e6db74>)@[</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>..</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>..</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z<span style=color:#e6db74>}</span><span style=color:#e6db74>..</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__len__</span>(self) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            (self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span> (self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span> (self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z)
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>These are just the basic methods, print them out and return the &lsquo;size&rsquo; of a cube. One major change I did (entirely too late in the process) was to change from a face-centered system, to an edge centered-system. In that, the original <code>OldCube(1)@(10..10, 10..10, 10..10)</code> would be a 1x1 cube including just the point <code>&lt;10, 10, 10></code>, but I changed that so that would be represented by <code>OldCube(1)@(10..11, 10..11, 10..11)</code>. The upper bounds are <em>not</em> inclusive. That made the math <em>loads</em> easier.</p><p>Okay, let&rsquo;s work through the <code>Cube</code> methods (they&rsquo;d all be in one class):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__iter__</span>(self) <span style=color:#f92672>-&gt;</span> Generator[Point, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> z <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z):
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>yield</span> Point(x, y, z)
</span></span></code></pre></div><p>I didn&rsquo;t actually end up using this, but it can be used to actually get all of the cubes in a point. So if you wanted to directly solve the problem, you could with this!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__contains__</span>(self, other: Union[Point, <span style=color:#e6db74>&#39;Cube&#39;</span>]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Is the cube/point other entirely contained in self.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(other, Point):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x
</span></span><span style=display:flex><span>                <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y
</span></span><span style=display:flex><span>                <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> isinstance(other, Cube):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> other<span style=color:#f92672>.</span>min <span style=color:#f92672>in</span> self <span style=color:#f92672>and</span> other<span style=color:#f92672>.</span>max <span style=color:#f92672>in</span> self
</span></span></code></pre></div><p>Next, implement <code>p: Point in c: Cube</code> and <code>c1: Cube in c2: Cube</code>. This is used to special case many of the later methods.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>overlaps</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Does the cube overlap with self at all?
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Note: This includes if the cubes are just touching since edges are inclusive.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>min <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> self<span style=color:#f92672>.</span>max <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> other<span style=color:#f92672>.</span>min <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> other<span style=color:#f92672>.</span>max <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> self <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> other <span style=color:#f92672>in</span> self
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>The flip side of <code>in</code>: do they overlap at all. This could be just touching, but also any number of other cases (partial overlap, to a superset of <code>in</code>).</p><p>Okay, the heart of all of the next methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__segment</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        xs <span style=color:#f92672>=</span> list(sorted([self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x, other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x, other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x]))
</span></span><span style=display:flex><span>        ys <span style=color:#f92672>=</span> list(sorted([self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y, other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y, other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y]))
</span></span><span style=display:flex><span>        zs <span style=color:#f92672>=</span> list(sorted([self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z, self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z, other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z, other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        segments <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, (x1, x2) <span style=color:#f92672>in</span> enumerate(zip(xs, xs[<span style=color:#ae81ff>1</span>:])):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j, (y1, y2) <span style=color:#f92672>in</span> enumerate(zip(ys, ys[<span style=color:#ae81ff>1</span>:])):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> k, (z1, z2) <span style=color:#f92672>in</span> enumerate(zip(zs, zs[<span style=color:#ae81ff>1</span>:])):
</span></span><span style=display:flex><span>                    new_segment <span style=color:#f92672>=</span> Cube(Point(x1, y1, z1), Point(x2, y2, z2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> new_segment <span style=color:#f92672>in</span> segments:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    segments<span style=color:#f92672>.</span>append(new_segment)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> segments
</span></span></code></pre></div><p>The idea of this method is that any two cubes can be divided into 3x3 = 27 &lsquo;segments&rsquo;, no matter how they overlap. If they overlap on a corner, the middle of those will be the middle segment. If they only touch, then the touching line will be a zero size middle segment. If they don&rsquo;t touch at all, the middle segment will be &lsquo;between&rsquo; the cubes.</p><p>This is the method that benefited the most from the rewrite to edge-focused cubes. Before that, I had to have all sorts of special cases where you didn&rsquo;t accidentally include the edge cubes twice. With the change&mldr; it&rsquo;s just this much code.</p><p>Now that we have that, we can implement <code>&</code>, <code>|</code>, <code>+</code>, and <code>-</code> as various combinations of <code>__segment</code> and <code>in</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__and__</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Calculate the list of cubes making up the intersection of self and other.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># One cube is entirely inside of the other</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self <span style=color:#f92672>in</span> other:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [self]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> other <span style=color:#f92672>in</span> self:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [other]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># No overlap at all</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>overlaps(other):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Finally, only segments that are in both</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Cube<span style=color:#f92672>.</span>compress([
</span></span><span style=display:flex><span>                segment
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> segment <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>__segment(other)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> segment <span style=color:#f92672>in</span> self <span style=color:#f92672>and</span> segment <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            ])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__or__</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Calculate the list of cubes making up the union of self and other.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># One cube is entirely inside the other</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self <span style=color:#f92672>in</span> other:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [other]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> other <span style=color:#f92672>in</span> self:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [self]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># No overlap at all</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>overlaps(other):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [self, other]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Otherwise, split into segments and return all of them</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Cube<span style=color:#f92672>.</span>compress([
</span></span><span style=display:flex><span>                segment
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> segment <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>__segment(other)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> segment <span style=color:#f92672>in</span> self <span style=color:#f92672>or</span> segment <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>            ])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__add__</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Adding is the same as intersection.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self <span style=color:#f92672>|</span> other
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__sub__</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Calculate the list of cubes resulting of removing other from self.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Subtract the entire thing</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self <span style=color:#f92672>in</span> other:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># No overlap at all</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>overlaps(other):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [self]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Cube<span style=color:#f92672>.</span>compress([
</span></span><span style=display:flex><span>            segment
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> segment <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>__segment(other)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> segment <span style=color:#f92672>in</span> self <span style=color:#f92672>and</span> segment <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> other
</span></span><span style=display:flex><span>        ])
</span></span></code></pre></div><p>Pretty sweet how clean that code is. But &mldr; what&rsquo;s that compress thing? It&rsquo;s not necessary to actually solve the problem, but what it does is make the number of cubes explode slightly less. Rather than up to 27 new cubes, if any of the new cubes can be combined (by glueing one face together), do it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cube</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>join</span>(self, other: <span style=color:#e6db74>&#39;Cube&#39;</span>) <span style=color:#f92672>-&gt;</span> Optional[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;If two cubes can be perfectly joined, return that.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># One cube contains the other</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self <span style=color:#f92672>in</span> other:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> other
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> other <span style=color:#f92672>in</span> self:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># The x/y/z edges match perfectly</span>
</span></span><span style=display:flex><span>        x_match <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x
</span></span><span style=display:flex><span>        y_match <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y
</span></span><span style=display:flex><span>        z_match <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z <span style=color:#f92672>==</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># The last dimension is contained within the other cube</span>
</span></span><span style=display:flex><span>        x_overlap <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        y_overlap <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        z_overlap <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> other<span style=color:#f92672>.</span>max<span style=color:#f92672>.</span>z <span style=color:#f92672>&lt;=</span> self<span style=color:#f92672>.</span>min<span style=color:#f92672>.</span>z)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># If we have exactly two matches and an overlap, we can combine</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>            (x_overlap <span style=color:#f92672>and</span> y_match <span style=color:#f92672>and</span> z_match)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (x_match <span style=color:#f92672>and</span> y_overlap <span style=color:#f92672>and</span> z_match)
</span></span><span style=display:flex><span>            <span style=color:#f92672>or</span> (x_match <span style=color:#f92672>and</span> y_match <span style=color:#f92672>and</span> z_overlap)
</span></span><span style=display:flex><span>        ):
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> Cube(min(self<span style=color:#f92672>.</span>min, other<span style=color:#f92672>.</span>min), max(self<span style=color:#f92672>.</span>max, other<span style=color:#f92672>.</span>max))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>compress</span>(cubes: List[<span style=color:#e6db74>&#39;Cube&#39;</span>]) <span style=color:#f92672>-&gt;</span> List[<span style=color:#e6db74>&#39;Cube&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;Take a list of cubes and join as many as we can.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cubes <span style=color:#f92672>=</span> list(cubes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_one_join</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i, c1 <span style=color:#f92672>in</span> enumerate(cubes):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> j, c2 <span style=color:#f92672>in</span> enumerate(cubes):
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&lt;=</span> i:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> c <span style=color:#f92672>:=</span> c1<span style=color:#f92672>.</span>join(c2):
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> i, j, c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> result <span style=color:#f92672>:=</span> find_one_join():
</span></span><span style=display:flex><span>                i, j, c <span style=color:#f92672>=</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> cubes[j]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> cubes[i]
</span></span><span style=display:flex><span>                cubes<span style=color:#f92672>.</span>append(c)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cubes
</span></span></code></pre></div><p>It&rsquo;s&mldr; something that came about when fiddling with the old cube-centered mess, but it still does help.</p><p>So what&rsquo;s the final algorithm look like?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read</span>(file: TextIO) <span style=color:#f92672>-&gt;</span> Generator[Tuple[bool, Cube], <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> file:
</span></span><span style=display:flex><span>        m <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;(on|off) x=(-?\d+)\.\.(-?\d+),y=(-?\d+)\.\.(-?\d+),z=(-?\d+)\.\.(-?\d+)&#39;</span>, line)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> m:
</span></span><span style=display:flex><span>            mode, x1, x2, y1, y2, z1, z2 <span style=color:#f92672>=</span> m<span style=color:#f92672>.</span>groups()
</span></span><span style=display:flex><span>            cube <span style=color:#f92672>=</span> Cube(
</span></span><span style=display:flex><span>                Point(int(x1), int(y1), int(z1)),
</span></span><span style=display:flex><span>                Point(int(x2) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, int(y2) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, int(z2) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> mode <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;on&#39;</span>, cube
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.command</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>(file: typer<span style=color:#f92672>.</span>FileText, limit: bool <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>    cubes: List[Cube] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> turn_on, cube <span style=color:#f92672>in</span> read(file):
</span></span><span style=display:flex><span>        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>turn_on<span style=color:#e6db74>=}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>cube<span style=color:#e6db74>=}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Turning on cubes, don&#39;t turn on anything that is already on</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> turn_on:
</span></span><span style=display:flex><span>            to_turn_on <span style=color:#f92672>=</span> [cube]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> old_cube <span style=color:#f92672>in</span> cubes:
</span></span><span style=display:flex><span>                to_turn_on <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>                    remaining_cube
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> to_turn_on_cube <span style=color:#f92672>in</span> to_turn_on
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> remaining_cube <span style=color:#f92672>in</span> to_turn_on_cube <span style=color:#f92672>-</span> old_cube
</span></span><span style=display:flex><span>                ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cubes <span style=color:#f92672>+=</span> to_turn_on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Turning off cubes, turn off anything that should be off</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            cubes <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>                reduced_cube
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> current_cube <span style=color:#f92672>in</span> cubes
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> reduced_cube <span style=color:#f92672>in</span> current_cube <span style=color:#f92672>-</span> cube
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Re-compress at the end of each cycle</span>
</span></span><span style=display:flex><span>        cubes <span style=color:#f92672>=</span> Cube<span style=color:#f92672>.</span>compress(cubes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;&#39;&#39;</span><span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>After </span><span style=color:#e6db74>{</span>turn_on<span style=color:#e6db74>=}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>cube<span style=color:#e6db74>=}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>len(cubes)<span style=color:#e6db74>=}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>sum(len(cube) <span style=color:#66d9ef>for</span> cube <span style=color:#f92672>in</span> cubes)<span style=color:#e6db74>=}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Remove all regions outside of -50..50</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># This is silly, because we&#39;ll need to keep them in part 2</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># But it&#39;s faster at least</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> limit:
</span></span><span style=display:flex><span>            cubes <span style=color:#f92672>=</span> Cube<span style=color:#f92672>.</span>compress([
</span></span><span style=display:flex><span>                reduced
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> cube <span style=color:#f92672>in</span> cubes
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> reduced <span style=color:#f92672>in</span> cube <span style=color:#f92672>&amp;</span> Cube(Point(<span style=color:#f92672>-</span><span style=color:#ae81ff>50</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>50</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>50</span>), Point(<span style=color:#ae81ff>51</span>, <span style=color:#ae81ff>51</span>, <span style=color:#ae81ff>51</span>))
</span></span><span style=display:flex><span>            ])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(sum(len(cube) <span style=color:#66d9ef>for</span> cube <span style=color:#f92672>in</span> cubes))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.command</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(file: typer<span style=color:#f92672>.</span>FileText):
</span></span><span style=display:flex><span>    main(file, <span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><p>Almost exactly what I described in the pseudo-code, albeit a bit longer. It&rsquo;s kind of funny, because we need to remove the -50..50 region even though we already calculated it. It does run quicker without it though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 cubinator.py part1 input.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>590467</span>
</span></span><span style=display:flex><span><span style=color:#75715e># time 33116921042ns / 33.12s</span>
</span></span></code></pre></div><h4 id=part-2-do-the-same-without-the--5050-limit><strong>Part 2:</strong> Do the same without the -50..50 limit.</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@app.command</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(file: typer<span style=color:#f92672>.</span>FileText):
</span></span><span style=display:flex><span>    main(file, <span style=color:#66d9ef>False</span>)
</span></span></code></pre></div><p>Yeah&mldr; it takes forever.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 cubinator.py part2 input.txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>1225064738333321</span>
</span></span><span style=display:flex><span><span style=color:#75715e># time 9420109196167ns / 9420.11s</span>
</span></span></code></pre></div><p>Yeah. That&rsquo;s 2hrs 37mins. But after working so long on this problem&mldr; I&rsquo;m done. :D</p><p>I am going to look at what algorithms other people used, because this one was kind of crazy&mldr;</p><p>(And apparently I didn&rsquo;t manage to actually push these&mldr; sadness)</p><h4 id=optimization-caching>Optimization: Caching</h4><p>Everything in this problem is immutable, so I can use <code>@cache</code> all over the place on <code>Cube</code>&rsquo;s methods. Unfortunately, there&rsquo;s not really that much overlap in the questions you ask:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>---</span> Day <span style=color:#ae81ff>22</span>: Reactor Reboot <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> python3 cubinator<span style=color:#f92672>.</span>py part1 input<span style=color:#f92672>.</span>txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>590467</span>
</span></span><span style=display:flex><span><span style=color:#75715e># time 35257615584ns / 35.26s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> python3 cubinator<span style=color:#f92672>.</span>py <span style=color:#f92672>--</span>cache part1 input<span style=color:#f92672>.</span>txt
</span></span><span style=display:flex><span><span style=color:#ae81ff>590467</span>
</span></span><span style=display:flex><span><span style=color:#75715e># time 35879987167ns / 35.88s</span>
</span></span></code></pre></div><p>Perhaps on the longer problem&mldr; but yeah, that already takes long enough, I don&rsquo;t really want to re-run it with caching.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 cubinator.py --debug --cache part2 input.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>12:45:47 INFO 0001: turn_on<span style=color:#f92672>=</span>True cube<span style=color:#f92672>=</span>Cube<span style=color:#f92672>(</span>105938<span style=color:#f92672>)</span>@<span style=color:#f92672>[</span>-40..7, -36..10, -36..13<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>12:45:47 INFO       len<span style=color:#f92672>(</span>cubes<span style=color:#f92672>)=</span>1, sum<span style=color:#f92672>(</span>len<span style=color:#f92672>(</span>cube<span style=color:#f92672>)</span> <span style=color:#66d9ef>for</span> cube in cubes<span style=color:#f92672>)=</span><span style=color:#ae81ff>105938</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>12:45:47 INFO 0002: turn_on<span style=color:#f92672>=</span>True cube<span style=color:#f92672>=</span>Cube<span style=color:#f92672>(</span>133650<span style=color:#f92672>)</span>@<span style=color:#f92672>[</span>-22..32, -48..7, -35..10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>12:45:47 INFO       len<span style=color:#f92672>(</span>cubes<span style=color:#f92672>)=</span>3, sum<span style=color:#f92672>(</span>len<span style=color:#f92672>(</span>cube<span style=color:#f92672>)</span> <span style=color:#66d9ef>for</span> cube in cubes<span style=color:#f92672>)=</span><span style=color:#ae81ff>183473</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>15:19:41 INFO 0419: turn_on<span style=color:#f92672>=</span>False cube<span style=color:#f92672>=</span>Cube<span style=color:#f92672>(</span>6643764051090<span style=color:#f92672>)</span>@<span style=color:#f92672>[</span>-80436..-61650, 3782..34677, 22972..34419<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>15:21:00 INFO       len<span style=color:#f92672>(</span>cubes<span style=color:#f92672>)=</span>3139, sum<span style=color:#f92672>(</span>len<span style=color:#f92672>(</span>cube<span style=color:#f92672>)</span> <span style=color:#66d9ef>for</span> cube in cubes<span style=color:#f92672>)=</span><span style=color:#ae81ff>1228724794372331</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>15:21:00 INFO 0420: turn_on<span style=color:#f92672>=</span>False cube<span style=color:#f92672>=</span>Cube<span style=color:#f92672>(</span>9585355541608<span style=color:#f92672>)</span>@<span style=color:#f92672>[</span>-62269..-36062, -15314..13682, 65100..77714<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>15:21:22 INFO       len<span style=color:#f92672>(</span>cubes<span style=color:#f92672>)=</span>3152, sum<span style=color:#f92672>(</span>len<span style=color:#f92672>(</span>cube<span style=color:#f92672>)</span> <span style=color:#66d9ef>for</span> cube in cubes<span style=color:#f92672>)=</span><span style=color:#ae81ff>1225064738333321</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1225064738333321</span>
</span></span></code></pre></div><p>Also&mldr; 2hrs 36mins. That&rsquo;s actually impressively consistent if anything. Not so great on the caching though.</p><h4 id=optimization-block-turn-on-together>Optimization: Block turn &lsquo;on&rsquo; together</h4><p>A sequence of turn on options in a row can all be done together. I&rsquo;m not sure if this would help with the overall performance, but worth a try?</p><h4 id=optimiation-octree>Optimiation: Octree</h4><p>One thing that I think would really work for this problem would be to use <a href=https://en.wikipedia.org/wiki/octrees>octrees</a>. Rather than representing a list of cubes, we could split the entire space into one giant octree. Then when we need to break apart a given cube, we can do so with the built in octree stuff and not have to check every cube against every other cube (that gets <em>very</em> expensive). The hardest bit to get right would probably be once cubes span multiple nodes (at multiple levels of the octree). Worth considering though?</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content data-pagefind-ignore=all><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>