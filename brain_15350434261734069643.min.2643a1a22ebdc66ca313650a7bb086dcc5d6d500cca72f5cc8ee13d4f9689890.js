(function(e,t){typeof exports=="object"&&typeof module!="undefined"?t(exports,require("gpu.js")):typeof define=="function"&&define.amd?define(["exports","gpu.js"],t):(e=typeof globalThis!="undefined"?globalThis:e||self,t(e.brain={},e.GPU))})(this,function(e,t){"use strict";function U(e){return Math.max(0,e)}function R(e,t){return e<=0?0:t}var Co=Object.freeze({__proto__:null,activate:U,measure:R}),Nt,Ft,St,jt,Lt,Ae,ee,ue,he;function re(e){return 1/(1+Math.exp(-e))}function le(e,t){return e*(1-e)*t}Nt=Object.freeze({__proto__:null,activate:re,measure:le});function T(e){return Math.tanh(e)}function W(e,t){return(1-e*e)*t}Ft=Object.freeze({__proto__:null,activate:T,measure:W});function $(e){return e>0?e:.01*e}function D(e,t){return e>0?t:.01*t}St=Object.freeze({__proto__:null,activate:$,measure:D}),jt=Object.freeze({__proto__:null,relu:Co,sigmoid:Nt,tanh:Ft,leakyRelu:St});class O{constructor(e){this.json={avgs:{error:0,iterations:0,testTime:0,trainTime:0},stats:{total:0,testSize:0,trainSize:0},sets:[]},this.initClassifier=e}testPartition(e,t,n){const s=this.initClassifier(),r=Date.now(),o=s.train(t,e),i=Date.now(),a=s.test(n),c=Date.now();return{...a,trainTime:i-r,testTime:c-i,iterations:o.iterations,error:o.error,total:a.total,network:s.toJSON()}}shuffleArray(e){for(let t=e.length-1;t>0;t--){const n=Math.floor(Math.random()*(t+1)),s=e[t];e[t]=e[n],e[n]=s}return e}train(e,t={},n=4){if(e.length<n)throw new Error(`Training set size is too small for ${e.length} k folds of ${n}`);this.shuffleArray(e);const i=e.length/n,o={trainTime:0,testTime:0,iterations:0,error:0},s={total:0,testSize:0,trainSize:0},c={total:0,testSize:0,trainSize:0,truePos:0,trueNeg:0,falsePos:0,falseNeg:0,precision:0,recall:0,accuracy:0},r=[];let a=null;for(let d=0;d<n;d++){const u=e.slice(0),h=u.splice(d*i,i),m=u,l=this.testPartition(t,m,h);a===null&&(a=l.hasOwnProperty("falseNeg")&&l.hasOwnProperty("falsePos")&&l.hasOwnProperty("trueNeg")&&l.hasOwnProperty("truePos"),a&&Object.assign(s,c)),o.iterations+=l.iterations,o.testTime+=l.testTime,o.trainTime+=l.trainTime,o.error+=l.error,s.total+=l.total,O.isBinaryStats(s)&&O.isBinaryPartitionResults(l)&&(s.accuracy+=l.accuracy,s.falseNeg+=l.falseNeg,s.falsePos+=l.falsePos,s.precision+=l.precision,s.recall+=l.recall,s.trueNeg+=l.trueNeg,s.truePos+=l.truePos),r.push(l)}return o.error/=n,o.iterations/=n,o.testTime/=n,o.trainTime/=n,O.isBinaryStats(s)&&(s.precision=s.truePos/(s.truePos+s.falsePos),s.recall=s.truePos/(s.truePos+s.falseNeg),s.accuracy=(s.trueNeg+s.truePos)/s.total),s.testSize=i,s.trainSize=e.length-i,this.json={avgs:o,stats:s,sets:r},this.json}toNeuralNetwork(){return this.fromJSON(this.json)}toJSON(){return this.json}fromJSON(e){const t=e.sets.reduce((e,t)=>e.error<t.error?e:t);return this.initClassifier().fromJSON(t.network)}}O.isBinaryStats=e=>e.accuracy!==void 0,O.isBinaryResults=e=>e.stats.accuracy!==void 0,O.isBinaryPartitionResults=e=>e.accuracy!==void 0;let de=null;function ht(e){de=e}function s(e,n){let s=de;return s===null&&(s=new t.GPU({mode:"gpu"}),ht(s)),s.createKernel(e,n).setPipeline(!0)}function K(e,n,s){let o=de;return o===null&&(o=new t.GPU({mode:"gpu"}),ht(o)),o.createKernelMap(e,n,s).setPipeline(!0)}function wo(e,n){return new t.Input(e,n)}function n(e){e instanceof t.Texture&&e.delete()}function jo(e){if(e instanceof t.Texture){e.clear();return}if(Array.isArray(e))if(typeof e[0]=="number")e.fill(0);else if(typeof e[0][0]=="number"){for(let t=0;t<e.length;t++)e[t].fill(0);return}else if(typeof e[0][0][0]=="number"){for(let t=0;t<e.length;t++){const n=e[t];for(let e=0;e<n.length;e++)n[e].fill(0)}return}if(e instanceof Float32Array){e.fill(0);return}throw new Error("unhandled value")}function m(e){if(e instanceof t.Texture)return e.clone();if(e instanceof Float32Array)return e.slice(0);if(Array.isArray(e)){if(typeof e[0]=="number")return e.slice(0);if(typeof e[0][0]=="number"){const t=new Array(e.length);for(let n=0;n<e.length;n++)t[n]=e[n].slice(0);return t}if(typeof e[0][0][0]=="number"){const t=new Array(e.length);for(let t=0;t<e.length;t++){const n=e[t],s=new Array(n.length);for(let e=0;e<n.length;e++)s[e]=n[e].slice(0)}return t}}throw new Error("unhandled value")}function go(e){let t=0;for(let n=0;n<this.constants.height;n++)for(let s=0;s<this.constants.width;s++)t+=e[n][s]**2;return t/this.constants.length}class fo{constructor({width:e,height:t}){this.calculate=s(go,{output:[1],constants:{width:e,height:t,length:e*t},immutable:!0}),this.addAbsolute=s(function(e,t){return e[0]+Math.abs(t[0][0])},{output:[1],immutable:!0}),this.add=s(function(e,t){return e[0]+t[0]},{output:[1],immutable:!0}),this.divide=s(function(e,t){const n=t[0];return n>0?n/e:0},{output:[1],immutable:!0})}}const B={width:1,height:1,depth:null,weights:null,deltas:null,praxis:null,praxisOpts:null,cleanupDeltas:!0};class h{constructor(e){this.praxis=null,this.predictKernel=null,this.compareKernel=null,e?this.settings={...B,...e}:this.settings={...B},this.setupPraxis()}get width(){var e;return(e=this.settings.width)!==null&&e!==void 0?e:0}get height(){var e;return(e=this.settings.height)!==null&&e!==void 0?e:0}get depth(){var e;return(e=this.settings.depth)!==null&&e!==void 0?e:0}get weights(){return this.settings.weights}set weights(e){this.settings.weights=e,this.settings.cleanupDeltas&&this.deltas&&jo(this.deltas)}get deltas(){return this.settings.deltas}set deltas(e){this.settings.deltas=e}get id(){var e;return(e=this.settings.id)!==null&&e!==void 0?e:""}set id(e){this.settings.id=e}setupPraxis(){const{initPraxis:e,praxis:t,praxisOpts:n}=this.settings;this.praxis||(e?n?this.praxis=e(this,n):this.praxis=e(this):t&&(this.praxis=t))}validate(){if(Number.isNaN(this.height))throw new Error(`${this.constructor.name} layer height is not a number`);if(Number.isNaN(this.width))throw new Error(`${this.constructor.name} layer width is not a number`);if(this.height<1)throw new Error(`${this.constructor.name} layer height is less than 1`);if(this.width<1)throw new Error(`${this.constructor.name} layer width is less than 1`)}setupKernels(){}reuseKernels(e){if(e.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${e.width} is not ${this.width}`);if(e.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${e.height} is not ${this.height}`);if(e.hasOwnProperty("predictKernel")&&e.predictKernel!==null){if(!e.predictKernel.immutable)throw new Error(`${e.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);this.predictKernel=e.predictKernel}if(e.hasOwnProperty("compareKernel")&&e.compareKernel!==null){if(!e.compareKernel.immutable)throw new Error(`${e.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);this.compareKernel=e.compareKernel}this.praxis=e.praxis}predict(){}compare(){}learn(){}toArray(){return Array.isArray(this.weights)?this.weights:this.weights.toArray()}toJSON(){return h.toJSON(this)}static toJSON(e){const{weights:n}=e;return{width:e.width,height:e.height,depth:e.depth,weights:ao(n&&n instanceof t.Texture?n.toArray():n),type:e.constructor.name,praxisOpts:e.praxis?e.praxis.toJSON():null}}}function ao(e){if(e===null)return null;if(Array.isArray(e)){{if(typeof e[0]=="number")return e;if(Array.isArray(e[0])&&typeof e[0][0]=="number")return e;if(Array.isArray(e[0][0])&&typeof e[0][0][0]=="number")return e;if(e[0]instanceof Float32Array){const t=e;return t.map(e=>Array.from(e))}if(e[0][0]instanceof Float32Array){const t=e;return t.map(e=>e.map(e=>Array.from(e)))}}}else if(e)return Array.from(e);throw new Error("unexpected value")}function u(e){return new Float32Array(e)}function d(e,t){const n=new Array(t);for(let s=0;s<t;s++)n[s]=u(e);return n}function j(e,t,n){const s=new Array(n);for(let o=0;o<n;o++)s[o]=d(e,t);return s}class M extends h{constructor(e,t){super(t),this.inputLayer=e;const{width:s,height:n,depth:o}=this;this.predictKernel=null,this.compareKernel=null,this.validate(),o>0?(this.weights=j(s,n,o),this.deltas=j(s,n,o)):n>0&&(this.weights=d(s,n),this.deltas=d(s,n)),this.setupPraxis()}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}}class S extends h{constructor(e,t){super(),this.settings=e,this.inputLayer=t}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}get filterCount(){return this.settings.filterCount}get filterWidth(){return this.settings.filterWidth}get filterHeight(){return this.settings.filterHeight}get filters(){return this.settings.filters}set filters(e){this.settings.filters=e}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(e){this.settings.filterDeltas=e}}class F{constructor(){this.predictKernel=null,this.compareKernel=null,this.praxis=null}get width(){return this.settings.width}get height(){return this.settings.height}get depth(){return this.settings.depth}get weights(){return this.settings.weights}set weights(e){this.settings.weights=e}get deltas(){return this.settings.deltas}set deltas(e){this.settings.deltas=e}toJSON(){return h.toJSON(this)}}class N extends h{constructor(e,t){super({...t,width:e.width,height:e.height,depth:e.depth}),this.inputLayer=e}validate(){var e;if(super.validate(),this.width!==this.inputLayer.width)throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);if(this.height!==this.inputLayer.height)throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);if(this.depth!==((e=this.inputLayer.depth)!==null&&e!==void 0?e:0))throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`)}}class L extends h{constructor(e,t,n){super(n),this.inputLayer1=e,this.inputLayer2=t,this.validate(),this.weights=d(this.width,this.height),this.deltas=d(this.width,this.height),this.setupPraxis()}}function io(e,t){return e[this.thread.y][this.thread.x]-t[this.thread.x]}function oo(e,t){return e[this.thread.y][this.thread.x]-t[this.thread.y][this.thread.x]}class H extends h{constructor(e,t){if(super(e),this.inputLayer=t,this.validate(),this.depth)throw new Error("Target layer not implemented for depth");this.height?(this.weights=d(this.width,this.height),this.deltas=d(this.width,this.height),this.errors=d(this.width,this.height)):(this.weights=u(this.width),this.deltas=u(this.width),this.errors=u(this.width))}setupKernels(){this.width===1?this.compareKernel=s(io,{output:[this.width,this.height],immutable:!0}):this.compareKernel=s(oo,{output:[this.width,this.height],immutable:!0})}predict(){n(this.weights),this.weights=m(this.inputLayer.weights)}compare(e){n(this.deltas),n(this.errors),n(this.inputLayer.deltas),this.deltas=this.compareKernel(this.weights,e),this.inputLayer.deltas=m(this.deltas),this.errors=m(this.deltas)}setupPraxis(){}}function Ne(e,t){return new H(e,t)}class be{}class je extends h{}class _ extends h{learn(e){const{weights:t}=this;if(!this.praxis)throw new Error("this.praxis not defined");this.weights=this.praxis.run(this,e),n(t)}}const i={toTable(e){const t=e.reduce((e,t)=>Object.assign(e,t),{});return i.toHash(t)},toTable2D(e){const t={};let n=0;for(let s=0;s<e.length;s++){const o=e[s];for(let e=0;e<o.length;e++){const s=o[e];for(const e in s)s.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n++)}}return t},toInputTable2D(e){const t={};let n=0;for(let s=0;s<e.length;s++){const o=e[s].input;for(let e=0;e<o.length;e++){const s=o[e];for(const e in s){if(!s.hasOwnProperty(e))continue;t.hasOwnProperty(e)||(t[e]=n++)}}}return t},toOutputTable2D(e){const t={};let n=0;for(let s=0;s<e.length;s++){const o=e[s].output;for(let e=0;e<o.length;e++){const s=o[e];for(const e in s){if(!s.hasOwnProperty(e))continue;t.hasOwnProperty(e)||(t[e]=n++)}}}return t},toHash(e){const t={};let s=0;const n=Object.keys(e);for(let e=0;e<n.length;e++)t[n[e]]=s++;return t},toArray(e,t,n){const s=new Float32Array(n);for(const n in e){if(!e.hasOwnProperty(n))continue;s[e[n]]=t.hasOwnProperty(n)?t[n]:0}return s},toArrayShort(e,t){const n=[];for(const s in e){if(!e.hasOwnProperty(s))continue;if(!t.hasOwnProperty(s))break;n[e[s]]=t[s]}return Float32Array.from(n)},toArrays(e,t,n){const s=[];for(let o=0;o<t.length;o++)s.push(this.toArray(e,t[o],n));return s},toObject(e,t){const n={};for(const s in e){if(!e.hasOwnProperty(s))continue;n[s]=t[e[s]]}return n},toObjectPartial(e,t,n=0,s=0){const o={};let i=0;for(const a in e){if(!e.hasOwnProperty(a))continue;if(n>0&&i++<n)continue;if(s>0&&i++>=s)continue;o[a]=t[e[a]-n]}return o},dataShape(e){const n=[];let t;e.hasOwnProperty("input")?(n.push("datum"),t=e.input):Array.isArray(e)?e[0]&&e[0].input?(n.push("array","datum"),t=e[0].input):Array.isArray(e[0])?(n.push("array"),t=e[0]):t=e:t=e;let s;for(;t;)if(s=Object.keys(t)[0],Array.isArray(t)||typeof t.buffer=="object"){n.push("array");const e=t[parseInt(s)];if(typeof e=="number"){n.push("number");break}t=e}else if(typeof t=="object"&&typeof t.buffer!="object"){n.push("object");const e=t[s];if(typeof e=="number"){n.push("number");break}t=e}else throw new Error("unhandled signature");return n},addKeys(e,t){if(Array.isArray(e))return t;let n=Object.keys(t).length;for(const s in e){if(!e.hasOwnProperty(s))continue;if(t.hasOwnProperty(s))continue;t[s]=n++}return t}};class ye{constructor(e,t={}){this.layerTemplate=e,this.settings={...t},this.kernel=null}get width(){return this.layerTemplate.width}get height(){return this.layerTemplate.height}get depth(){return this.layerTemplate.depth}setupKernels(){}reuseKernels(e){if(e.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${e.width} is not ${this.width}`);if(e.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${e.height} is not ${this.height}`);e.hasOwnProperty("kernel")&&(this.kernel=e.kernel)}toJSON(){return{...this.settings}}}function so(e,t){return e[this.thread.y][this.thread.x]+this.constants.learningRate*t[this.thread.y][this.thread.x]}const no={learningRate:.3};class xe extends ye{constructor(e,t){super(e),this.settings={...no,...t},this.kernel=null}run(e){return this.kernel(e.weights,e.deltas)}setupKernels(){this.kernel=s(so,{output:[this.width,this.height],constants:{learningRate:this.settings.learningRate}})}}function st(e,t){return new xe(e,t)}function eo(e){return e}function Js(e,t,n,s){const o=e[this.thread.y][this.thread.x],i=s[this.thread.y][0],a=t[this.thread.y][this.thread.x],r=n[this.thread.x][0],c=this.constants.learningRate*i*r+this.constants.momentum*o;return a+c}const Zs={learningRate:.3,momentum:.1,weightsLayer:null,incomingLayer:null,deltaLayer:null};class ze extends ye{constructor(e,t){super(e),this.kernelMap=null,this.settings={...Zs,...t},this.changes=d(e.width,e.height)}get learningRate(){return this.settings.learningRate}get momentum(){return this.settings.momentum}get weightsLayer(){return this.settings.weightsLayer}set weightsLayer(e){this.settings.weightsLayer=e}get deltaLayer(){return this.settings.deltaLayer}set deltaLayer(e){this.settings.deltaLayer=e}get incomingLayer(){return this.settings.incomingLayer}set incomingLayer(e){this.settings.incomingLayer=e}run(){const e=this.kernelMap(this.changes,this.weightsLayer.weights,this.incomingLayer.weights,this.deltaLayer.deltas);return this.changes=e.changes,e.result}setupKernels(){this.kernelMap=K({changes:eo},Js,{output:[this.width,this.height],constants:{learningRate:this.learningRate,momentum:this.momentum}})}}function De(e,t){return new ze(e,t)}function qe(e,t,n){return n*t+(1-t)*e*e}function Ze(e,t,n){return e>t?t:e<n?n:e}function Qs(e,t,n){const s=t[this.thread.y][this.thread.x],i=Ze(s,this.constants.clipValue,-this.constants.clipValue),o=e[this.thread.y][this.thread.x],a=n[this.thread.y][this.thread.x],r=qe(s,this.constants.decayRate,a);return o+-this.constants.learningRate*i/Math.sqrt(r+this.constants.smoothEps)-this.constants.regularizationStrength*o}const Xs={decayRate:.999,regularizationStrength:1e-6,learningRate:.01,smoothEps:1e-8,clipValue:5};class ge extends ye{constructor(e,t={}){super(e),this.kernelMap=null,this.settings={...Xs,...t},this.momenta=d(e.width,e.height)}get clipValue(){return this.settings.clipValue}get decayRate(){return this.settings.decayRate}get learningRate(){return this.settings.learningRate}get regularizationStrength(){return this.settings.regularizationStrength}get smoothEps(){return this.settings.smoothEps}run(e){const{momenta:t,result:s}=this.kernelMap(e.weights,e.deltas,this.momenta);return n(this.momenta),this.momenta=t,s}setupKernels(){this.kernelMap=K({momenta:qe},Qs,{output:[this.width,this.height],constants:{clipValue:this.clipValue,decayRate:this.decayRate,learningRate:this.learningRate,regularizationStrength:this.regularizationStrength,smoothEps:this.smoothEps},functions:[Ze],immutable:!0})}}function ae(e,t){return new ge(e,t)}const Gs=ge,Ys=ae;Lt=Object.freeze({__proto__:null,ArthurDeviationBiases:xe,arthurDeviationBiases:st,ArthurDeviationWeights:ze,arthurDeviationWeights:De,MomentumRootMeanSquaredPropagation:ge,momentumRootMeanSquaredPropagation:ae,MRmsProp:Gs,mRmsProp:Ys});function se(e,t){e.hasOwnProperty("inputLayer")?se(e.inputLayer,t):(e.hasOwnProperty("inputLayer1")&&se(e.inputLayer1,t),e.hasOwnProperty("inputLayer2")&&se(e.inputLayer2,t)),t(e)}function ct(e){const t=e.slice(0);for(let e=0;e<t.length;e++){let n=0;se(t[e],s=>{t.includes(s)||(t.splice(e+n,0,s),n++)})}return t}function rt(e,t){if(e.width!==t.width)throw new Error(`Layer width mismatch of ${e.width} and ${t.width}`);if(e.height!==t.height)throw new Error(`Layer height mismatch of ${e.height} and ${t.height}`)}function qs(e,t){return e[this.thread.y][this.thread.x]+t[this.thread.y][this.thread.x]}class it extends L{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),rt(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=s(qs,{output:[this.width,this.height],immutable:!0})}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){n(this.inputLayer1.deltas),n(this.inputLayer2.deltas),this.inputLayer1.deltas=m(this.deltas),this.inputLayer2.deltas=m(this.deltas)}}function a(e,t,n){return new it(e,t,n)}function Ge(){return Math.random()*.4-.2}function A(e,t){return Math.random()*(t-e)+e}function f(){if(f.returnV)return f.returnV=!1,f.vVal;const t=2*Math.random()-1,n=2*Math.random()-1,e=t*t+n*n;if(e===0||e>1)return f();const s=Math.sqrt(-2*Math.log(e)/e);return f.vVal=n*s,f.returnV=!0,t*s}function Ks(e,t){return Math.floor(Math.random()*(t-e)+e)}function Us(e,t){return e+f()*t}f.returnV=!1,f.vVal=0,Ae=Object.freeze({__proto__:null,randomFloat:A,gaussRandom:f,randomInteger:Ks,randomN:Us});function C(e,t=null){const n=new Float32Array(e);if(t===null)for(let t=0;t<e;t++)n[t]=Ge();else for(let s=0;s<e;s++)n[s]=A(-t,t);return n}function P(e,t,n){const s=new Array(t);for(let o=0;o<t;o++)s[o]=C(e,n);return s}function E(e,t,n,s){const o=new Array(n);for(let i=0;i<n;i++)o[i]=P(e,t,s);return o}const Ws={...B,std:null};class Ee extends _{constructor(e){super(),this.settings={...Ws,...e},this.setupPraxis(),this.validate(),this.weights||(this.weights=P(this.width,this.height,e.std)),this.deltas||(this.deltas=d(this.width,this.height))}predict(){}compare(){}}function r(e){return new Ee(e)}function $s(e,t){let n=0;for(let s=0;s<this.constants.size;s++)n+=e[this.thread.y][s]*t[s][this.thread.x];return n}function Vs(e,t,n){let s=t[this.thread.y][this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[this.thread.y][t]*n[this.thread.x][t];return s}function Hs(e,t,n){let s=t[this.thread.y][this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[t][this.thread.x]*n[t][this.thread.y];return s}class Fe extends L{constructor(){super(...arguments),this.compareKernel1=null,this.compareKernel2=null}get width(){return this.inputLayer2.width}set width(e){throw new Error("Cannot set width on Multiply")}get height(){return this.inputLayer1.height}set height(e){throw new Error("Cannot set height on Multiply")}get depth(){return this.inputLayer1.depth}set depth(e){throw new Error("Cannot set depth on Multiply")}validate(){if(super.validate(),this.inputLayer1.width!==this.inputLayer2.height)throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`)}setupKernels(){this.predictKernel=s($s,{output:[this.width,this.height],constants:{size:this.inputLayer2.height},immutable:!0}),this.compareKernel1=s(Vs,{output:[this.inputLayer1.width,this.inputLayer1.height],constants:{size:this.inputLayer2.width},immutable:!0}),this.compareKernel2=s(Hs,{output:[this.inputLayer2.width,this.inputLayer2.height],constants:{size:this.inputLayer1.height},immutable:!0})}reuseKernels(e){super.reuseKernels(e),this.compareKernel1=e.compareKernel1,this.compareKernel2=e.compareKernel2}predict(){if(n(this.weights),!this.predictKernel)throw new Error("this.predictKernel is not set");this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){if(!this.compareKernel1)throw new Error("this.compareKernel1 not set");if(!this.compareKernel2)throw new Error("this.compareKernel2 not set");const e=this.inputLayer1.deltas,t=this.inputLayer2.deltas,s=this.compareKernel1(this.deltas,this.inputLayer1.deltas,this.inputLayer2.weights),o=this.compareKernel2(this.deltas,this.inputLayer2.deltas,this.inputLayer1.weights);this.inputLayer2.deltas=o,this.inputLayer1.deltas=s,n(e),n(t)}setupPraxis(){}toJSON(){return{...super.toJSON(),width:this.width,height:this.height}}}function l(e,t,n){return new Fe(e,t,n)}function Os(e){return 1/(1+Math.exp(-e[this.thread.y][this.thread.x]))}function ws(e){return 1/(1+Math.exp(-e[this.thread.z][this.thread.y][this.thread.x]))}function _s(e,t){const n=e[this.thread.y][this.thread.x],s=t[this.thread.y][this.thread.x];return n*(1-n)*s}function ys(e,t){const n=e[this.thread.z][this.thread.y][this.thread.x],s=t[this.thread.z][this.thread.y][this.thread.x];return n*(1-n)*s}class Re extends M{setupKernels(){this.depth>0?(this.predictKernel=s(ws,{output:[this.width,this.height,this.depth],functions:[re],immutable:!0}),this.compareKernel=s(ys,{output:[this.width,this.height,this.depth],functions:[le],immutable:!0})):(this.predictKernel=s(Os,{output:[this.width,this.height],functions:[re],immutable:!0}),this.compareKernel=s(_s,{output:[this.width,this.height],functions:[le],immutable:!0}))}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){n(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}learn(){}}function w(e,t){return new Re(e,t)}function js(e,t){const{height:o}=e;function c(e,t){const n=De(e,t);return n.setupKernels(),n}function d(e,t){const n=st(e,t);return n.setupKernels(),n}const n=r({id:"weights",height:o,width:t.height,initPraxis:c}),u=r({id:"biases",height:o,initPraxis:d}),h=l(n,t),m=a(h,u),i=w(m),s=n.praxis;return s.weightsLayer=n,s.incomingLayer=t,s.deltaLayer=i,i}function Ie(e,t){if(typeof e.stride=="number")return{strideX:e.stride,strideY:e.stride};let n=t.stride,s=t.stride;return typeof e.strideX=="number"&&(n=e.strideX),typeof e.strideY=="number"&&(s=e.strideY),{strideX:n,strideY:s}}function Be(e,t){if(typeof e.padding=="number")return{paddingX:e.padding,paddingY:e.padding};let n=t.padding,s=t.padding;return typeof e.paddingX=="number"&&(n=e.paddingX),typeof e.paddingY=="number"&&(s=e.paddingY),{paddingX:n,paddingY:s}}function Ve(e,t){return new Float32Array(e).fill(t)}function bs(e,t,n){const s=this.constants.paddingX-this.thread.x*this.constants.strideX,a=this.thread.x*this.constants.strideX-this.constants.paddingX,r=Math.min(this.constants.filterWidth,s+this.constants.inputWidth),o=this.constants.paddingY-this.thread.y*this.constants.strideY,c=this.thread.y*this.constants.strideY-this.constants.paddingY,l=Math.min(this.constants.filterHeight,o+this.constants.inputHeight);let i=0;for(let n=0;n<this.constants.inputDepth;n++)for(let d=Math.max(0,o),u=Math.max(0,c);d<l;d++,u++)for(let o=Math.max(0,s),c=Math.max(0,a);o<r;o++,c++)i+=t[n][d][o]*e[n][u][c];return i+n[this.thread.z]}function vs(e,t,n){const s=Math.max(0,Math.ceil((this.constants.paddingX-this.thread.x)/this.constants.strideX)),a=s*this.constants.strideX+this.thread.x-this.constants.paddingX,r=Math.min(this.constants.deltaWidth,Math.floor((this.constants.inputWidth-1-this.thread.x+this.constants.paddingX)/this.constants.strideX)+1),o=Math.max(0,Math.ceil((this.constants.paddingY-this.thread.y)/this.constants.strideY)),c=o*this.constants.strideY+this.thread.y-this.constants.paddingY,l=Math.min(this.constants.deltaHeight,Math.floor((this.constants.inputHeight-1-this.thread.y+this.constants.paddingY)/this.constants.strideY)+1);let i=e[this.thread.z][this.thread.y][this.thread.x];for(let e=o,d=c;e<l;e++,d+=this.constants.strideY)for(let o=s,c=a;o<r;o++,c+=this.constants.strideX)i+=t[this.thread.z][d][c]*n[this.constants.deltaZ][e][o];return i}function fs(e,t,n){const s=this.thread.x+this.constants.paddingX,o=s<this.constants.filterWidth?0:Math.floor((s-this.constants.filterWidth+this.constants.strideX)/this.constants.strideX),c=s-o*this.constants.strideX,u=Math.min(o+Math.floor(c/this.constants.strideX)+1,this.constants.deltaWidth),i=this.thread.y+this.constants.paddingY,a=i<this.constants.filterHeight?0:Math.floor((i-this.constants.filterHeight+this.constants.strideY)/this.constants.strideY),l=i-a*this.constants.strideY,h=Math.min(a+Math.floor(l/this.constants.strideY)+1,this.constants.deltaHeight);let d=e[this.thread.z][this.thread.y][this.thread.x],r=a;for(let s=l;r<h;s-=this.constants.strideY,r++){let e=o;for(let o=c;e<u;o-=this.constants.strideX,e++)d+=t[this.thread.z][s][o]*n[this.constants.deltaZ][r][e]}return d}function ms(e,t){let n=0;for(let e=0;e<this.constants.deltaHeight;e++)for(let s=0;s<this.constants.deltaWidth;s++)n+=t[this.thread.z][e][s];return e[this.thread.z][this.thread.y][this.thread.x]+n}const ve={stride:0,padding:0,bias:.1,filterCount:1,filterWidth:0,filterHeight:0};class Ye extends S{constructor(e,t){var n,s,o;super(e,t),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...ve,...e,...Be(e,ve),...Ie(e,ve)},this.weights=(n=e.weights)!==null&&n!==void 0?n:E(this.width,this.height,this.depth),this.deltas=j(this.width,this.height,this.depth),this.biases=Ve(this.depth,this.bias),this.biasDeltas=(s=e.biasDeltas)!==null&&s!==void 0?s:C(this.depth),this.filters=(o=e.filters)!==null&&o!==void 0?o:E(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=j(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingX}get width(){return Math.floor((this.inputLayer.width+this.paddingX*2-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+this.paddingY*2-this.filterHeight)/this.strideY+1)}get bias(){return this.settings.bias}get depth(){return this.filterCount}get biases(){return this.settings.biases}set biases(e){this.settings.biases=e}get biasDeltas(){return this.settings.biasDeltas}set biasDeltas(e){this.settings.biasDeltas=e}get filters(){return this.settings.filters}set filters(e){this.settings.filters=e}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(e){this.settings.filterDeltas=e}setupKernels(){this.predictKernel=s(bs,{constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareFilterDeltasKernel=s(vs,{constants:{deltasWidth:this.width,deltasHeight:this.height,deltasDepth:this.depth,inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareInputDeltasKernel=s(fs,{constants:{filterCount:this.filterCount},output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],immutable:!0}),this.compareBiasesKernel=s(ms,{output:[1,1,this.depth],constants:{deltaWidth:this.width,deltaHeight:this.height},immutable:!0})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const{filterDeltas:e,biasDeltas:t}=this;this.filterDeltas=this.compareFilterDeltasKernel(e,this.inputLayer.weights,this.deltas),n(e),this.biasDeltas=this.compareBiasesKernel(t,this.deltas),n(t),n(this.deltas),this.deltas=this.compareInputDeltasKernel(this.filters,this.inputLayer.deltas),n(this.inputLayer.deltas),this.inputLayer.deltas=m(this.deltas)}learn(e){const{weights:t}=this;this.weights=this.praxis.run(this,e),n(t)}}function hs(e,t){return new Ye(e,t)}function Xe(e){return e}function Bt(e){return Xe(Math.random())<this.constants.probability?0:e[this.thread.y][this.thread.x]}function ts(e){return e[this.thread.y][this.thread.x]*this.constants.probability}function Jn(e,t){return e[this.thread.y][this.thread.x]===0?0:t[this.thread.y][this.thread.x]}const Zn={...B,probability:.5};class tt extends S{constructor(e,t){super(t,e),this.predictKernelMap=null,this.settings={...Zn,...t},this.dropouts=null,this.validate()}setupKernels(e){const t=[this.width,this.height];e?(this.predictKernelMap=K({dropouts:Xe},Bt,{output:t,immutable:!0}),this.compareKernel=s(Jn,{output:t,immutable:!0})):this.predictKernelMap=K({},ts,{output:t,immutable:!0})}predict(){n(this.weights),this.dropouts&&n(this.dropouts);const{result:e,dropouts:t}=this.predictKernelMap(this.inputLayer.weights);this.weights=e,this.dropouts=t}compare(){n(this.deltas),this.deltas=this.compareKernel(this.dropouts,this.inputLayer.deltas)}}function Qn(e,t){return new tt(e,t)}function Xn(e,t){const{height:s,praxisOpts:n=null}=e,o=r({id:"weights",height:s,width:t.height,praxisOpts:n}),i=r({id:"biases",height:s,praxisOpts:n});return w(a(l(o,t,{praxisOpts:n}),i,{praxisOpts:n}),{praxisOpts:n})}function Gn(e,t,n){let s=0,o=0;for(let n=0;n<this.constants.inputHeight;n++)for(let i=0;i<this.constants.inputWidth;i++)s+=e[n][i]*t[this.thread.x][o],o++;return s+n[this.thread.x]}function Hn(e,t,n){let s=0,o=0;for(let n=0;n<this.constants.inputDepth;n++)for(let i=0;i<this.constants.inputHeight;i++)for(let a=0;a<this.constants.inputWidth;a++)s+=e[n][i][a]*t[this.thread.x][o],o++;return s+n[this.thread.x]}function Pn(e,t,n){let s=0;const o=this.thread.x+this.thread.y*this.output.x;for(let e=0;e<this.constants.filterCount;e++)s+=n[e][o]*t[0][e];return s+e[this.thread.y][this.thread.x]}function Ln(e,t,n){let s=0;const o=this.thread.x+this.thread.y*this.output.x;for(let e=0;e<this.constants.filterCount;e++)s+=n[e][o]*t[0][e];return s+e[this.thread.z][this.thread.y][this.thread.x]}function zn(e,t){return e[this.thread.x]+t[this.thread.y][this.thread.x]}function Tn(e,t,n){return e[this.thread.y][this.thread.x]+t[this.thread.y][this.thread.x]*n[this.constants.deltaY][this.constants.deltaX]}function Fn(e,t,n){const s=Math.floor(this.thread.x/(this.constants.inputWidth*this.constants.inputHeight)),o=Math.floor((this.thread.x-s*this.constants.inputWidth*this.constants.inputHeight)/this.constants.inputWidth),i=this.thread.x-this.constants.inputWidth*(o+this.constants.inputHeight*s);return e[this.thread.y][this.thread.x]+t[s][o][i]*n[0][this.thread.y]}class ut extends S{constructor(e,t){super(e,t),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...e},this.validate();const n=t.width*t.height*t.depth;this.biases=Ve(this.height,this.bias),this.biasDeltas=u(this.height),this.filters=P(n,this.height),this.filterDeltas=d(n,this.height),this.depth>0?(this.weights=E(this.width,this.height,this.depth),this.deltas=j(this.width,this.height,this.depth)):this.height>0&&(this.weights=P(this.width,this.height),this.deltas=d(this.width,this.height))}get bias(){return this.settings.bias}get biases(){return this.settings.biases}set biases(e){this.settings.biases=e}get biasDeltas(){return this.settings.biases}set biasDeltas(e){this.settings.biasDeltas=e}validate(){if(super.validate(),this.depth>0)throw new Error("depth not supported")}setupKernels(){const{inputLayer:e}=this,t=e.width*e.height*e.depth;e.depth>0?(this.predictKernel=s(Hn,{output:[this.width,this.height],constants:{inputHeight:e.height,inputWidth:e.width,inputDepth:e.depth}}),this.compareFilterDeltasKernel=s(Fn,{output:[t,this.height],constants:{inputWidth:e.width,inputHeight:e.height},immutable:!0}),this.compareInputDeltasKernel=s(Ln,{output:[e.width,e.height,e.depth],constants:{filterCount:this.height},immutable:!0})):(this.predictKernel=s(Gn,{output:[this.width,this.height],constants:{inputHeight:e.height,inputWidth:e.width}}),this.compareFilterDeltasKernel=s(Tn,{output:[t,this.height],constants:{inputWidth:e.width}}),this.compareInputDeltasKernel=s(Pn,{output:[e.width,e.height],constants:{filterCount:this.height}})),this.compareBiasesKernel=s(zn,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const e=this.inputLayer.deltas;this.inputLayer.deltas=this.compareInputDeltasKernel(e,this.deltas,this.filters),n(e);const{biasDeltas:s,filterDeltas:t}=this;this.biasDeltas=this.compareBiasesKernel(this.biases,this.deltas),this.filterDeltas=this.compareFilterDeltasKernel(t,this.inputLayer.weights,this.deltas),n(s),n(t)}}function Sn(e,t){return new ut(e,t)}function An(e){return-e[this.thread.y][this.thread.x]}class ft extends N{constructor(e,t){super(e,t),this.validate()}setupKernels(){this.predictKernel=s(An,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}}function pt(e,t){return new ft(e,t)}function En(e,t){return e[this.thread.y][this.thread.x]*t[this.thread.y][this.thread.x]}function xn(e,t){return e[this.thread.y][this.thread.x]*t[this.thread.y][this.thread.x]}class bt extends L{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),rt(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=s(En,{output:[this.width,this.height],immutable:!0}),this.compareKernel=s(xn,{output:[this.width,this.height],immutable:!0})}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){n(this.inputLayer1.deltas),n(this.inputLayer2.deltas),this.inputLayer1.deltas=this.compareKernel(this.inputLayer2.weights,this.deltas),this.inputLayer2.deltas=this.compareKernel(this.inputLayer1.weights,this.deltas)}}function x(e,t,n){return new bt(e,t,n)}function yt(e){return new Float32Array(e).fill(1)}function _t(e,t){const n=new Array(t);for(let s=0;s<t;s++)n[s]=yt(e);return n}class wt extends _{constructor(e){super(e),this.validate(),this.weights=_t(this.width,this.height),this.deltas=d(this.width,this.height)}}function Ot(e){return new wt(e)}function wn(e){return T(e[this.thread.y][this.thread.x])}function yn(e){return T(e[this.thread.z][this.thread.y][this.thread.x])}function cn(e,t){return W(e[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function an(e,t){return W(e[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class At extends M{setupKernels(){this.depth>0?(this.predictKernel=s(yn,{output:[this.width,this.height,this.depth],functions:[T],immutable:!0}),this.compareKernel=s(an,{output:[this.width,this.height,this.depth],functions:[W],immutable:!0})):(this.predictKernel=s(wn,{output:[this.width,this.height],functions:[T],immutable:!0}),this.compareKernel=s(cn,{output:[this.width,this.height],functions:[W],immutable:!0}))}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){n(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function te(e,t){return new At(e,t)}class Mt extends _{constructor(e){super(e),this.validate(),this.weights=d(this.width,this.height),this.deltas=d(this.width,this.height)}predict(){}compare(){}}function b(e){return new Mt(e)}function on(e,t,n){const{height:s}=e,h=r({height:s,width:n.height}),d=r({width:s,height:s}),c=b({height:s}),o=w(a(a(l(h,n),l(d,t)),c)),u=r({height:s,width:n.height}),i=r({width:s,height:s}),m=b({height:s}),f=w(a(a(l(u,n),l(i,t)),m)),p=r({height:s,width:n.height}),g=r({width:s,height:s}),v=b({height:s}),j=te(a(a(l(p,n),l(g,x(f,t))),v));return a(x(a(Ot({width:o.width,height:o.height}),pt(o)),j),x(t,o))}const Jt={weights:null};class Dt extends je{constructor(e){super({...Jt,...e}),this.reshapeInput=null,this.validate(),this.reshapeInput=null,this.deltas=d(this.width,this.height)}setupKernels(){this.width===1&&(this.predict=this.predict1D,this.reshapeInput=s(function(e){return e[this.thread.y]},{output:[1,this.height],immutable:!0}))}reuseKernels(e){this.reshapeInput=e.reshapeInput}predict(e){if((Array.isArray(e)||e instanceof Float32Array)&&typeof e[0]=="number"&&e.length===this.height*this.width)n(this.weights),this.weights=wo(e,[this.width,this.height]);else if(Array.isArray(e)&&e.length===this.height&&(Array.isArray(e[0])||e[0]instanceof Float32Array)&&e[0].length===this.width)this.weights=m(e);else throw new Error("Inputs are not of sized correctly")}predict1D(e){this.weights&&n(this.weights),this.reshapeInput?this.weights=this.reshapeInput(e):this.weights=e}compare(){}learn(){}}function Zt(e){return new Dt(e)}function Qt(e){return $(e[this.thread.y][this.thread.x])}function Gt(e){return $(e[this.thread.z][this.thread.y][this.thread.x])}function Yt(e,t){return D(e[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function It(e,t){return D(e[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class Oe extends M{setupKernels(){const{width:e,height:t,depth:n}=this.inputLayer;this.depth>0?(this.predictKernel=s(Gt,{output:[e,t,n],functions:[$],immutable:!0}),this.compareKernel=s(It,{output:[e,t,n],functions:[D],immutable:!0})):(this.predictKernel=s(Qt,{output:[e,t],functions:[$],immutable:!0}),this.compareKernel=s(Yt,{output:[e,t],functions:[D],immutable:!0}))}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){const{deltas:e}=this;this.deltas=this.compareKernel(this.weights,e),n(e)}}function rs(e,t){return new Oe(e,t)}function Vt(e,t,n){const{height:s}=e;if(typeof s!="number")throw new Error("no settings.height given");n.setDimensions&&n.setDimensions(1,s);const o=r({width:t.height,height:s,std:.08,id:"inputGateWeights"}),i=r({width:s,height:s,std:.08,id:"inputGatePeepholes"}),c=b({width:1,height:s,id:"inputGateBias"}),d=w(a(a(l(o,t),l(i,n)),c),{id:"inputGate"}),u=r({width:t.height,height:s,std:.08,id:"forgetGateWeights"}),h=r({width:s,height:s,std:.08,id:"forgetGatePeepholes"}),m=b({width:1,height:s,id:"forgetGateBias"}),f=w(a(a(l(u,t),l(h,n)),m),{id:"forgetGate"}),p=r({width:t.height,height:s,std:.08,id:"outputGateWeights"}),g=r({width:s,height:s,std:.08,id:"outputGatePeepholes"}),v=b({width:1,height:s,id:"outputGateBias"}),j=w(a(a(l(p,t),l(g,n)),v),{id:"outputGate"}),y=r({width:t.height,height:s,std:.08,id:"memoryWeights"}),_=r({width:s,height:s,std:.08,id:"memoryPeepholes"}),O=b({width:1,height:s,id:"memoryBias"}),C=te(a(a(l(y,t),l(_,n)),O),{id:"memory"}),E=x(f,n,{id:"retainCell"}),k=x(d,C,{id:"writeCell"}),A=a(E,k,{id:"cell"});return x(j,te(A),{id:"activations"})}function $t(e,t){const{height:n}=e,s=r({height:n,width:t.height,id:"outputGate",std:.08}),o=r({height:n,id:"output",std:.08}),i=l(s,t,{id:"outputGateConnected"});return Ne({id:"target",...e},a(i,o))}function Wt(e){return e}function Ut(e){return e}function Kt(e){const n=this.constants.paddingX-this.thread.x*this.constants.strideX,o=this.thread.x*this.constants.strideX-this.constants.paddingX,i=Math.min(this.constants.filterWidth,n+this.constants.inputWidth),s=this.constants.paddingY-this.thread.y*this.constants.strideY,a=this.thread.y*this.constants.strideY-this.constants.paddingY,r=Math.min(this.constants.filterHeight,s+this.constants.inputHeight);let t=-99999;for(let l=Math.max(0,s),c=Math.max(0,a);l<r;l++,c++)for(let a=Math.max(0,n),s=Math.max(0,o);a<i;a++,s++)if(c>=0&&c<this.constants.inputHeight&&s>=0&&s<this.constants.inputWidth){const n=e[this.thread.z][c][s];n>t&&(t=n)}return t}function qt(e,t,n){const o=Math.floor(this.thread.x/this.output.x*this.constants.outputWidth),i=Math.floor(this.thread.y/this.output.y*this.constants.outputHeight);let s=0;for(let a=0;a<this.constants.inputHeight;a++)for(let r=0;r<this.constants.inputWidth;r++){const c=n[a][r],l=t[a][r];c===o&&l===i&&(s+=e[a][r])}return s}const Pt={padding:0,stride:0,filterWidth:0,filterHeight:0,filterCount:0};class Rt extends S{constructor(e,t){super(e,t),this.predictKernelMap=null,this.settings={...e,...Ie(e,Pt),...Be(e,Pt)},this.weights=E(this.width,this.height,this.depth),this.deltas=j(this.width,this.height,this.depth),this.filters=E(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=j(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingY}get width(){return Math.floor((this.inputLayer.width+this.paddingX*2-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+this.paddingY*2-this.filterHeight)/this.strideY+1)}get depth(){return this.settings.filterCount}get filterCount(){return this.settings.filterCount}get switchX(){return this.settings.switchX}set switchX(e){this.settings.switchX=e}get switchY(){return this.settings.switchY}set switchY(e){this.settings.switchY=e}setupKernels(){this.predictKernelMap=K({switchX:Ut,switchY:Wt},Kt,{output:[this.width,this.height,this.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,paddingX:this.paddingX,paddingY:this.paddingY,filterHeight:this.filterHeight,filterWidth:this.filterWidth}}),this.compareKernel=s(qt,{output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,outputWidth:this.width,outputHeight:this.height}})}predict(){const{result:e,switchX:t,switchY:n}=this.predictKernelMap(this.inputLayer.weights);this.switchX=t,this.switchY=n,this.weights=e}compare(){const e=this.inputLayer.deltas;this.inputLayer.deltas=this.compareKernel(this.deltas,this.switchX,this.switchY),n(e)}}function Xt(e,t){return new Rt(e,t)}class q extends F{constructor(e){super(),this.praxis=null,this.predictKernel=null,this.compareKernel=null,this.settings={},this.recurrentInput=e,this.validate()}get width(){return this.recurrentInput.width}get height(){return this.recurrentInput.height}get depth(){return this.recurrentInput.depth}get deltas(){return this.recurrentInput.deltas}set deltas(e){const t=this.recurrentInput.deltas;this.recurrentInput.deltas=e,n(t)}get weights(){return this.recurrentInput.weights}set weights(e){const t=this.recurrentInput.weights;this.recurrentInput.weights=e,n(t)}validate(){if(h.prototype.validate.call(this),this.width!==this.recurrentInput.width)throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);if(this.height!==this.recurrentInput.height)throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`)}setDimensions(e,t){this.recurrentInput.width=e,this.recurrentInput.height=t}predict(){}compare(){}learn(){}setupKernels(){}reuseKernels(){}}class J extends F{constructor(e){super(),this.praxis=null,this.settings={},this.predictKernel=null,this.compareKernel=null,e&&(this.settings={...e})}setDimensions(e,t){this.praxis=null,this.settings={...this.settings,width:e,height:t,weights:d(e,t),deltas:d(e,t)}}setupKernels(){}reuseKernels(){}predict(){}compare(){}learn(e){const{weights:t}=this;this.weights=this.praxis.run(this,e),n(t)}}function zt(){return new J}function en(e){return U(e[this.thread.y][this.thread.x])}function tn(e,t){return R(e[this.thread.y][this.thread.x],t[this.thread.y][this.thread.x])}function nn(e){return U(e[this.thread.z][this.thread.y][this.thread.x])}function sn(e,t){return R(e[this.thread.z][this.thread.y][this.thread.x],t[this.thread.z][this.thread.y][this.thread.x])}class Tt extends M{setupKernels(){const{width:e,height:t,depth:n}=this.inputLayer;n>0?(this.predictKernel=s(nn,{output:[e,t,n],functions:[U],immutable:!0}),this.compareKernel=s(sn,{output:[e,t,n],functions:[R],immutable:!0})):(this.predictKernel=s(en,{output:[e,t],functions:[U],immutable:!0}),this.compareKernel=s(tn,{output:[e,t],functions:[R],immutable:!0}))}predict(){n(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){n(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function kt(e,t){return new Tt(e,t)}function rn(e,t,n){const{height:s}=e;if(typeof s!="number")throw new Error("height not set");n.setDimensions&&n.setDimensions(1,s);const o=r({id:"weight",height:s,width:t.height,std:.08}),i=r({id:"transition",height:s,width:s,std:.08}),c=b({id:"bias",height:s});return kt(a(a(l(o,t),l(i,n)),c))}class Et extends h{constructor(e,t){super(e),this.inputLayer=t,this.validate()}predict(){n(this.weights),this.weights=m(this.inputLayer.weights)}learn(){}}function ln(e,t){return new Et(e,t)}function dn(e){let t=-(1/0);for(let n=0;n<this.constants.inputHeight;n++)for(let s=0;s<this.constants.inputWidth;s++){const o=e[n][s];o>t&&(t=o)}return t}function un(e){let t=-(1/0);for(let n=0;n<this.constants.inputDepth;n++)for(let s=0;s<this.constants.inputHeight;s++)for(let o=0;o<this.constants.inputWidth;o++){const i=e[n][s][o];i>t&&(t=i)}return t}function hn(e){let t=0;for(let n=0;n<this.constants.inputHeight;n++)for(let s=0;s<this.constants.inputWidth;s++)t+=e[n][s];return t}function mn(e){let t=0;for(let n=0;n<this.constants.inputDepth;n++)for(let s=0;s<this.constants.inputHeight;s++)for(let o=0;o<this.constants.inputWidth;o++)t+=e[n][s][o];return t}function fn(e,t){return Math.exp(e[this.thread.x]-t[0])}function pn(e,t){return Math.exp(e[this.thread.z][this.thread.y][this.thread.x]-t[0])}function gn(e,t){return e[this.thread.y][this.thread.x]/t[0]}function vn(e,t){return e[this.thread.z][this.thread.y][this.thread.x]/t[0]}function bn(e,t){let n=0;const s=this.thread.x+this.thread.y*this.output.x;return s===e&&(n=1),-(n-t[this.thread.y][this.thread.x])}function jn(e,t){let n=0;const s=this.thread.x+this.thread.y*this.output.x+this.thread.z*this.output.x*this.output.y;return s===e&&(n=1),-(n-t[this.thread.z][this.thread.y][this.thread.x])}class Ct extends N{constructor(e,t){super(e,t),this.errors=null,this.getExponentialsKernel=null,this.getMaxValueKernel=null,this.getSumKernel=null,this.validate(),this.depth>0?(this.weights=E(this.width,this.height,this.depth),this.deltas=j(this.width,this.height,this.depth)):this.height>0?(this.weights=P(this.width,this.height),this.deltas=d(this.width,this.height)):(this.weights=C(this.width),this.deltas=u(this.width))}setupKernels(){const{width:e,height:t,depth:n}=this;n>0?(this.getExponentialsKernel=s(pn,{output:[e,t,n]}),this.getMaxValueKernel=s(un,{output:[1,1,1],constants:{inputWidth:e,inputHeight:t,inputDepth:n}}),this.getSumKernel=s(mn,{output:[1,1,1],constants:{inputWidth:e,inputHeight:t,inputDepth:n}}),this.predictKernel=s(vn,{output:[e,t,n]}),this.compareKernel=s(jn,{output:[e,t,n],immutable:!0})):(this.getExponentialsKernel=s(fn,{output:[e,t]}),this.getMaxValueKernel=s(dn,{output:[1,1],constants:{inputWidth:e,inputHeight:t}}),this.getSumKernel=s(hn,{output:[1,1],constants:{inputWidth:e,inputHeight:t}}),this.predictKernel=s(gn,{output:[e,t]}),this.compareKernel=s(bn,{output:[e,t],immutable:!0}))}predict(){const t=this.getMaxValueKernel(this.inputLayer.weights),e=this.getExponentialsKernel(this.inputLayer.weights,t),n=this.getSumKernel(e);this.weights=this.predictKernel(e,n)}compare(e){const{deltas:t,errors:s}=this;this.errors=this.compareKernel(e[0],t),this.deltas=m(this.errors),n(t),n(s);const o=this.inputLayer.deltas;this.inputLayer.deltas=m(this.deltas),n(o)}}function _n(e,t){return new Ct(e,t)}class xt extends h{constructor(e,t){super(t),this.inputLayer=e}predict(){n(this.weights),this.weights=m(this.inputLayer.weights),this.validate()}learn(){}}function On(e,t){return new xt(e,t)}function vt(e){return e[this.thread.x][this.thread.y]}const Cn=vt;class gt extends N{get width(){return this.inputLayer.height}get height(){return this.inputLayer.width}constructor(e){super(e),this.validate()}setupKernels(){this.predictKernel=s(vt,{output:[this.height,this.width]}),this.compareKernel=s(Cn,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}compare(){this.inputLayer.deltas=this.compareKernel(this.deltas)}}function kn(e){return new gt(e)}const g={Activation:M,Internal:F,InternalModel:be,EntryPoint:je,Filter:S,Model:_,Modifier:N,Operator:L,Target:H};ee=Object.freeze({__proto__:null,layerTypes:g,Add:it,add:a,arthurFeedForward:js,BaseLayer:h,baseLayerDefaultSettings:B,Convolution:Ye,convolution:hs,Dropout:tt,dropout:Qn,feedForward:Xn,FullyConnected:ut,fullyConnected:Sn,gru:on,Input:Dt,input:Zt,LeakyRelu:Oe,leakyRelu:rs,lstmCell:Vt,Multiply:Fe,multiply:l,MultiplyElement:bt,multiplyElement:x,Negative:ft,negative:pt,Ones:wt,ones:Ot,output:$t,Pool:Rt,pool:Xt,Random:Ee,random:r,RecurrentInput:q,RecurrentZeros:J,rnnCell:rn,Regression:Et,regression:ln,Relu:Tt,relu:kt,Sigmoid:Re,sigmoid:w,SoftMax:Ct,softMax:_n,SVM:xt,svm:On,Tanh:At,tanh:te,Target:H,target:Ne,Transpose:gt,transpose:kn,Zeros:Mt,zeros:b});const Mn=Object.keys(ee);function y(e,t,n){if(!Mn.find(t=>t===e.type))return null;const s=ee[e.type];if(s.prototype instanceof g.Filter){if(!t)throw new Error("inputLayer missing");return new s(e,t)}if(s.prototype instanceof g.Activation||s.prototype instanceof g.Modifier){if(!t)throw new Error("inputLayer missing");return new s(t,e)}if(s.prototype instanceof g.Internal)return new s(e);if(s.prototype instanceof g.Operator){if(!t)throw new Error("inputLayer1 missing");if(!n)throw new Error("inputLayer2 missing");return new s(t,n,e)}if(s.prototype instanceof g.InternalModel||s.prototype instanceof g.EntryPoint||s.prototype instanceof g.Model)return new s(e);if(s===H){if(!t)throw new Error("inputLayer missing");return new s(e,t)}return null}class v{constructor(e,t){this.prop=null,this.table={},this.length=0;const n=this.table;if(t){this.prop=t;for(let s=0;s<e.length;s++){const i=e[s],o=i[t];for(const e in o){if(!o.hasOwnProperty(e))continue;if(n.hasOwnProperty(e))continue;n[e]=this.length++}}}else if(Array.isArray(e)&&Array.isArray(e[0]))for(let t=0;t<e.length;t++){const s=e[t];for(let e=0;e<s.length;e++){const t=s[e];for(const e in t){if(!t.hasOwnProperty(e))continue;if(n.hasOwnProperty(e))continue;n[e]=this.length++}}}else for(let t=0;t<e.length;t++){const s=e[t];for(const e in s){if(!s.hasOwnProperty(e))continue;if(n.hasOwnProperty(e))continue;n[e]=this.length++}}}}ue=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function Dn(e,t,n){return n={path:t,exports:{},require:function(e,t){return Nn(e,t??n.path)}},e(n,n.exports),n.exports}function Nn(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}he=Dn(function(e,t){var n,o,s=ue&&ue.__assign||function(){return s=Object.assign||function(e){for(var t,s,n=1,o=arguments.length;n<o;n++){t=arguments[n];for(s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e},s.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.thaw=t.Block=t.Thaw=void 0,n=function(){function e(t,n){o=this,n===void 0&&(n={});var o,i=s(s({},e.defaultSettings),n),a=i.each,r=i.done;this.i=0,this.isStopped=!1,this.items=t,this.options=n,this.tick=function(){if(o.isStopped)return;if(o.timeout=setTimeout(o.tick,0),e.thawing)return;var t=o.items[o.i];if(o.i>=o.items.length){r!==null&&(e.thawing=!0,r(),e.thawing=!1),o.isStopped=!0,clearTimeout(o.timeout);return}a!==null?(e.thawing=!0,a(t,o.i),e.thawing=!1):t!==void 0&&t(),o.i++},e.thaws.push(this),n.delay||this.tick()}return Object.defineProperty(e,"isThawing",{get:function(){return e.thawing},enumerable:!1,configurable:!0}),e.stopAll=function(){for(var t=0;t<e.thaws.length;t++)e.thaws[t].stop()},e.prototype.makeReady=function(){return!!this.isStopped&&(this.isStopped=!1,!0)},e.prototype.add=function(e){return this.items.push(e),this.makeReady()&&this.tick(),this},e.prototype.insert=function(e){return this.items.splice(this.i,0,e),this.makeReady()&&this.tick(),this},e.prototype.addArray=function(e){return this.items=this.items.concat(e),this.makeReady()&&this.tick(),this},e.prototype.insertArray=function(e){var t=this.items.splice(0,this.i),n=this.items;return this.items=t.concat(e,n),this.makeReady()&&this.tick(),this},e.prototype.stop=function(){return this.isStopped=!0,clearTimeout(this.timeout),this.options.done&&this.options.done(),this},e.thawing=!1,e.thaws=[],e.defaultSettings={each:null,done:null},e}(),t.Thaw=n;function i(e,t){return new n(e,t)}t.thaw=i,o=function(){function e(e,t){t===void 0&&(t=200),this.index=0,this.thaws=[],this.count=t,this.options=e}return e.prototype.add=function(e){var t=this.next();return t.add(e),this},e.prototype.addArray=function(e){var t=this.next();return t.addArray(e),this},e.prototype.insert=function(e){var t=this.next();return t.insert(e),this},e.prototype.insertArray=function(e){var t=this.next();return t.insertArray(e),this},e.prototype.stop=function(){for(var e=0;e<this.thaws.length;e++)this.thaws[e].stop();return this},e.prototype.next=function(){var e,t=this.thaws;return t.length<this.count?(e=new n([],this.options),t.push(e)):e=t[this.index]||null,this.index++,this.index>=this.count&&(this.index=0),e},e}(),t.Block=o,typeof window!="undefined"&&(window.Thaw=n,window.thaw=i,window.Thaw.Block=o)});const Rn={learningRate:.3,binaryThresh:.5,initPraxis:(e,t)=>{var n;return ae(e,(n=e.settings.praxisOpts)!==null&&n!==void 0?n:t)}},me={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.3,callbackPeriod:10,errorCheckInterval:100,timeout:1/0};class Z{constructor(e={}){this.trainOpts={},this.layers=null,this._inputLayer=null,this._hiddenLayers=null,this._outputLayer=null,this._model=null,this.meanSquaredError=null,this.inputLookup=null,this.inputLookupLength=null,this.outputLookup=null,this.outputLookupLength=null,this.options={...Rn,...e},this._updateTrainingOptions({...me,...e})}static _validateTrainingOptions(e){const{iterations:s,errorThresh:t,log:o,logPeriod:i,learningRate:n,callback:a,callbackPeriod:r,timeout:c}=e,l={iterations:()=>typeof s=="number"&&s>0,errorThresh:()=>typeof t=="number"&&t>0&&t<1,log:()=>typeof o=="function"||typeof o=="boolean",logPeriod:()=>typeof i=="number"&&i>0,learningRate:()=>typeof n=="number"&&n>0&&n<1,callback:()=>typeof a=="function"||a===null,callbackPeriod:()=>typeof r=="number"&&r>0,timeout:()=>typeof c=="number"&&c>0};Object.keys(me).forEach(t=>{if(l.hasOwnProperty(t)&&!l[t]()){const n=e[t];throw new Error(`[${t}, ${(n??"undefined").toString()}] is out of normal training range, your network will probably not train.`)}})}_setLogMethod(e){typeof e=="function"?this.trainOpts.log=e:e?this.trainOpts.log=console.log:this.trainOpts.log=!1}_updateTrainingOptions(e){var s;this.trainOpts={...me,...this.trainOpts,...e},Z._validateTrainingOptions(this.trainOpts),this._setLogMethod((s=e.log)!==null&&s!==void 0?s:this.trainOpts.log);const{callback:o,callbackPeriod:t,errorCheckInterval:n}=this.trainOpts;o&&t!==n&&console.warn(`options.callbackPeriod with value of ${(t??"undefined").toString()} does not match options.errorCheckInterval with value of ${(n??"undefined").toString()}, if logging error, it will repeat.  These values may need to match`)}_connectOptionsLayers(){const{inputLayerIndex:t,outputLayerIndex:n,layers:e}=this.options;if(!e)throw new Error("this.options.layers in unexpected state");if(typeof t!="number")throw new Error("inputLayerIndex not a number");if(typeof n!="number")throw new Error("inputLayerIndex not a number");const s=e[t];if(!s)throw new Error("inputLayer not found in this.options.layers");const o=e[n];if(!o)throw new Error("outputLayer not found in this.options.layers");return this._inputLayer=s,this._hiddenLayers=e.slice(t,n-t),this._outputLayer=o,e}_connectNewLayers(){const{inputLayer:n,outputLayer:s}=this.options;if(!n)throw new Error("inputLayer not defined");const e=[];this._inputLayer=n();const t=this._connectHiddenLayers(this._inputLayer);if(!s)throw new Error("outputLayer not defined");return this._outputLayer=s(t[t.length-1],t.length),e.push(this._inputLayer),e.push(...t),e.push(this._outputLayer),ct(e)}_connectHiddenLayers(e){this._hiddenLayers=[];const n=[],{hiddenLayers:t}=this.options;if(!t)throw new Error("hiddenLayers not defined");for(let s=0;s<t.length;s++){const o=t[s](e,s);n.push(o),this._hiddenLayers.push(o),e=o}return n}initialize(){this.layers=this.options.layers?this._connectOptionsLayers():this._connectNewLayers(),this.initializeLayers(this.layers),this._model=this.layers.filter(e=>e instanceof _)}initializeLayers(e){var t,n;for(let o=0;o<e.length;o++){const s=e[o];s.setupKernels(!0),s instanceof _&&s.praxis===null&&typeof this.options.initPraxis=="function"&&(s.praxis=this.options.initPraxis(s,(n=(t=s.settings.praxisOpts)!==null&&t!==void 0?t:this.options.praxisOpts)!==null&&n!==void 0?n:{}),s.praxis.setupKernels())}const s=e[e.length-1];this.meanSquaredError=new fo({width:s.width,height:s.height})}run(e){let s;if(Array.isArray(e)||e.buffer)s=e;else if(this.inputLookup)s=i.toArray(this.inputLookup,e,this.inputLookupLength);else throw new Error("input is incompatible with net");let n=this.runInput(s);return n instanceof t.Texture&&(n=n.toArray()),this.outputLookup?i.toObject(this.outputLookup,n):n}runInput(e){if(!this.layers)throw new Error("not initialized");this.layers[0].predict(e);for(let e=1;e<this.layers.length;e++)this.layers[e].predict();return this.layers[this.layers.length-1].weights}train(e,t={}){const{preparedData:n,status:s,endTime:i}=this._prepTraining(e,t);let o=!0;const a=()=>this._calculateTrainingError(n),r=()=>this._trainPatterns(n);for(;o;)o=this._trainingTick(s,i,a,r);return s}async trainAsync(e,t={}){const{preparedData:n,status:s,endTime:o}=this._prepTraining(e,t);return await new Promise((e,t)=>{try{const i=()=>this._calculateTrainingError(n),a=()=>this._trainPatterns(n),t=new he.Thaw(new Array(this.trainOpts.iterations),{delay:!0,each:()=>this._trainingTick(s,o,i,a)||t.stop(),done:()=>e(s)});t.tick()}catch(e){t(e)}})}_trainingTick(e,t,n,s){const{trainOpts:o}=this;return!(e.iterations>=o.iterations||e.error<=o.errorThresh||Date.now()>=t)&&(typeof o.log=="function"&&e.iterations%o.logPeriod===0?(e.error=n(),o.log(`iterations: ${e.iterations}, training error: ${e.error}`)):e.iterations%o.errorCheckInterval===0?e.error=n():s(),o.callback&&e.iterations%o.callbackPeriod===0&&o.callback(Object.assign(e)),e.iterations++,!0)}_prepTraining(e,t){this._updateTrainingOptions(t);const n=this.formatData(e),s=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0,o={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:this.transferData(n),status:o,endTime:s}}verifyIsInitialized(){this._model||this.initialize()}_calculateTrainingError(e){let s=new Float32Array([0]);const i=this.meanSquaredError;for(let t=0;t<e.length;++t){const a=s,o=this._trainPattern(e[t].input,e[t].output,!0);s=i.add(s,o),n(o),n(a)}const o=i.divide(e.length,s);if(n(s),o instanceof t.Texture){const e=o.toArray();return n(o),e[0]}return o[0]}_trainPatterns(e){for(let t=0;t<e.length;++t)this._trainPattern(e[t].input,e[t].output,!1)}_trainPattern(e,t,n){var s;if(this.runInput(e),this._calculateDeltas(t),this.adjustWeights(),n){if(!((s=this._outputLayer)===null||s===void 0?void 0:s.errors))throw new Error("outputLayer.errors not defined");return this.meanSquaredError.calculate(this._outputLayer.errors)}return null}_calculateDeltas(e){const t=this.layers;for(let n=t.length-1;n>-1;n--)t[n].compare(e)}adjustWeights(){const e=this._model;for(let t=0;t<e.length;t++)e[t].learn(this.trainOpts.learningRate)}formatData(e){if(!Array.isArray(e)){const t=[];t.push(e),e=t}const n=e[0].input;let t;if(Array.isArray(e)&&!Array.isArray(n)&&!(n instanceof Float32Array)){if(!this.inputLookup){const t=new v(e,"input");this.inputLookup=t.table,this.inputLookupLength=t.length}t=e.map(e=>{const t=i.toArray(this.inputLookup,e.input,this.inputLookupLength);return{input:t}},this)}else t=e;const s=e[0].output;if(!Array.isArray(s)&&!(s instanceof Float32Array)){if(!this.outputLookup){const t=new v(e,"output");this.outputLookup=t.table,this.outputLookupLength=t.length}t=e.map((e,n)=>{const s=i.toArray(this.outputLookup,e.output,this.inputLookupLength);return{input:t[n].input,output:s}},this)}return t}transferData(e){const t=new Array(e.length),n=s(function(e){return e[this.thread.x]},{output:[e[0].input.length],immutable:!0}),o=s(function(e){return e[this.thread.x]},{output:[e[0].output.length],immutable:!0});for(let s=0;s<e.length;s++){const i=e[s];t[s]={input:n(i.input),output:o(i.output)}}return t}test(){throw new Error(`${this.constructor.name}-test is not yet implemented`)}toJSON(){var e;if(this.layers||this.initialize(),!this._model||!this.layers||!this._inputLayer||!this._hiddenLayers||!this._outputLayer)throw new Error("network is not initialized");const t=[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s],n=e.toJSON();e.hasOwnProperty("inputLayer")?n.inputLayerIndex=this.layers.indexOf(e.inputLayer):e.hasOwnProperty("inputLayer1")&&e.hasOwnProperty("inputLayer2")&&(n.inputLayer1Index=this.layers.indexOf(e.inputLayer1),n.inputLayer2Index=this.layers.indexOf(e.inputLayer2)),t.push(n)}return{type:this.constructor.name,sizes:(e=this.options.sizes)!==null&&e!==void 0?e:[this._inputLayer.height].concat(this._hiddenLayers.map(e=>e.height)).concat([this._outputLayer.height]),outputLayerIndex:this.layers.indexOf(this._outputLayer),layers:t,inputLayerIndex:this.layers.indexOf(this._inputLayer)}}static fromJSON(e,t){var o,i,a,r;const s=e.layers,n=[],c=t?(o=y(s[0]))!==null&&o!==void 0?o:t(s[0]):y(s[0]);if(!c)throw new Error("unable to find layer");n.push(c);for(let o=1;o<s.length;o++){const e=s[o];if(typeof e.inputLayerIndex=="undefined"&&typeof e.inputLayer1Index=="undefined"&&typeof e.inputLayer2Index=="undefined"){const s=t?(i=y(e))!==null&&i!==void 0?i:t(e):y(e);if(!s)throw new Error("unable to find layer");n.push(s)}else if(typeof e.inputLayerIndex=="number"){const s=n[e.inputLayerIndex];if(!s)throw new Error("inputLayer1 not found");const o=t?(a=y(e,s))!==null&&a!==void 0?a:t(e,s):y(e,s);if(!o)throw new Error("unable to find layer");n.push(o)}else{if(typeof e.inputLayer1Index!="number")throw new Error("Cannot create network from provided JSON. inputLayer1Index not defined.");if(typeof e.inputLayer2Index!="number")throw new Error("Cannot create network from provided JSON. inputLayer2Index not defined.");const s=n[e.inputLayer1Index],o=n[e.inputLayer2Index];if(s===void 0)throw new Error(`Cannot create network from provided JSON. layer of index ${e.inputLayer1Index} not found.`);if(o===void 0)throw new Error(`Cannot create network from provided JSON. layer of index ${e.inputLayer2Index} not found.`);const i=t?(r=y(e,s,o))!==null&&r!==void 0?r:t(e,s,o):y(e,s,o);if(!i)throw new Error("unable to find layer");n.push(i)}}return new this({...e,layers:n})}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}createTrainStream(){throw new Error(`${this.constructor.name}-createTrainStream is not yet implemented`)}}function In(e,t){if(!t)throw new TypeError(`Required parameter 'net' is of type ${typeof t}. Must be of type 'brain.NeuralNetwork'`);const o=t.run(e);let n=null,s=-1;return Object.entries(o).forEach(([e,t])=>{typeof t!="undefined"&&typeof t=="number"&&t>s&&(n=e,s=t)}),n}function Bn(e){const t=[];for(let n=0;n<e.length;n++)t.push(Float32Array.from(e[n]));return t}function Vn(e,t){const n=[];for(let t=0;t<e.length;t++)n.push(Float32Array.from(e[t]));for(let e=0;e<t.length;e++)n.push(Float32Array.from(t[e]));return n}function $n(e){const t=[];for(let n=0;n<e.length;n++)t.push(Float32Array.from([e[n]]));return t}function Wn(e,t){const n=[];for(let t=0;t<e.length;t++)n.push(Float32Array.from([e[t]]));for(let e=0;e<t.length;e++)n.push(Float32Array.from([t[e]]));return n}function Un(e){return Float32Array.from(e)}function Kn(e,t,n,s,o,i){const a=[];for(let t=0;t<e.length;t++){const s=e[t],i=new Float32Array(o);for(const e in s)s.hasOwnProperty(e)&&(i[n[e]]=s[e]);a.push(i)}for(let e=0;e<t.length;e++){const n=t[e],o=new Float32Array(i);for(const e in n)n.hasOwnProperty(e)&&(o[s[e]]=n[e]);a.push(o)}return a}function qn(e){const t=[];for(const n in e){if(!e.hasOwnProperty(n))continue;t.push(Float32Array.from([e[n]]))}return t}function Yn(e,t){const n=[];for(const t in e){if(!e.hasOwnProperty(t))continue;n.push(Float32Array.from([e[t]]))}for(const e in t){if(!t.hasOwnProperty(e))continue;n.push(Float32Array.from([t[e]]))}return n}function ot(e,t,n){const s=new Float32Array(n);for(const n in e)e.hasOwnProperty(n)&&(s[t[n]]=e[n]);return s}function oe(e){return Array.isArray(e)||e instanceof Float32Array?Math.max(...e):Math.max(...Object.values(e))}function ne(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]**2;return t/e.length}function et(e,t){if(e.buffer instanceof ArrayBuffer)return null;if(Array.isArray(e))return Un;if(!t)throw new Error("table is not Object");const{length:n}=Object.keys(t);return e=>{const s=new Float32Array(n);for(const n in t){if(!t.hasOwnProperty(n))continue;if(typeof e[n]!="number")continue;s[t[n]]=e[n]||0}return s}}function Je(){return{inputSize:0,outputSize:0,binaryThresh:.5}}function es(){return{activation:"sigmoid",iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,leakyReluAlpha:.01,learningRate:.3,momentum:.1,callbackPeriod:10,timeout:1/0,beta1:.9,beta2:.999,epsilon:1e-8}}class pe{constructor(e={}){this.options=Je(),this.trainOpts=es(),this.sizes=[],this.outputLayer=-1,this.biases=[],this.weights=[],this.outputs=[],this.deltas=[],this.changes=[],this.errors=[],this.errorCheckInterval=1,this.inputLookup=null,this.inputLookupLength=0,this.outputLookup=null,this.outputLookupLength=0,this._formatInput=null,this._formatOutput=null,this.runInput=e=>(this.setActivation(),this.runInput(e)),this.calculateDeltas=e=>(this.setActivation(),this.calculateDeltas(e)),this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0,this.options={...this.options,...e},this.updateTrainingOptions(e);const{inputSize:n,hiddenLayers:t,outputSize:s}=this.options;n&&s&&(this.sizes=[n].concat(t??[]).concat([s]))}initialize(){if(!this.sizes.length)throw new Error("Sizes must be set before initializing");this.outputLayer=this.sizes.length-1,this.biases=new Array(this.outputLayer),this.weights=new Array(this.outputLayer),this.outputs=new Array(this.outputLayer),this.deltas=new Array(this.outputLayer),this.changes=new Array(this.outputLayer),this.errors=new Array(this.outputLayer);for(let e=0;e<=this.outputLayer;e++){const t=this.sizes[e];if(this.deltas[e]=u(t),this.errors[e]=u(t),this.outputs[e]=u(t),e>0){this.biases[e]=C(t),this.weights[e]=new Array(t),this.changes[e]=new Array(t);for(let n=0;n<t;n++){const s=this.sizes[e-1];this.weights[e][n]=C(s),this.changes[e][n]=u(s)}}}this.setActivation(),this.trainOpts.praxis==="adam"&&this._setupAdam()}setActivation(e){const t=e??this.trainOpts.activation;switch(t){case"sigmoid":this.runInput=this._runInputSigmoid,this.calculateDeltas=this._calculateDeltasSigmoid;break;case"relu":this.runInput=this._runInputRelu,this.calculateDeltas=this._calculateDeltasRelu;break;case"leaky-relu":this.runInput=this._runInputLeakyRelu,this.calculateDeltas=this._calculateDeltasLeakyRelu;break;case"tanh":this.runInput=this._runInputTanh,this.calculateDeltas=this._calculateDeltasTanh;break;default:throw new Error(`Unknown activation ${t}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}}get isRunnable(){return this.sizes.length>0}run(e){if(!this.isRunnable)throw new Error("network not runnable");let t;this.inputLookup?t=i.toArray(this.inputLookup,e,this.inputLookupLength):t=e,this.validateInput(t);const n=this.runInput(t).slice(0);return this.outputLookup?i.toObject(this.outputLookup,n):n}_runInputSigmoid(e){this.outputs[0]=e;let t=null;for(let n=1;n<=this.outputLayer;n++){const o=this.sizes[n],i=this.weights[n],a=this.biases[n],s=this.outputs[n];for(let t=0;t<o;t++){const n=i[t];let r=a[t];for(let t=0;t<n.length;t++)r+=n[t]*e[t];s[t]=1/(1+Math.exp(-r))}t=e=s}if(!t)throw new Error("output was empty");return t}_runInputRelu(e){this.outputs[0]=e;let t=null;for(let n=1;n<=this.outputLayer;n++){const o=this.sizes[n],i=this.weights[n],a=this.biases[n],s=this.outputs[n];for(let t=0;t<o;t++){const r=i[t];let n=a[t];for(let t=0;t<r.length;t++)n+=r[t]*e[t];s[t]=n<0?0:n}t=e=s}if(!t)throw new Error("output was empty");return t}_runInputLeakyRelu(e){this.outputs[0]=e;const{leakyReluAlpha:n}=this.trainOpts;let t=null;for(let s=1;s<=this.outputLayer;s++){const i=this.sizes[s],a=this.weights[s],r=this.biases[s],o=this.outputs[s];for(let t=0;t<i;t++){const c=a[t];let s=r[t];for(let t=0;t<c.length;t++)s+=c[t]*e[t];o[t]=Math.max(s,n*s)}t=e=o}if(!t)throw new Error("output was empty");return t}_runInputTanh(e){this.outputs[0]=e;let t=null;for(let n=1;n<=this.outputLayer;n++){const o=this.sizes[n],i=this.weights[n],a=this.biases[n],s=this.outputs[n];for(let t=0;t<o;t++){const n=i[t];let r=a[t];for(let t=0;t<n.length;t++)r+=n[t]*e[t];s[t]=Math.tanh(r)}t=e=s}if(!t)throw new Error("output was empty");return t}verifyIsInitialized(e){if(this.sizes.length&&this.outputLayer>0)return;this.sizes=[],this.sizes.push(e[0].input.length),this.options.hiddenLayers?this.options.hiddenLayers.forEach(e=>{this.sizes.push(e)}):this.sizes.push(Math.max(3,Math.floor(e[0].input.length/2))),this.sizes.push(e[0].output.length),this.initialize()}updateTrainingOptions(e){const t={...this.trainOpts,...e};this.validateTrainingOptions(t),this.trainOpts=t,this.setLogMethod(this.trainOpts.log)}validateTrainingOptions(e){const t={activation:()=>["sigmoid","relu","leaky-relu","tanh"].includes(e.activation),iterations:()=>{const t=e.iterations;return typeof t=="number"&&t>0},errorThresh:()=>{const t=e.errorThresh;return typeof t=="number"&&t>0&&t<1},log:()=>{const t=e.log;return typeof t=="function"||typeof t=="boolean"},logPeriod:()=>{const t=e.logPeriod;return typeof t=="number"&&t>0},leakyReluAlpha:()=>{const t=e.leakyReluAlpha;return typeof t=="number"&&t>0&&t<1},learningRate:()=>{const t=e.learningRate;return typeof t=="number"&&t>0&&t<1},momentum:()=>{const t=e.momentum;return typeof t=="number"&&t>0&&t<1},callback:()=>{const t=e.callback;return typeof t=="function"||t===void 0},callbackPeriod:()=>{const t=e.callbackPeriod;return typeof t=="number"&&t>0},timeout:()=>{const t=e.timeout;return typeof t=="number"&&t>0},praxis:()=>{const t=e.praxis;return!t||t==="adam"},beta1:()=>{const t=e.beta1;return t>0&&t<1},beta2:()=>{const t=e.beta2;return t>0&&t<1},epsilon:()=>{const t=e.epsilon;return t>0&&t<1}};for(const n in t){const s=e;if(!t[n]())throw new Error(`[${n}, ${s[n]}] is out of normal training range, your network will probably not train.`)}}getTrainOptsJSON(){const{activation:l,iterations:s,errorThresh:n,log:e,logPeriod:o,leakyReluAlpha:i,learningRate:a,momentum:r,callbackPeriod:c,timeout:t,praxis:d,beta1:u,beta2:h,epsilon:m}=this.trainOpts;return{activation:l,iterations:s,errorThresh:n,log:typeof e=="function"||typeof e=="boolean"&&e,logPeriod:o,leakyReluAlpha:i,learningRate:a,momentum:r,callbackPeriod:c,timeout:t===1/0?"Infinity":t,praxis:d,beta1:u,beta2:h,epsilon:m}}setLogMethod(e){typeof e=="function"?this.trainOpts.log=e:e?this.trainOpts.log=this.logTrainingStatus:this.trainOpts.log=!1}logTrainingStatus(e){console.log(`iterations: ${e.iterations}, training error: ${e.error}`)}calculateTrainingError(e){let t=0;for(let n=0;n<e.length;++n)t+=this.trainPattern(e[n],!0);return t/e.length}trainPatterns(e){for(let t=0;t<e.length;++t)this.trainPattern(e[t])}trainingTick(e,t,n){const{callback:s,callbackPeriod:i,errorThresh:a,iterations:r,log:o,logPeriod:c}=this.trainOpts;return!(t.iterations>=r||t.error<=a||Date.now()>=n)&&(t.iterations++,o&&t.iterations%c===0?(t.error=this.calculateTrainingError(e),o(t)):t.iterations%this.errorCheckInterval===0?t.error=this.calculateTrainingError(e):this.trainPatterns(e),s&&t.iterations%i===0&&s({iterations:t.iterations,error:t.error}),!0)}prepTraining(e,t={}){this.updateTrainingOptions(t);const n=this.formatData(e),s=Date.now()+this.trainOpts.timeout,o={error:1,iterations:0};return this.verifyIsInitialized(n),this.validateData(n),{preparedData:n,status:o,endTime:s}}train(e,t={}){const{preparedData:s,status:n,endTime:o}=this.prepTraining(e,t);for(;!0;)if(!this.trainingTick(s,n,o))break;return n}async trainAsync(e,t={}){const{preparedData:s,status:n,endTime:o}=this.prepTraining(e,t);return await new Promise((e,t)=>{try{const t=new he.Thaw(new Array(this.trainOpts.iterations),{delay:!0,each:()=>this.trainingTick(s,n,o)||t.stop(),done:()=>e(n)});t.tick()}catch(e){t(e)}})}trainPattern(e,t){return this.runInput(e.input),this.calculateDeltas(e.output),this.adjustWeights(),t?ne(this.errors[this.outputLayer]):null}_calculateDeltasSigmoid(e){for(let t=this.outputLayer;t>=0;t--){const n=this.sizes[t],s=this.outputs[t],o=this.errors[t],i=this.deltas[t],a=this.weights[t+1];for(let r=0;r<n;r++){const l=s[r];let c=0;if(t===this.outputLayer)c=e[r]-l;else{const e=this.deltas[t+1];for(let t=0;t<e.length;t++)c+=e[t]*a[t][r]}o[r]=c,i[r]=c*l*(1-l)}}}_calculateDeltasRelu(e){for(let t=this.outputLayer;t>=0;t--){const s=this.sizes[t],o=this.outputs[t],i=this.weights[t+1],n=this.deltas[t+1],a=this.errors[t],r=this.deltas[t];for(let c=0;c<s;c++){const d=o[c];let l=0;if(t===this.outputLayer)l=e[c]-d;else for(let e=0;e<n.length;e++)l+=n[e]*i[e][c];a[c]=l,r[c]=d>0?l:0}}}_calculateDeltasLeakyRelu(e){const t=this.trainOpts.leakyReluAlpha;for(let n=this.outputLayer;n>=0;n--){const o=this.sizes[n],i=this.outputs[n],s=this.deltas[n+1],a=this.weights[n+1],r=this.errors[n],c=this.deltas[n];for(let l=0;l<o;l++){const u=i[l];let d=0;if(n===this.outputLayer)d=e[l]-u;else for(let e=0;e<s.length;e++)d+=s[e]*a[e][l];r[l]=d,c[l]=u>0?d:t*d}}}_calculateDeltasTanh(e){for(let t=this.outputLayer;t>=0;t--){const s=this.sizes[t],o=this.outputs[t],n=this.deltas[t+1],i=this.weights[t+1],a=this.errors[t],r=this.deltas[t];for(let c=0;c<s;c++){const d=o[c];let l=0;if(t===this.outputLayer)l=e[c]-d;else for(let e=0;e<n.length;e++)l+=n[e]*i[e][c];a[c]=l,r[c]=(1-d*d)*l}}}adjustWeights(){const{learningRate:e,momentum:t}=this.trainOpts;for(let n=1;n<=this.outputLayer;n++){const s=this.outputs[n-1],i=this.sizes[n],a=this.deltas[n],o=this.changes[n],r=this.weights[n],c=this.biases[n];for(let n=0;n<i;n++){const l=a[n];for(let i=0;i<s.length;i++){let a=o[n][i];a=e*l*s[i]+t*a,o[n][i]=a,r[n][i]+=a}c[n]+=e*l}}}_setupAdam(){this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0;for(let e=0;e<=this.outputLayer;e++){const t=this.sizes[e];if(e>0){this.biasChangesLow[e]=u(t),this.biasChangesHigh[e]=u(t),this.changesLow[e]=new Array(t),this.changesHigh[e]=new Array(t);for(let n=0;n<t;n++){const s=this.sizes[e-1];this.changesLow[e][n]=u(s),this.changesHigh[e][n]=u(s)}}}this.adjustWeights=this._adjustWeightsAdam}_adjustWeightsAdam(){this.iterations++;const{iterations:n}=this,{beta1:e,beta2:t,epsilon:s,learningRate:o}=this.trainOpts;for(let i=1;i<=this.outputLayer;i++){const c=this.outputs[i-1],h=this.sizes[i],l=this.deltas[i],d=this.changesLow[i],u=this.changesHigh[i],m=this.weights[i],f=this.biases[i],a=this.biasChangesLow[i],r=this.biasChangesHigh[i];for(let i=0;i<h;i++){const g=l[i];for(let a=0;a<c.length;a++){const r=g*c[a],l=d[i][a]*e+(1-e)*r,h=u[i][a]*t+(1-t)*r*r,f=l/(1-Math.pow(e,n)),p=h/(1-Math.pow(t,n));d[i][a]=l,u[i][a]=h,m[i][a]+=o*f/(Math.sqrt(p)+s)}const p=l[i],v=a[i]*e+(1-e)*p,b=r[i]*t+(1-t)*p*p,j=a[i]/(1-Math.pow(e,n)),y=r[i]/(1-Math.pow(t,n));a[i]=v,r[i]=b,f[i]+=o*j/(Math.sqrt(y)+s)}}}validateData(e){const t=this.sizes[0],n=this.sizes[this.sizes.length-1],{length:s}=e;for(let o=0;o<s;o++){const{input:i,output:a}=e[o];if(i.length!==t)throw new Error(`input at index ${o} length ${i.length} must be ${t}`);if(e[o].output.length!==n)throw new Error(`output at index ${o} length ${a.length} must be ${n}`)}}validateInput(e){const t=this.sizes[0];if(e.length!==t)throw new Error(`input length ${e.length} must match options.inputSize of ${t}`)}formatData(e){if(!Array.isArray(e[0].input))if(this.inputLookup)this.inputLookupLength=Object.keys(this.inputLookup).length;else{const t=new v(e,"input");this.inputLookup=t.table,this.inputLookupLength=t.length}if(!Array.isArray(e[0].output))if(this.outputLookup)this.outputLookupLength=Object.keys(this.outputLookup).length;else{const t=new v(e,"output");this.outputLookup=t.table,this.outputLookupLength=t.length}if(this._formatInput||(this._formatInput=et(e[0].input,this.inputLookup)),this._formatOutput||(this._formatOutput=et(e[0].output,this.outputLookup)),this._formatInput&&this._formatOutput){const t=[];for(let n=0;n<e.length;n++)t.push({input:this._formatInput(e[n].input),output:this._formatOutput(e[n].output)});return t}if(this._formatInput){const t=[];for(let n=0;n<e.length;n++)t.push({input:this._formatInput(e[n].input),output:e[n].output});return t}if(this._formatOutput){const t=[];for(let n=0;n<e.length;n++)t.push({input:e[n].input,output:this._formatOutput(e[n].output)});return t}return e}addFormat(e){var t,n;(!Array.isArray(e.input)||typeof e.input[0]!="number")&&(this.inputLookup=i.addKeys(e.input,(t=this.inputLookup)!==null&&t!==void 0?t:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length)),(!Array.isArray(e.output)||typeof e.output[0]!="number")&&(this.outputLookup=i.addKeys(e.output,(n=this.outputLookup)!==null&&n!==void 0?n:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length))}test(e){const{preparedData:t}=this.prepTraining(e),o=t[0].output.length===1,n=[];let s=0;if(o){let o=0,i=0,e=0,a=0;for(let l=0;l<t.length;l++){const d=this.runInput(t[l].input),u=t[l].output,r=d[0]>this.options.binaryThresh?1:0,c=u[0];if(r!==c){const e=t[l];n.push({input:e.input,output:e.output,actual:r,expected:c})}r===0&&c===0?a++:r===1&&c===1?e++:r===0&&c===1?i++:r===1&&c===0&&o++,s+=ne(d.map((e,t)=>u[t]-e))}return{error:s/t.length,misclasses:n,total:t.length,trueNeg:a,truePos:e,falseNeg:i,falsePos:o,precision:e>0?e/(e+o):0,recall:e>0?e/(e+i):0,accuracy:(a+e)/t.length}}for(let e=0;e<t.length;e++){const o=this.runInput(t[e].input),i=t[e].output,a=o.indexOf(oe(o)),r=i.indexOf(oe(i));if(a!==r){const s=t[e];n.push({input:s.input,output:s.output,actual:a,expected:r})}s+=ne(o.map((e,t)=>i[t]-e))}return{error:s/t.length,misclasses:n,total:t.length}}toJSON(){var e,t;this.isRunnable||this.initialize();const s=this.weights.map(e=>e.map(e=>Array.from(e))),o=this.biases.map(e=>Array.from(e)),n=[],i=this.sizes.length-1;for(let a=0;a<=i;a++)n.push({weights:(e=s[a])!==null&&e!==void 0?e:[],biases:(t=o[a])!==null&&t!==void 0?t:[]});return{type:"NeuralNetwork",sizes:[...this.sizes],layers:n,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}fromJSON(e){if(this.options={...Je(),...e.options},e.hasOwnProperty("trainOpts")){const t={...e.trainOpts,timeout:e.trainOpts.timeout==="Infinity"?1/0:e.trainOpts.timeout};this.updateTrainingOptions(t)}this.sizes=e.sizes,this.initialize(),this.inputLookup=e.inputLookup?{...e.inputLookup}:null,this.inputLookupLength=e.inputLookupLength,this.outputLookup=e.outputLookup?{...e.outputLookup}:null,this.outputLookupLength=e.outputLookupLength;const t=e.layers,n=this.weights.map((e,n)=>t[n].weights.map(e=>Float32Array.from(e))),s=this.biases.map((e,n)=>Float32Array.from(t[n].biases));for(let e=0;e<=this.outputLayer;e++)this.weights[e]=n[e]||[],this.biases[e]=s[e]||[];return this}toFunction(e){const{activation:i,leakyReluAlpha:l}=this.trainOpts;let t=!1;const n=(e,s)=>{if(e===0)return`(input[${s}]||0)`;const r=this.weights[e][s],c=this.biases[e][s];if(!r)throw new Error(`weights at layerIndex ${e} & nodeIndex ${s} not found`);if(!c)throw new Error(`bias as layerIndex ${e} & nodeIndex ${s} not found`);const a=[];r.forEach((t,s)=>{t<0?a.push(`${t}*${n(e-1,s)}`):a.push(`+${t}*${n(e-1,s)}`)});const o=`(${c.toString()}${a.join("")})`;switch(i){case"sigmoid":return`1/(1+1/Math.exp(${o}))`;case"relu":return t=!0,`((v=${o})<0?0:v)`;case"leaky-relu":return t=!0,`Math.max((v=${o}),${l}*v)`;case"tanh":return`Math.tanh(${o})`;default:throw new Error(`Unknown activation ${i}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}};function a(e){if(e.find(e=>e.includes('"')))throw new Error(`key contains '"', which is not compatible`)}const s=[];let o,r="";if(this.inputLookup){const e=Object.keys(this.inputLookup);a(e),r=`input = new Float32Array([${Object.keys(this.inputLookup).map(e=>`input["${e}"]`).join(",")}]);`}if(this.sizes.length<1)throw new Error("No layers");for(let e=0;e<this.sizes[this.outputLayer];e++)s.push(n(this.outputLayer,e));if(this.outputLookup){const e=Object.keys(this.outputLookup);a(e);const t=e.map((e,t)=>`"${e}":${s[t]}`).join(",");o=`{${t}}`}else o=`[${s.join(",")}]`;const c=`${r}${t?"var v;":""}return ${o};`;return new Function("input",e?e(c):c)}}function ns(e,t,n){let s=t[this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[this.thread.x][t]*n[t];return 1/(1+Math.exp(-s))}function ss(e,t,n){let s=t[this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[this.thread.x][t]*n[t];return s<0?0:s}function os(e,t,n){let s=t[this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[this.thread.x][t]*n[t];return s<0?0:.01*s}function is(e,t,n){let s=t[this.thread.x];for(let t=0;t<this.constants.size;t++)s+=e[this.thread.x][t]*n[t];return Math.tanh(s)}function Qe(e,t){return t-e}function cs(e,t){return e*t*(1-t)}function ls(e,t){return t>0?e:0}function ds(e,t){return t>0?e:.01*e}function us(e,t){return(1-t*t)*e}function we(e,t,n,s){let o=0;for(let i=0;i<t;i++)o+=s[i]*n[i][e];return o}function Ke(e,t,n,s,o){return e*s*o+t*n}function Ue(e,t){return e+t}function ps(e,t){return e[this.thread.x]+t[this.thread.x]*this.constants.learningRate}function gs(e){let t=0;for(let n=0;n<this.constants.size;n++)t+=e[n]**2;return t/this.constants.size}class We extends pe{constructor(e={}){super(e),this.texturizeInputData=()=>{throw new Error("not yet setup")},this.forwardPropagate=[],this.backwardPropagate=[],this.changesPropagate=[],this.biasesPropagate=[],this.getMSE=()=>{throw new Error("not yet setup")},this._addMSE=()=>{throw new Error("not yet setup")},this._divideMSESum=()=>{throw new Error("not yet setup")},this.outputs=[],this.deltas=[],this.errors=[],this.weights=[],this.changes=[],this.biases=[],this.runInput=e=>{let t;this.outputs[0]=e;for(let s=1;s<=this.outputLayer;s++)n(this.outputs[s]),this.outputs[s]=this.forwardPropagate[s](this.weights[s],this.biases[s],e),t=e=this.outputs[s];return t},this.calculateDeltas=e=>{for(let t=this.outputLayer;t>0;t--){n(this.deltas[t]),n(this.errors[t]);let s;t===this.outputLayer?s=this.backwardPropagate[t](this.outputs[t],e):s=this.backwardPropagate[t](this.weights[t+1],this.outputs[t],this.deltas[t+1]),this.deltas[t]=s.result,this.errors[t]=s.error}},this.errorCheckInterval=100,this.gpu=new t.GPU({mode:e.mode})}initialize(){super.initialize(),this.buildRunInput(),this.buildCalculateDeltas(),this.buildGetChanges(),this.buildChangeBiases(),this.buildGetMSE()}setActivation(){}trainPattern(e,t){return this.runInput(e.input),this.calculateDeltas(e.output),this.adjustWeights(),t?this.getMSE(this.errors[this.outputLayer]):null}calculateTrainingError(e){let s=new Float32Array([0]);for(let t=0;t<e.length;++t){const i=s,o=this.trainPattern(e[t],!0);s=this._addMSE(s,o),n(o),n(i)}const o=this._divideMSESum(e.length,s);return n(s),(o instanceof t.Texture?o.toArray():o)[0]}adjustWeights(){this.getChanges(),this.changeBiases()}buildRunInput(){let e=null;switch(this.trainOpts.activation){case"sigmoid":e=ns;break;case"relu":e=ss;break;case"leaky-relu":e=os;break;case"tanh":e=is;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}for(let t=1;t<=this.outputLayer;t++)this.forwardPropagate[t]=this.gpu.createKernel(e,{output:[this.sizes[t]],pipeline:!0,constants:{size:this.sizes[t-1]},immutable:!0});this.texturizeInputData=this.gpu.createKernel(function(e){return e[this.thread.x]},{output:[this.sizes[1]],pipeline:!0,immutable:!0})}buildCalculateDeltas(){let e;switch(this.trainOpts.activation){case"sigmoid":e=cs;break;case"relu":e=ls;break;case"leaky-relu":e=ds;break;case"tanh":e=us;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}e=t.alias(t.utils.getMinifySafeName(()=>e),e),this.gpu.addFunction(e);for(let t=this.outputLayer;t>0;t--)t===this.outputLayer?this.backwardPropagate[this.outputLayer]=this.gpu.createKernelMap({error:Qe},function(t,n){const s=t[this.thread.x],o=n[this.thread.x];return e(Qe(s,o),s)},{output:[this.sizes[this.outputLayer]],pipeline:!0,immutable:!0}):this.backwardPropagate[t]=this.gpu.createKernelMap({error:we},function(t,n,s){const o=n[this.thread.x];return e(we(this.thread.x,this.constants.size,t,s),o)},{output:[this.sizes[t]],pipeline:!0,constants:{size:this.sizes[t+1]},immutable:!0})}buildGetChanges(){for(let e=1;e<=this.outputLayer;e++)this.changesPropagate[e]=this.gpu.createKernelMap({weights:Ue,changes:Ke},function(e,t,n,s){const o=Ke(this.constants.learningRate,this.constants.momentum,s[this.thread.y][this.thread.x],t[this.thread.y],e[this.thread.x]);return Ue(o,n[this.thread.y][this.thread.x])},{output:[this.sizes[e-1],this.sizes[e]],pipeline:!0,constants:{size:this.sizes[e-1],learningRate:this.trainOpts.learningRate,momentum:this.trainOpts.momentum},immutable:!0})}getChanges(){for(let e=1;e<=this.outputLayer;e++){const s=this.weights[e],o=this.changes[e],t=this.changesPropagate[e](this.outputs[e-1],this.deltas[e],s,o);n(s),n(o),this.weights[e]=t.weights,this.changes[e]=t.changes,n(t.result)}}buildChangeBiases(){for(let e=1;e<=this.outputLayer;e++)this.biasesPropagate[e]=this.gpu.createKernel(ps,{output:[this.sizes[e]],pipeline:!0,constants:{learningRate:this.trainOpts.learningRate},immutable:!0})}changeBiases(){for(let e=1;e<=this.outputLayer;e++){const t=this.biases[e];this.biases[e]=this.biasesPropagate[e](t,this.deltas[e]),n(t)}}buildGetMSE(){this.getMSE=this.gpu.createKernel(gs,{output:[1],constants:{size:this.sizes[this.outputLayer]},pipeline:!0,immutable:!0}),this._addMSE=this.gpu.createKernel(function(e,t){return e[0]+t[0]},{output:[1],pipeline:!0,immutable:!0}),this._divideMSESum=this.gpu.createKernel(function(e,t){const n=t[0];return n>0?n/e:0},{output:[1]})}run(e){if(!this.isRunnable)throw new Error("network not runnable");let n;this.inputLookup?n=i.toArray(this.inputLookup,e,this.inputLookupLength):n=e,this.validateInput(n);const s=this.runInput(n),o=s instanceof t.Texture?s.toArray():s;return this.outputLookup?i.toObject(this.outputLookup,o):o}prepTraining(e,t={}){this.updateTrainingOptions(t);const n=this.formatData(e),s=Date.now()+this.trainOpts.timeout,o={error:1,iterations:0};this.verifyIsInitialized(n);const i=this.gpu.createKernel(function(e){return e[this.thread.x]},{output:[n[0].output.length],pipeline:!0,immutable:!0});return{preparedData:n.map(e=>({input:this.texturizeInputData(e.input),output:i(e.output)})),status:o,endTime:s}}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}toJSON(){var e,n;this.sizes===null&&this.initialize();const o=this.weights.map(e=>(e instanceof t.Texture?e.toArray():e).map(e=>Array.from(e))),i=this.biases.map(e=>Array.from(e instanceof t.Texture?e.toArray():e)),s=[];for(let t=0;t<=this.outputLayer;t++)s.push({weights:(e=o[t])!==null&&e!==void 0?e:[],biases:(n=i[t])!==null&&n!==void 0?n:[]});return{type:"NeuralNetworkGPU",sizes:[...this.sizes],layers:s,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}}class $e extends F{constructor(){super(...arguments),this.settings={},this.layer=null}setLayer(e){this.layer=e}get width(){if(!this.layer)throw new Error("layer not set");return this.layer.width}set width(e){throw new Error(`${this.constructor.name}-width is not yet implemented`)}get height(){if(!this.layer)throw new Error("layer not set");return this.layer.height}set height(e){throw new Error(`${this.constructor.name}-height is not yet implemented`)}get deltas(){if(!this.layer)throw new Error("layer not set");return this.layer.deltas}set deltas(e){if(!this.layer)throw new Error("layer not set");n(this.layer.deltas),this.layer.deltas=e}get weights(){if(!this.layer)throw new Error("layer not set");return this.layer.weights}set weights(e){if(!this.layer)throw new Error("layer not set");n(this.layer.weights),this.layer.weights=e}predict(){}compare(){}learn(){throw new Error("no longer using")}setupKernels(){}reuseKernels(){}}class He extends Z{constructor(e={}){super(e),this.trainOpts={},this._outputConnection=null,this._layerSets=[],this._hiddenLayerOutputIndices=[],this._model=null}_connectLayers(){if(!this.options.inputLayer)throw new Error("inputLayer not found");if(!this.options.outputLayer)throw new Error("outputLayer not found");const t=this.options.inputLayer(),e=this._connectHiddenLayers(t),n=this.options.outputLayer(e[e.length-1],-1);return{inputLayer:t,hiddenLayers:e,outputLayer:n}}_connectLayersDeep(){const s=[],n=this._layerSets[this._layerSets.length-1];let o=0;function e(e){const t=n.indexOf(e);if(t<0)throw new Error("unable to find layer");return s[t]}function t(e){return{...e.settings,weights:null,deltas:null,praxis:null}}for(let r=0;r<n.length;r++){const i=n[r];let a;if(i instanceof M)a=new i.constructor(e(i.inputLayer),t(i));else if(i instanceof je)a=new i.constructor(t(i));else if(i instanceof S)a=new i.constructor(t(i.inputLayer),e(i.inputLayer));else if(i instanceof F){const e=n[this._hiddenLayerOutputIndices[o++]];if(i instanceof $e)throw new Error("unfinished");if(i instanceof q)a=new q(e);else if(i instanceof J)a=new q(e);else throw new Error(`hidden layer ${i.constructor.name} extends unknown hidden layer`)}else if(i instanceof be||i instanceof _)a=i;else if(i instanceof N)a=new i.constructor(e(i.inputLayer),t(i.inputLayer));else if(i instanceof L)a=new i.constructor(e(i.inputLayer1),e(i.inputLayer2),t(i));else if(i instanceof H)a=new i.constructor(t(i),e(i.inputLayer));else throw new Error(`hidden layer ${i.constructor.name} extends unknown hidden layer`);s.push(a)}return s}_connectHiddenLayers(e){const t=[];if(!this.options.hiddenLayers)throw new Error("hiddenLayers not defined");for(let n=0;n<this.options.hiddenLayers.length;n++){const o=new J,s=this.options.hiddenLayers[n](e,o,n);e=s,t.push(s)}return t}initialize(){this._outputConnection=new $e;let e;if(this.options.layers)e=this._connectOptionsLayers();else{const{inputLayer:n,hiddenLayers:t,outputLayer:s}=this._connectLayers();e=ct([n,...t,s]),this._hiddenLayerOutputIndices=t.map(t=>e.indexOf(t)),this._inputLayer=n,this._hiddenLayers=t,this._outputLayer=s}this.layers=e,this._layerSets=[e],this._model=e.filter(e=>e instanceof _||e instanceof be),this.initializeLayers(e)}initializeDeep(){const e=this._connectLayersDeep();for(let t=0;t<e.length;t++){const n=e[t];n.setupKernels(!0),n.reuseKernels(this._layerSets[0][t])}this._layerSets.push(e)}run(e){for(;this._layerSets.length<=e.length;)this.initializeDeep();const n=this.runInputs(e);return n instanceof t.Texture?n.toArray():n}runInput(){throw new Error("use .runInputs()")}runInputs(e){for(;this._layerSets.length<e.length;)this.initializeDeep();const t=e.length-1;for(let n=0;n<=t;n++){const s=this._layerSets[n];s[0].predict(e[n]);for(let e=1;e<s.length;e++)s[e].predict()}const n=this._layerSets[t],s=n[n.length-1].weights;return this.end(),s}train(e,t={}){const{preparedData:n,status:s,endTime:i}=this._prepTraining(e,t);let o=!0;const a=()=>this._calculateTrainingError(n),r=()=>this._trainPatterns(n);for(;o;)o=this._trainingTick(s,i,a,r);return s}end(){const t=this._layerSets.length-1,e=this._layerSets[t];e[0].predict([new Float32Array([0])]);for(let t=1;t<e.length;t++)e[t].predict()}transferData(e){return e}_prepTraining(e,t){this._updateTrainingOptions(t);const n=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0,s={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:this.transferData(e),status:s,endTime:n}}_calculateTrainingError(e){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let s=new Float32Array(1);for(let t=0;t<e.length;++t){const i=s,o=this._trainPattern(e[t],!0);s=this.meanSquaredError.add(s,o),n(o),n(i)}const o=this.meanSquaredError.divide(e.length,s);if(n(s),o instanceof t.Texture){const e=o.toArray();return e[0]}return o[0]}formatData(e){return e}_calculateDeltas(e){const t=this._layerSets[this._layerSets.length-1];for(let e=t.length-2;e>=0;e--)t[e].compare();for(let t=e.length-2;t>=0;t--){const n=this._layerSets[t];n[n.length-1].compare(e[t+1]);for(let e=n.length-2;e>=0;e--)n[e].compare()}}adjustWeights(){var e;const t=this._model;for(let n=0;n<t.length;n++)t[n].learn((e=this.options.learningRate)!==null&&e!==void 0?e:0)}_trainPatterns(e){for(let t=0;t<e.length;++t)this._trainPattern(e[t],!1)}_trainPattern(e,t){if(this.runInputs(e),this._calculateDeltas(e),this.adjustWeights(),t){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let t=new Float32Array(1);for(let s=0,a=e.length-2;s<=a;s++){const o=this._layerSets[s],r=o[o.length-1],i=t;t=this.meanSquaredError.addAbsolute(i,r.errors),n(i)}return m(this.meanSquaredError.divide(e.length,t))}return null}}class o{constructor(e,t){this.rows=0,this.columns=0,e&&(this.rows=e),t&&(this.columns=t),this.weights=u(this.rows*this.columns),this.deltas=u(this.rows*this.columns)}getWeight(e,t){const n=this.columns*e+t;if(n<0||n>=this.weights.length)throw new Error("get accessor is skewed");return this.weights[n]}setWeight(e,t,n){const s=this.columns*e+t;if(s<0||s>=this.weights.length)throw new Error("set accessor is skewed");return this.weights[s]=n,this}getDelta(e,t){const n=this.columns*e+t;if(n<0||n>=this.deltas.length)throw new Error("get accessor is skewed");return this.deltas[n]}setDelta(e,t,n){const s=this.columns*e+t;if(s<0||s>=this.weights.length)throw new Error("set accessor is skewed");return this.deltas[s]=n,this}toJSON(){return{rows:this.rows,columns:this.columns,weights:Array.from(this.weights.slice(0))}}static fromJSON(e){const t=new o(e.rows,e.columns);for(let n=0,s=e.rows*e.columns;n<s;n++)t.weights[n]=e.weights[n];return t}static fromArray(e){const t=new o(e.length,e[0].length);return t.fromArray(e),t}deltasToArray(){return this.toArray("deltas")}weightsToArray(){return this.toArray("weights")}toArray(e="weights"){const t=new Array(this.rows);return this.iterate({row:e=>{t[e]=new Array(this.columns)},column:(n,s)=>{e==="weights"?t[n][s]=this.getWeight(n,s):e==="deltas"&&(t[n][s]=this.getDelta(n,s))}}),t}fromArray(e,t="weights"){if(e.length!==this.rows)throw new Error("rows do not match");if(e[0].length!==this.columns)throw new Error("columns do not match");return this.iterate({column:(n,s)=>{const o=e[n][s];if(typeof o!="number")throw new Error("value not number");t==="weights"?this.setWeight(n,s,o):t==="deltas"&&this.setDelta(n,s,o)}}),this}iterate(e){const t=this.rows,n=this.columns;for(let s=0;s<t;s++){e.row&&e.row(s);for(let t=0;t<n;t++)e.column&&e.column(s,t)}return this}}class c extends o{constructor(e,t,n){super(e,t),this.std=n;for(let e=0,t=this.weights.length;e<t;e++)this.weights[e]=A(-n,n)}}class p{constructor(e,t=0){if(this.values=e,this.indexTable={},this.characterTable={},this.characters=[],this.specialIndexes=[],this.isSetup=!1,e===void 0)return;this.setup(e,t)}setup(e,t=0){if(this.isSetup)throw new Error("DataFormatter is already setup");this.values=e,this.buildCharactersFromIterable(e),this.buildTables(t),e[0].input&&this.addInputOutput(),this.addUnrecognized(),this.isSetup=!0}buildCharactersFromIterable(e){const t={};for(let s=0,o=e.length;s<o;s++){const n=e[s];if(n.hasOwnProperty("length")){const e=n;for(let n=0,o=e.length;n<o;n++){const s=e[n];if(t.hasOwnProperty(s))continue;t[s]=!0,this.characters.push(s)}}else if(typeof n=="number"){if(t.hasOwnProperty(n))continue;t[n]=!0,this.characters.push(n)}else if(typeof n=="boolean"){const e=n.toString();if(t.hasOwnProperty(e))continue;t[e]=!0,this.characters.push(e)}else if(Array.isArray(n)&&typeof n[0]=="string")for(let e=0;e<n.length;e++){const s=n[e];if(t.hasOwnProperty(s))continue;t[s]=!0,this.characters.push(s)}else if(Array.isArray(n)&&(typeof n[0]=="number"||typeof n[0]=="boolean"))for(let e=0;e<n.length;e++){const o=n[e].toString();if(t.hasOwnProperty(s))continue;t[o]=!0,this.characters.push(o)}else if(n.hasOwnProperty("input")&&n.hasOwnProperty("output")){const{input:e,output:s}=n;Array.isArray(e)?this.addCharacters(e,t):this.addCharacters(e.toString(),t),Array.isArray(s)?this.addCharacters(s,t):this.addCharacters(s.toString(),t)}else throw new Error("Unhandled value")}}addCharacters(e,t){for(let n=0;n<e.length;n++){const s=e[n].toString();if(t.hasOwnProperty(s))continue;t[s]=!0,this.characters.push(s)}}buildTables(e){const t=this.characters.length;for(let n=0;n<t;n++){const s=this.characters[n];n>=e&&(this.indexTable[s]=n,this.characterTable[n]=s)}}toIndexes(e,t=0){const s=[],{indexTable:n}=this;switch(typeof e){case"number":case"boolean":e=e.toString()}for(let i=0,r=e.length;i<r;i++){const a=e[i].toString();let o=n[a];if(o===void 0)if(n.unrecognized)o=n.unrecognized;else throw new Error(`unrecognized character "${a}"`);if(o<t)continue;s.push(o)}return s}toIndexesInputOutput(e,t,n=0){const s=this.toIndexesValue(e,n,!0);return typeof t=="undefined"?s:s.concat(this.toIndexesValue(t,n,!1))}toIndexesValue(e,t,n){if(typeof e=="string")e=e.split("");else if(typeof e=="number"||typeof e=="boolean")e=e.toString().split("");else if(Array.isArray(e)&&(typeof e[0]=="number"||typeof e[0]=="boolean"||typeof e[0]=="string"))e=e.map(e=>e.toString());else throw new Error("unrecognized value");return n&&(e=e.concat(["stop-input","start-output"])),this.toIndexes(e,t)}toCharacters(e,t=0){const n=[],{indexTable:s,characterTable:o}=this;for(let a=0,c=e.length;a<c;a++){const r=e[a];if(r<t)continue;let i=o[r];if(i===void 0)if(s.unrecognized)i=o[s.unrecognized];else throw new Error(`unrecognized index "${r}"`);else i!==null&&n.push(i.toString())}return n}toString(e,t){return this.toCharacters(e,t).join("")}addInputOutput(){this.addSpecial("stop-input"),this.addSpecial("start-output")}addUnrecognized(){this.addSpecial("unrecognized")}static fromAllPrintable(e,t=[`
`]){for(let e=32;e<=126;e++)t.push(String.fromCharCode(e));return new p(t,e)}static fromAllPrintableInputOutput(e,t=[`
`]){const n=p.fromAllPrintable(e,t);return n.addInputOutput(),n.addUnrecognized(),n}static fromStringInputOutput(e,t){const s=Array.from(new Set(e)).join(""),n=new p(s.split(""),t);return n.addInputOutput(),n.addUnrecognized(),n.isSetup=!0,n}static fromArrayInputOutput(e,t){const n=[];for(let t=0;t<e.length;t++){const s=e[t];n.push(V(s.input),V(s.output))}const o=Array.isArray(n)?n.flat():n,s=new p(Array.from(new Set(o)),t);return s.addInputOutput(),s.addUnrecognized(),s.isSetup=!0,s}static fromString(e,t=0){const n=Array.from(new Set(e)).join("");return new p(n.split(""),t)}toJSON(){return{indexTable:this.indexTable,characterTable:this.characterTable,values:this.values,characters:this.characters,specialIndexes:this.specialIndexes}}static fromJSON(e){const t=new p;return t.indexTable=e.indexTable,t.characterTable=e.characterTable,t.values=e.values,t.characters=e.characters,t.specialIndexes=e.specialIndexes,t.isSetup=!0,t}addSpecial(e,t=null){const n=this.indexTable[e]=this.characters.length;this.characterTable[n]=t,this.specialIndexes.push(this.characters.length),this.characters.push(e)}toFunctionString(){return`
var characterTable = ${JSON.stringify(this.characterTable)};
var indexTable = ${JSON.stringify(this.indexTable)};
var characters = ${JSON.stringify(this.characters)};
var dataFormatter = {
  toIndexes: function ${this.toIndexes.toString()},
  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},
  toCharacters: function ${this.toCharacters.toString()},
  toIndexesValue: function ${this.toIndexesValue.toString()},
};`}formatDataIn(e,t){var n;return e===void 0?[]:Array.isArray(e)&&typeof e[0]=="number"?e:((n=this.indexTable)===null||n===void 0?void 0:n.hasOwnProperty("stop-input"))?this.toIndexesInputOutput(e,t):this.toIndexes(e)}formatDataOut(e,t){return this.toCharacters(t).join("")}format(e){if(typeof e[0]=="number"&&!Array.isArray(e[0])&&(!e[0].hasOwnProperty("input")||!e[0].hasOwnProperty("output")))return e;const t=[];if(typeof e[0]=="string"||typeof e[0]=="number"||Array.isArray(e[0]))if(this.isSetup)for(let n=0,s=e.length;n<s;n++)t.push(this.formatDataIn(e[n]));else{this.setup(e);for(let n=0;n<e.length;n++)t.push(this.formatDataIn(V(e[n])))}else if(e[0].input&&e[0].output){this.isSetup||this.setup(e);for(let n=0,s=e.length;n<s;n++)t.push(this.formatDataIn(V(e[n].input),V(e[n].output)))}else throw new Error("unrecognized data");return t}}function V(e){if(typeof e=="string")return e;if(typeof e=="number")return e.toString();if(typeof e=="boolean")return e.toString();if(Array.isArray(e)&&typeof e[0]=="string")return e;if(typeof e[0]=="boolean")return e.map(e=>e.toString());if(typeof e[0]=="number")return e.map(e=>e.toString());throw new Error("unrecognized value, expected string[], string, number[], number, boolean[], or boolean")}function xs(e,t){e.rows=t.rows,e.columns=t.columns,e.weights=t.weights.slice(0),e.deltas=t.deltas.slice(0)}function Cs(e,t,n){for(let s=0;s<t.weights.length;s++)e.weights[s]=t.weights[s]+n.weights[s],e.deltas[s]=0}function Es(e,t,n){for(let s=0;s<e.deltas.length;s++)t.deltas[s]=e.deltas[s],n.deltas[s]=e.deltas[s]}function ks(e){for(let t=0;t<e.weights.length;t++)e.weights[t]=1,e.deltas[t]=0}function As(e,t){e.rows=t.rows,e.columns=t.columns,e.weights=t.weights.slice(0),e.deltas=t.deltas.slice(0);for(let n=0;n<t.weights.length;n++)e.weights[n]=-t.weights[n],e.deltas[n]=0}function Ss(e,t,n){const i=t.rows,o=t.columns,s=n.columns;for(let a=0;a<i;a++){const r=o*a,c=s*a;for(let i=0;i<s;i++){let a=0;for(let e=0;e<o;e++){const d=s*e,c=r+e,l=d+i;a+=t.weights[c]*n.weights[l],t.deltas[c]=0,n.deltas[l]=0}e.weights[c+i]=a}}}function Ms(e,t,n){const i=t.rows,o=t.columns,s=n.columns;for(let a=0;a<i;a++){const r=o*a,c=s*a;for(let i=0;i<s;i++)for(let a=0;a<o;a++){const h=s*a,l=r+a,d=h+i,u=e.deltas[c+i];t.deltas[l]+=n.weights[d]*u,n.deltas[d]+=t.weights[l]*u}}}function Fs(e,t,n){const{weights:s}=t;for(let o=0;o<s.length;o++)e.weights[o]=t.weights[o]*n.weights[o],e.deltas[o]=0}function Ts(e,t,n){for(let s=0;s<t.weights.length;s++)t.deltas[s]=n.weights[s]*e.deltas[s],n.deltas[s]=t.weights[s]*e.deltas[s]}function zs(e,t){for(let n=0;n<t.weights.length;n++)e.weights[n]=Math.max(0,t.weights[n]),e.deltas[n]=0}function Ds(e,t){for(let n=0;n<e.deltas.length;n++)t.deltas[n]=t.weights[n]>0?e.deltas[n]:0}function Ns(e,t,n){const{columns:s}=t,o=s*n;for(let n=0;n<s;n++)e.weights[n]=t.weights[o+n],e.deltas[n]=0}function Ls(e,t,n){const{columns:s}=t,o=s*n;for(let n=0;n<s;n++)t.deltas[o+n]=e.deltas[n]}function Rs(e,t){for(let n=0;n<t.weights.length;n++)e.weights[n]=1/(1+Math.exp(-t.weights[n])),e.deltas[n]=0}function Ps(e,t){for(let n=0;n<e.deltas.length;n++){const s=e.weights[n];t.deltas[n]=s*(1-s)*e.deltas[n]}}function Q(e){const t=new o(e.rows,e.columns);let n=-999999;for(let t=0;t<e.weights.length;t++)e.weights[t]>n&&(n=e.weights[t]);let s=0;for(let o=0;o<e.weights.length;o++)t.weights[o]=Math.exp(e.weights[o]-n),s+=t.weights[o];for(let n=0;n<e.weights.length;n++)t.weights[n]/=s;return t}function Is(e,t){for(let n=0;n<t.weights.length;n++)e.weights[n]=Math.tanh(t.weights[n]),e.deltas[n]=0}function Bs(e,t){for(let n=0;n<e.deltas.length;n++){const s=e.weights[n];t.deltas[n]=(1-s*s)*e.deltas[n]}}class Se{constructor(){this.states=[],this.inputRow=0}add(e,t){if(e.weights.length!==t.weights.length)throw new Error("misaligned matrices");const n=new o(e.rows,e.columns);return this.states.push({name:"add",product:n,left:e,right:t,forwardFn:Cs,backpropagationFn:Es}),n}allOnes(e,t){const n=new o(e,t);return this.states.push({name:"allOnes",product:n,left:n,forwardFn:ks,backpropagationFn:()=>{}}),n}cloneNegative(e){const t=new o(e.rows,e.columns);return this.states.push({name:"cloneNegative",product:t,left:e,forwardFn:As,backpropagationFn:()=>{}}),t}subtract(e,t){if(e.weights.length!==t.weights.length)throw new Error("misaligned matrices");return this.add(this.add(this.allOnes(e.rows,e.columns),this.cloneNegative(e)),t)}multiply(e,t){if(e.columns!==t.rows)throw new Error("misaligned matrices");const n=new o(e.rows,t.columns);return this.states.push({name:"multiply",product:n,left:e,right:t,forwardFn:Ss,backpropagationFn:Ms}),n}multiplyElement(e,t){if(e.weights.length!==t.weights.length)throw new Error("misaligned matrices");const n=new o(e.rows,e.columns);return this.states.push({name:"multiplyElement",product:n,left:e,right:t,forwardFn:Fs,backpropagationFn:Ts}),n}relu(e){const t=new o(e.rows,e.columns);return this.states.push({name:"relu",product:t,left:e,forwardFn:zs,backpropagationFn:Ds}),t}input(e){return this.states.push({name:"input",product:e,forwardFn:t=>{if(!this.inputValue)return;if(this.inputValue.length!==t.weights.length)throw new Error("this.inputValue is of wrong dimensions");t.weights=e.weights=this.inputValue},backpropagationFn:()=>{}}),e}inputMatrixToRow(e){const n=this,t=new o(e.columns,1);return this.states.push({name:"inputMatrixToRow",product:t,left:e,get right(){return n.inputRow},forwardFn:Ns,backpropagationFn:Ls}),t}sigmoid(e){const t=new o(e.rows,e.columns);return this.states.push({name:"sigmoid",product:t,left:e,forwardFn:Rs,backpropagationFn:Ps}),t}tanh(e){const t=new o(e.rows,e.columns);return this.states.push({name:"tanh",product:t,left:e,forwardFn:Is,backpropagationFn:Bs}),t}observe(e){return this.states.push({name:"observe",product:new o,forwardFn:()=>{},backpropagationFn:()=>{}}),e}runIndex(e=0){this.inputRow=e;let t=this.states[0];for(let e=0,n=this.states.length;e<n;e++){if(t=this.states[e],!t.hasOwnProperty("forwardFn"))continue;t.forwardFn(t.product,t.left,t.right)}return t.product}runInput(e){this.inputValue=e;let t=this.states[0];for(let e=0,n=this.states.length;e<n;e++){if(t=this.states[e],!t.hasOwnProperty("forwardFn"))continue;t.forwardFn(t.product,t.left,t.right)}return t.product}backpropagate(){let t=this.states.length,e=this.states[0];for(;t-- >0;){if(e=this.states[t],!e.hasOwnProperty("backpropagationFn"))continue;e.backpropagationFn(e.product,e.left,e.right)}return e.product}backpropagateIndex(e=0){this.inputRow=e;let n=this.states.length,t=this.states[0];for(;n-- >0;){if(t=this.states[n],!t.hasOwnProperty("backpropagationFn"))continue;t.backpropagationFn(t.product,t.left,t.right)}return t.product}predictTarget(e,t){let s=0;const n=this.runInput(e);for(let e=0;e<n.weights.length;e++){const o=n.weights[e]-t[e];s+=Math.abs(o),n.deltas[e]=o}return s}predictTargetIndex(e,t){const n=this.runIndex(e),s=n,o=Q(n);return s.deltas=o.weights.slice(0),s.deltas[t]-=1,-Math.log2(o.weights[t])}}function _e(e){const{weights:t}=e;let n=t[0],s=0;for(let e=1;e<t.length;e++){const o=t[e];if(o<n)continue;s=e,n=o}return s}function ie(e){const s=A(0,1),o=e.weights;let n=0,t=0;for(;!0;){if(n+=o[t],n>s)return t;t++}}const k={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.01,callbackPeriod:10,timeout:1/0},I=()=>({inputSize:20,inputRange:20,hiddenLayers:[20,20],outputSize:20,decayRate:.999,smoothEps:1e-8,regc:1e-6,clipval:5,maxPredictionLength:100,dataFormatter:new p});class z{constructor(e={}){this.options={...I()},this.trainOpts={...k},this.stepCache={},this.runs=0,this.ratioClipped=0,this.model=Object.seal({isInitialized:!1,input:new o(0,0),hiddenLayers:[],output:new o(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new c(0,0,.08)}),this.initialLayerInputs=[],this.options={...this.options,...e},this.updateTrainingOptions({...k}),e.json&&this.fromJSON(e.json)}initialize(){const{dataFormatter:e}=this.options;e?.characters.length&&(this.options.inputSize=this.options.inputRange=this.options.outputSize=e.characters.length),this.model=this.mapModel()}createHiddenLayers(){const{hiddenLayers:e,inputSize:s}=this.options,t=[];t.push(this.getHiddenLayer(e[0],s));let n=e[0];for(let s=1;s<e.length;s++){const o=e[s];t.push(this.getHiddenLayer(o,n)),n=o}return t}getHiddenLayer(e,t){return{weight:new c(e,t,.08),transition:new c(e,e,.08),bias:new o(e,1)}}getEquation(e,t,n,s){if(!s.weight||!s.transition||!s.bias)throw new Error("hiddenLayer does not have expected properties");const a=e.relu.bind(e),o=e.add.bind(e),i=e.multiply.bind(e);return a(o(o(i(s.weight,t),i(s.transition,n)),s.bias))}createInputMatrix(){const{inputRange:e,inputSize:t}=this.options;if(e<1)throw new Error("this.options.inputRange not an expected number");if(t<1)throw new Error("this.options.inputSize not an expected number");return new c(e+1,t,.08)}createOutputMatrices(){const{outputSize:e,hiddenLayers:t}=this.options,n=ce(t);return{outputConnector:new c(e+1,n,.08),output:new o(e+1,1)}}bindEquation(){const{model:e}=this,{hiddenLayers:i}=this.options,t=new Se,s=[],o=e.equationConnections.length>0?ce(e.equationConnections):this.initialLayerInputs;let n=this.getEquation(t,t.inputMatrixToRow(e.input),o[0],e.hiddenLayers[0]);s.push(n);for(let a=1,r=i.length;a<r;a++){if(!o[a])throw new Error(`Cannot find equation at index ${a}`);n=this.getEquation(t,n,o[a],e.hiddenLayers[a]),s.push(n)}e.equationConnections.push(s),t.add(t.multiply(e.outputConnector,n),e.output),e.equations.push(t)}mapModel(){const e=[];this.initialLayerInputs=this.options.hiddenLayers.map(e=>new o(e,1));const n=this.createInputMatrix();e.push(n);const t=this.createHiddenLayers();if(!t.length)throw new Error("net.hiddenLayers not set");for(let n=0,o=t.length;n<o;n++){const s=t[n];for(const t in s){if(!s.hasOwnProperty(t))continue;e.push(s[t])}}const{output:s,outputConnector:i}=this.createOutputMatrices();return e.push(i),e.push(s),Object.seal({isInitialized:!0,input:n,hiddenLayers:t,output:s,equations:[],allMatrices:e,equationConnections:[],outputConnector:i})}trainInput(e){this.runs++;const{model:t}=this,n=e.length;let s=0,o;for(;t.equations.length<=e.length+1;)this.bindEquation();for(let i=-1,a=e.length;i<a;i++){const r=i+1;o=t.equations[r];const c=i===-1?0:e[i]+1,l=i===n-1?0:e[i+1]+1;s+=o.predictTargetIndex(c,l)}return Math.pow(2,s/(n-1))/100}backpropagate(e){let t=e.length;const{model:s}=this,{equations:n}=s;for(;t>0;)n[t].backpropagateIndex(e[t-1]+1),t--;n[0].backpropagateIndex(0)}adjustWeights(){const{regc:a,clipval:e,decayRate:s,smoothEps:r}=this.options,{trainOpts:c,model:l,stepCache:t}=this,{learningRate:d}=c,{allMatrices:o}=l;let n=0,i=0;for(let c=0;c<o.length;c++){const l=o[c],{weights:h,deltas:f}=l;c in t||(t[c]=u(l.rows*l.columns));const m=t[c];for(let t=0;t<h.length;t++){let o=f[t];const c=h[t];m[t]=m[t]*s+(1-s)*o*o,o>e?(o=e,n++):o<-e&&(o=-e,n++),i++,h[t]=c+-d*o/Math.sqrt(m[t]+r)-a*c}}this.ratioClipped=n/i}get isRunnable(){return!this.model||this.model.equations.length!==0||(console.error(`No equations bound, did you run train()?`),!1)}checkRunnable(){if(!this.isRunnable)throw new Error("Network not runnable")}run(e=[],t=!1,n=1){const c=this.options.maxPredictionLength+(e!==null?e.length:0)+(this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0);this.checkRunnable();const i=this.options.dataFormatter&&e.length>0?this.options.dataFormatter.formatDataIn(e):e,{model:a}=this,r=[];let s=0;for(;!0;){const u=s===0?0:s<i.length?i[s-1]+1:r[s-1];for(;a.equations.length<=s;)this.bindEquation();const h=a.equations[s],m=h.runIndex(u),e=new o(a.output.rows,a.output.columns);if(xs(e,m),n!==1&&t)for(let t=0,s=e.weights.length;t<s;t++)e.weights[t]/=n;const l=Q(e),d=t?ie(l):_e(l);if(s++,d===0)break;if(s>=c)break;r.push(d)}return this.options.dataFormatter.formatDataOut(i,r.slice(i.length).map(e=>e-1))}verifyIsInitialized(){this.model.isInitialized||this.initialize()}updateTrainingOptions(e){var t;this.trainOpts={...k,...e},this.validateTrainingOptions(this.trainOpts),this.setLogMethod((t=e.log)!==null&&t!==void 0?t:this.trainOpts.log)}validateTrainingOptions(e){const t={iterations:()=>{const t=e.iterations;return typeof t=="number"&&t>0},errorThresh:()=>{const t=e.errorThresh;return typeof t=="number"&&t>0&&t<1},log:()=>{const t=e.log;return typeof t=="function"||typeof t=="boolean"},logPeriod:()=>{const t=e.logPeriod;return typeof t=="number"&&t>0},learningRate:()=>{const t=e.learningRate;return typeof t=="number"&&t>0&&t<1},callback:()=>{const t=e.callback;return typeof t=="function"||t===void 0},callbackPeriod:()=>{const t=e.callbackPeriod;return typeof t=="number"&&t>0},timeout:()=>{const t=e.timeout;return typeof t=="number"&&t>0}};for(const n in t){const s=e;if(!t[n]())throw new Error(`[${n}, ${s[n]}] is out of normal training range, your network will probably not train.`)}}setLogMethod(e){typeof e=="function"?this.trainOpts.log=e:e?this.trainOpts.log=console.log:this.trainOpts.log=!1}prepTraining(e,t){var n;this.updateTrainingOptions(t);const s=this.options.dataFormatter.format(e),o=Date.now()+((n=this.trainOpts.timeout)!==null&&n!==void 0?n:0),i={error:1,iterations:0};return this.verifyIsInitialized(),{preparedData:s,status:i,endTime:o}}train(e,t={}){var i;this.trainOpts=t={...k,...t};const{iterations:c,errorThresh:l,logPeriod:d,callback:a,callbackPeriod:u}=this.trainOpts,r=t.log===!0?console.log:t.log;let s=1/0,n,o;if((i=this.options)===null||i===void 0?void 0:i.dataFormatter)o=this.options.dataFormatter.format(e);else if(Array.isArray(e)&&Array.isArray(e[0])&&typeof e[0][0]=="number")o=e;else throw new Error("training not in expected format of number[][]");this.verifyIsInitialized();for(n=0;n<c&&s>l;n++){let t=0;for(let e=0;e<o.length;e++){const n=this.trainPattern(o[e],!0);t+=n}if(s=t/e.length,isNaN(s))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");r&&n%d===0&&r(`iterations: ${n}, training error: ${s}`),a&&n%u===0&&a({error:s,iterations:n})}return{error:s,iterations:n}}addFormat(){}formatData(e){const t=[];for(let n=0;n<e.length;n++)t.push(this.options.dataFormatter.formatDataIn(e[n]));return t}toJSON(){this.model.isInitialized||this.initialize();const{model:e,options:t}=this;return{type:this.constructor.name,options:{...t,dataFormatter:t.dataFormatter.toJSON()},trainOpts:{...this.trainOpts,timeout:this.trainOpts.timeout===1/0?"Infinity":this.trainOpts.timeout},input:e.input.toJSON(),hiddenLayers:e.hiddenLayers.map(e=>{const t={};for(const n in e){if(!e.hasOwnProperty(n))continue;t[n]=e[n].toJSON()}return t}),outputConnector:this.model.outputConnector.toJSON(),output:this.model.output.toJSON()}}fromJSON(e){const{options:n}=e,t=[],s=o.fromJSON(e.input);t.push(s);const i=[];e.hiddenLayers.forEach(e=>{const n={};for(const s in e)n[s]=o.fromJSON(e[s]),t.push(n[s]);i.push(n)});const a=o.fromJSON(e.outputConnector);t.push(a);const r=o.fromJSON(e.output);return t.push(r),n.dataFormatter?this.options={...I(),...n,dataFormatter:p.fromJSON(n.dataFormatter)}:this.options={...I(),...n,dataFormatter:new p},this.model=Object.seal({isInitialized:!0,input:s,hiddenLayers:i,output:r,allMatrices:t,outputConnector:a,equations:[],equationConnections:[]}),this.initialLayerInputs=this.options.hiddenLayers.map(e=>new o(e,1)),this.bindEquation(),this}toFunction(e){const{model:t}=this,{equations:a}=this.model,p=a[1],{states:n}=p,f=JSON.stringify(this.toJSON());function m(e){const s=t.equationConnections[0],{states:n}=a[0];for(let t=0,s=n.length;t<s;t++)if(n[t].product===e)return t;return s.indexOf(e)}function d(e,t){for(let s=0,i=n.length;s<i;s++){const o=n[s];if(s===t){const t=m(e);return t>-1&&(e===o.left||e===o.right)?`typeof prevStates[${t}] === 'object' ? prevStates[${t}].product : new Matrix(${e.rows}, ${e.columns})`:`new Matrix(${e.rows}, ${e.columns})`}if(e===o.product)return`states[${s}].product`;if(e===o.right)return`states[${s}].right`;if(e===o.left)return`states[${s}].left`}return""}function o(e,n){if(!e||!e.rows||!e.columns)return"null";if(e===t.input)return`json.input`;if(e===t.outputConnector)return`json.outputConnector`;if(e===t.output)return`json.output`;for(let n=0,o=t.hiddenLayers.length;n<o;n++){const s=t.hiddenLayers[n];for(const t in s){if(!s.hasOwnProperty(t))continue;if(s[t]!==e)continue;return`json.hiddenLayers[${n}].${t}`}}return d(e,n)}function i(e){const t=e.toString().split("{");t.shift();const s=t.join("{"),n=s.split("}");return n.pop(),n.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function h(e){return`src/recurrent/matrix/${e.replace(/[A-Z]/g,function(e){return`-${e.toLowerCase()}`})}.js`}const s=[],l={},c=[];for(let t=0,r=n.length;t<r;t++){const e=n[t];s.push(`states[${t}] = {
      name: '${e.forwardFn.name}',
      left: ${e.left?o(e.left,t):"undefined"},
      right: ${e.right?o(e.right,t):"undefined"},
      product: ${o(e.product,t)}
    }`);const a=e.forwardFn.name;l[a]||(l[a]=!0,c.push(`        case '${a}': //compiled from ${h(a)}
          ${i(e.forwardFn.toString())}
          break;`))}const r=`
  if (typeof rawInput === 'undefined') rawInput = [];
  if (typeof isSampleI === 'undefined') isSampleI = false;
  if (typeof temperature === 'undefined') temperature = 1;
  var json = ${f};
  ${this.options.dataFormatter?`${this.options.dataFormatter.toFunctionString()};
  Object.assign(dataFormatter, json.options.dataFormatter);`:""}
  ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataIn=="function"?`const formatDataIn = function (input, output) { ${i(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`:""}
  ${this.options.dataFormatter!==null&&typeof this.options.dataFormatter.formatDataOut=="function"?`const formatDataOut = function formatDataOut(input, output) { ${i(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`:""}
  var maxPredictionLength =
    ${this.options.maxPredictionLength} +
    rawInput.length +
    ${this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0};
  var input = ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataIn=="function"?"formatDataIn(rawInput)":"rawInput"};
  var _i = 0;
  var output = [];
  var states = [];
  var prevStates;
  while (true) {
    var previousIndex = (_i === 0
        ? 0
        : _i < input.length
          ? input[_i - 1] + 1
          : output[_i - 1])
          ;
    var rowPluckIndex = previousIndex;
    prevStates = states;
    states = [];
    ${s.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${s.length}; stateIndex < stateMax; stateIndex++) {
      var state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;
      switch (state.name) {
${c.join(`
`)}
      }
    }

    var logProbabilities = state.product;
    if (temperature !== 1 && isSampleI) {
      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {
        logProbabilities.weights[q] /= temperature;
      }
    }

    var probs = softmax(logProbabilities);
    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);

    _i++;
    if (nextIndex === 0) {
      break;
    }
    if (_i >= maxPredictionLength) {
      break;
    }

    output.push(nextIndex);
  }
  ${this.options.dataFormatter&&typeof this.options.dataFormatter.formatDataOut=="function"?"return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))":"return output.slice(input.length).map(function(value) { return value - 1; })"};
  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = zeros(rows * columns);
  }
  ${u.toString()}
  ${Q.toString().replace("_1.Matrix","Matrix")}
  ${A.toString()}
  ${ie.toString()}
  ${_e.toString()}`;return new Function("rawInput","isSampleI","temperature",e?e(r):r)}trainPattern(e,t){const n=this.trainInput(e);return this.backpropagate(e),this.adjustWeights(),t?n:0}}function ce(e){return e[e.length-1]}class Ht extends z{getHiddenLayer(e,t){return mt(e,t)}getEquation(e,t,n,s){return at(e,t,n,s)}}function mt(e,t){return{updateGateInputMatrix:new c(e,t,.08),updateGateHiddenMatrix:new c(e,e,.08),updateGateBias:new o(e,1),resetGateInputMatrix:new c(e,t,.08),resetGateHiddenMatrix:new c(e,e,.08),resetGateBias:new o(e,1),cellWriteInputMatrix:new c(e,t,.08),cellWriteHiddenMatrix:new c(e,e,.08),cellWriteBias:new o(e,1)}}function at(e,t,n,s){if(!s.updateGateInputMatrix||!s.updateGateHiddenMatrix||!s.updateGateBias||!s.resetGateInputMatrix||!s.resetGateHiddenMatrix||!s.resetGateBias||!s.cellWriteInputMatrix||!s.cellWriteHiddenMatrix||!s.cellWriteBias)throw new Error("hiddenLayer does not have expected properties");const c=e.sigmoid.bind(e),o=e.add.bind(e),i=e.multiply.bind(e),r=e.multiplyElement.bind(e),l=e.tanh.bind(e),d=e.allOnes.bind(e),u=e.cloneNegative.bind(e),a=c(o(o(i(s.updateGateInputMatrix,t),i(s.updateGateHiddenMatrix,n)),s.updateGateBias)),h=c(o(o(i(s.resetGateInputMatrix,t),i(s.resetGateHiddenMatrix,n)),s.resetGateBias)),m=l(o(o(i(s.cellWriteInputMatrix,t),i(s.cellWriteHiddenMatrix,r(h,n))),s.cellWriteBias));return o(r(o(d(a.rows,a.columns),u(a)),m),r(n,a))}class Te{constructor(e,t){this.prop=t,this.length=0,this.table={};for(let n=0;n<e.length;n++){const o=e[n],s=o[t];for(let e=0;e<s.length;e++){const t=s[e];for(const e in t){if(!t.hasOwnProperty(e))continue;if(this.table.hasOwnProperty(e))continue;this.table[e]=this.length++}}}}}const Ce=()=>({...I(),inputSize:1,hiddenLayers:[20],outputSize:1,inputRange:0});class X extends z{constructor(e={}){super(),this.inputLookupLength=0,this.inputLookup=null,this.outputLookup=null,this.outputLookupLength=0,this.model=Object.seal({isInitialized:!1,hiddenLayers:[],output:new o(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new c(0,0,.08)}),this.options=Ce(),this.options={...this.options,...e},this.updateTrainingOptions({...to,...e}),e.json&&this.fromJSON(e.json)}createInputMatrix(){throw new Error("Input Matrices do not exist on RNNTimeStep")}createOutputMatrices(){const{outputSize:e}=this.options,t=ce(this.options.hiddenLayers),n=new c(e,t,.08),s=new c(e,1,.08);return{output:s,outputConnector:n}}bindEquation(){const{model:e,options:r}=this,{hiddenLayers:c,inputSize:l}=r,i=e.hiddenLayers,t=new Se,s=[],a=e.equationConnections.length>0?e.equationConnections[e.equationConnections.length-1]:this.initialLayerInputs;let n=this.getEquation(t,t.input(new o(l,1)),a[0],i[0]);s.push(n);for(let e=1,o=c.length;e<o;e++)n=this.getEquation(t,n,a[e],i[e]),s.push(n);e.equationConnections.push(s),t.add(t.multiply(e.outputConnector,n),e.output),e.equations.push(t)}initialize(){this.model=this.mapModel()}mapModel(){const e=[];this.initialLayerInputs=this.options.hiddenLayers.map(e=>new o(e,1));const t=this.createHiddenLayers();for(let n=0,o=t.length;n<o;n++){const s=t[n];for(const t in s){if(!s.hasOwnProperty(t))continue;e.push(s[t])}}const{outputConnector:n,output:s}=this.createOutputMatrices();return e.push(n),e.push(s),Object.seal({isInitialized:!0,hiddenLayers:t,output:s,equations:[],allMatrices:e,equationConnections:[],outputConnector:n})}backpropagate(){for(let e=this.model.equations.length-1;e>-1;e--)this.model.equations[e].backpropagate()}run(e){const t=i.dataShape(e).join(",");switch(t){case"array,number":return this.runArray(e);case"array,array,number":return this.runArrayOfArray(e);case"object,number":return this.runObject(e);case"array,object,number":return this.runArrayOfObject(e);default:throw new Error(`Unrecognized data shape ${t}`)}}forecast(e,t=1){const n=i.dataShape(e).join(",");switch(n){case"array,number":return this.forecastArray(e,t);case"array,array,number":return this.forecastArrayOfArray(e,t);case"object,number":return this.runObject(e);case"array,object,number":return this.forecastArrayOfObject(e,t);default:throw new Error(`Unrecognized data shape ${n}`)}}forecastArray(e,t=1){this.checkRunnable();const{model:a}=this,{equations:s}=a,r=e.length+t;for(;s.length<=r;)this.bindEquation();let n,o=0;if(this.options.inputSize===1)for(let t=0;t<e.length;t++)n=s[o++].runInput(Float32Array.from([e[t]]));else for(let t=0;t<e.length;t++)n=s[o++].runInput(Float32Array.from([]));if(!n)throw new Error("lastOutput not set");const i=[n.weights[0]];for(let e=0,a=t-1;e<a;e++)n=s[o++].runInput(n.weights),i.push(n.weights[0]);return this.end(),Float32Array.from(i)}forecastArrayOfArray(e,t=1){this.checkRunnable();const{model:a}=this,{equations:s}=a,r=e.length+t;for(;s.length<=r;)this.bindEquation();let n,o=0;for(let t=0;t<e.length;t++)n=s[o++].runInput(e[t]);if(!n)throw new Error("lastOutput not set");const i=[Float32Array.from(n.weights)];for(let e=0,a=t-1;e<a;e++)n=s[o++].runInput(n.weights),i.push(Float32Array.from(n.weights.slice(0)));return this.end(),i}forecastArrayOfObject(e,t=1){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");const n=e.map(e=>i.toArray(this.inputLookup,e,this.inputLookupLength));return this.forecastArrayOfArray(n,t).map(e=>i.toObject(this.outputLookup,e))}train(e,t={}){this.trainOpts=t={...k,...t},this.options.inputSize===1&&this.options.outputSize===1&&this.setSize(e),this.verifySize();const o=this.formatData(e);let s=1/0,n;this.verifyIsInitialized();const{iterations:r,errorThresh:c,logPeriod:l,callback:i,callbackPeriod:d}=this.trainOpts,a=t.log===!0?console.log:t.log;for(n=0;n<r&&s>c;n++){let e=0;for(let t=0;t<o.length;t++){const n=this.trainPattern(o[t],!0);e+=n}if(s=e/o.length,isNaN(s))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");a&&n%l===0&&a(`iterations: ${n}, training error: ${s}`),i&&n%d===0&&i({error:s,iterations:n})}return{error:s,iterations:n}}trainArrayOfArray(e){if(e.length<2)throw new Error("input must be an array of 2 or more");const{equations:t}=this.model;for(;t.length<e.length;)this.bindEquation();let n=0;for(let s=0,o=e.length-1;s<o;s++)n+=t[s].predictTarget(e[s],e[s+1]);return this.end(),n/e.length}trainPattern(e,t){const n=this.trainArrayOfArray(e);return this.backpropagate(),this.adjustWeights(),t?n:0}setSize(e){let t=0;const n=i.dataShape(e).join(",");switch(n){case"array,array,number":case"array,object,number":case"array,datum,array,number":case"array,datum,object,number":t=1;break;case"array,array,array,number":t=e[0][0].length;break;case"array,array,object,number":t=Object.keys(i.toTable2D(e)).length;break;case"array,datum,array,array,number":t=e[0].input[0].length;break;case"array,datum,array,object,number":t=Object.keys(i.toInputTable2D(e)).length;break;default:throw new Error("unknown data shape or configuration")}this.options=Object.seal({...this.options,inputSize:t,outputSize:t})}verifySize(){if((this.options.inputSize||this.options.outputSize)&&this.options.inputSize!==this.options.outputSize)throw new Error("manually set inputSize and outputSize mismatch")}runArray(e){this.checkRunnable();const{equations:t}=this.model;for(;t.length<=e.length;)this.bindEquation();let n;for(let s=0;s<e.length;s++)n=t[s].runInput(new Float32Array([e[s]]));return this.end(),n.weights[0]}runArrayOfArray(e){this.checkRunnable();const{model:s}=this,{equations:n}=s;for(;n.length<=e.length;)this.bindEquation();let t;for(let s=0;s<e.length;s++){const o=n[s].runInput(e[s]);t=o.weights}return this.end(),t??Float32Array.from([])}runObject(e){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set");if(this.inputLookup===this.outputLookup){const t=i.toArrayShort(this.inputLookup,e);return i.toObjectPartial(this.outputLookup,this.forecastArray(t,this.outputLookupLength-t.length),t.length)}return i.toObject(this.outputLookup,this.forecastArray(i.toArray(this.inputLookup,e,this.inputLookupLength),this.outputLookupLength))}runArrayOfObject(e){if(this.inputLookup===null)throw new Error("this.inputLookup not set");if(this.outputLookup===null)throw new Error("this.outputLookup not set");const t=e.map(e=>i.toArray(this.inputLookup,e,this.inputLookupLength));return this.forecastArrayOfArray(t,1).map(e=>i.toObject(this.outputLookup,e))[0]}runArrayOfObjectOfArray(e){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");return i.toObject(this.outputLookup,this.runArrayOfArray(i.toArrays(this.inputLookup,e,this.inputLookupLength)))}end(){this.model.equations[this.model.equations.length-1].runInput(new Float32Array(this.options.outputSize))}requireInputOutputOfOne(){if(this.options.inputSize!==1)throw new Error("inputSize must be 1 for this data size");if(this.options.outputSize!==1)throw new Error("outputSize must be 1 for this data size")}formatArray(e){const t=[];this.requireInputOutputOfOne();for(let n=0;n<e.length;n++)t.push(Float32Array.from([e[n]]));return[t]}formatArrayOfArray(e){const t=[],{inputSize:n,outputSize:s}=this.options;if(n===1&&s===1){for(let n=0;n<e.length;n++)t.push($n(e[n]));return t}if(n!==e[0].length)throw new Error("inputSize must match data input size");if(s!==e[0].length)throw new Error("outputSize must match data output size");for(let n=0;n<e.length;n++)t.push(Float32Array.from(e[n]));return[t]}formatArrayOfObject(e){if(this.requireInputOutputOfOne(),!this.inputLookup){const t=new v(e);this.inputLookup=this.outputLookup=t.table,this.inputLookupLength=this.outputLookupLength=t.length}const t=[];for(let n=0;n<e.length;n++)t.push(qn(e[n]));return t}formatArrayOfObjectMulti(e){if(!this.inputLookup){const t=new v(e);this.inputLookup=this.outputLookup=t.table,this.inputLookupLength=this.outputLookupLength=t.length}const t=[];for(let n=0;n<e.length;n++)t.push([ot(e[n],this.inputLookup,this.inputLookupLength)]);return t}formatArrayOfDatumOfArray(e){const t=[];this.requireInputOutputOfOne();for(let n=0;n<e.length;n++){const s=e[n];t.push(Wn(s.input,s.output))}return t}formatArrayOfDatumOfObject(e){if(this.requireInputOutputOfOne(),!this.inputLookup){const t=new v(e,"input");this.inputLookup=t.table,this.inputLookupLength=t.length}if(!this.outputLookup){const t=new v(e,"output");this.outputLookup=t.table,this.outputLookupLength=t.length}const t=[];for(let n=0;n<e.length;n++){const s=e[n];t.push(Yn(s.input,s.output))}return t}formatArrayOfArrayOfArray(e){const t=[];for(let n=0;n<e.length;n++)t.push(Bn(e[n]));return t}formatArrayOfArrayOfObject(e){if(!this.inputLookup){const t=new v(e);this.inputLookup=this.outputLookup=t.table,this.inputLookupLength=this.outputLookupLength=t.length}const t=[];for(let n=0;n<e.length;n++){const s=[];for(let t=0;t<e[n].length;t++)s.push(ot(e[n][t],this.inputLookup,this.inputLookupLength));t.push(s)}return t}formatArrayOfDatumOfArrayOfArray(e){const t=[],{inputSize:n,outputSize:s}=this.options;if(n!==e[0].input[0].length)throw new Error("inputSize must match data input size");if(s!==e[0].output[0].length)throw new Error("outputSize must match data output size");for(let n=0;n<e.length;n++){const s=e[n];t.push(Vn(s.input,s.output))}return t}formatArrayOfDatumOfArrayOfObject(e){if(!this.inputLookup){const t=new Te(e,"input");this.inputLookup=t.table,this.inputLookupLength=t.length}if(!this.outputLookup){const t=new Te(e,"output");this.outputLookup=t.table,this.outputLookupLength=t.length}if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set to usable number");const t=[];for(let n=0;n<e.length;n++){const s=e[n];t.push(Kn(s.input,s.output,this.inputLookup,this.outputLookup,this.inputLookupLength,this.outputLookupLength))}return t}formatData(e){const t=i.dataShape(e).join(",");switch(t){case"array,number":return this.formatArray(e);case"array,array,number":return this.formatArrayOfArray(e);case"array,object,number":return this.options.inputSize===1?this.formatArrayOfObject(e):this.formatArrayOfObjectMulti(e);case"array,datum,array,number":return this.formatArrayOfDatumOfArray(e);case"array,datum,object,number":return this.formatArrayOfDatumOfObject(e);case"array,array,array,number":return this.formatArrayOfArrayOfArray(e);case"array,array,object,number":return this.formatArrayOfArrayOfObject(e);case"array,datum,array,array,number":return this.formatArrayOfDatumOfArrayOfArray(e);case"array,datum,array,object,number":return this.formatArrayOfDatumOfArrayOfObject(e);default:throw new Error("unknown data shape or configuration")}}test(e){const n=[];let s=0;const t=this.formatData(e);for(let o=0;o<t.length;o++){const i=t[o],a=this.run(i.splice(0,i.length-1)),l=i[i.length-1];let r=0,c=0;for(let e=0;e<a.length;e++){c++;const t=l[e]-a[e];r+=t*t}s+=r/c;const d=Math.abs(r);if(d>this.trainOpts.errorThresh){const t=e[o];n.push({value:t,actual:a})}}return{error:s/t.length,misclasses:n,total:t.length}}addFormat(e){var t,n,s,o,a,r;const c=i.dataShape(e).join(",");switch(c){case"array,array,number":case"datum,array,array,number":case"array,number":case"datum,array,number":return;case"datum,object,number":{this.inputLookup=i.addKeys(e.input,(t=this.inputLookup)!==null&&t!==void 0?t:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length),this.outputLookup=i.addKeys(e.output,(n=this.outputLookup)!==null&&n!==void 0?n:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break}case"object,number":{this.inputLookup=this.outputLookup=i.addKeys(e,(s=this.inputLookup)!==null&&s!==void 0?s:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break}case"array,object,number":{const t=e;for(let e=0;e<t.length;e++)this.inputLookup=this.outputLookup=i.addKeys(t[e],(o=this.inputLookup)!==null&&o!==void 0?o:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break}case"datum,array,object,number":{const t=e,n=t.input;for(let e=0;e<n.length;e++)this.inputLookup=i.addKeys(n[e],(a=this.inputLookup)!==null&&a!==void 0?a:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length);const s=t.output;for(let e=0;e<s.length;e++)this.outputLookup=i.addKeys(s[e],(r=this.outputLookup)!==null&&r!==void 0?r:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break}default:throw new Error("unknown data shape or configuration")}}toJSON(){this.model||this.initialize();const{model:e}=this,t={...this.options,...I};return{type:this.constructor.name,options:t,hiddenLayers:e.hiddenLayers.map(e=>{const t={};for(const n in e){if(!e.hasOwnProperty(n))continue;t[n]=e[n].toJSON()}return t}),outputConnector:e.outputConnector.toJSON(),output:e.output.toJSON(),inputLookup:this.inputLookup,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup,outputLookupLength:this.outputLookupLength}}fromJSON(e){const{options:n}=e,t=[],s=[];e.hiddenLayers.forEach(e=>{const n={};for(const s in e)n[s]=o.fromJSON(e[s]),t.push(n[s]);s.push(n)});const i=o.fromJSON(e.outputConnector);t.push(i);const a=o.fromJSON(e.output);return t.push(a),this.options={...Ce(),...n},this.inputLookup=e.inputLookup,this.inputLookupLength=e.inputLookupLength,this.outputLookup=e.outputLookup,this.outputLookupLength=e.outputLookupLength,this.model=Object.seal({isInitialized:!0,hiddenLayers:s,output:a,allMatrices:t,outputConnector:i,equations:[],equationConnections:[]}),this.initialLayerInputs=n.hiddenLayers.map(e=>new o(e,1)),this.bindEquation(),this}toFunction(e){const{model:o,inputLookup:t,inputLookupLength:l,outputLookup:n,outputLookupLength:w}=this,{inputSize:s}=this.options,{equations:u}=o,y=u[1],{states:a}=y,j=JSON.stringify(this.toJSON());function m(e){const n=o.equationConnections[0],{states:t}=u[0];for(let n=0,s=t.length;n<s;n++)if(t[n].product===e)return n;return n.indexOf(e)}function b(e,t){for(let n=0,o=a.length;n<o;n++){const s=a[n];if(n===t){const t=m(e);switch(e){case s.left:if(t>-1)return`typeof prevStates[${t}] === 'object' ? prevStates[${t}].product : new Matrix(${e.rows}, ${e.columns})`;case s.right:if(t>-1)return`typeof prevStates[${t}] === 'object' ? prevStates[${t}].product : new Matrix(${e.rows}, ${e.columns})`;case s.product:return`new Matrix(${e.rows}, ${e.columns})`;default:throw Error("unknown state")}}if(e===s.product)return`states[${n}].product`;if(e===s.right)return`states[${n}].right`;if(e===s.left)return`states[${n}].left`}return""}function r(e,t){if(!e||!e.rows||!e.columns)return"null";if(e===o.outputConnector)return`json.outputConnector`;if(e===o.output)return`json.output`;for(let t=0,s=o.hiddenLayers.length;t<s;t++){const n=o.hiddenLayers[t];for(const s in n){if(!n.hasOwnProperty(s))continue;if(n[s]!==e)continue;return`json.hiddenLayers[${t}].${s}`}}return b(e,t)}function f(){return t?s===1?t===n?`function lookupInput(input) {
            var table = ${JSON.stringify(t)};
            var result = [];
            for (var p in table) {
              if (!input.hasOwnProperty(p)) break;
              result.push(Float32Array.from([input[p]]));
            }
            return result;
          }`:`function lookupInput(input) {
          var table = ${JSON.stringify(t)};
          var result = [];
          for (var p in table) {
            result.push(Float32Array.from([input[p]]));
          }
          return result;
        }`:`function lookupInput(rawInputs) {
        var table = ${JSON.stringify(t)};
        var result = [];
        for (var i = 0; i < rawInputs.length; i++) {
          var rawInput = rawInputs[i];
          var input = new Float32Array(${l});
          for (var p in table) {
            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;
          }
          result.push(input);
        }
        return result;
      }`:""}function p(){return n?s===1?t===n?`function lookupOutputPartial(output, input) {
            var table = ${JSON.stringify(n)};
            var offset = input.length;
            var result = {};
            var i = 0;
            for (var p in table) {
              if (i++ < offset) continue;
              result[p] = output[table[p] - offset][0];
            }
            return result;
          }`:`function lookupOutput(output) {
          var table = ${JSON.stringify(n)};
          var result = {};
          for (var p in table) {
            result[p] = output[table[p]][0];
          }
          return result;
        }`:`function lookupOutput(output) {
        var table = ${JSON.stringify(n)};
        var result = {};
        for (var p in table) {
          result[p] = output[table[p]];
        }
        return result;
      }`:""}function g(e){const t=e.toString().split("{");t.shift();const s=t.join("{"),n=s.split("}");return n.pop(),n.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function v(e){return`src/recurrent/matrix/${e.replace(/[A-Z]/g,function(e){return`-${e.toLowerCase()}`})}.js`}const c=[],h={},i=[];for(let n=0,l=a.length;n<l;n++){const e=a[n];c.push(`states[${n}] = {
      name: '${e.forwardFn.name}',
      left: ${e.left?r(e.left,n):"undefined"},
      right: ${e.right?r(e.right,n):"undefined"},
      product: ${r(e.product,n)}
    }`);const o=e.forwardFn.name;h[o]||(h[o]=!0,e.name==="input"?(i.push(`case '${o}':`),i.push(t&&s===1?"product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;":s===1?"product.weights = [input[_i]];":"product.weights = input[_i];"),i.push("break;")):i.push(`        case '${o}':${o!=="forwardFn"?` //compiled from ${v(o)}`:""}
          ${g(e.forwardFn.toString())}
          break;`))}const _=s===1&&this.outputLookup,d=`
  var input = ${this.inputLookup?"lookupInput(rawInput)":"rawInput"};
  var json = ${j};
  var output = [];
  var states = [];
  var prevStates;
  var state;
  var max = ${_?t===n?l:`input.length + ${w-1}`:"input.length"};
  for (var _i = 0; _i < max; _i++) {
    prevStates = states;
    states = [];
    ${c.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${c.length}; stateIndex < stateMax; stateIndex++) {
      state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;

      switch (state.name) {
${i.join(`
`)}
      }
    }
    ${s===1&&t?"if (_i >= input.length - 1) { output.push(state.product.weights); }":"output = state.product.weights;"}
  }
  ${n?n===t?"return lookupOutputPartial(output, input)":"return lookupOutput(output)":s===1?"return output[0]":"return output"};
  ${f()}
  ${p()}

  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = new Float32Array(rows * columns);
  }
  ${Q.toString().replace("_2.default","Matrix")}
  ${A.toString()}
  ${ie.toString()}
  ${_e.toString()}`;return new Function("rawInput",e?e(d):d)}}const to={...k};class ke extends X{getHiddenLayer(e,t){return mt(e,t)}getEquation(e,t,n,s){return at(e,t,n,s)}}class Me extends z{getHiddenLayer(e,t){return Le(e,t)}getEquation(e,t,n,s){return Pe(e,t,n,s)}}function Le(e,t){return{inputMatrix:new c(e,t,.08),inputHidden:new c(e,e,.08),inputBias:new o(e,1),forgetMatrix:new c(e,t,.08),forgetHidden:new c(e,e,.08),forgetBias:new o(e,1),outputMatrix:new c(e,t,.08),outputHidden:new c(e,e,.08),outputBias:new o(e,1),cellActivationMatrix:new c(e,t,.08),cellActivationHidden:new c(e,e,.08),cellActivationBias:new o(e,1)}}function Pe(e,t,n,s){if(!s.inputMatrix||!s.inputHidden||!s.inputBias||!s.forgetMatrix||!s.forgetHidden||!s.forgetBias||!s.outputMatrix||!s.outputHidden||!s.outputBias||!s.cellActivationMatrix||!s.cellActivationHidden||!s.cellActivationBias)throw new Error("hiddenLayer does not have expected properties");const a=e.sigmoid.bind(e),o=e.add.bind(e),i=e.multiply.bind(e),r=e.multiplyElement.bind(e),c=e.tanh.bind(e),l=a(o(o(i(s.inputMatrix,t),i(s.inputHidden,n)),s.inputBias)),d=a(o(o(i(s.forgetMatrix,t),i(s.forgetHidden,n)),s.forgetBias)),u=a(o(o(i(s.outputMatrix,t),i(s.outputHidden,n)),s.outputBias)),h=c(o(o(i(s.cellActivationMatrix,t),i(s.cellActivationHidden,n)),s.cellActivationBias)),m=r(d,n),f=r(l,h),p=o(m,f);return r(u,c(p))}class nt extends X{getHiddenLayer(e,t){return Le(e,t)}getEquation(e,t,n,s){return Pe(e,t,n,s)}}function ro(e,t){const n=[];for(;e<t;e++)n.push(e);return n}function co(e){return Array.isArray(e)?Float32Array.from(e):Float32Array.from(Object.values(e))}function lo({pixelX:e,pixelY:t,radius:n,inputs:s,row:o,line:i,fontSize:a,fontClassName:r}){let c=`<rect
              x="${e/2-n}"
              y="${t/2+o*t-n}"
              width="${2*n}"
              height="${2*n}"
              stroke="black"
              stroke-width="1"
              fill="${s.color}"
              class="${s.className}" />
            <line
              x1="${e/4}"
              y1="${t/2+o*t}"
              x2="${e/2-n}"
              y2="${t/2+o*t}"
              style="stroke:${i.color};stroke-width:${i.width}"
              class="${i.className}" />`;return s.labels&&(c+=`<text
              x="${e/8}"
              y="${t/2+o*t-5}"
              fill="black"
              font-size="${a}"
              class="${r}">${s.labels[o]}</text>`),c}function uo({pixelX:e,pixelY:t,row:n,column:s,radius:o,hidden:i}){return`<circle
            cx="${e/2+s*e}"
            cy="${t/2+n*t}"
            r="${o}"
            stroke="black"
            stroke-width="1"
            fill="${i.color}"
            class="${i.className}" />`}function ho({pixelX:e,pixelY:t,row:n,column:s,line:o,outputs:i,radius:a}){return`<circle
            cx="${e/2+s*e}"
            cy="${t/2+n*t}"
            r="${a}"
            stroke="black"
            stroke-width="1"
            fill="${i.color}"
            class="${i.className}" />
          <line
            x1="${e/2+s*e+a}"
            y1="${t/2+n*t}"
            x2="${e/2+s*e+e/4}"
            y2="${t/2+n*t}"
            style="stroke:${o.color};stroke-width:${o.width}"
            class="${o.className}" />`}function mo({pixelX:e,pixelY:t,row:n,column:s,radius:o,lineY:i,line:a,previousConnectionIndex:r}){return`<line
            x1="${e/2+(s-1)*e+o}"
            y1="${i/2+r*i}"
            x2="${e/2+s*e-o}"
            y2="${t/2+n*t}"
            style="stroke:${a.color};stroke-width:${a.width}"
            class="${a.className}" />`}function fe(e){const{sizes:t,height:o,width:i}=e;let n="";const s=i/t.length;for(let i=0;i<t.length;i++){const r=t[i],a=o/r;for(let c=0;c<r;c++)if(i===0)n+=lo({pixelX:s,pixelY:a,row:c,column:i,...e});else{i===t.length-1?n+=ho({pixelX:s,pixelY:a,row:c,column:i,...e}):n+=uo({pixelX:s,pixelY:a,row:c,column:i,...e});const r=t[i-1],l=o/r;for(let t=0;t<r;t++)n+=mo({pixelX:s,pixelY:a,row:c,column:i,lineY:l,previousConnectionIndex:t,...e})}}return n}function po({pixelX:e,pixelY:t,row:n,column:s,radius:o,recurrentLine:i}){const a=e/2+s*e+o+1,r=t/2+n*t,c=a-o*2-2,l=r,d=c+100,u=l+50,h=a-100,m=r+50;return`<path
              d="M ${a} ${r} C ${d} ${u}, ${h} ${m}, ${c} ${l}"
              stroke="${i.color}"
              stroke-width="${i.width}"
              fill="transparent"
              stroke-linecap="round"
              marker-end="url(#arrow)"
              class="${i.className}" />`}function lt(e){const{width:o,height:i,recurrentLine:s,sizes:t,radius:a}=e,r=o/t.length;let n=`<defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="${s.color}" />
              </marker>
            </defs>`;n+=fe(e);for(let e=1;e<t.length;e++){const o=t[e],c=i/o;for(let t=0;t<o;t++)n+=po({pixelX:r,pixelY:c,row:t,column:e,radius:a,recurrentLine:s})}return n}function vo(e){const{options:t}=e;if(!t)throw new Error("options not defined");if(!t.inputLayer)throw new Error("options.inputLater not defined");if(!t.hiddenLayers)throw new Error("options.hiddenLayers not defined");if(t.hiddenLayers.length<1)throw new Error("options.hiddenLayers is empty");if(!t.outputLayer)throw new Error("options.outputLayer not defined");const s=t.inputLayer(),n=[];n.push(t.hiddenLayers[0](s,0));for(let e=1;e<t.hiddenLayers.length;e++)n.push(t.hiddenLayers[e](n[e-1],e));const o=t.outputLayer(n[n.length-1],n.length);return{inputSize:s.height,hiddenLayers:n.map(e=>e.height),outputSize:o.height}}function bo(e){const n=[],{options:t}=e;if(!t.inputLayer)throw new Error("inputLayer not defined");if(!t.outputLayer)throw new Error("outputLayer not defined");const s=t.inputLayer();n.push(t.hiddenLayers[0](s,zt(),0));for(let e=1;e<t.hiddenLayers.length;e++)n.push(t.hiddenLayers[e](n[e-1],zt(),e));const o=t.outputLayer(n[n.length-1],-1);return{inputSize:s.height,hiddenLayers:n.map(e=>e.height),outputSize:o.height}}function Y(e,t,n){return`<svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="1.1"
            width="${t}"
            height="${n}">${e}</svg>`}function yo(e){return e.sizes}function _o(e){const{options:i,sizes:o}=e,{inputSize:n,outputSize:s,hiddenLayers:t}=i;if(!o){if(typeof n=="number"&&n<1)throw new Error("inputSize not set");if(typeof s=="number"&&s<1)throw new Error("outputSize not set");if(t?.some(e=>e<1))throw new Error("hiddenLayers not set")}return typeof n=="number"&&Array.isArray(t)&&typeof s=="number"?[n].concat(t).concat([s]):o}function dt(e){const{options:t}=e,{inputSize:n,outputSize:s,hiddenLayers:o}=t;return[n].concat(o).concat([s])}function Oo(){return{line:{width:.5,color:"black",className:"connection"},recurrentLine:{width:1,color:"red",className:"recurrence"},inputs:{color:"rgba(0, 128, 0, 0.5)",labels:null,className:"input"},outputs:{color:"rgba(100, 149, 237, 0.5)",className:"output"},hidden:{color:"rgba(255, 127, 80, 0.5)",className:"hidden-neuron"},fontSize:"14px",fontClassName:"label",radius:8,width:400,height:250,sizes:[]}}function xo(e,t){const s={...Oo(),...t},{width:o,height:i,inputs:a}=s;let n=[];if(e instanceof pe||e instanceof We)n=_o(e);else if(e instanceof He){const{inputSize:t,hiddenLayers:s,outputSize:o}=bo(e);n=[t].concat(s).concat([o])}else if(e instanceof Z){const{inputSize:t,hiddenLayers:s,outputSize:o}=vo(e);n=[t].concat(s).concat([o])}else if(e instanceof z||e instanceof Me||e instanceof Ht||e instanceof X||e instanceof nt||e instanceof ke)return Y(lt({...s,sizes:G(dt(e),a.labels)}),o,i);else if(e.hasOwnProperty("type"))switch(e.type){case"NeuralNetwork":case"NeuralNetworkGPU":return Y(fe({...s,sizes:G(yo(e),a.labels)}),o,i);case"RNN":case"GRU":case"LSTM":case"RNNTimeStep":case"GRUTimeStep":case"LSTMTimeStep":return Y(lt({...s,sizes:G(dt(e),a.labels)}),o,i);default:throw new Error("unrecognized network")}else if(e.hasOwnProperty("inputSize")&&e.hasOwnProperty("hiddenLayers")&&e.hasOwnProperty("outputSize")){const{inputSize:t,hiddenLayers:s,outputSize:o}=e;n=[t,...s,o]}else if(e.hasOwnProperty("sizes"))n=e.sizes;else throw new Error("unrecognized network");return Y(fe({...s,sizes:G(n,a.labels)}),o,i)}function G(e,t){if(!e)throw new Error("sizes not set");if(e.some(e=>e<1))throw new Error("sizes not set correctly");if(t&&t.length!==e[0])throw new Error("not enough labels for inputs");return e}const Eo={RNNTimeStep:X,LSTMTimeStep:nt,GRUTimeStep:ke,RNN:z,LSTM:Me,GRU:Ht},ko={max:oe,mse:ne,ones:yt,ones2D:_t,random:Ae,randomWeight:Ge,randos:C,range:ro,toArray:co,DataFormatter:p,zeros:u,toSVG:xo};e.CrossValidate=O,e.FeedForward=Z,e.NeuralNetwork=pe,e.NeuralNetworkGPU=We,e.Recurrent=He,e.activation=jt,e.layer=ee,e.layerTypes=g,e.likely=In,e.lookup=i,e.praxis=Lt,e.recurrent=Eo,e.utilities=ko,Object.defineProperty(e,"__esModule",{value:!0})})