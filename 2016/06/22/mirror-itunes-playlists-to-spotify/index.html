<!doctype html><html><head><title>Mirror iTunes playlists to Spotify â€“ jverkamp.com</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=alternate type=application/atom+xml title="jverkamp.com (Atom 2.0)" href=//blog.jverkamp.com/feed/><script src=/jquery_5823201688106629450.min.8c7d803d89ebdecf2416d468f4ecb981a3acf645154a7a336f2e5d0190ea8163.js integrity="sha256-jH2APYnr3s8kFtRo9Oy5gaOs9kUVSnozby5dAZDqgWM=" defer></script>
<script src=/jquery.fancybox_6181813213021922412.min.921ca906a32e718ab61ac0b4da24e0eaa6bdd41912654a33b44bd3fc2f0c2a4d.js integrity="sha256-khypBqMucYq2GsC02iTg6qa91BkSZUoztEvT/C8MKk0=" defer></script>
<script src=/katex_12008035502722260518.min.1c3dce03daaf56a7d2fe0d0ec49bf35256837226f835adaf52c09502ef9bc5d1.js integrity="sha256-HD3OA9qvVqfS/g0OxJvzUlaDcib4Na2vUsCVAu+bxdE=" defer></script>
<script src=/bigfoot_8444447145154709333.min.5e80bd85ebaeb95607834d6777bfe7013d1d161f0f02a31b845e4bd765898316.js integrity="sha256-XoC9heuuuVYHg01nd7/nAT0dFh8PAqMbhF5L12WJgxY=" defer></script>
<script src=/mermaid_12365941879912544862.min.973b5415b3fa1835d620c0e58236f859d5f80891f447e240cbbb9eb825251ff0.js integrity="sha256-lztUFbP6GDXWIMDlgjb4WdX4CJH0R+JAy7ueuCUlH/A=" defer></script>
<script src=/main.min.982c2d7bb434b4cf8b19c2cf38ef7e7f7162ddbed610e5bdddbb937001e26574.js integrity="sha256-mCwte7Q0tM+LGcLPOO9+f3Fi3b7WEOW93buTcAHiZXQ=" defer></script>
<link rel=stylesheet href=/katex_14163593549783030822.min.16bacd59fb224ae6c97a749ab0ac1e708cb5e0c9ce5c9a08d7fd73dc8e69429f.css integrity="sha256-FrrNWfsiSubJenSasKwecIy14MnOXJoI1/1z3I5pQp8="><link rel=stylesheet href=/bigfoot-default_16482899066638414220.min.f15d4faa4519addb976f9d69b42bd9eb491b3596b6b2eda83aa3e9e1f48b8f14.css integrity="sha256-8V1PqkUZrduXb51ptCvZ60kbNZa2su2oOqPp4fSLjxQ="><link rel=stylesheet href=/jquery.fancybox_16222217791602823071.min.e28b5d7d9d89efacb5f708ac30cbd76b1b9a0f816dfd9da96631d1d09cbbdd76.css integrity="sha256-4otdfZ2J76y19wisMMvXaxuaD4Ft/Z2pZjHR0Jy73XY="><link rel=stylesheet href=/css_4780214198035419921.min.246b6f8e7620eeb717bca5e7b121037906e5dfaa05805f427fcc5a09b6c99f5c.css integrity="sha256-JGtvjnYg7rcXvKXnsSEDeQbl36oFgF9Cf8xaCbbJn1w="><link rel=stylesheet href=/main.min.1a5fbab1ecff843d4ee6e936243fb06066197cd8c9357883d791333ce6001f3b.css integrity="sha256-Gl+6sez/hD1O5uk2JD+wYGYZfNjJNXiD15EzPOYAHzs="></head><body><div id=wrapper><header id=page-header role=banner><h1><a href=/>JP's Blog</a></h1><ul id=page-header-links><li><a href=https://github.com/jpverkamp>GitHub</a> *
<a href=https://www.flickr.com/photos/jpverkamp>Flickr</a> *
<a href=/resume>Resume</a></li><li><form action=//www.google.com/search method=get onsubmit='(function(e){e.q.value="site:blog.jverkamp.com "+e.qfront.value})(this)' class="navbar-form navbar-right" role=search _lpchecked=1><div class=form-group><input name=q type=hidden>
<input name=qfront type=text class=form-control placeholder=Search>
<button type=submit class="btn btn-default" value=Search>Search</button></div></form></li></ul><nav id=header-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=https://blog.jverkamp.com/reviews/>Reviews</a></li><li><a href=https://blog.jverkamp.com/programming/>Programming</a></li><li><a href=https://blog.jverkamp.com/photography/>Photography</a></li><li><a href=https://blog.jverkamp.com/maker/>Maker</a></li><li><a href=https://blog.jverkamp.com/writing/>Writing</a></li><li><a href=https://blog.jverkamp.com/research/>Research</a></li><li class=subscription data-subscription=rss><a href=/atom.xml rel=subscribe-rss title="subscribe via RSS">RSS</a></li></ul></nav></header><div id=page-content-wrapper><div id=page-content><article><header><h1 class=entry-title>Mirror iTunes playlists to Spotify</h1><div class=entry-meta><span class=entry-date>2016-06-22</span></div><div class=entry-taxonomies><div class=entry-tags><ul class=taxonomy-keys><li><a class=taxonomy-key href=/programming/languages/>Languages</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2016/06/04/parsing-motorola-surfboard-stats/ class=previous-link></a><a class=taxonomy-value href=/programming/languages/python>Python</a><a href=https://blog.jverkamp.com/2016/07/14/solving-loop-puzzles/ class=next-link></a></li></ul></li><li><a class=taxonomy-key href=/programming/topics/>Topics</a><ul class=taxonomy-values><li><a href=https://blog.jverkamp.com/2015/09/08/backing-up-github-repositories/ class=previous-link></a><a class=taxonomy-value href=/programming/topics/backups>Backups</a></li></ul></li><li><a class=taxonomy-key href=/programming>programming</a><ul><li><a href=https://blog.jverkamp.com/2016/06/04/parsing-motorola-surfboard-stats/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2016/07/14/solving-loop-puzzles/ class=next-link>Next</a></ul></li><li><a class=taxonomy-key href=/>All Posts</a><ul><li><a href=https://blog.jverkamp.com/2016/06/21/ancillary-mercy/ class=previous-link>Prev</a>
<a href=https://blog.jverkamp.com/2016/06/25/shadows-of-self/ class=next-link>Next</a></ul></li></ul></div></div></header><div class=entry-content><p>At the moment, I have an Apple Music subscription. It&rsquo;s great to be able to listen to more or less whatever music I want to. I switched from Spotify because they were missing a few artists that I actually did want to listen to. Unfortunately, there are a few things that Apple Music doesn&rsquo;t do that I would like to have&ndash;chief among them the ability to play on a Roku.</p><p>One nice thing that Spotify does have though is a fairly powerful API: <a href=https://developer.spotify.com/web-api/>Spotify Web API</a>. Inspired by a post on <a href=http://aguo.us/writings/spotify-billboard.html>Spotify and billboard.py</a> which automatically creates Spotify playlists from the Billboard music ranking charts, I decided to write up a script that can sync my playlists from iTunes to Spotify.</p><p>First, let&rsquo;s write a method that uses the Spotify web API to search for tracks (or actually any <code>type</code>, such as an artist):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@memory.cache</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>spotify_search</span>(type, retries <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>, <span style=color:#f92672>**</span>params):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Search for an item on the spotify API.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logging<span style=color:#f92672>.</span>debug(<span style=color:#e6db74>&#39;spotify_search(</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#39;</span><span style=color:#f92672>.</span>format(type, params))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;https://api.spotify.com/v1/search&#39;</span>
</span></span><span style=display:flex><span>    query <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>.</span>join(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{key}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>{value}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(key <span style=color:#f92672>=</span> key, value <span style=color:#f92672>=</span> params[key])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> params
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    response <span style=color:#f92672>=</span> requests<span style=color:#f92672>.</span>get(url, {<span style=color:#e6db74>&#39;type&#39;</span>: type, <span style=color:#e6db74>&#39;q&#39;</span>: query})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>==</span> <span style=color:#ae81ff>419</span>:
</span></span><span style=display:flex><span>        timeout <span style=color:#f92672>=</span> int(response<span style=color:#f92672>.</span>headers[<span style=color:#e6db74>&#39;Retry-After&#39;</span>])
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#39;Rate limited, waiting </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> seconds...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(timeout))
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(timeout)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> spotify_search(type, retries <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>, <span style=color:#f92672>**</span>params)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>!=</span> <span style=color:#ae81ff>200</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> retries:
</span></span><span style=display:flex><span>            logging<span style=color:#f92672>.</span>warning(<span style=color:#e6db74>&#39;Non-200 status code for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, retrying in 1 second...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(query))
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> spotify_search(type, retries <span style=color:#f92672>=</span> retries <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>**</span>params)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            logging<span style=color:#f92672>.</span>critical(<span style=color:#e6db74>&#39;Non-200 status code for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, no more retries&#39;</span><span style=color:#f92672>.</span>format(query))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#39;Error in spotify api for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(query))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    type_plural <span style=color:#f92672>=</span> type <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;s&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>json()[type_plural][<span style=color:#e6db74>&#39;total&#39;</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()[type_plural][<span style=color:#e6db74>&#39;items&#39;</span>][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><p>Essentially, it&rsquo;s just a call to the API endpoint <code>/v1/search</code>. The only two odd parts are how the query string is formatted (it looks something like this: <code>Artist:Arist Name Song:Song Name</code>) and the <code>memory.cache</code> decorator.</p><p>The decorator comes from <a href=https://pypi.python.org/pypi/joblib>joblib</a> and is basically an easy way to make sure that I don&rsquo;t fetch this information more than once per song no matter how many times I call this method. It will save the results and return them directly for any future calls. To initialize it, all I have to do is run <code>memory = joblib.Memory(cachedir = 'cache', verbose = 0)</code> at the top of my code.</p><p>Now that we have a way of looking up songs, lets write a few more helper methods to read from the iTunes library. The first thing that you have to do is check the Advanced setting to &lsquo;Share iTunes Library XML with other applications&rsquo;:</p><figure><img src=/embeds/2016/itunes-settings.png></figure><p>This will make the file <code>iTunes Library.xml</code> / <code>iTunes Music Library.xml</code> (it changed between Yosemite and El Capitan) available in your iTunes folder. This is a <a href=https://en.wikipedia.org/wiki/plist>plist</a> file which means the built in <a href=https://docs.python.org/2/library/plistlib.html>plistlib</a> can read it directly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>expanduser(<span style=color:#e6db74>&#39;~/Music/iTunes/iTunes Music Library.xml&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(path, <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> fin:
</span></span><span style=display:flex><span>    ITUNES_LIBRARY <span style=color:#f92672>=</span> plistlib<span style=color:#f92672>.</span>load(fin)
</span></span></code></pre></div><p>We can then use this directly to read in information about any given track that we have in our library.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@memory.cache</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_track</span>(track_id):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Get a track by ID.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logging<span style=color:#f92672>.</span>debug(<span style=color:#e6db74>&#39;get_track(</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#39;</span><span style=color:#f92672>.</span>format(track_id))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    track <span style=color:#f92672>=</span> ITUNES_LIBRARY[<span style=color:#e6db74>&#39;Tracks&#39;</span>]<span style=color:#f92672>.</span>get(str(track_id), <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> track:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>remove_parentheticals</span>(s):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> re<span style=color:#f92672>.</span>sub(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;\s+[\(\[].*[\)\]]&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>, s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    spotify_data <span style=color:#f92672>=</span> spotify_search(<span style=color:#e6db74>&#39;track&#39;</span>,
</span></span><span style=display:flex><span>        artist <span style=color:#f92672>=</span> remove_parentheticals(track[<span style=color:#e6db74>&#39;Artist&#39;</span>]),
</span></span><span style=display:flex><span>        track <span style=color:#f92672>=</span> remove_parentheticals(track[<span style=color:#e6db74>&#39;Name&#39;</span>]),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> spotify_data:
</span></span><span style=display:flex><span>        track<span style=color:#f92672>.</span>update(spotify_data)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> track
</span></span></code></pre></div><p>Essentially, we pull the <code>Tracks</code> object out of the iTunes library which is indexed by a <code>track_id</code>. There&rsquo;s one kind of weird part here in that the <code>Tracks</code> object uses numeric strings as keys while the <code>Playlists</code> tracks (see below) are returned as <code>int</code>s. Thus the cast. We take the information from iTunes and then try to look up the song in Spotify. If the search returns, we shove the two objects together. If not, we return just the iTunes information and deal with that later.</p><p>Next, we want to look up playlists:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_playlists</span>():
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Return all playlists for the current user.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Each will be of the form:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {&#39;name&#39;: &#39;</span><span style=color:#e6db74>{playlist_name}</span><span style=color:#e6db74>&#39;, &#39;tracks&#39;: [...]}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> playlist <span style=color:#f92672>in</span> ITUNES_LIBRARY[<span style=color:#e6db74>&#39;Playlists&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> any(key <span style=color:#f92672>in</span> playlist <span style=color:#f92672>and</span> playlist[key] <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;Master&#39;</span>, <span style=color:#e6db74>&#39;Movies&#39;</span>, <span style=color:#e6db74>&#39;TV Shows&#39;</span>, <span style=color:#e6db74>&#39;Podcasts&#39;</span>, <span style=color:#e6db74>&#39;iTunesU&#39;</span>, <span style=color:#e6db74>&#39;Audiobooks&#39;</span>]):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;name&#39;</span>: playlist[<span style=color:#e6db74>&#39;Name&#39;</span>],
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;tracks&#39;</span>: [
</span></span><span style=display:flex><span>                get_track(track[<span style=color:#e6db74>&#39;Track ID&#39;</span>])
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> track <span style=color:#f92672>in</span> playlist[<span style=color:#e6db74>&#39;Playlist Items&#39;</span>]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> get_track(track[<span style=color:#e6db74>&#39;Track ID&#39;</span>])
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>This is a bit odd, since there are many different kinds of playlists in the iTunes library, not all of which have the same keys. With a bit of experimentation, I found that the list of keys above are the ones we want to avoid. Other than that, we will <code>yield</code> each playlist along with a list of track objects from <code>get_track</code>. This is why I cached those results, since a track can (and often will be) in multiple playlists and we don&rsquo;t want to re-fetch the track information if that&rsquo;s the case.</p><p>That&rsquo;s actually the lion&rsquo;s share of what I need. All that&rsquo;s left is the code to create / find Spotify playlists and then add the songs to them. For that, I&rsquo;m going to use the <a href=https://github.com/plamere/spotipy>spotipy</a> library rather than directly dealing with the endpoints. For the most part, it really helps with the OAuth tokens. All we have to do to create a Spotipy client is this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>token <span style=color:#f92672>=</span> spotipy<span style=color:#f92672>.</span>util<span style=color:#f92672>.</span>prompt_for_user_token(
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>env[<span style=color:#e6db74>&#39;SPOTIFY_USERNAME&#39;</span>],
</span></span><span style=display:flex><span>    client_id <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>env[<span style=color:#e6db74>&#39;SPOTIFY_CLIENT_ID&#39;</span>],
</span></span><span style=display:flex><span>    client_secret <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>env[<span style=color:#e6db74>&#39;SPOTIFY_CLIENT_SECRET&#39;</span>],
</span></span><span style=display:flex><span>    redirect_uri <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>env[<span style=color:#e6db74>&#39;SPOTIFY_REDIRECT_URI&#39;</span>],
</span></span><span style=display:flex><span>    scope <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>env[<span style=color:#e6db74>&#39;SPOTIFY_SCOPE&#39;</span>],
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sp <span style=color:#f92672>=</span> spotipy<span style=color:#f92672>.</span>Spotify(auth <span style=color:#f92672>=</span> token)
</span></span></code></pre></div><p>You have to <a href=https://developer.spotify.com/my-applications/#!/applications>create a Spotify App</a>, but that&rsquo;s straight forward enough and free. The first time this is run, you will have to okay the permissions in your web browser, but after that it will keep track of your Spotify API token and will run transparently.</p><p>I&rsquo;m going to use that to write one more helper method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_spotify_playlist</span>(title):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;Get either an existing or new playlist by title.&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    playlists <span style=color:#f92672>=</span> sp<span style=color:#f92672>.</span>user_playlists(sp<span style=color:#f92672>.</span>me()[<span style=color:#e6db74>&#39;id&#39;</span>])[<span style=color:#e6db74>&#39;items&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> playlist <span style=color:#f92672>in</span> playlists:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> title <span style=color:#f92672>==</span> playlist[<span style=color:#e6db74>&#39;name&#39;</span>]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> playlist
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sp<span style=color:#f92672>.</span>user_playlist_create(sp<span style=color:#f92672>.</span>me()[<span style=color:#e6db74>&#39;id&#39;</span>], title)
</span></span></code></pre></div><p><a href=http://aguo.us/writings/spotify-billboard.html>The article</a> that inspired this code only used the <code>user_playlist_create</code> method, but that will create a new playlist on each run. Instead, we want to check if there&rsquo;s already a playlist matching the name that we&rsquo;re trying to create. If so, return that playlist. If not, create a new one to return.</p><p>Now we have everything we need. We can write a script that will loop through any iTunes playlists specified on the command line (or all of them if none are specified) and sync them to Spotify:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> playlist <span style=color:#f92672>in</span> get_playlists():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> playlist[<span style=color:#e6db74>&#39;name&#39;</span>] <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> sys<span style=color:#f92672>.</span>argv:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    spotify_playlist <span style=color:#f92672>=</span> get_spotify_playlist(<span style=color:#e6db74>&#39;iTunes - </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(playlist[<span style=color:#e6db74>&#39;name&#39;</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    uris <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        track[<span style=color:#e6db74>&#39;uri&#39;</span>] <span style=color:#66d9ef>for</span>
</span></span><span style=display:flex><span>        track <span style=color:#f92672>in</span> playlist[<span style=color:#e6db74>&#39;tracks&#39;</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;uri&#39;</span> <span style=color:#f92672>in</span> track
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>chunks</span>(items, size):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> start <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(items), size):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> items[start : start <span style=color:#f92672>+</span> size]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> uri_chunk <span style=color:#f92672>in</span> chunks(uris, <span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>        sp<span style=color:#f92672>.</span>user_playlist_add_tracks(sp<span style=color:#f92672>.</span>me()[<span style=color:#e6db74>&#39;id&#39;</span>], spotify_playlist[<span style=color:#e6db74>&#39;id&#39;</span>], uri_chunk)
</span></span></code></pre></div><p>I did hit one interesting temporary roadblock in that the Spotify API cannot accept more than 100 URIs at a time, but the <code>chunk</code> method took care of that. One thing that is nice is that the list of songs in a playlist form a set. So it doesn&rsquo;t matter if we add the same song to a playlist more than once, it will still only exist a single time. That&rsquo;s pretty cool!</p><p>And that&rsquo;s it. A quick run (it took a few minutes to get all of the information for the 500 songs I have in my iTunes library) and I now have a Spotify playlist for each of my iTunes ones. It&rsquo;s not perfect. There are still a few artists that are on Apple Music but not Spotify. But for a stopgap and when I&rsquo;m on computers that don&rsquo;t have my iTunes library, it works pretty well. I&rsquo;ll probably set this up to run periodically, just so I always have my playlists relatively up to date.</p></div></article></div></div><footer id=page-footer role=contentinfo><nav id=footer-navigation role=navigation class=ribbon><ul class=main-navigation><li><a href=/archive-by-date/>All posts: By Date</a></li><li><a href=/archive-by-tag/>All posts: By Tag</a></li><li><a href=/atom.xml>RSS: All <sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li><li><a href=/programming/atom.xml>RSS: programming<sup><svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24"><path fill="#fff" d="M6.503 20.752C6.503 22.546 5.047 24 3.252 24c-1.796.0-3.252-1.454-3.252-3.248s1.456-3.248 3.252-3.248c1.795.001 3.251 1.454 3.251 3.248zM0 8.18v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817C15.777 15.29 8.721 8.242.0 8.18zm0-3.368C10.58 4.858 19.152 13.406 19.183 24H24c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg></sup></a></li></ul></nav><div id=page-footer-content><div class=legal><p>All posts unless otherwise mentioned are licensed under
<a rel=license href=//creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US><img alt="Creative Commons License" style=border-width:0 src=//i.creativecommons.org/l/by-nc-sa/3.0/80x15.png></a></p><p>Any source code unless otherwise mentioned is licensed under the <a href=//directory.fsf.org/wiki/License:BSD_3Clause>3 clause BSD license</a></p></div></div></footer></div></body></html>